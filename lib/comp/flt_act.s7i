
(********************************************************************)
(*                                                                  *)
(*  flt_act.s7i   Generate code for actions of the type float.      *)
(*  Copyright (C) 1990 - 1994, 2004 - 2014  Thomas Mertes           *)
(*                                                                  *)
(*  This file is part of the Seed7 compiler.                        *)
(*                                                                  *)
(*  This program is free software; you can redistribute it and/or   *)
(*  modify it under the terms of the GNU General Public License as  *)
(*  published by the Free Software Foundation; either version 2 of  *)
(*  the License, or (at your option) any later version.             *)
(*                                                                  *)
(*  This program is distributed in the hope that it will be useful, *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of  *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *)
(*  GNU General Public License for more details.                    *)
(*                                                                  *)
(*  You should have received a copy of the GNU General Public       *)
(*  License along with this program; if not, write to the           *)
(*  Free Software Foundation, Inc., 51 Franklin Street,             *)
(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)
(*                                                                  *)
(********************************************************************)


const ACTION: FLT_A2TAN           is action "FLT_A2TAN";
const ACTION: FLT_ABS             is action "FLT_ABS";
const ACTION: FLT_ACOS            is action "FLT_ACOS";
const ACTION: FLT_ADD             is action "FLT_ADD";
const ACTION: FLT_ADD_ASSIGN      is action "FLT_ADD_ASSIGN";
const ACTION: FLT_ASIN            is action "FLT_ASIN";
const ACTION: FLT_ATAN            is action "FLT_ATAN";
const ACTION: FLT_CAST            is action "FLT_CAST";
const ACTION: FLT_CEIL            is action "FLT_CEIL";
const ACTION: FLT_CMP             is action "FLT_CMP";
const ACTION: FLT_COS             is action "FLT_COS";
const ACTION: FLT_COSH            is action "FLT_COSH";
const ACTION: FLT_CPY             is action "FLT_CPY";
const ACTION: FLT_DGTS            is action "FLT_DGTS";
const ACTION: FLT_DIV             is action "FLT_DIV";
const ACTION: FLT_DIV_ASSIGN      is action "FLT_DIV_ASSIGN";
const ACTION: FLT_EQ              is action "FLT_EQ";
const ACTION: FLT_EXP             is action "FLT_EXP";
const ACTION: FLT_FLOOR           is action "FLT_FLOOR";
const ACTION: FLT_GE              is action "FLT_GE";
const ACTION: FLT_GT              is action "FLT_GT";
const ACTION: FLT_HASHCODE        is action "FLT_HASHCODE";
const ACTION: FLT_ICAST           is action "FLT_ICAST";
const ACTION: FLT_ICONV           is action "FLT_ICONV";
const ACTION: FLT_IFLT            is action "FLT_IFLT";
const ACTION: FLT_IPOW            is action "FLT_IPOW";
const ACTION: FLT_ISNAN           is action "FLT_ISNAN";
const ACTION: FLT_ISNEGATIVEZERO  is action "FLT_ISNEGATIVEZERO";
const ACTION: FLT_LE              is action "FLT_LE";
const ACTION: FLT_LOG             is action "FLT_LOG";
const ACTION: FLT_LOG10           is action "FLT_LOG10";
const ACTION: FLT_LOG2            is action "FLT_LOG2";
const ACTION: FLT_LT              is action "FLT_LT";
const ACTION: FLT_MULT            is action "FLT_MULT";
const ACTION: FLT_MULT_ASSIGN     is action "FLT_MULT_ASSIGN";
const ACTION: FLT_NE              is action "FLT_NE";
const ACTION: FLT_NEGATE          is action "FLT_NEGATE";
const ACTION: FLT_PARSE           is action "FLT_PARSE";
const ACTION: FLT_PLUS            is action "FLT_PLUS";
const ACTION: FLT_POW             is action "FLT_POW";
const ACTION: FLT_RAND            is action "FLT_RAND";
const ACTION: FLT_ROUND           is action "FLT_ROUND";
const ACTION: FLT_SBTR            is action "FLT_SBTR";
const ACTION: FLT_SBTR_ASSIGN     is action "FLT_SBTR_ASSIGN";
const ACTION: FLT_SCI             is action "FLT_SCI";
const ACTION: FLT_SIN             is action "FLT_SIN";
const ACTION: FLT_SINH            is action "FLT_SINH";
const ACTION: FLT_SQRT            is action "FLT_SQRT";
const ACTION: FLT_STR             is action "FLT_STR";
const ACTION: FLT_TAN             is action "FLT_TAN";
const ACTION: FLT_TANH            is action "FLT_TANH";
const ACTION: FLT_TRUNC           is action "FLT_TRUNC";
const ACTION: FLT_VALUE           is action "FLT_VALUE";


const proc: flt_prototypes (inout file: c_prog) is func

  begin
    if not ccConf.HAS_LOG2 then
      writeln(c_prog, "#define LN2 0.693147180559945309417232121458176568075500134360255254120680009493393");
    end if;
    if ccConf.HAS_EXP10 then
      declareExtern(c_prog, "double exp10(double x);");
    end if;
    declareExtern(c_prog, "intType     fltCmp (floatType, floatType);");
    declareExtern(c_prog, "intType     fltCmpGeneric (const genericType, const genericType);");
    declareExtern(c_prog, "void        fltCpyGeneric (genericType *const, const genericType);");
    declareExtern(c_prog, "striType    fltDgts (floatType, intType);");
    if not ccConf.NAN_COMPARISON_OKAY then
      declareExtern(c_prog, "boolType    fltEq (floatType, floatType);");
      declareExtern(c_prog, "boolType    fltGe (floatType, floatType);");
      declareExtern(c_prog, "boolType    fltGt (floatType, floatType);");
    end if;
    declareExtern(c_prog, "floatType   fltIPow (floatType, intType);");
    declareExtern(c_prog, "boolType    fltIsNegativeZero (floatType);");
    writeln(c_prog, "#define     fltIsNegativeZeroMacro(number) (memcmp(&(number), &negativeZero, sizeof(floatType)) == 0)");
    if not ccConf.NAN_COMPARISON_OKAY then
      declareExtern(c_prog, "boolType    fltLe (floatType, floatType);");
      declareExtern(c_prog, "boolType    fltLt (floatType, floatType);");
    end if;
    declareExtern(c_prog, "floatType   fltParse (const const_striType);");
    if not ccConf.POW_FUNCTION_OKAY then
      declareExtern(c_prog, "floatType   fltPow (floatType, floatType);");
    end if;
    declareExtern(c_prog, "floatType   fltRand (floatType, floatType);");
    declareExtern(c_prog, "striType    fltSci (floatType, intType);");
    declareExtern(c_prog, "striType    fltStr (floatType);");
    declareExtern(c_prog, "floatType   fltValue (const const_objRefType);");
  end func;


const proc: process (FLT_A2TAN, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "atan2(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process (FLT_ABS, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "fabs(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process (FLT_ACOS, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "acos(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process (FLT_ADD, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") + (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process (FLT_ADD_ASSIGN, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: statement is expr_type.value;
  begin
    process_expr(params[1], statement);
    statement.expr &:= "+=";
    process_expr(params[3], statement);
    statement.expr &:= ";\n";
    doLocalDeclsOfStatement(statement, c_expr);
  end func;


const proc: process (FLT_ASIN, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "asin(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process (FLT_ATAN, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "atan(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process (FLT_CAST, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  local
    var string: temp_name is "";
  begin
    temp_name := defineTempVariable("rtlValueUnion", "tmp_", c_expr);
    c_expr.expr &:= "(";
    c_expr.expr &:= temp_name;
    c_expr.expr &:= ".floatValue=";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ",";
    c_expr.expr &:= temp_name;
    c_expr.expr &:= ".intValue)";
  end func;


const proc: process (FLT_CEIL, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "ceil(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process (FLT_CMP, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "fltCmp(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process (FLT_COS, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "cos(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process (FLT_COSH, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "cosh(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process (FLT_CPY, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: statement is expr_type.value;
  begin
    process_expr(params[1], statement);
    statement.expr &:= "=";
    process_expr(params[3], statement);
    statement.expr &:= ";\n";
    doLocalDeclsOfStatement(statement, c_expr);
  end func;


const proc: process (FLT_DGTS, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr := "fltDgts(";
    getStdParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    getStdParamToResultExpr(params[3], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_const_flt_div (in reference: dividend, in float: divisor,
    inout expr_type: c_expr) is func

  local
    var reference: evaluatedDividend is NIL;
    var float: quotient is 0.0;
    var string: dividend_name is "";
  begin
    incr(countOptimizations);
    if divisor = 0.0 and (ccConf.FLOAT_ZERO_DIV_ERROR or ccConf.CHECK_FLOAT_DIV_BY_ZERO) then
      if getConstant(dividend, FLOATOBJECT, evaluatedDividend) then
        quotient := getValue(evaluatedDividend, float) / divisor;
        c_expr.expr &:= floatLiteral(quotient);
      else
        c_expr.expr &:= "(";
        dividend_name := getParameterAsVariable("floatType", "tmp_", dividend, c_expr);
        c_expr.expr &:= dividend_name;
        c_expr.expr &:= "==0.0 || os_isnan(";
        c_expr.expr &:= dividend_name;
        c_expr.expr &:= ") ? NOT_A_NUMBER : (";
        c_expr.expr &:= dividend_name;
        if isNegativeZero(divisor) then
          c_expr.expr &:= "<0.0 ? POSITIVE_INFINITY : NEGATIVE_INFINITY))";
        else
          c_expr.expr &:= "<0.0 ? NEGATIVE_INFINITY : POSITIVE_INFINITY))";
        end if;
      end if;
    else
      c_expr.expr &:= "(";
      process_expr(dividend, c_expr);
      c_expr.expr &:= ") / ";
      c_expr.expr &:= floatLiteral(divisor);
    end if;
  end func;


const proc: process (FLT_DIV, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  local
    var reference: evaluatedParam is NIL;
    var string: dividend is "";
    var string: divisor is "";
  begin
    if getConstant(params[3], FLOATOBJECT, evaluatedParam) then
      process_const_flt_div(params[1], getValue(evaluatedParam, float), c_expr);
    elsif ccConf.FLOAT_ZERO_DIV_ERROR and isActionExpression(params[3], "FLT_NEGATE") and
          category(getActionParameter(params[3], 2)) = FLOATOBJECT and
          not isVar(getActionParameter(params[3], 2)) and
          getValue(getActionParameter(params[3], 2), float) = 0.0 then
      process_const_flt_div(params[1], getValue(evaluate(prog, params[3]), float), c_expr);
    elsif ccConf.FLOAT_ZERO_DIV_ERROR and evaluate_const_expr = 0 and
          category(params[3]) = FLOATOBJECT and not isVar(params[3]) and
          getValue(params[3], float) = 0.0 then
      process_const_flt_div(params[1], getValue(evaluate(prog, params[3]), float), c_expr);
    elsif ccConf.CHECK_FLOAT_DIV_BY_ZERO then
      c_expr.expr &:= "(";
      dividend := getParameterAsVariable("floatType", "tmp_", params[1], c_expr);
      divisor := getParameterAsVariable("floatType", "tmp_", params[3], c_expr);
      c_expr.expr &:= divisor;
      c_expr.expr &:= "==0.0 ? (";
      c_expr.expr &:= dividend;
      c_expr.expr &:= "==0.0 || os_isnan(";
      c_expr.expr &:= dividend;
      c_expr.expr &:= ") ? NOT_A_NUMBER : ((";
      c_expr.expr &:= dividend;
      c_expr.expr &:= "<0.0)==fltIsNegativeZero(";
      c_expr.expr &:= divisor;
      c_expr.expr &:= ") ? POSITIVE_INFINITY : NEGATIVE_INFINITY)) : ";
      c_expr.expr &:= dividend;
      c_expr.expr &:= " / ";
      c_expr.expr &:= divisor;
      c_expr.expr &:= ")";
    else
      c_expr.expr &:= "(";
      process_expr(params[1], c_expr);
      c_expr.expr &:= ") / (";
      process_expr(params[3], c_expr);
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process_const_flt_div_assign (in reference: param1, in float: divisor,
    inout expr_type: c_expr) is func

  local
    var expr_type: statement is expr_type.value;
    var integer: temp_num is 0;
    var string: dividend is "";
  begin
    incr(countOptimizations);
    if divisor = 0.0 and (ccConf.FLOAT_ZERO_DIV_ERROR or ccConf.CHECK_FLOAT_DIV_BY_ZERO) then
      if isNormalVariable(param1) then
        dividend := normalVariable(param1, statement);
      else
        incr(statement.temp_num);
        dividend := "tmp_" & str(statement.temp_num);
        statement.temp_decls &:= "floatType *";
        statement.temp_decls &:= dividend;
        statement.temp_decls &:= ";\n";
        statement.expr &:= dividend;
        statement.expr &:= "=&(";
        process_expr(param1, statement);
        statement.expr &:= ");\n";
        dividend := "*" & dividend;
      end if;
      statement.expr &:= dividend;
      statement.expr &:= "=(";
      statement.expr &:= dividend;
      statement.expr &:= "==0.0 || os_isnan(";
      statement.expr &:= dividend;
      statement.expr &:= ") ? NOT_A_NUMBER : (";
      statement.expr &:= dividend;
      if isNegativeZero(divisor) then
        statement.expr &:= "<0.0 ? POSITIVE_INFINITY : NEGATIVE_INFINITY));\n";
      else
        statement.expr &:= "<0.0 ? NEGATIVE_INFINITY : POSITIVE_INFINITY));\n";
      end if;
    else
      process_expr(param1, statement);
      statement.expr &:= "/=";
      statement.expr &:= floatLiteral(divisor);
      statement.expr &:= ";\n";
    end if;
    doLocalDeclsOfStatement(statement, c_expr);
  end func;


const proc: process (FLT_DIV_ASSIGN, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  local
    var reference: evaluatedParam is NIL;
    var expr_type: statement is expr_type.value;
    var string: dividend is "";
    var string: divisor is "";
  begin
    if getConstant(params[3], FLOATOBJECT, evaluatedParam) then
      process_const_flt_div_assign(params[1], getValue(evaluatedParam, float), c_expr);
    elsif ccConf.FLOAT_ZERO_DIV_ERROR and isActionExpression(params[3], "FLT_NEGATE") and
        category(getActionParameter(params[3], 2)) = FLOATOBJECT and
        not isVar(getActionParameter(params[3], 2)) then
      process_const_flt_div_assign(params[1], getValue(evaluate(prog, params[3]), float), c_expr);
    elsif ccConf.CHECK_FLOAT_DIV_BY_ZERO then
      if isNormalVariable(params[1]) then
        dividend := normalVariable(params[1], statement);
      else
        incr(statement.temp_num);
        dividend := "tmp_" & str(statement.temp_num);
        statement.temp_decls &:= "floatType *";
        statement.temp_decls &:= dividend;
        statement.temp_decls &:= ";\n";
        statement.expr &:= dividend;
        statement.expr &:= "=&(";
        process_expr(params[1], statement);
        statement.expr &:= ");\n";
        dividend := "*" & dividend;
      end if;
      if isNormalVariable(params[3]) then
        divisor := normalVariable(params[3], statement);
      else
        incr(statement.temp_num);
        divisor := "tmp_" & str(statement.temp_num);
        statement.temp_decls &:= "floatType ";
        statement.temp_decls &:= divisor;
        statement.temp_decls &:= ";\n";
        statement.expr &:= divisor;
        statement.expr &:= "=";
        process_expr(params[3], statement);
        statement.expr &:= ";\n";
      end if;
      statement.expr &:= dividend;
      statement.expr &:= "=(";
      statement.expr &:= divisor;
      statement.expr &:= "==0.0 ? (";
      statement.expr &:= dividend;
      statement.expr &:= "==0.0 || os_isnan(";
      statement.expr &:= dividend;
      statement.expr &:= ") ? NOT_A_NUMBER : ((";
      statement.expr &:= dividend;
      statement.expr &:= "<0.0)==fltIsNegativeZero(";
      statement.expr &:= divisor;
      statement.expr &:= ") ? POSITIVE_INFINITY : NEGATIVE_INFINITY)) : ";
      statement.expr &:= dividend;
      statement.expr &:= " / ";
      statement.expr &:= divisor;
      statement.expr &:= ");\n";
      doLocalDeclsOfStatement(statement, c_expr);
    else
      process_expr(params[1], statement);
      statement.expr &:= "/=";
      process_expr(params[3], statement);
      statement.expr &:= ";\n";
      doLocalDeclsOfStatement(statement, c_expr);
    end if;
  end func;


const proc: process_const_flt_eq (in float: number, in reference: param3,
    inout expr_type: c_expr) is func

  local
    var reference: evaluatedParam is NIL;
    var float: number2 is 0.0;
  begin
    if isNaN(number) then
      incr(countOptimizations);
      c_expr.expr &:= "0/*NaN == anything*/";
    elsif getConstant(param3, FLOATOBJECT, evaluatedParam) then
      incr(countOptimizations);
      number2 := getValue(evaluatedParam, float);
      c_expr.expr &:= str(ord(number = number2));
      c_expr.expr &:= "/*";
      c_expr.expr &:= str(number);
      c_expr.expr &:= " == ";
      c_expr.expr &:= str(number2);
      c_expr.expr &:= "*/";
    elsif not ccConf.NAN_COMPARISON_OKAY then
      c_expr.expr &:= "fltEq(";
      c_expr.expr &:= floatLiteral(number);
      c_expr.expr &:= ", ";
      process_expr(param3, c_expr);
      c_expr.expr &:= ")";
    else
      c_expr.expr &:= floatLiteral(number);
      c_expr.expr &:= " == (";
      process_expr(param3, c_expr);
      c_expr.expr &:= ")";
    end if;
  end func;

const proc: process (FLT_EQ, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  local
    var reference: evaluatedParam is NIL;
  begin
    if getConstant(params[1], FLOATOBJECT, evaluatedParam) then
      process_const_flt_eq(getValue(evaluatedParam, float), params[3], c_expr);
    elsif getConstant(params[3], FLOATOBJECT, evaluatedParam) then
      process_const_flt_eq(getValue(evaluatedParam, float), params[1], c_expr);
    elsif not ccConf.NAN_COMPARISON_OKAY then
      c_expr.expr &:= "fltEq(";
      process_expr(params[1], c_expr);
      c_expr.expr &:= ", ";
      process_expr(params[3], c_expr);
      c_expr.expr &:= ")";
    else
      c_expr.expr &:= "(";
      process_expr(params[1], c_expr);
      c_expr.expr &:= ") == (";
      process_expr(params[3], c_expr);
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process (FLT_EXP, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "exp(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process (FLT_FLOOR, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "floor(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_const_flt_ge (in float: number, in reference: param3,
    inout expr_type: c_expr) is func

  local
    var reference: evaluatedParam is NIL;
    var float: number2 is 0.0;
  begin
    if isNaN(number) then
      incr(countOptimizations);
      c_expr.expr &:= "0/*NaN >= anything*/";
    elsif getConstant(param3, FLOATOBJECT, evaluatedParam) then
      incr(countOptimizations);
      number2 := getValue(evaluatedParam, float);
      c_expr.expr &:= str(ord(number >= number2));
      c_expr.expr &:= "/*";
      c_expr.expr &:= str(number);
      c_expr.expr &:= " >= ";
      c_expr.expr &:= str(number2);
      c_expr.expr &:= "*/";
    elsif not ccConf.NAN_COMPARISON_OKAY then
      c_expr.expr &:= "fltGe(";
      c_expr.expr &:= floatLiteral(number);
      c_expr.expr &:= ", ";
      process_expr(param3, c_expr);
      c_expr.expr &:= ")";
    else
      c_expr.expr &:= floatLiteral(number);
      c_expr.expr &:= " >= (";
      process_expr(param3, c_expr);
      c_expr.expr &:= ")";
    end if;
  end func;

const proc: process_const_flt_ge (in reference: param1, in float: number,
    inout expr_type: c_expr) is func

  local
    var reference: evaluatedParam is NIL;
    var float: number1 is 0.0;
  begin
    if isNaN(number) then
      incr(countOptimizations);
      c_expr.expr &:= "0/*anything >= NaN*/";
    elsif getConstant(param1, FLOATOBJECT, evaluatedParam) then
      incr(countOptimizations);
      number1 := getValue(evaluatedParam, float);
      c_expr.expr &:= str(ord(number1 >= number));
      c_expr.expr &:= "/*";
      c_expr.expr &:= str(number1);
      c_expr.expr &:= " >= ";
      c_expr.expr &:= str(number);
      c_expr.expr &:= "*/";
    elsif not ccConf.NAN_COMPARISON_OKAY then
      c_expr.expr &:= "fltGe(";
      process_expr(param1, c_expr);
      c_expr.expr &:= ", ";
      c_expr.expr &:= floatLiteral(number);
      c_expr.expr &:= ")";
    else
      c_expr.expr &:= "(";
      process_expr(param1, c_expr);
      c_expr.expr &:= ") >= ";
      c_expr.expr &:= floatLiteral(number);
    end if;
  end func;

const proc: process (FLT_GE, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  local
    var reference: evaluatedParam is NIL;
  begin
    if getConstant(params[1], FLOATOBJECT, evaluatedParam) then
      process_const_flt_ge(getValue(evaluatedParam, float), params[3], c_expr);
    elsif getConstant(params[3], FLOATOBJECT, evaluatedParam) then
      process_const_flt_ge(params[1], getValue(evaluatedParam, float), c_expr);
    elsif not ccConf.NAN_COMPARISON_OKAY then
      c_expr.expr &:= "fltGe(";
      process_expr(params[1], c_expr);
      c_expr.expr &:= ", ";
      process_expr(params[3], c_expr);
      c_expr.expr &:= ")";
    else
      c_expr.expr &:= "(";
      process_expr(params[1], c_expr);
      c_expr.expr &:= ") >= (";
      process_expr(params[3], c_expr);
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process (FLT_GT, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    if not ccConf.NAN_COMPARISON_OKAY then
      c_expr.expr &:= "fltGt(";
      process_expr(params[1], c_expr);
      c_expr.expr &:= ", ";
      process_expr(params[3], c_expr);
      c_expr.expr &:= ")";
    else
      c_expr.expr &:= "(";
      process_expr(params[1], c_expr);
      c_expr.expr &:= ") > (";
      process_expr(params[3], c_expr);
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process (FLT_HASHCODE, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  local
    var string: temp_name is "";
  begin
    temp_name := defineTempVariable("rtlValueUnion", "tmp_", c_expr);
    c_expr.expr &:= "(";
    c_expr.expr &:= temp_name;
    c_expr.expr &:= ".floatValue=";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ",";
    c_expr.expr &:= temp_name;
    c_expr.expr &:= ".intValue)";
  end func;


const proc: process (FLT_ICAST, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  local
    var string: temp_name is "";
  begin
    temp_name := defineTempVariable("rtlValueUnion", "tmp_", c_expr);
    c_expr.expr &:= "(";
    c_expr.expr &:= temp_name;
    c_expr.expr &:= ".intValue=";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ",";
    c_expr.expr &:= temp_name;
    c_expr.expr &:= ".floatValue)";
  end func;


const proc: process (FLT_ICONV, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(floatType)(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process (FLT_IFLT, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(floatType)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_const_flt_ipow (in float: base, in reference: exponent,
    inout expr_type: c_expr) is func

  local
    var reference: evaluatedExponent is NIL;
    var string: exponentName is "";
  begin
    if getConstant(exponent, INTOBJECT, evaluatedExponent) then
      incr(countOptimizations);
      c_expr.expr &:= floatLiteral(base ** getValue(evaluatedExponent, integer));
    elsif base = -1.0 then
      c_expr.expr &:= "((";
      process_expr(exponent, c_expr);
      c_expr.expr &:= ")&1?";
      c_expr.expr &:= floatLiteral(-1.0);
      c_expr.expr &:= ":";
      c_expr.expr &:= floatLiteral(1.0);
      c_expr.expr &:= ")";
    elsif base = 0.0 then
      incr(countOptimizations);
      if isNegativeZero(base) then
        c_expr.expr &:= "(";
        exponentName := getParameterAsVariable("intType", "exp_", exponent, c_expr);
        c_expr.expr &:= exponentName;
        c_expr.expr &:= "<0?(";
        c_expr.expr &:= exponentName;
        c_expr.expr &:= "&1?";
        c_expr.expr &:= floatLiteral(-Infinity);
        c_expr.expr &:= ":";
        c_expr.expr &:= floatLiteral(Infinity);
        c_expr.expr &:= "):(";
        c_expr.expr &:= exponentName;
        c_expr.expr &:= "==0?1.0:(";
        c_expr.expr &:= exponentName;
        c_expr.expr &:= "&1?";
        c_expr.expr &:= floatLiteral(-0.0);
        c_expr.expr &:= ":0.0)))";
      else
        c_expr.expr &:= "(";
        exponentName := getParameterAsVariable("intType", "exp_", exponent, c_expr);
        c_expr.expr &:= exponentName;
        c_expr.expr &:= "<0?";
        c_expr.expr &:= floatLiteral(Infinity);
        c_expr.expr &:= ":(";
        c_expr.expr &:= exponentName;
        c_expr.expr &:= "==0?1.0:0.0))";
      end if;
    elsif base = 1.0 then
      incr(countOptimizations);
      c_expr.expr &:= floatLiteral(1.0);
    elsif base = -2.0 then
      incr(countOptimizations);
      if ccConf.INT_MIN <= integer.first and ccConf.INT_MAX >= integer.last then
        c_expr.expr &:= "(";
        exponentName := getParameterAsVariable("intType", "exp_", exponent, c_expr);
        c_expr.expr &:= "ldexp(";
        c_expr.expr &:= exponentName;
        c_expr.expr &:= "&1? -1.0:1.0, (int) ";
        c_expr.expr &:= exponentName;
        c_expr.expr &:= "))";
      else
        c_expr.expr &:= "(";
        exponentName := getParameterAsVariable("intType", "exp_", exponent, c_expr);
        c_expr.expr &:= exponentName;
        c_expr.expr &:= "<";
        c_expr.expr &:= integerLiteral(ccConf.INT_MIN);
        c_expr.expr &:= "?0.0:(";
        c_expr.expr &:= exponentName;
        c_expr.expr &:= ">";
        c_expr.expr &:= integerLiteral(ccConf.INT_MAX);
        c_expr.expr &:= "?(";
        c_expr.expr &:= exponentName;
        c_expr.expr &:= "&1?";
        c_expr.expr &:= floatLiteral(-Infinity);
        c_expr.expr &:= ":";
        c_expr.expr &:= floatLiteral(Infinity);
        c_expr.expr &:= "):ldexp(";
        c_expr.expr &:= exponentName;
        c_expr.expr &:= "&1? -1.0:1.0, (int) ";
        c_expr.expr &:= exponentName;
        c_expr.expr &:= ")))";
      end if;
    elsif base = 2.0 then
      incr(countOptimizations);
      if ccConf.INT_MIN <= integer.first and ccConf.INT_MAX >= integer.last then
        c_expr.expr &:= "ldexp(1.0, ";
        process_expr(exponent, c_expr);
        c_expr.expr &:= ")";
      else
        c_expr.expr &:= "(";
        exponentName := getParameterAsVariable("intType", "exp_", exponent, c_expr);
        c_expr.expr &:= exponentName;
        c_expr.expr &:= "<";
        c_expr.expr &:= integerLiteral(ccConf.INT_MIN);
        c_expr.expr &:= "?0.0:(";
        c_expr.expr &:= exponentName;
        c_expr.expr &:= ">";
        c_expr.expr &:= integerLiteral(ccConf.INT_MAX);
        c_expr.expr &:= "?";
        c_expr.expr &:= floatLiteral(Infinity);
        c_expr.expr &:= ":ldexp(1.0, (int) ";
        c_expr.expr &:= exponentName;
        c_expr.expr &:= ")))";
      end if;
    elsif base >= 4.0 and
          base <= flt(ccConf.INT_RANGE_IN_FLOATTYPE_MAX) and
          floor(base) = base and
          2 ** log2(trunc(base)) = trunc(base) then
      incr(countOptimizations);
      c_expr.expr &:= "(";
      exponentName := getParameterAsVariable("intType", "exp_", exponent, c_expr);
      c_expr.expr &:= exponentName;
      c_expr.expr &:= "<";
      c_expr.expr &:= integerLiteral(ccConf.INT_MIN div trunc(base));
      c_expr.expr &:= "?0.0:(";
      c_expr.expr &:= exponentName;
      c_expr.expr &:= ">";
      c_expr.expr &:= integerLiteral(ccConf.INT_MAX div trunc(base));
      c_expr.expr &:= "?";
      c_expr.expr &:= floatLiteral(Infinity);
      c_expr.expr &:= ":ldexp(1.0, (int)";
      c_expr.expr &:= exponentName;
      c_expr.expr &:= "*";
      c_expr.expr &:= str(log2(trunc(base)));
      c_expr.expr &:= ")))";
    else
      c_expr.expr &:= "fltIPow(";
      c_expr.expr &:= floatLiteral(base);
      c_expr.expr &:= ", ";
      process_expr(exponent, c_expr);
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process_const_flt_ipow (in reference: base, in integer: exponent,
    inout expr_type: c_expr) is func

  local
    const array string: power is [2] (
        (*  2 *) "x*x", "x*x*x", "(a=x*x,a*a)", "(a=x*x,a*a*x)", "(a=x*x*x,a*a)",
        (*  7 *) "(a=x*x,a*a*a*x)", "(b=(a=x*x,a*a),b*b)", "(b=(a=x*x,a*a),b*b*x)",
        (* 10 *) "(b=(a=x*x,a*a*x),b*b)", "(b=(a=x*x,a*a*x),b*b*x)",
        (* 12 *) "(b=(a=x*x*x,a*a),b*b)", "(b=(a=x*x,a*a),b*b*b*x)",
        (* 14 *) "(b=(a=x*x,a*a*a*x),b*b)", "(b=(a=x*x*x,a*a),b*b*a)",
        (* 16 *) "(c=(b=(a=x*x,a*a),b*b),c*c)", "(c=(b=(a=x*x,a*a),b*b),c*c*x)",
        (* 18 *) "(c=(b=(a=x*x,a*a),b*b),c*c*a)", "(c=(b=(a=x*x,a*a*x),b*a),c*c*b)",
        (* 20 *) "(c=(b=(a=x*x,a*a*x),b*b),c*c)", "(c=(b=(a=x*x,a*a*x),b*b),c*c*x)",
        (* 22 *) "(c=(b=(a=x*x,a*a*x),b*b*x),c*c)");
    const string: variables is "abc";
    var reference: evaluatedBase is NIL;
    var string: powerTemplate is "";
    var string: baseName is "";
    var string: variableName is "";
    var string: powerName is "";
    var char: ch is ' ';
  begin
    if exponent = -1 then
      incr(countOptimizations);
      if ccConf.CHECK_FLOAT_DIV_BY_ZERO then
        c_expr.expr &:= "(";
        baseName := getParameterAsVariable("floatType", "tmp_", base, c_expr);
        c_expr.expr &:= baseName;
        c_expr.expr &:= "==0.0?(fltIsNegativeZero(";
        c_expr.expr &:= baseName;
        c_expr.expr &:= ") ? POSITIVE_INFINITY : NEGATIVE_INFINITY) : 1.0 / ";
        c_expr.expr &:= baseName;
        c_expr.expr &:= ")";
      else
        c_expr.expr &:= "1.0 / (";
        process_expr(base, c_expr);
        c_expr.expr &:= ")";
      end if;
    elsif exponent = 0 then
      incr(countOptimizations);
      c_expr.expr &:= floatLiteral(1.0);
    elsif exponent = 1 then
      incr(countOptimizations);
      process_expr(base, c_expr);
    elsif exponent < 0 and exponent in {-maxIdx(power) .. -2} then
      incr(countOptimizations);
      powerTemplate := power[-exponent];
      c_expr.expr &:= "(";
      baseName := getParameterAsVariable("floatType", "tmp_", base, c_expr);
      for ch range variables do
        if pos(powerTemplate, ch) <> 0 then
          variableName := defineTempVariable("floatType", str(ch) & "_", c_expr);
          powerTemplate := replace(powerTemplate, str(ch), variableName);
        end if;
      end for;
      if ccConf.CHECK_FLOAT_DIV_BY_ZERO then
        powerName := defineTempVariable("floatType", "power_",
            replace(powerTemplate, "x", baseName), c_expr);
        c_expr.expr &:= powerName;
        c_expr.expr &:= "==0.0?(fltIsNegativeZero(";
        c_expr.expr &:= powerName;
        c_expr.expr &:= ") ? POSITIVE_INFINITY : NEGATIVE_INFINITY) : 1.0 / ";
        c_expr.expr &:= powerName;
        c_expr.expr &:= ")";
      else
        c_expr.expr &:= "1.0 / (";
        c_expr.expr &:= replace(powerTemplate, "x", baseName);
        c_expr.expr &:= "))";
      end if;
    elsif exponent in {2 .. maxIdx(power)} then
      incr(countOptimizations);
      powerTemplate := power[exponent];
      c_expr.expr &:= "(";
      baseName := getParameterAsVariable("floatType", "tmp_", base, c_expr);
      for ch range variables do
        if pos(powerTemplate, ch) <> 0 then
          variableName := defineTempVariable("floatType", str(ch) & "_", c_expr);
          powerTemplate := replace(powerTemplate, str(ch), variableName);
        end if;
      end for;
      c_expr.expr &:= replace(powerTemplate, "x", baseName);
      c_expr.expr &:= ")";
    elsif exponent >= -ccConf.INT_RANGE_IN_FLOATTYPE_MAX and
          exponent <= ccConf.INT_RANGE_IN_FLOATTYPE_MAX and
          ccConf.POW_FUNCTION_OKAY then
      c_expr.expr &:= "pow(";
      process_expr(base, c_expr);
      c_expr.expr &:= ", ";
      c_expr.expr &:= floatLiteral(flt(exponent));
      c_expr.expr &:= ")";
    else
      c_expr.expr &:= "fltIPow(";
      process_expr(base, c_expr);
      c_expr.expr &:= ", ";
      c_expr.expr &:= integerLiteral(exponent);
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process (FLT_IPOW, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  local
    var reference: evaluatedParam is NIL;
  begin
    if getConstant(params[1], FLOATOBJECT, evaluatedParam) then
      process_const_flt_ipow(getValue(evaluatedParam, float), params[3], c_expr);
    elsif getConstant(params[3], INTOBJECT, evaluatedParam) then
      process_const_flt_ipow(params[1], getValue(evaluatedParam, integer), c_expr);
    else
      c_expr.expr &:= "fltIPow(";
      process_expr(params[1], c_expr);
      c_expr.expr &:= ", ";
      process_expr(params[3], c_expr);
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process (FLT_ISNAN, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "os_isnan(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process (FLT_ISNEGATIVEZERO, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "fltIsNegativeZero(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_const_flt_le (in float: number, in reference: param3,
    inout expr_type: c_expr) is func

  local
    var reference: evaluatedParam is NIL;
    var float: number2 is 0.0;
  begin
    if isNaN(number) then
      incr(countOptimizations);
      c_expr.expr &:= "0/*NaN <= anything*/";
    elsif getConstant(param3, FLOATOBJECT, evaluatedParam) then
      incr(countOptimizations);
      number2 := getValue(evaluatedParam, float);
      c_expr.expr &:= str(ord(number <= number2));
      c_expr.expr &:= "/*";
      c_expr.expr &:= str(number);
      c_expr.expr &:= " <= ";
      c_expr.expr &:= str(number2);
      c_expr.expr &:= "*/";
    elsif not ccConf.NAN_COMPARISON_OKAY then
      c_expr.expr &:= "fltLe(";
      c_expr.expr &:= floatLiteral(number);
      c_expr.expr &:= ", ";
      process_expr(param3, c_expr);
      c_expr.expr &:= ")";
    else
      c_expr.expr &:= floatLiteral(number);
      c_expr.expr &:= " <= (";
      process_expr(param3, c_expr);
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process_const_flt_le (in reference: param1, in float: number,
    inout expr_type: c_expr) is func

  local
    var reference: evaluatedParam is NIL;
    var float: number1 is 0.0;
  begin
    if isNaN(number) then
      incr(countOptimizations);
      c_expr.expr &:= "0/*anything <= NaN*/";
    elsif getConstant(param1, FLOATOBJECT, evaluatedParam) then
      incr(countOptimizations);
      number1 := getValue(evaluatedParam, float);
      c_expr.expr &:= str(ord(number1 <= number));
      c_expr.expr &:= "/*";
      c_expr.expr &:= str(number1);
      c_expr.expr &:= " <= ";
      c_expr.expr &:= str(number);
      c_expr.expr &:= "*/";
    elsif not ccConf.NAN_COMPARISON_OKAY then
      c_expr.expr &:= "fltLe(";
      process_expr(param1, c_expr);
      c_expr.expr &:= ", ";
      c_expr.expr &:= floatLiteral(number);
      c_expr.expr &:= ")";
    else
      c_expr.expr &:= "(";
      process_expr(param1, c_expr);
      c_expr.expr &:= ") <= ";
      c_expr.expr &:= floatLiteral(number);
    end if;
  end func;


const proc: process (FLT_LE, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  local
    var reference: evaluatedParam is NIL;
  begin
    if getConstant(params[1], FLOATOBJECT, evaluatedParam) then
      process_const_flt_le(getValue(evaluatedParam, float), params[3], c_expr);
    elsif getConstant(params[3], FLOATOBJECT, evaluatedParam) then
      process_const_flt_le(params[1], getValue(evaluatedParam, float), c_expr);
    elsif not ccConf.NAN_COMPARISON_OKAY then
      c_expr.expr &:= "fltLe(";
      process_expr(params[1], c_expr);
      c_expr.expr &:= ", ";
      process_expr(params[3], c_expr);
      c_expr.expr &:= ")";
    else
      c_expr.expr &:= "(";
      process_expr(params[1], c_expr);
      c_expr.expr &:= ") <= (";
      process_expr(params[3], c_expr);
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process (FLT_LOG, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "log(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process (FLT_LOG10, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "log10(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process (FLT_LOG2, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    if ccConf.HAS_LOG2 then
      c_expr.expr &:= "log2(";
      process_expr(params[1], c_expr);
      c_expr.expr &:= ")";
    else
      c_expr.expr &:= "log(";
      process_expr(params[1], c_expr);
      c_expr.expr &:= ")/LN2";
    end if;
  end func;


const proc: process (FLT_LT, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    if not ccConf.NAN_COMPARISON_OKAY then
      c_expr.expr &:= "fltLt(";
      process_expr(params[1], c_expr);
      c_expr.expr &:= ", ";
      process_expr(params[3], c_expr);
      c_expr.expr &:= ")";
    else
      c_expr.expr &:= "(";
      process_expr(params[1], c_expr);
      c_expr.expr &:= ") < (";
      process_expr(params[3], c_expr);
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process (FLT_MULT, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") * (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process (FLT_MULT_ASSIGN, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: statement is expr_type.value;
  begin
    process_expr(params[1], statement);
    statement.expr &:= "*=";
    process_expr(params[3], statement);
    statement.expr &:= ";\n";
    doLocalDeclsOfStatement(statement, c_expr);
  end func;


const proc: process_const_flt_ne (in float: number, in reference: param3,
    inout expr_type: c_expr) is func

  local
    var reference: evaluatedParam is NIL;
    var float: number2 is 0.0;
  begin
    if isNaN(number) then
      c_expr.expr &:= "1/*NaN != anything*/";
    elsif getConstant(param3, FLOATOBJECT, evaluatedParam) then
      incr(countOptimizations);
      number2 := getValue(evaluatedParam, float);
      c_expr.expr &:= str(ord(number <> number2));
      c_expr.expr &:= "/*";
      c_expr.expr &:= str(number);
      c_expr.expr &:= " != ";
      c_expr.expr &:= str(number2);
      c_expr.expr &:= "*/";
    elsif not ccConf.NAN_COMPARISON_OKAY then
      c_expr.expr &:= "!fltEq(";
      c_expr.expr &:= floatLiteral(number);
      c_expr.expr &:= ", ";
      process_expr(param3, c_expr);
      c_expr.expr &:= ")";
    else
      c_expr.expr &:= floatLiteral(number);
      c_expr.expr &:= " != (";
      process_expr(param3, c_expr);
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process (FLT_NE, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  local
    var reference: evaluatedParam is NIL;
  begin
    if getConstant(params[1], FLOATOBJECT, evaluatedParam) then
      process_const_flt_ne(getValue(evaluatedParam, float), params[3], c_expr);
    elsif getConstant(params[3], FLOATOBJECT, evaluatedParam) then
      process_const_flt_ne(getValue(evaluatedParam, float), params[1], c_expr);
    elsif not ccConf.NAN_COMPARISON_OKAY then
      c_expr.expr &:= "!fltEq(";
      process_expr(params[1], c_expr);
      c_expr.expr &:= ", ";
      process_expr(params[3], c_expr);
      c_expr.expr &:= ")";
    else
      c_expr.expr &:= "(";
      process_expr(params[1], c_expr);
      c_expr.expr &:= ") != (";
      process_expr(params[3], c_expr);
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process (FLT_NEGATE, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  local
    var reference: evaluatedParam is NIL;
  begin
    if getConstant(params[2], FLOATOBJECT, evaluatedParam) then
      incr(countOptimizations);
      c_expr.expr &:= floatLiteral(-getValue(evaluatedParam, float));
    else
      c_expr.expr &:= "-(";
      process_expr(params[2], c_expr);
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process (FLT_PARSE, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "fltParse(";
    getAnyParamToExpr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process (FLT_PLUS, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    process_expr(params[2], c_expr);
  end func;


const proc: process_const_flt_pow (in float: base, in reference: exponent,
    inout expr_type: c_expr) is func

  local
    var reference: evaluatedExponent is NIL;
    var string: exponentName is "";
  begin
    if getConstant(exponent, FLOATOBJECT, evaluatedExponent) then
      incr(countOptimizations);
      c_expr.expr &:= floatLiteral(base ** getValue(evaluatedExponent, float));
    elsif base = 1.0 then
      incr(countOptimizations);
      c_expr.expr &:= floatLiteral(1.0);
    elsif base = 2.0 and ccConf.HAS_EXP2 then
      incr(countOptimizations);
      c_expr.expr &:= "exp2(";
      process_expr(exponent, c_expr);
      c_expr.expr &:= ")";
    elsif base = 10.0 and ccConf.HAS_EXP10 then
      incr(countOptimizations);
      c_expr.expr &:= "exp10(";
      process_expr(exponent, c_expr);
      c_expr.expr &:= ")";
    elsif base = E then
      incr(countOptimizations);
      c_expr.expr &:= "exp(";
      process_expr(exponent, c_expr);
      c_expr.expr &:= ")";
    else
      if ccConf.POW_FUNCTION_OKAY then
        c_expr.expr &:= "pow(";
      else
        c_expr.expr &:= "fltPow(";
      end if;
      c_expr.expr &:= floatLiteral(base);
      c_expr.expr &:= ", ";
      process_expr(exponent, c_expr);
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process_const_flt_pow (in reference: base, in float: exponent,
    inout expr_type: c_expr) is func

  begin
    if exponent >= flt(-ccConf.INT_RANGE_IN_FLOATTYPE_MAX) and
        exponent <= flt(ccConf.INT_RANGE_IN_FLOATTYPE_MAX) and
        floor(exponent) = exponent then
      process_const_flt_ipow(base, trunc(exponent), c_expr);
(*
    elsif exponent = -0.5 then
      incr(countOptimizations);
      c_expr.expr &:= "1.0/sqrt(";
      process_expr(base, c_expr);
      c_expr.expr &:= ")";
*)
    elsif exponent = 0.33333333333333333333333333333333333333333333333333 and
        ccConf.HAS_CBRT then
      incr(countOptimizations);
      c_expr.expr &:= "cbrt(";
      process_expr(base, c_expr);
      c_expr.expr &:= ")";
    elsif exponent = 0.5 then
      incr(countOptimizations);
      c_expr.expr &:= "sqrt(";
      process_expr(base, c_expr);
      c_expr.expr &:= ")";
    else
      if ccConf.POW_FUNCTION_OKAY then
        c_expr.expr &:= "pow(";
      else
        c_expr.expr &:= "fltPow(";
      end if;
      process_expr(base, c_expr);
      c_expr.expr &:= ", ";
      c_expr.expr &:= floatLiteral(exponent);
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process (FLT_POW, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  local
    var reference: evaluatedParam is NIL;
  begin
    if getConstant(params[1], FLOATOBJECT, evaluatedParam) then
      process_const_flt_pow(getValue(evaluatedParam, float), params[3], c_expr);
    elsif getConstant(params[3], FLOATOBJECT, evaluatedParam) then
      process_const_flt_pow(params[1], getValue(evaluatedParam, float), c_expr);
    else
      if ccConf.POW_FUNCTION_OKAY then
        c_expr.expr &:= "pow(";
      else
        c_expr.expr &:= "fltPow(";
      end if;
      process_expr(params[1], c_expr);
      c_expr.expr &:= ", ";
      process_expr(params[3], c_expr);
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process (FLT_RAND, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "fltRand(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process (FLT_ROUND, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  local
    var string: number is "";
  begin
    if category(params[1]) = FLOATOBJECT and not isVar(params[1]) then
      (* Some compilers (cl) truncate different than the runtime  *)
      (* library. This is related to the behaviour of printf in   *)
      (* this runtime library: The function printf is not able    *)
      (* to write a float value of a power of two exactly. The    *)
      (* combination of inexact float literals and a C compiler   *)
      (* that trunctates this literals leads to errors. To avoid  *)
      (* problems we do the rounding instead of the C compiler.   *)
      incr(countOptimizations);
      block
        c_expr.expr &:= integerLiteral(round(getValue(params[1], float)));
      exception
        catch RANGE_ERROR:
          warning(DOES_RAISE, "RANGE_ERROR", c_expr);
          c_expr.expr &:= intRaiseError("RANGE_ERROR");
      end block;
    else
      c_expr.expr &:= "(";
      number := getParameterAsVariable("floatType", "tmp_", params[1], c_expr);
      if conversion_range_check then
        incr(countRangeChecks);
        c_expr.expr &:= "rngChk(os_isnan(";
        c_expr.expr &:= number;
        c_expr.expr &:= ")||";
        c_expr.expr &:= number;
        c_expr.expr &:= "<";
        c_expr.expr &:= floatLiteral(flt(integer.first) - 0.5);
        c_expr.expr &:= "||";
        c_expr.expr &:= number;
        c_expr.expr &:= ">";
        c_expr.expr &:= floatLiteral(flt(integer.last) + 0.5);
        c_expr.expr &:= ")?";
        c_expr.expr &:= intRaiseError("RANGE_ERROR");
        c_expr.expr &:= ":";
      end if;
      (* Formula used: (a<0.0?-((intType)(0.5-a)):(intType)(0.5+a)) *)
      c_expr.expr &:= number;
      c_expr.expr &:= "<0.0?(intType)(";
      c_expr.expr &:= number;
      c_expr.expr &:= "-0.5):(intType)(";
      c_expr.expr &:= number;
      c_expr.expr &:= "+0.5))";
    end if;
  end func;


const proc: process (FLT_SBTR, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") - (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process (FLT_SBTR_ASSIGN, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: statement is expr_type.value;
  begin
    process_expr(params[1], statement);
    statement.expr &:= "-=";
    process_expr(params[3], statement);
    statement.expr &:= ";\n";
    doLocalDeclsOfStatement(statement, c_expr);
  end func;


const proc: process (FLT_SCI, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr := "fltSci(";
    getStdParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    getStdParamToResultExpr(params[3], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process (FLT_SIN, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "sin(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process (FLT_SINH, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "sinh(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process (FLT_SQRT, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "sqrt(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process (FLT_STR, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr := "fltStr(";
    getStdParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process (FLT_TAN, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "tan(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process (FLT_TANH, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "tanh(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process (FLT_TRUNC, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  local
    var string: number is "";
  begin
    if category(params[1]) = FLOATOBJECT and not isVar(params[1]) then
      (* Some compilers (cl) truncate different than the runtime  *)
      (* library. This is related to the behaviour of printf in   *)
      (* this runtime library: The function printf is not able    *)
      (* to write a float value of a power of two exactly. The    *)
      (* combination of inexact float literals and a C compiler   *)
      (* that trunctates this literals leads to errors. To avoid  *)
      (* problems we do the truncation instead of the C compiler. *)
      incr(countOptimizations);
      block
        c_expr.expr &:= integerLiteral(trunc(getValue(params[1], float)));
      exception
        catch RANGE_ERROR:
          warning(DOES_RAISE, "RANGE_ERROR", c_expr);
          c_expr.expr &:= intRaiseError("RANGE_ERROR");
      end block;
    elsif conversion_range_check then
      incr(countRangeChecks);
      c_expr.expr &:= "(";
      number := getParameterAsVariable("floatType", "tmp_", params[1], c_expr);
      c_expr.expr &:= "rngChk(os_isnan(";
      c_expr.expr &:= number;
      c_expr.expr &:= ")||";
      c_expr.expr &:= number;
      c_expr.expr &:= "<";
      c_expr.expr &:= floatLiteral(flt(integer.first));
      c_expr.expr &:= "||";
      c_expr.expr &:= number;
      c_expr.expr &:= ">";
      c_expr.expr &:= floatLiteral(flt(integer.last));
      c_expr.expr &:= ")?";
      c_expr.expr &:= intRaiseError("RANGE_ERROR");
      c_expr.expr &:= ":(intType)(";
      c_expr.expr &:= number;
      c_expr.expr &:= "))";
    else
      c_expr.expr &:= "(intType)(";
      process_expr(params[1], c_expr);
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process (FLT_VALUE, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "fltValue(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;
