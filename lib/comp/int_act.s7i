
(********************************************************************)
(*                                                                  *)
(*  int_act.s7i   Generate code for actions of the type integer.    *)
(*  Copyright (C) 1990 - 1994, 2004 - 2014  Thomas Mertes           *)
(*                                                                  *)
(*  This file is part of the Seed7 compiler.                        *)
(*                                                                  *)
(*  This program is free software; you can redistribute it and/or   *)
(*  modify it under the terms of the GNU General Public License as  *)
(*  published by the Free Software Foundation; either version 2 of  *)
(*  the License, or (at your option) any later version.             *)
(*                                                                  *)
(*  This program is distributed in the hope that it will be useful, *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of  *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *)
(*  GNU General Public License for more details.                    *)
(*                                                                  *)
(*  You should have received a copy of the GNU General Public       *)
(*  License along with this program; if not, write to the           *)
(*  Free Software Foundation, Inc., 51 Franklin Street,             *)
(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)
(*                                                                  *)
(********************************************************************)


const ACTION: INT_ABS             is action "INT_ABS";
const ACTION: INT_ADD             is action "INT_ADD";
const ACTION: INT_AND             is action "INT_AND";
const ACTION: INT_AND_ASSIGN      is action "INT_AND_ASSIGN";
const ACTION: INT_BINOM           is action "INT_BINOM";
const ACTION: INT_BIT_LENGTH      is action "INT_BIT_LENGTH";
const ACTION: INT_BYTES_BE        is action "INT_BYTES_BE";
const ACTION: INT_BYTES_BE_2_INT  is action "INT_BYTES_BE_2_INT";
const ACTION: INT_BYTES_LE        is action "INT_BYTES_LE";
const ACTION: INT_BYTES_LE_2_INT  is action "INT_BYTES_LE_2_INT";
const ACTION: INT_CMP             is action "INT_CMP";
const ACTION: INT_CONV            is action "INT_CONV";
const ACTION: INT_CPY             is action "INT_CPY";
const ACTION: INT_DECR            is action "INT_DECR";
const ACTION: INT_DIV             is action "INT_DIV";
const ACTION: INT_EQ              is action "INT_EQ";
const ACTION: INT_FACT            is action "INT_FACT";
const ACTION: INT_GE              is action "INT_GE";
const ACTION: INT_GROW            is action "INT_GROW";
const ACTION: INT_GT              is action "INT_GT";
const ACTION: INT_HASHCODE        is action "INT_HASHCODE";
const ACTION: INT_INCR            is action "INT_INCR";
const ACTION: INT_LE              is action "INT_LE";
const ACTION: INT_LOG10           is action "INT_LOG10";
const ACTION: INT_LOG2            is action "INT_LOG2";
const ACTION: INT_LOWEST_SET_BIT  is action "INT_LOWEST_SET_BIT";
const ACTION: INT_LPAD0           is action "INT_LPAD0";
const ACTION: INT_LSHIFT          is action "INT_LSHIFT";
const ACTION: INT_LSHIFT_ASSIGN   is action "INT_LSHIFT_ASSIGN";
const ACTION: INT_LT              is action "INT_LT";
const ACTION: INT_MDIV            is action "INT_MDIV";
const ACTION: INT_MOD             is action "INT_MOD";
const ACTION: INT_MULT            is action "INT_MULT";
const ACTION: INT_MULT_ASSIGN     is action "INT_MULT_ASSIGN";
const ACTION: INT_NE              is action "INT_NE";
const ACTION: INT_NEGATE          is action "INT_NEGATE";
const ACTION: INT_ODD             is action "INT_ODD";
const ACTION: INT_OR              is action "INT_OR";
const ACTION: INT_ORD             is action "INT_ORD";
const ACTION: INT_OR_ASSIGN       is action "INT_OR_ASSIGN";
const ACTION: INT_PARSE           is action "INT_PARSE";
const ACTION: INT_PLUS            is action "INT_PLUS";
const ACTION: INT_POW             is action "INT_POW";
const ACTION: INT_PRED            is action "INT_PRED";
const ACTION: INT_radix           is action "INT_radix";
const ACTION: INT_RADIX           is action "INT_RADIX";
const ACTION: INT_RAND            is action "INT_RAND";
const ACTION: INT_REM             is action "INT_REM";
const ACTION: INT_RSHIFT          is action "INT_RSHIFT";
const ACTION: INT_RSHIFT_ASSIGN   is action "INT_RSHIFT_ASSIGN";
const ACTION: INT_SBTR            is action "INT_SBTR";
const ACTION: INT_SHRINK          is action "INT_SHRINK";
const ACTION: INT_SQRT            is action "INT_SQRT";
const ACTION: INT_STR             is action "INT_STR";
const ACTION: INT_SUCC            is action "INT_SUCC";
const ACTION: INT_URSHIFT         is action "INT_URSHIFT";
const ACTION: INT_URSHIFT_ASSIGN  is action "INT_URSHIFT_ASSIGN";
const ACTION: INT_VALUE           is action "INT_VALUE";
const ACTION: INT_XOR             is action "INT_XOR";
const ACTION: INT_XOR_ASSIGN      is action "INT_XOR_ASSIGN";


const proc: process (INT_ABS, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "labs(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process (INT_ADD, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") + (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process (INT_AND, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") & (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process (INT_AND_ASSIGN, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: statement is expr_type.value;
  begin
    process_expr(params[1], statement);
    statement.expr &:= "&=";
    process_expr(params[3], statement);
    statement.expr &:= ";\n";
    doLocalDeclsOfStatement(statement, c_expr);
  end func;


const proc: process (INT_BINOM, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "intBinom(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process (INT_BIT_LENGTH, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "intBitLength(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process (INT_BYTES_BE, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr := "intBytesBe(";
    getStdParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    getStdParamToResultExpr(params[2], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process (INT_BYTES_BE_2_INT, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "intBytesBe2Int(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process (INT_BYTES_LE, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr := "intBytesLe(";
    getStdParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    getStdParamToResultExpr(params[2], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process (INT_BYTES_LE_2_INT, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "intBytesLe2Int(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process (INT_CMP, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "intCmp(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process (INT_CONV, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process (INT_CPY, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: statement is expr_type.value;
  begin
    process_expr(params[1], statement);
    statement.expr &:= "=";
    process_expr(params[3], statement);
    statement.expr &:= ";\n";
    doLocalDeclsOfStatement(statement, c_expr);
  end func;


const proc: process (INT_DECR, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    setDiagnosticLine(c_expr);
    c_expr.expr &:= "--(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_const_int_div (in reference: dividend, in integer: divisor,
    inout expr_type: c_expr) is func

  local
    var reference: evaluatedDividend is NIL;
  begin
    if divisor = 0 then
      incr(countOptimizations);
      c_expr.expr &:= raiseError("NUMERIC_ERROR");
    elsif getConstant(dividend, INTOBJECT, evaluatedDividend) then
      incr(countOptimizations);
      c_expr.expr &:= str(getValue(evaluatedDividend, integer) div divisor);
    elsif divisor = 1 then
      incr(countOptimizations);
      c_expr.expr &:= "(";
      process_expr(dividend, c_expr);
      c_expr.expr &:= ")";
    elsif divisor = -1 then
      incr(countOptimizations);
      c_expr.expr &:= "-(";
      process_expr(dividend, c_expr);
      c_expr.expr &:= ")";
    else
      c_expr.expr &:= "(";
      process_expr(dividend, c_expr);
      c_expr.expr &:= ") / ";
      c_expr.expr &:= str(divisor);
    end if;
  end func;


const proc: process_const_int_div (in integer: dividend, in reference: divisor,
    inout expr_type: c_expr) is func

  local
    var string: divisor_name is "";
  begin
    if dividend = 0 then
      incr(countOptimizations);
      c_expr.expr &:= "((";
      process_expr(divisor, c_expr);
      c_expr.expr &:= ")==0?";
      c_expr.expr &:= raiseError("NUMERIC_ERROR");
      c_expr.expr &:= ":0)";
    elsif ccConf.CHECK_INT_DIV_BY_ZERO then
      c_expr.expr &:= "(";
      divisor_name := getParameterAsVariable("intType", "tmp_b_", divisor, c_expr);
      c_expr.expr &:= divisor_name;
      c_expr.expr &:= "==0?";
      c_expr.expr &:= raiseError("NUMERIC_ERROR");
      c_expr.expr &:= ":";
      c_expr.expr &:= str(dividend);
      c_expr.expr &:= " / ";
      c_expr.expr &:= divisor_name;
      c_expr.expr &:= ")";
    else
      c_expr.expr &:= str(dividend);
      c_expr.expr &:= " / (";
      process_expr(divisor, c_expr);
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process (INT_DIV, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  local
    var reference: evaluatedParam is NIL;
    var string: divisor_name is "";
  begin
    if getConstant(params[3], INTOBJECT, evaluatedParam) then
      process_const_int_div(params[1], getValue(evaluatedParam, integer), c_expr);
    elsif getConstant(params[1], INTOBJECT, evaluatedParam) then
      process_const_int_div(getValue(evaluatedParam, integer), params[3], c_expr);
    elsif ccConf.CHECK_INT_DIV_BY_ZERO then
      c_expr.expr &:= "(";
      divisor_name := getParameterAsVariable("intType", "tmp_b_", params[3], c_expr);
      c_expr.expr &:= divisor_name;
      c_expr.expr &:= "==0?";
      c_expr.expr &:= raiseError("NUMERIC_ERROR");
      c_expr.expr &:= ":(";
      process_expr(params[1], c_expr);
      c_expr.expr &:= ") / ";
      c_expr.expr &:= divisor_name;
      c_expr.expr &:= ")";
    else
      c_expr.expr &:= "(";
      process_expr(params[1], c_expr);
      c_expr.expr &:= ") / (";
      process_expr(params[3], c_expr);
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process (INT_EQ, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") == (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process (INT_FACT, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  local
    var string: number_name is "";
  begin
    c_expr.expr &:= "(";
    number_name := getParameterAsVariable("intType", "tmp_", params[2], c_expr);
    c_expr.expr &:= number_name;
    c_expr.expr &:= "<0||";
    c_expr.expr &:= number_name;
    c_expr.expr &:= ">=sizeof(fact)/sizeof(intType)?";
    c_expr.expr &:= raiseError("NUMERIC_ERROR");
    c_expr.expr &:= ":fact[";
    c_expr.expr &:= number_name;
    c_expr.expr &:= "])";
  end func;


const proc: process (INT_GE, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") >= (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process (INT_GROW, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: statement is expr_type.value;
  begin
    process_expr(params[1], statement);
    statement.expr &:= "+=";
    process_expr(params[3], statement);
    statement.expr &:= ";\n";
    doLocalDeclsOfStatement(statement, c_expr);
  end func;


const proc: process (INT_GT, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") > (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process (INT_HASHCODE, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process (INT_INCR, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    setDiagnosticLine(c_expr);
    c_expr.expr &:= "++(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process (INT_LE, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") <= (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process (INT_LOG10, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "intLog10(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process (INT_LOG2, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "intLog2(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process (INT_LOWEST_SET_BIT, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "intLowestSetBit(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process (INT_LPAD0, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr := "intLpad0(";
    getStdParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ",";
    getStdParamToResultExpr(params[3], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_const_int_lshift (in reference: param1, in integer: shiftCount,
    inout expr_type: c_expr) is func

  begin
    if shiftCount < 0 then
      incr(countOptimizations);
      c_expr.expr &:= raiseError("NUMERIC_ERROR");
    elsif shiftCount >= ccConf.INTTYPE_SIZE then
      incr(countOptimizations);
      c_expr.expr &:= "(";
      process_expr(param1, c_expr);
      c_expr.expr &:= ")!=0?";
      c_expr.expr &:= raiseError("NUMERIC_ERROR");
      c_expr.expr &:= ":0";
    else
      c_expr.expr &:= "(";
      process_expr(param1, c_expr);
      c_expr.expr &:= ") << ";
      c_expr.expr &:= str(shiftCount);
    end if;
  end func;


const proc: process (INT_LSHIFT, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  local
    var reference: evaluatedParam is NIL;
    var string: lshift_name is "";
  begin
    if getConstant(params[3], INTOBJECT, evaluatedParam) then
      process_const_int_lshift(params[1], getValue(evaluatedParam, integer), c_expr);
    elsif integer_shift_check then
      c_expr.expr &:= "(";
      lshift_name := getParameterAsVariable("intType", "lshift_", params[3], c_expr);
      c_expr.expr &:= lshift_name;
      c_expr.expr &:= "<0?";
      c_expr.expr &:= raiseError("NUMERIC_ERROR");
      c_expr.expr &:= ":";
      c_expr.expr &:= lshift_name;
      c_expr.expr &:= ">=";
      c_expr.expr &:= integerLiteral(ccConf.INTTYPE_SIZE);
      c_expr.expr &:= "?((";
      process_expr(params[1], c_expr);
      c_expr.expr &:= ")!=0?";
      c_expr.expr &:= raiseError("NUMERIC_ERROR");
      c_expr.expr &:= ":0):(";
      process_expr(params[1], c_expr);
      c_expr.expr &:= ") << ";
      c_expr.expr &:= lshift_name;
      c_expr.expr &:= ")";
    else
      c_expr.expr &:= "(";
      process_expr(params[1], c_expr);
      c_expr.expr &:= ") << (";
      process_expr(params[3], c_expr);
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process (INT_LSHIFT_ASSIGN, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: statement is expr_type.value;
  begin
    process_expr(params[1], statement);
    statement.expr &:= "<<=";
    process_expr(params[3], statement);
    statement.expr &:= ";\n";
    doLocalDeclsOfStatement(statement, c_expr);
  end func;


const proc: process (INT_LT, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") < (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_const_int_mdiv (in reference: dividend, in integer: divisor,
    inout expr_type: c_expr) is func

  local
    var reference: evaluatedDividend is NIL;
    var string: dividend_name is "";
  begin
    incr(countOptimizations);
    if divisor = 0 then
      c_expr.expr &:= raiseError("NUMERIC_ERROR");
    elsif getConstant(dividend, INTOBJECT, evaluatedDividend) then
      c_expr.expr &:= str(getValue(evaluatedDividend, integer) mdiv divisor);
    elsif divisor = 1 then
      c_expr.expr &:= "(";
      process_expr(dividend, c_expr);
      c_expr.expr &:= ")";
    elsif divisor = -1 then
      c_expr.expr &:= "-(";
      process_expr(dividend, c_expr);
      c_expr.expr &:= ")";
    elsif divisor > 0 and 2 ** log2(divisor) = divisor then
      if ccConf.RSHIFT_DOES_SIGN_EXTEND then
        c_expr.expr &:= "(";
        process_expr(dividend, c_expr);
        c_expr.expr &:= ") >> ";
        c_expr.expr &:= str(log2(divisor));
      else
        c_expr.expr &:= "(";
        dividend_name := getParameterAsVariable("intType", "tmp_a_", dividend, c_expr);
        doRshift(dividend_name, str(log2(divisor)), c_expr);
        c_expr.expr &:= ")";
      end if;
    elsif divisor < 0 and bitLength(divisor) = lowestSetBit(divisor) then
      # The check above is (almost) equivalent to:
      #   divisor < 0 and 2 ** log2(-divisor) = -divisor
      # The check with bitLength is used to avoid negating the divisor.
      # Negating the divisor would fail for the most negative integer.
      if ccConf.RSHIFT_DOES_SIGN_EXTEND then
        c_expr.expr &:= "-(";
        process_expr(dividend, c_expr);
        c_expr.expr &:= ") >> ";
        c_expr.expr &:= str(bitLength(divisor));
      else
        incr(c_expr.temp_num);
        dividend_name := "tmp_a_" & str(c_expr.temp_num);
        c_expr.temp_decls &:= "intType ";
        c_expr.temp_decls &:= dividend_name;
        c_expr.temp_decls &:= ";\n";
        c_expr.expr &:= "(";
        c_expr.expr &:= dividend_name;
        c_expr.expr &:= "=-(";
        process_expr(dividend, c_expr);
        c_expr.expr &:= "),";
        doRshift(dividend_name, str(bitLength(divisor)), c_expr);
        c_expr.expr &:= ")";
      end if;
    else
      c_expr.expr &:= "(";
      dividend_name := getParameterAsVariable("intType", "tmp_a_", dividend, c_expr);
      c_expr.expr &:= dividend_name;
      if divisor > 0 then
        (* Formula used: a<0?(a+1)/b-1:a/b *)
        c_expr.expr &:= "<0?(";
        c_expr.expr &:= dividend_name;
        c_expr.expr &:= "+1)/";
        c_expr.expr &:= str(divisor);
        c_expr.expr &:= "-1:(intType)((uintType)";
        c_expr.expr &:= dividend_name;
        c_expr.expr &:= "/";
        c_expr.expr &:= str(divisor);
        c_expr.expr &:= "))";
      else # divisor < 0
        (* Formula used: a>0?(a-1)/b-1:a/b *)
        c_expr.expr &:= ">0?(";
        c_expr.expr &:= dividend_name;
        c_expr.expr &:= "-1)/";
        c_expr.expr &:= str(divisor);
        c_expr.expr &:= "-1:";
        c_expr.expr &:= dividend_name;
        c_expr.expr &:= "/";
        c_expr.expr &:= str(divisor);
        c_expr.expr &:= ")";
      end if;
    end if;
  end func;


const proc: process_const_int_mdiv (in integer: dividend, in reference: divisor,
    inout expr_type: c_expr) is func

  local
    var string: divisor_name is "";
  begin
    incr(countOptimizations);
    if dividend = 0 then
      c_expr.expr &:= "((";
      process_expr(divisor, c_expr);
      c_expr.expr &:= ")==0?";
      c_expr.expr &:= raiseError("NUMERIC_ERROR");
      c_expr.expr &:= ":0)";
    else
      c_expr.expr &:= "(";
      divisor_name := getParameterAsVariable("intType", "tmp_b_", divisor, c_expr);
      c_expr.expr &:= divisor_name;
      if dividend > 0 then
        (* Formula used: b<0?(a-1)/b-1:a/b *)
        c_expr.expr &:= "<0?";
        c_expr.expr &:= str(pred(dividend));
      else # dividend < 0
        (* Formula used: b>0?(a+1)/b-1:a/b *)
        c_expr.expr &:= ">0?";
        c_expr.expr &:= str(succ(dividend));
      end if;
      c_expr.expr &:= "/";
      c_expr.expr &:= divisor_name;
      c_expr.expr &:= "-1:";
      if ccConf.CHECK_INT_DIV_BY_ZERO then
        c_expr.expr &:= divisor_name;
        c_expr.expr &:= "==0?";
        c_expr.expr &:= raiseError("NUMERIC_ERROR");
        c_expr.expr &:= ":";
      end if;
      c_expr.expr &:= str(dividend);
      c_expr.expr &:= "/";
      c_expr.expr &:= divisor_name;
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process (INT_MDIV, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  local
    var reference: evaluatedParam is NIL;
    var string: dividend_name is "";
    var string: divisor_name is "";
  begin
    if getConstant(params[3], INTOBJECT, evaluatedParam) then
      process_const_int_mdiv(params[1], getValue(evaluatedParam, integer), c_expr);
    elsif getConstant(params[1], INTOBJECT, evaluatedParam) then
      process_const_int_mdiv(getValue(evaluatedParam, integer), params[3], c_expr);
    else
      c_expr.expr &:= "(";
      dividend_name := getParameterAsVariable("intType", "tmp_a_", params[1], c_expr);
      divisor_name := getParameterAsVariable("intType", "tmp_b_", params[3], c_expr);
      (* Formula used: a>0&&b<0?(a-1)/b-1:a<0&&b>0?(a+1)/b-1:a/b *)
      c_expr.expr &:= dividend_name;
      c_expr.expr &:= ">0&&";
      c_expr.expr &:= divisor_name;
      c_expr.expr &:= "<0?(";
      c_expr.expr &:= dividend_name;
      c_expr.expr &:= "-1)/";
      c_expr.expr &:= divisor_name;
      c_expr.expr &:= "-1:";
      c_expr.expr &:= dividend_name;
      c_expr.expr &:= "<0&&";
      c_expr.expr &:= divisor_name;
      c_expr.expr &:= ">0?(";
      c_expr.expr &:= dividend_name;
      c_expr.expr &:= "+1)/";
      c_expr.expr &:= divisor_name;
      c_expr.expr &:= "-1:";
      if ccConf.CHECK_INT_DIV_BY_ZERO then
        c_expr.expr &:= divisor_name;
        c_expr.expr &:= "==0?";
        c_expr.expr &:= raiseError("NUMERIC_ERROR");
        c_expr.expr &:= ":";
      end if;
      c_expr.expr &:= dividend_name;
      c_expr.expr &:= "/";
      c_expr.expr &:= divisor_name;
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process_const_int_mod (in reference: dividend, in integer: divisor,
    inout expr_type: c_expr) is func

  local
    var reference: evaluatedDividend is NIL;
    var string: dividend_name is "";
    var string: quotient_name is "";
  begin
    incr(countOptimizations);
    if divisor = 0 then
      c_expr.expr &:= raiseError("NUMERIC_ERROR");
    elsif getConstant(dividend, INTOBJECT, evaluatedDividend) then
      c_expr.expr &:= str(getValue(evaluatedDividend, integer) mod divisor);
    elsif divisor = 1 or divisor = -1 then
      c_expr.expr &:= "0";
    elsif divisor > 0 and 2 ** log2(divisor) = divisor then
      c_expr.expr &:= "(";
      process_expr(dividend, c_expr);
      c_expr.expr &:= ")&";
      c_expr.expr &:= str(pred(divisor));
    elsif divisor < 0 and bitLength(divisor) = lowestSetBit(divisor) then
      # The check above is (almost) equivalent to:
      #   divisor < 0 and 2 ** log2(-divisor) = -divisor
      # The check with bitLength is used to avoid negating the divisor.
      # Negating the divisor would fail for the most negative integer.
      c_expr.expr &:= "-(-(";
      process_expr(dividend, c_expr);
      c_expr.expr &:= ")&";
      c_expr.expr &:= str(-succ(divisor));
      c_expr.expr &:= ")";
    else
      c_expr.expr &:= "(";
      dividend_name := getParameterAsVariable("intType", "tmp_a_", dividend, c_expr);
      incr(c_expr.temp_num);
      quotient_name := "tmp_c_" & str(c_expr.temp_num);
      c_expr.temp_decls &:= "intType ";
      c_expr.temp_decls &:= quotient_name;
      c_expr.temp_decls &:= ";\n";
      (* Formula used: c=a%b,a<0^b<0&&c!=0?c+b:c *)
      c_expr.expr &:= quotient_name;
      c_expr.expr &:= "=";
      c_expr.expr &:= dividend_name;
      c_expr.expr &:= "%";
      c_expr.expr &:= str(divisor);
      c_expr.expr &:= ",";
      c_expr.expr &:= dividend_name;
      if divisor > 0 then
        (* Formula used: c=a%b,a<0&&c!=0?c+b:c *)
        c_expr.expr &:= "<0";
      else # divisor < 0
        (* Formula used: c=a%b,a>0&&c!=0?c+b:c *)
        c_expr.expr &:= ">0";
      end if;
      c_expr.expr &:= "&&";
      c_expr.expr &:= quotient_name;
      c_expr.expr &:= "!=0?";
      c_expr.expr &:= quotient_name;
      c_expr.expr &:= "+";
      c_expr.expr &:= str(divisor);
      c_expr.expr &:= ":";
      c_expr.expr &:= quotient_name;
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process_const_int_mod (in integer: dividend, in reference: divisor,
    inout expr_type: c_expr) is func

  local
    var string: divisor_name is "";
    var string: quotient_name is "";
  begin
    incr(countOptimizations);
    if dividend = 0 then
      c_expr.expr &:= "((";
      process_expr(divisor, c_expr);
      c_expr.expr &:= ")==0?";
      c_expr.expr &:= raiseError("NUMERIC_ERROR");
      c_expr.expr &:= ":0)";
    elsif dividend = 1 then
      c_expr.expr &:= "(";
      divisor_name := getParameterAsVariable("intType", "tmp_b_", divisor, c_expr);
      c_expr.expr &:= divisor_name;
      c_expr.expr &:= "<=0?(";
      c_expr.expr &:= divisor_name;
      c_expr.expr &:= "==0?";
      c_expr.expr &:= raiseError("NUMERIC_ERROR");
      c_expr.expr &:= ":";
      c_expr.expr &:= divisor_name;
      c_expr.expr &:= "+1):(";
      c_expr.expr &:= divisor_name;
      c_expr.expr &:= "==1?0:1))";
    else
      c_expr.expr &:= "(";
      divisor_name := getParameterAsVariable("intType", "tmp_b_", divisor, c_expr);
      incr(c_expr.temp_num);
      quotient_name := "tmp_c_" & str(c_expr.temp_num);
      c_expr.temp_decls &:= "intType ";
      c_expr.temp_decls &:= quotient_name;
      c_expr.temp_decls &:= ";\n";
      if ccConf.CHECK_INT_DIV_BY_ZERO or ccConf.CHECK_INT_REM_BY_ZERO then
        c_expr.expr &:= divisor_name;
        c_expr.expr &:= "==0?";
        c_expr.expr &:= raiseError("NUMERIC_ERROR");
        c_expr.expr &:= ":(";
      end if;
      (* Formula used: c=a%b,a<0^b<0&&c!=0?c+b:c *)
      c_expr.expr &:= quotient_name;
      c_expr.expr &:= "=";
      c_expr.expr &:= str(dividend);
      c_expr.expr &:= "%";
      c_expr.expr &:= divisor_name;
      c_expr.expr &:= ",";
      c_expr.expr &:= divisor_name;
      if dividend > 0 then
        (* Formula used: c=a%b,b<0&&c!=0?c+b:c *)
        c_expr.expr &:= "<0";
      else # dividend < 0 then
        (* Formula used: c=a%b,b>0&&c!=0?c+b:c *)
        c_expr.expr &:= ">0";
      end if;
      c_expr.expr &:= "&&";
      c_expr.expr &:= quotient_name;
      c_expr.expr &:= "!=0?";
      c_expr.expr &:= quotient_name;
      c_expr.expr &:= "+";
      c_expr.expr &:= divisor_name;
      c_expr.expr &:= ":";
      c_expr.expr &:= quotient_name;
      if ccConf.CHECK_INT_DIV_BY_ZERO or ccConf.CHECK_INT_REM_BY_ZERO then
        c_expr.expr &:= ")";
      end if;
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process (INT_MOD, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  local
    var reference: evaluatedParam is NIL;
    var string: dividend_name is "";
    var string: divisor_name is "";
    var string: quotient_name is "";
  begin
    if getConstant(params[3], INTOBJECT, evaluatedParam) then
      process_const_int_mod(params[1], getValue(evaluatedParam, integer), c_expr);
    elsif getConstant(params[1], INTOBJECT, evaluatedParam) then
      process_const_int_mod(getValue(evaluatedParam, integer), params[3], c_expr);
    elsif ccConf.CHECK_INT_REM_ZERO_BY_ZERO and evaluate_const_expr = 0 and
          category(params[1]) = INTOBJECT and not isVar(params[1]) and
          getValue(params[1], integer) = 0 then
      c_expr.expr &:= "((";
      process_expr(params[3], c_expr);
      c_expr.expr &:= ")==0?";
      c_expr.expr &:= raiseError("NUMERIC_ERROR");
      c_expr.expr &:= ":0)";
(*
    elsif isActionExpression(params[3], "INT_LSHIFT") and
        category(getValue(params[3], ref_list)[2]) = INTOBJECT and
        not isVar(getValue(params[3], ref_list)[2]) and
        getValue(getValue(params[3], ref_list)[2], integer) = 1 then
      incr(countOptimizations);
      c_expr.expr &:= "/* mask lower bits */ (";
      process_expr(params[1], c_expr);
      c_expr.expr &:= ")&((1<<(";
      process_expr(getValue(params[3], ref_list)[4], c_expr);
      c_expr.expr &:= "))-1)";
*)
    else
      c_expr.expr &:= "(";
      dividend_name := getParameterAsVariable("intType", "tmp_a_", params[1], c_expr);
      divisor_name := getParameterAsVariable("intType", "tmp_b_", params[3], c_expr);
      incr(c_expr.temp_num);
      quotient_name := "tmp_c_" & str(c_expr.temp_num);
      c_expr.temp_decls &:= "intType ";
      c_expr.temp_decls &:= quotient_name;
      c_expr.temp_decls &:= ";\n";
      (* Formula used: c=a%b,a<0^b<0&&c!=0?c+b:c *)
      if ccConf.CHECK_INT_DIV_BY_ZERO or ccConf.CHECK_INT_REM_BY_ZERO then
        c_expr.expr &:= divisor_name;
        c_expr.expr &:= "==0?";
        c_expr.expr &:= raiseError("NUMERIC_ERROR");
        c_expr.expr &:= ":(";
      end if;
      c_expr.expr &:= quotient_name;
      c_expr.expr &:= "=";
      c_expr.expr &:= dividend_name;
      c_expr.expr &:= "%";
      c_expr.expr &:= divisor_name;
      c_expr.expr &:= ",";
      c_expr.expr &:= dividend_name;
      c_expr.expr &:= "<0^";
      c_expr.expr &:= divisor_name;
      c_expr.expr &:= "<0&&";
      c_expr.expr &:= quotient_name;
      c_expr.expr &:= "!=0?";
      c_expr.expr &:= quotient_name;
      c_expr.expr &:= "+";
      c_expr.expr &:= divisor_name;
      c_expr.expr &:= ":";
      c_expr.expr &:= quotient_name;
      if ccConf.CHECK_INT_DIV_BY_ZERO or ccConf.CHECK_INT_REM_BY_ZERO then
        c_expr.expr &:= ")";
      end if;
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process (INT_MULT, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") * (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process (INT_MULT_ASSIGN, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: statement is expr_type.value;
  begin
    process_expr(params[1], statement);
    statement.expr &:= "*=";
    process_expr(params[3], statement);
    statement.expr &:= ";\n";
    doLocalDeclsOfStatement(statement, c_expr);
  end func;


const proc: process (INT_NE, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") != (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process (INT_NEGATE, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "-(";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process (INT_ODD, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")&1";
  end func;


const proc: process (INT_OR, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") | (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process (INT_ORD, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process (INT_OR_ASSIGN, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: statement is expr_type.value;
  begin
    process_expr(params[1], statement);
    statement.expr &:= "|=";
    process_expr(params[3], statement);
    statement.expr &:= ";\n";
    doLocalDeclsOfStatement(statement, c_expr);
  end func;


const proc: process (INT_PARSE, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "intParse(";
    getAnyParamToExpr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process (INT_PLUS, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    process_expr(params[2], c_expr);
  end func;


const proc: process_const_int_pow (in reference: base, in integer: exponent,
    inout expr_type: c_expr) is func

  local
    const array string: power is [2] (
        (*  2 *) "x*x", "x*x*x", "(a=x*x,a*a)", "(a=x*x,a*a*x)", "(a=x*x*x,a*a)",
        (*  7 *) "(a=x*x,a*a*a*x)", "(b=(a=x*x,a*a),b*b)", "(b=(a=x*x,a*a),b*b*x)",
        (* 10 *) "(b=(a=x*x,a*a*x),b*b)", "(b=(a=x*x,a*a*x),b*b*x)",
        (* 12 *) "(b=(a=x*x*x,a*a),b*b)", "(b=(a=x*x,a*a),b*b*b*x)",
        (* 14 *) "(b=(a=x*x,a*a*a*x),b*b)", "(b=(a=x*x*x,a*a),b*b*a)",
        (* 16 *) "(c=(b=(a=x*x,a*a),b*b),c*c)", "(c=(b=(a=x*x,a*a),b*b),c*c*x)",
        (* 18 *) "(c=(b=(a=x*x,a*a),b*b),c*c*a)", "(c=(b=(a=x*x,a*a*x),b*a),c*c*b)",
        (* 20 *) "(c=(b=(a=x*x,a*a*x),b*b),c*c)", "(c=(b=(a=x*x,a*a*x),b*b),c*c*x)",
        (* 22 *) "(c=(b=(a=x*x,a*a*x),b*b*x),c*c)");
    const string: variables is "abc";
    var reference: evaluatedBase is NIL;
    var string: powerTemplate is "";
    var string: baseName is "";
    var string: variableName is "";
    var char: ch is ' ';
  begin
    if exponent < 0 then
      incr(countOptimizations);
      c_expr.expr &:= raiseError("NUMERIC_ERROR");
    elsif getConstant(base, INTOBJECT, evaluatedBase) then
      incr(countOptimizations);
      c_expr.expr &:= str(getValue(evaluatedBase, integer) ** exponent);
    elsif exponent = 0 then
      incr(countOptimizations);
      c_expr.expr &:= integerLiteral(1);
    elsif exponent = 1 then
      incr(countOptimizations);
      process_expr(base, c_expr);
    elsif exponent in {2 .. maxIdx(power)} then
      incr(countOptimizations);
      powerTemplate := power[exponent];
      c_expr.expr &:= "(";
      baseName := getParameterAsVariable("intType", "tmp_", base, c_expr);
      for ch range variables do
        if pos(powerTemplate, ch) <> 0 then
          incr(c_expr.temp_num);
          variableName := str(ch) & "_" & str(c_expr.temp_num);
          c_expr.temp_decls &:= "intType ";
          c_expr.temp_decls &:= variableName;
          c_expr.temp_decls &:= ";\n";
          powerTemplate := replace(powerTemplate, str(ch), variableName);
        end if;
      end for;
      c_expr.expr &:= replace(powerTemplate, "x", baseName);
      c_expr.expr &:= ")";
    else
      c_expr.expr &:= "intPow(";
      process_expr(base, c_expr);
      c_expr.expr &:= ", ";
      c_expr.expr &:= str(exponent);
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process_const_int_pow (in integer: base, in reference: exponent,
    inout expr_type: c_expr) is func

  local
    var string: exponent_name is "";
  begin
    if base = -1 then
      incr(countOptimizations);
      c_expr.expr &:= "(";
      exponent_name := getParameterAsVariable("intType", "tmp_", exponent, c_expr);
      c_expr.expr &:= exponent_name;
      c_expr.expr &:= "<0?";
      c_expr.expr &:= raiseError("NUMERIC_ERROR");
      c_expr.expr &:= ":1-((";
      c_expr.expr &:= exponent_name;
      c_expr.expr &:= "&1)<<1))";
    elsif base = 0 then
      incr(countOptimizations);
      c_expr.expr &:= "(";
      exponent_name := getParameterAsVariable("intType", "tmp_", exponent, c_expr);
      c_expr.expr &:= exponent_name;
      c_expr.expr &:= "<0?";
      c_expr.expr &:= raiseError("NUMERIC_ERROR");
      c_expr.expr &:= ":(";
      c_expr.expr &:= exponent_name;
      c_expr.expr &:= "==0?";
      c_expr.expr &:= integerLiteral(1);
      c_expr.expr &:= ":";
      c_expr.expr &:= integerLiteral(0);
      c_expr.expr &:= "))";
    elsif base = 1 then
      incr(countOptimizations);
      c_expr.expr &:= "((";
      process_expr(exponent, c_expr);
      c_expr.expr &:= ")<0?";
      c_expr.expr &:= raiseError("NUMERIC_ERROR");
      c_expr.expr &:= ":";
      c_expr.expr &:= integerLiteral(1);
      c_expr.expr &:= ")";
    elsif base = 2 then
      incr(countOptimizations);
      c_expr.expr &:= "(";
      exponent_name := getParameterAsVariable("intType", "tmp_", exponent, c_expr);
      c_expr.expr &:= exponent_name;
      c_expr.expr &:= "<0?";
      c_expr.expr &:= raiseError("NUMERIC_ERROR");
      c_expr.expr &:= ":";
      c_expr.expr &:= integerLiteral(1);
      c_expr.expr &:= "<<";
      c_expr.expr &:= exponent_name;
      c_expr.expr &:= ")";
    elsif base > 0 and 2 ** log2(base) = base then
      incr(countOptimizations);
      c_expr.expr &:= "(";
      exponent_name := getParameterAsVariable("intType", "tmp_", exponent, c_expr);
      c_expr.expr &:= exponent_name;
      c_expr.expr &:= "<0?";
      c_expr.expr &:= raiseError("NUMERIC_ERROR");
      c_expr.expr &:= ":";
      c_expr.expr &:= integerLiteral(1);
      c_expr.expr &:= "<<";
      c_expr.expr &:= str(log2(base));
      c_expr.expr &:= "*";
      c_expr.expr &:= exponent_name;
      c_expr.expr &:= ")";
    else
      c_expr.expr &:= "intPow(";
      c_expr.expr &:= str(base);
      c_expr.expr &:= ", ";
      process_expr(exponent, c_expr);
      c_expr.expr &:= ")";
    end if
  end func;


const proc: process (INT_POW, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  local
    var reference: evaluatedParam is NIL;
  begin
    if getConstant(params[3], INTOBJECT, evaluatedParam) then
      process_const_int_pow(params[1], getValue(evaluatedParam, integer), c_expr);
    elsif getConstant(params[1], INTOBJECT, evaluatedParam) then
      process_const_int_pow(getValue(evaluatedParam, integer), params[3], c_expr);
    else
      c_expr.expr &:= "intPow(";
      process_expr(params[1], c_expr);
      c_expr.expr &:= ", ";
      process_expr(params[3], c_expr);
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process (INT_PRED, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")-1";
  end func;


const proc: process_const_int_radix (in reference: param1, in integer: base,
    in boolean: upperCase, inout expr_type: c_expr) is func

  begin
    if base < 2 or base > 36 then
      c_expr.expr &:= raiseError("NUMERIC_ERROR");
    elsif base = 10 then
      prepare_stri_result(c_expr);
      c_expr.result_expr := "intStr(";
      getStdParamToResultExpr(param1, c_expr);
      c_expr.result_expr &:= ")";
    elsif 2 ** log2(base) = base then
      prepare_stri_result(c_expr);
      c_expr.result_expr := "intRadixPow2(";
      getStdParamToResultExpr(param1, c_expr);
      c_expr.result_expr &:= ",";
      c_expr.result_expr &:= str(log2(base));
      c_expr.result_expr &:= ",";
      c_expr.result_expr &:= str(pred(base));
      c_expr.result_expr &:= ",";
      c_expr.result_expr &:= str(ord(upperCase));
      c_expr.result_expr &:= ")";
    else
      prepare_stri_result(c_expr);
      c_expr.result_expr := "intRadix(";
      getStdParamToResultExpr(param1, c_expr);
      c_expr.result_expr &:= ", ";
      c_expr.result_expr &:= str(base);
      c_expr.result_expr &:= ",";
      c_expr.result_expr &:= str(ord(upperCase));
      c_expr.result_expr &:= ")";
    end if;
  end func;


const proc: process_int_radix (in ref_list: params, in boolean: upperCase,
    inout expr_type: c_expr) is func

  local
    var reference: evaluatedParam is NIL;
  begin
    if getConstant(params[3], INTOBJECT, evaluatedParam) then
      process_const_int_radix(params[1], getValue(evaluatedParam, integer), upperCase, c_expr);
    else
      prepare_stri_result(c_expr);
      c_expr.result_expr := "intRadix(";
      getStdParamToResultExpr(params[1], c_expr);
      c_expr.result_expr &:= ", ";
      getStdParamToResultExpr(params[3], c_expr);
      c_expr.result_expr &:= ",";
      c_expr.result_expr &:= str(ord(upperCase));
      c_expr.result_expr &:= ")";
    end if;
  end func;


const proc: process (INT_radix, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    process_int_radix(params, FALSE, c_expr);
  end func;


const proc: process (INT_RADIX, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    process_int_radix(params, TRUE, c_expr);
  end func;


const proc: process (INT_RAND, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "intRand(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_const_int_rem (in reference: dividend, in integer: divisor,
    inout expr_type: c_expr) is func

  local
    var reference: evaluatedDividend is NIL;
  begin
    if divisor = 0 then
      incr(countOptimizations);
      c_expr.expr &:= raiseError("NUMERIC_ERROR");
    elsif getConstant(dividend, INTOBJECT, evaluatedDividend) then
      incr(countOptimizations);
      c_expr.expr &:= str(getValue(evaluatedDividend, integer) rem divisor);
    elsif divisor = 1 or divisor = -1 then
      incr(countOptimizations);
      c_expr.expr &:= "0";
    else
      c_expr.expr &:= "(";
      process_expr(dividend, c_expr);
      c_expr.expr &:= ") % ";
      c_expr.expr &:= str(divisor);
    end if;
  end func;


const proc: process_const_int_rem (in integer: dividend, in reference: divisor,
    inout expr_type: c_expr) is func

  local
    var string: divisor_name is "";
  begin
    if dividend = 0 then
      incr(countOptimizations);
      c_expr.expr &:= "((";
      process_expr(divisor, c_expr);
      c_expr.expr &:= ")==0?";
      c_expr.expr &:= raiseError("NUMERIC_ERROR");
      c_expr.expr &:= ":0)";
    elsif ccConf.CHECK_INT_DIV_BY_ZERO or ccConf.CHECK_INT_REM_BY_ZERO then
      c_expr.expr &:= "(";
      divisor_name := getParameterAsVariable("intType", "tmp_b_", divisor, c_expr);
      c_expr.expr &:= divisor_name;
      c_expr.expr &:= "==0?";
      c_expr.expr &:= raiseError("NUMERIC_ERROR");
      c_expr.expr &:= ":";
      c_expr.expr &:= str(dividend);
      c_expr.expr &:= " % ";
      c_expr.expr &:= divisor_name;
      c_expr.expr &:= ")";
    else
      c_expr.expr &:= str(dividend);
      c_expr.expr &:= " % (";
      process_expr(divisor, c_expr);
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process (INT_REM, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  local
    var reference: evaluatedParam is NIL;
    var string: divisor_name is "";
  begin
    if getConstant(params[3], INTOBJECT, evaluatedParam) then
      process_const_int_rem(params[1], getValue(evaluatedParam, integer), c_expr);
    elsif getConstant(params[1], INTOBJECT, evaluatedParam) then
      process_const_int_rem(getValue(evaluatedParam, integer), params[3], c_expr);
    elsif ccConf.CHECK_INT_REM_ZERO_BY_ZERO and evaluate_const_expr = 0 and
          category(params[1]) = INTOBJECT and not isVar(params[1]) and
          getValue(params[1], integer) = 0 then
      c_expr.expr &:= "((";
      process_expr(params[3], c_expr);
      c_expr.expr &:= ")==0?";
      c_expr.expr &:= raiseError("NUMERIC_ERROR");
      c_expr.expr &:= ":0)";
    elsif ccConf.CHECK_INT_DIV_BY_ZERO or ccConf.CHECK_INT_REM_BY_ZERO then
      c_expr.expr &:= "(";
      divisor_name := getParameterAsVariable("intType", "tmp_b_", params[3], c_expr);
      c_expr.expr &:= divisor_name;
      c_expr.expr &:= "==0?";
      c_expr.expr &:= raiseError("NUMERIC_ERROR");
      c_expr.expr &:= ":(";
      process_expr(params[1], c_expr);
      c_expr.expr &:= ") % ";
      c_expr.expr &:= divisor_name;
      c_expr.expr &:= ")";
    else
      c_expr.expr &:= "(";
      process_expr(params[1], c_expr);
      c_expr.expr &:= ") % (";
      process_expr(params[3], c_expr);
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process_const_int_rshift (in reference: param1, in integer: shiftCount,
    inout expr_type: c_expr) is func

  local
    var string: number_name is "";
  begin
    if shiftCount < 0 then
      incr(countOptimizations);
      c_expr.expr &:= raiseError("NUMERIC_ERROR");
    elsif shiftCount >= ccConf.INTTYPE_SIZE then
      incr(countOptimizations);
      c_expr.expr &:= "((";
      process_expr(param1, c_expr);
      c_expr.expr &:= ")<0?-1:0)";
    else
      if ccConf.RSHIFT_DOES_SIGN_EXTEND then
        c_expr.expr &:= "(";
        process_expr(param1, c_expr);
        c_expr.expr &:= ") >> ";
        c_expr.expr &:= str(shiftCount);
      else
        c_expr.expr &:= "(";
        number_name := getParameterAsVariable("intType", "tmp_", param1, c_expr);
        doRshift(number_name, str(shiftCount), c_expr);
        c_expr.expr &:= ")";
      end if;
    end if;
  end func;


const proc: process (INT_RSHIFT, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  local
    var reference: evaluatedParam is NIL;
    var string: number_name is "";
    var string: rshift_name is "";
  begin
    if getConstant(params[3], INTOBJECT, evaluatedParam) then
      process_const_int_rshift(params[1], getValue(evaluatedParam, integer), c_expr);
    elsif integer_shift_check then
      if ccConf.RSHIFT_DOES_SIGN_EXTEND then
        c_expr.expr &:= "(";
        rshift_name := getParameterAsVariable("intType", "rshift_", params[3], c_expr);
        c_expr.expr &:= rshift_name;
        c_expr.expr &:= "<0?";
        c_expr.expr &:= raiseError("NUMERIC_ERROR");
        c_expr.expr &:= ":";
        c_expr.expr &:= rshift_name;
        c_expr.expr &:= ">=";
        c_expr.expr &:= integerLiteral(ccConf.INTTYPE_SIZE);
        c_expr.expr &:= "?((";
        process_expr(params[1], c_expr);
        c_expr.expr &:= ")<0?-1:0):(";
        process_expr(params[1], c_expr);
        c_expr.expr &:= ") >> ";
        c_expr.expr &:= rshift_name;
        c_expr.expr &:= ")";
      else
        c_expr.expr &:= "(";
        number_name := getParameterAsVariable("intType", "tmp_", params[1], c_expr);
        rshift_name := getParameterAsVariable("intType", "rshift_", params[3], c_expr);
        c_expr.expr &:= rshift_name;
        c_expr.expr &:= "<0?";
        c_expr.expr &:= raiseError("NUMERIC_ERROR");
        c_expr.expr &:= ":";
        c_expr.expr &:= rshift_name;
        c_expr.expr &:= ">=";
        c_expr.expr &:= integerLiteral(ccConf.INTTYPE_SIZE);
        c_expr.expr &:= "?(";
        c_expr.expr &:= number_name;
        c_expr.expr &:= "<0?-1:0):";
        doRshift(number_name, rshift_name, c_expr);
        c_expr.expr &:= ")";
      end if;
    else
      if ccConf.RSHIFT_DOES_SIGN_EXTEND then
        c_expr.expr &:= "(";
        process_expr(params[1], c_expr);
        c_expr.expr &:= ") >> (";
        process_expr(params[3], c_expr);
        c_expr.expr &:= ")";
      else
        c_expr.expr &:= "(";
        number_name := getParameterAsVariable("intType", "tmp_", params[1], c_expr);
        (* Formula used: a<0?~(~a>>b):a>>b *)
        c_expr.expr &:= number_name;
        c_expr.expr &:= "<0?~(~";
        c_expr.expr &:= number_name;
        c_expr.expr &:= " >> (";
        process_expr(params[3], c_expr);
        c_expr.expr &:= ")):";
        c_expr.expr &:= number_name;
        c_expr.expr &:= " >> (";
        process_expr(params[3], c_expr);
        c_expr.expr &:= "))";
      end if;
    end if;
  end func;


const proc: process (INT_RSHIFT_ASSIGN, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: statement is expr_type.value;
    var string: number_name is "";
  begin
    if ccConf.RSHIFT_DOES_SIGN_EXTEND then
      process_expr(params[1], statement);
      statement.expr &:= ">>=";
      process_expr(params[3], statement);
      statement.expr &:= ";\n";
    else
      (* Formula used: if (a<0) a= ~(~a>>b); else a>>=b; *)
      if isNormalVariable(params[1]) then
        number_name := normalVariable(params[1], statement);
      else
        incr(statement.temp_num);
        number_name := "tmp_" & str(statement.temp_num);
        statement.temp_decls &:= "intType *";
        statement.temp_decls &:= number_name;
        statement.temp_decls &:= ";\n";
        statement.expr &:= number_name;
        statement.expr &:= "=&(";
        process_expr(params[1], statement);
        statement.expr &:= ");\n";
        number_name := "*" & number_name;
      end if;
      statement.expr &:= "if (";
      statement.expr &:= number_name;
      statement.expr &:= "<0) ";
      statement.expr &:= number_name;
      statement.expr &:= "= ~(~";
      statement.expr &:= number_name;
      statement.expr &:= " >> (";
      process_expr(params[3], statement);
      statement.expr &:= ")); else ";
      statement.expr &:= number_name;
      statement.expr &:= " >>= (";
      process_expr(params[3], statement);
      statement.expr &:= ");\n";
    end if;
    doLocalDeclsOfStatement(statement, c_expr);
  end func;


const proc: process (INT_SBTR, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") - (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process (INT_SHRINK, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: statement is expr_type.value;
  begin
    process_expr(params[1], statement);
    statement.expr &:= "-=";
    process_expr(params[3], statement);
    statement.expr &:= ";\n";
    doLocalDeclsOfStatement(statement, c_expr);
  end func;


const proc: process (INT_SQRT, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "intSqrt(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process (INT_STR, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  local
    var string: buffer_name is "";
  begin
    if ccConf.ALLOW_STRITYPE_SLICES then
      incr(c_expr.temp_num);
      buffer_name := "buffer_" & str(c_expr.temp_num);
      c_expr.temp_decls &:= "union {\n";
      c_expr.temp_decls &:= "  struct striStruct striBuf;\n";
      c_expr.temp_decls &:= "  char charBuf[SIZ_STRI(INTTYPE_DECIMAL_SIZE)];\n";
      c_expr.temp_decls &:= "} ";
      c_expr.temp_decls &:= buffer_name;
      c_expr.temp_decls &:= ";\n";
      c_expr.expr &:= "intStrToBuffer(";
      process_expr(params[1], c_expr);
      c_expr.expr &:= ", &";
      c_expr.expr &:= buffer_name;
      c_expr.expr &:= ".striBuf)";
    else
      prepare_stri_result(c_expr);
      c_expr.result_expr := "intStr(";
      getStdParamToResultExpr(params[1], c_expr);
      c_expr.result_expr &:= ")";
    end if;
  end func;


const proc: process (INT_SUCC, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")+1";
  end func;


const proc: process_const_int_urshift (in reference: param1, in integer: shiftCount,
    inout expr_type: c_expr) is func

  begin
    if shiftCount < 0 then
      incr(countOptimizations);
      c_expr.expr &:= raiseError("NUMERIC_ERROR");
    elsif shiftCount >= ccConf.INTTYPE_SIZE then
      incr(countOptimizations);
      c_expr.expr &:= "0";
    else
      c_expr.expr &:= "(intType)((uintType)(";
      process_expr(param1, c_expr);
      c_expr.expr &:= ") >> ";
      c_expr.expr &:= str(shiftCount);
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process (INT_URSHIFT, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  local
    var reference: evaluatedParam is NIL;
    var string: urshift_name is "";
  begin
    if getConstant(params[3], INTOBJECT, evaluatedParam) then
      process_const_int_urshift(params[1], getValue(evaluatedParam, integer), c_expr);
    elsif integer_shift_check then
      c_expr.expr &:= "(";
      urshift_name := getParameterAsVariable("intType", "urshift_", params[3], c_expr);
      c_expr.expr &:= urshift_name;
      c_expr.expr &:= "<0?";
      c_expr.expr &:= raiseError("NUMERIC_ERROR");
      c_expr.expr &:= ":";
      c_expr.expr &:= urshift_name;
      c_expr.expr &:= ">=";
      c_expr.expr &:= integerLiteral(ccConf.INTTYPE_SIZE);
      c_expr.expr &:= "?0:(intType)((uintType)(";
      process_expr(params[1], c_expr);
      c_expr.expr &:= ") >> ";
      c_expr.expr &:= urshift_name;
      c_expr.expr &:= "))";
    else
      c_expr.expr &:= "(intType)((uintType)(";
      process_expr(params[1], c_expr);
      c_expr.expr &:= ") >> (";
      process_expr(params[3], c_expr);
      c_expr.expr &:= "))";
    end if;
  end func;


const proc: process (INT_URSHIFT_ASSIGN, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: statement is expr_type.value;
    var string: number_name is "";
  begin
    if isNormalVariable(params[1]) then
      number_name := normalVariable(params[1], statement);
    else
      incr(statement.temp_num);
      number_name := "tmp_" & str(statement.temp_num);
      statement.temp_decls &:= "intType *";
      statement.temp_decls &:= number_name;
      statement.temp_decls &:= ";\n";
      statement.expr &:= number_name;
      statement.expr &:= "=&(";
      process_expr(params[1], statement);
      statement.expr &:= ");\n";
    end if;
    statement.expr &:= number_name;
    statement.expr &:= "=(intType)((uintType)(";
    statement.expr &:= number_name;
    statement.expr &:= ") >> (";
    process_expr(params[3], statement);
    statement.expr &:= "));\n";
    doLocalDeclsOfStatement(statement, c_expr);
  end func;


const proc: process (INT_VALUE, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "intValue(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process (INT_XOR, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") ^ (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process (INT_XOR_ASSIGN, in reference: function,
    in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: statement is expr_type.value;
  begin
    process_expr(params[1], statement);
    statement.expr &:= "^=";
    process_expr(params[3], statement);
    statement.expr &:= ";\n";
    doLocalDeclsOfStatement(statement, c_expr);
  end func;
