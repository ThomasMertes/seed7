
(********************************************************************)
(*                                                                  *)
(*  scanstri.s7i  String scanner functions                          *)
(*  Copyright (C) 2007, 2008  Thomas Mertes                         *)
(*                                                                  *)
(*  This file is part of the Seed7 Runtime Library.                 *)
(*                                                                  *)
(*  The Seed7 Runtime Library is free software; you can             *)
(*  redistribute it and/or modify it under the terms of the GNU     *)
(*  Lesser General Public License as published by the Free Software *)
(*  Foundation; either version 2.1 of the License, or (at your      *)
(*  option) any later version.                                      *)
(*                                                                  *)
(*  The Seed7 Runtime Library is distributed in the hope that it    *)
(*  will be useful, but WITHOUT ANY WARRANTY; without even the      *)
(*  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR *)
(*  PURPOSE.  See the GNU Lesser General Public License for more    *)
(*  details.                                                        *)
(*                                                                  *)
(*  You should have received a copy of the GNU Lesser General       *)
(*  Public License along with this program; if not, write to the    *)
(*  Free Software Foundation, Inc., 51 Franklin Street,             *)
(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)
(*                                                                  *)
(********************************************************************)


include "charsets.s7i";


(**
 *  Skips a possibly nested comment from a 'string'.
 *  The comment starts with (* and ends with *) . When the function is
 *  called it is assumed that 'stri' is empty or stri[1] contains the
 *  '*'. When the function is left 'stri' is empty or stri[1] contains
 *  the character after the ')'.
 *)
const proc: skipComment (inout string: stri) is func
  local
    var integer: leng is 0;
    var integer: pos is 1;
  begin
    leng := length(stri);
    repeat
      repeat
        while pos <= leng and stri[pos] not in special_comment_char do
          incr(pos);
        end while;
        if pos <= leng and stri[pos] = '(' then
          incr(pos);
          if pos <= leng and stri[pos] = '*' then
            stri := stri[pos ..];
            skipComment(stri);
            leng := length(stri);
            pos := 1;
          end if;
        end if;
      until pos > leng or stri[pos] = '*';
      if pos <= leng then
        incr(pos);
      end if;
    until pos > leng or stri[pos] = ')';
    stri := stri[succ(pos) ..];
  end func; # skipComment


(**
 *  Reads a possibly nested comment from a 'string'.
 *  The comment starts with (* and ends with *) . When the function is
 *  called it is assumed that 'stri' is empty or stri[1] contains the
 *  '*'. When the function is left 'stri' is empty or stri[1] contains
 *  the character after the ')'.
 *  @return the content of the comment, including the introducing (*
 *          and the ending *) .
 *)
const func string: getComment (inout string: stri) is func
  result
    var string: symbol is "(";
  local
    var integer: leng is 0;
    var integer: pos is 1;
  begin
    leng := length(stri);
    repeat
      repeat
        while pos <= leng and stri[pos] not in special_comment_char do
          incr(pos);
        end while;
        if pos <= leng and stri[pos] = '(' then
          incr(pos);
          if pos <= leng and stri[pos] = '*' then
            symbol &:= stri[.. pos - 2];
            stri := stri[pos ..];
            symbol &:= getComment(stri);
            leng := length(stri);
            pos := 1;
          end if;
        end if;
      until pos > leng or stri[pos] = '*';
      if pos <= leng then
        incr(pos);
      end if;
    until pos > leng or stri[pos] = ')';
    symbol &:= stri[.. pos];
    stri := stri[succ(pos) ..];
  end func; # getComment


(**
 *  Skips a line comment from a 'string'.
 *  A line comment starts with # and ends with the end of the line.
 *  When the function is called it is assumed that 'stri' is empty or
 *  stri[1] contains the '#'. When the function is left 'stri' is
 *  empty or stri[1] contains '\n'.
 *)
const proc: skipLineComment (inout string: stri) is func
  local
    var integer: leng is 0;
    var integer: pos is 1;
  begin
    leng := length(stri);
    repeat
      incr(pos);
    until pos > leng or stri[pos] = '\n';
    stri := stri[pos ..];
  end func; # skipLineComment


(**
 *  Reads a line comment from a 'string'.
 *  A line comment starts with # and ends with the end of the line.
 *  When the function is called it is assumed that 'stri' is empty or
 *  stri[1] contains the '#'. When the function is left 'stri' is
 *  empty or stri[1] contains '\n'.
 *  @return the content of the comment, including the start
 *          marker # but without the line end character.
 *)
const func string: getLineComment (inout string: stri) is func
  result
    var string: symbol is "";
  local
    var integer: leng is 0;
    var integer: pos is 1;
  begin
    leng := length(stri);
    repeat
      incr(pos);
    until pos > leng or stri[pos] = '\n';
    symbol := stri[.. pred(pos)];
    stri := stri[pos ..];
  end func; # getLineComment


(**
 *  Reads a sequence of digits from a 'string'.
 *  When the function is called it is assumed that 'stri' is empty or
 *  stri[1] contains the first character to be handled. When the
 *  function is left 'stri' is empty or stri[1] contains the character
 *  after the digits.
 *  @return the digit sequence or "" when no digit was found.
 *)
const func string: getDigits (inout string: stri) is func
  result
    var string: symbol is "";
  local
    var integer: leng is 0;
    var integer: pos is 1;
  begin
    leng := length(stri);
    while pos <= leng and stri[pos] >= '0' and stri[pos] <= '9' do
      incr(pos);
    end while;
    symbol := stri[.. pred(pos)];
    stri := stri[pos ..];
  end func;


(**
 *  Reads a numeric literal from a 'string'.
 *  When the function is called it is assumed that 'stri' is empty or
 *  stri[1] contains the introducing digit. When the function is left
 *  'stri' is empty or stri[1] contains the character after the
 *  literal.
 *  @return The function returns the numeric literal.
 *)
const func string: getNumber (inout string: stri) is func
  result
    var string: symbol is "";
  local
    var integer: leng is 0;
    var integer: pos is 1;
  begin
    leng := length(stri);
    while pos <= leng and stri[pos] in digit_char do
      incr(pos);
    end while;
    if pos <= leng and stri[pos] = '.' then
      # float literal
      incr(pos);
      while pos <= leng and stri[pos] in digit_char do
        incr(pos);
      end while;
      if pos <= leng and (stri[pos] = 'E' or stri[pos] = 'e') then
        incr(pos);
        if pos <= leng and stri[pos] = '+' then
          incr(pos);
        elsif pos <= leng and stri[pos] = '-' then
          incr(pos);
        end if;
        while pos <= leng and stri[pos] in digit_char do
          incr(pos);
        end while;
      end if;
    elsif pos <= leng and stri[pos] = '#' then
      # based integer literal
      incr(pos);
      while pos <= leng and stri[pos] in alphanum_char do
        incr(pos);
      end while;
    elsif pos <= leng and (stri[pos] = 'E' or stri[pos] = 'e') then
      # integer literal with exponent
      incr(pos);
      if pos <= leng and stri[pos] = '+' then
        incr(pos);
      elsif pos <= leng and stri[pos] = '-' then
        incr(pos);
      end if;
      while pos <= leng and stri[pos] in digit_char do
        incr(pos);
      end while;
    elsif pos <= leng and stri[pos] = '_' then
      # bigInteger literal
      incr(pos);
    end if;
    symbol := stri[.. pred(pos)];
    stri := stri[pos ..];
  end func;


(**
 *  Reads an escape sequence from 'stri' and appends it to 'symbol'.
 *  The function accepts escape sequences from character end string
 *  literals. When the function is called it is assumed that stri[1]
 *  contains the introducing \ . When the function is left stri[1]
 *  contains the character after the escape sequence. The complete
 *  escape sequence including the introducing \ is appended to
 *  'symbol'.
 *)
const proc: getEscapeSequence (in string: stri, inout integer: pos, inout string: symbol) is func
  local
    var integer: leng is 0;
    var integer: backslashPos is 0;
    var string: numberStri is "";
  begin
    leng := length(stri);
    symbol &:= "\\";
    incr(pos);
    if pos <= leng then
      if stri[pos] = '\n' or stri[pos] = ' ' or stri[pos] = '\t' or stri[pos] = '\r' then
        repeat
          symbol &:= str(stri[pos]);
          incr(pos);
        until pos > leng or
            stri[pos] <> '\n' and stri[pos] <> ' ' and stri[pos] <> '\t' and stri[pos] <> '\r';
        if pos <= leng and stri[pos] = '\\' then
          symbol &:= str(stri[pos]);
          incr(pos);
        end if;
      elsif stri[pos] in digit_char then
        backslashPos := pos(stri, '\\', succ(pos));
        numberStri := stri[pos .. pred(backslashPos)];
        symbol &:= getNumber(numberStri);
        if numberStri = "" then
          symbol &:= "\\";
          pos := succ(backslashPos);
        else
          pos := backslashPos - length(numberStri);
        end if;
      else
        symbol &:= str(stri[pos]);
        incr(pos);
      end if;
    end if;
  end func;


(**
 *  Reads a character literal from a 'string'.
 *  When the function is called it is assumed that stri[1] contains
 *  the introducing ' . When the function is left 'stri' is empty or
 *  stri[1] contains the character after the closing ' .
 *  @return the character literal including the introducing ' and
 *          the closing ' .
 *)
const func string: getCharLiteral (inout string: stri) is func
  result
    var string: symbol is "'";
  local
    var integer: leng is 0;
    var integer: pos is 2;
  begin
    leng := length(stri);
    if pos <= leng and stri[pos] <> '\n' and stri[pos] <> '\r' then
      if stri[pos] = '\\' then
        repeat
          getEscapeSequence(stri, pos, symbol);
        until stri[pos] <> '\\';
      else
        symbol &:= str(stri[pos]);
        incr(pos);
      end if;
      if pos > leng or stri[pos] <> '\'' then
        if stri[pos] <> '\n' and stri[pos] <> '\r' and stri[pos] <> EOF then
          repeat
            symbol &:= str(stri[pos]);
            incr(pos);
          until pos > leng or
              stri[pos] = '\'' or
              stri[pos] = '\n' or
              stri[pos] = '\r';
          if pos <= leng and stri[pos] = '\'' then
            symbol &:= str(stri[pos]);
            incr(pos);
          end if;
        end if;
      else
        symbol &:= str(stri[pos]);
        incr(pos);
      end if;
    end if;
    stri := stri[pos ..];
  end func;


(**
 *  Reads a string literal from a 'string'.
 *  When the function is called it is assumed that stri[1] contains
 *  the introducing " . When the function is left 'stri' is empty or
 *  stri[1] contains the character after the closing " .
 *  @return the string literal including the introducing " and the
 *          closing " .
 *)
const func string: getStringLiteral (inout string: stri) is func
  result
    var string: symbol is "\"";
  local
    var integer: leng is 0;
    var integer: pos is 1;
    var boolean: reading_string is TRUE;
  begin
    leng := length(stri);
    incr(pos);
    repeat
      while pos <= leng and stri[pos] in no_escape_char do
        symbol &:= str(stri[pos]);
        incr(pos);
      end while;
      if pos > leng or stri[pos] = '\n' or stri[pos] = '\r' then
        reading_string := FALSE;
      elsif stri[pos] = '\"' then
        symbol &:= str(stri[pos]);
        incr(pos);
        if pos <= leng and stri[pos] = '\"' then
          symbol &:= str(stri[pos]);
          incr(pos);
        else
          reading_string := FALSE;
        end if;
      elsif stri[pos] = '\\' then
        getEscapeSequence(stri, pos, symbol);
      else
        repeat
          symbol &:= str(stri[pos]);
          incr(pos);
        until pos > leng or stri[pos] >= ' ' or stri[pos] <= '~';
      end if;
    until not reading_string;
    stri := stri[pos ..];
  end func;


(**
 *  Reads an alphanumeric name from a 'string'.
 *  A name consists of a letter or underscore followed by letters,
 *  digits or underscores. When the function is called it is assumed
 *  that 'stri' is empty or stri[1] contains the first character to be
 *  handled. When the function is left 'stri' is empty or stri[1]
 *  contains the character after the name.
 *  @return the name or "" when no letter or underscore was found.
 *)
const func string: getName (inout string: stri) is func
  result
    var string: symbol is "";
  local
    var integer: leng is 0;
    var integer: pos is 1;
  begin
    leng := length(stri);
    if pos <= leng and stri[pos] in name_start_char then
      incr(pos);
      while pos <= leng and stri[pos] in name_char do
        incr(pos);
      end while;
      symbol := stri[.. pred(pos)];
      stri := stri[pos ..];
    end if;
  end func;


(**
 *  Skips space characters from a 'string'.
 *  When the function is called it is assumed that 'stri' is empty or
 *  stri[1] contains the first character to be handled. When the
 *  function is left 'stri' is empty or stri[1] contains the character
 *  after the space characters.
 *)
const proc: skipSpace (inout string: stri) is func
  local
    var integer: leng is 0;
    var integer: pos is 1;
  begin
    leng := length(stri);
    if pos <= leng and stri[pos] = ' ' then
      repeat
        incr(pos);
      until pos > leng or stri[pos] <> ' ';
      stri := stri[pos ..];
    end if;
  end func;


(**
 *  Skips whitespace characters from a 'string'.
 *  When the function is called it is assumed that 'stri' is empty or
 *  stri[1] contains the first character to be handled. When the
 *  function is left 'stri' is empty or stri[1] contains the character
 *  after the whitespace characters.
 *)
const proc: skipWhiteSpace (inout string: stri) is func
  local
    var integer: leng is 0;
    var integer: pos is 1;
  begin
    leng := length(stri);
    if pos <= leng and stri[pos] in white_space_char then
      repeat
        incr(pos);
      until pos > leng or stri[pos] not in white_space_char;
      stri := stri[pos ..];
    end if;
  end func;


(**
 *  Reads whitespace characters from a 'string'.
 *  When the function is called it is assumed that 'stri' is empty or
 *  stri[1] contains the first character to be handled. When the
 *  function is left 'stri' is empty or stri[1] contains the character
 *  after the whitespace characters.
 *  @return the string of whitespace characters or "" when no
 *          whitespace character was found.
 *)
const func string: getWhiteSpace (inout string: stri) is func
  result
    var string: symbol is "";
  local
    var integer: leng is 0;
    var integer: pos is 1;
  begin
    leng := length(stri);
    if pos <= leng and stri[pos] in white_space_char then
      repeat
        incr(pos);
      until pos > leng or stri[pos] not in white_space_char;
      symbol := stri[.. pred(pos)];
      stri := stri[pos ..];
    end if;
  end func;


(**
 *  Reads a symbol or a comment from a 'string'.
 *  Before reading the symbol or comment it skips whitespace
 *  characters. A symbol can be a literal (numeric, character or
 *  string), a name, a special symbol (sequence of special characters)
 *  or a parenthesis. A comment can be a normal comment or a line
 *  comment. When the function is called it is assumed that 'stri' is
 *  empty or stri[1] contains a whitespace character or the first
 *  character of a symbol or comment. When the function is left 'stri'
 *  is empty or stri[1] contains the character after the symbol or
 *  comment.
 *  @return the symbol, comment or "" when EOF was reached.
 *)
const func string: getSymbolOrComment (inout string: stri) is func
  result
    var string: symbol is "";
  local
    var integer: leng is 0;
    var integer: pos is 1;
  begin
    leng := length(stri);
    while pos <= leng and stri[pos] in white_space_char do
      incr(pos);
    end while;
    if pos <= leng then
      case stri[pos] of
        when name_start_char:
          incr(pos);
          while pos <= leng and stri[pos] in name_char do
            incr(pos);
          end while;
          symbol := stri[.. pred(pos)];
          stri := stri[pos ..];
        when special_char:
          incr(pos);
          while pos <= leng and stri[pos] in special_char do
            incr(pos);
          end while;
          symbol := stri[.. pred(pos)];
          stri := stri[pos ..];
        when left_paren_char:
          decr(leng);
          stri := stri[succ(pos) ..];
          if pos <= leng and stri[pos] = '*' then
            symbol := getComment(stri);
          else
            symbol := "(";
          end if;
        when other_paren_char:
          symbol := stri[.. pos];
          stri := stri[succ(pos) ..];
        when digit_char:
          symbol := getNumber(stri);
        when apostrophe_char:
          symbol := getCharLiteral(stri);
        when quotation_char:
          symbol := getStringLiteral(stri);
        when sharp_char:
          symbol := getLineComment(stri);
        otherwise:
          incr(pos);
          symbol := stri[.. pred(pos)];
          stri := stri[pos ..];
      end case;
    end if;
  end func;


(**
 *  Reads a symbol from a 'string'.
 *  Before reading the symbol it skips whitespace characters and
 *  comments (normal comments and line comments). A symbol can be a
 *  literal (numeric, character or string), a name, a special symbol
 *  (sequence of special characters) or a parenthesis. When the
 *  function is called it is assumed that 'stri' is empty or stri[1]
 *  contains a whitespace character or the first character of a symbol
 *  or comment. When the function is left 'stri' is empty or stri[1]
 *  contains the character after the symbol.
 *  @return the symbol or "" when EOF was reached.
 *)
const func string: getSymbol (inout string: stri) is func
  result
    var string: symbol is "";
  local
    var integer: leng is 0;
    var integer: pos is 1;
  begin
    leng := length(stri);
    while pos <= leng and stri[pos] in white_space_char do
      incr(pos);
    end while;
    if pos <= leng then
      case stri[pos] of
        when name_start_char:
          incr(pos);
          while pos <= leng and stri[pos] in name_char do
            incr(pos);
          end while;
          symbol := stri[.. pred(pos)];
          stri := stri[pos ..];
        when special_char:
          incr(pos);
          while pos <= leng and stri[pos] in special_char do
            incr(pos);
          end while;
          symbol := stri[.. pred(pos)];
          stri := stri[pos ..];
        when left_paren_char:
          decr(leng);
          stri := stri[succ(pos) ..];
          if pos <= leng and stri[pos] = '*' then
            skipComment(stri);
            symbol := getSymbol(stri);
          else
            symbol := "(";
          end if;
        when other_paren_char:
          symbol := stri[.. pos];
          stri := stri[succ(pos) ..];
        when digit_char:
          symbol := getNumber(stri);
        when apostrophe_char:
          symbol := getCharLiteral(stri);
        when quotation_char:
          symbol := getStringLiteral(stri);
        when sharp_char:
          symbol := getLineComment(stri);
        otherwise:
          incr(pos);
          symbol := stri[.. pred(pos)];
          stri := stri[pos ..];
      end case;
    end if;
  end func;
