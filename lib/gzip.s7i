
(********************************************************************)
(*                                                                  *)
(*  gzip.s7i      Gzip uncompression function                       *)
(*  Copyright (C) 2008  Thomas Mertes                               *)
(*                                                                  *)
(*  This file is part of the Seed7 Runtime Library.                 *)
(*                                                                  *)
(*  The Seed7 Runtime Library is free software; you can             *)
(*  redistribute it and/or modify it under the terms of the GNU     *)
(*  Lesser General Public License as published by the Free Software *)
(*  Foundation; either version 2.1 of the License, or (at your      *)
(*  option) any later version.                                      *)
(*                                                                  *)
(*  The Seed7 Runtime Library is distributed in the hope that it    *)
(*  will be useful, but WITHOUT ANY WARRANTY; without even the      *)
(*  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR *)
(*  PURPOSE.  See the GNU Lesser General Public License for more    *)
(*  details.                                                        *)
(*                                                                  *)
(*  You should have received a copy of the GNU Lesser General       *)
(*  Public License along with this program; if not, write to the    *)
(*  Free Software Foundation, Inc., 51 Franklin Street,             *)
(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)
(*                                                                  *)
(********************************************************************)


const func string: getZeroTerminatedString (in string: stri, inout integer: currPos) is func
  result
    var string: result is "";
  local
    var integer: startPos is 0;
  begin
    startPos := currPos;
    while stri[currPos] <> '\0\' do
      incr(currPos);
    end while;
    result := stri[startPos .. pred(currPos)];
    incr(currPos);
  end func;


const func integer: getBits (in string: stri,
    inout integer: bytePos, inout integer: bitPos, in var integer: bitsNeeded) is func
  result
    var integer: result is 0;
  local
    var integer: bitsInByte is 0;
    var integer: bitsInResult is 0;
  begin
    while bitsNeeded <> 0 do
      bitsInByte := 8 - bitPos;
      if bitsInByte > bitsNeeded then
        bitsInByte := bitsNeeded;
      end if;
      result +:= (ord(stri[bytePos]) >> bitPos) mod (1 << bitsInByte) << bitsInResult;
      bitPos +:= bitsInByte;
      if bitPos = 8 then
        bitPos := 0;
        incr(bytePos);
      end if;
      bitsNeeded -:= bitsInByte;
      bitsInResult +:= bitsInByte;
    end while;
  end func;


const proc: getNonCompressedBlock (in string: stri, inout integer: bytePos,
    inout string: result) is func
  local
    var integer: length is 0;
    var integer: nlength is 0;
  begin
    length := ord(stri[bytePos]) + (ord(stri[succ(bytePos)]) << 8);
    nlength := ord(stri[bytePos + 2]) + (ord(stri[bytePos + 3]) << 8);
    # writeln("len=" <& length);
    # writeln("nlen=" <& nlength);
    result &:= stri[bytePos + 4 len length];
    bytePos +:= 4 + length;
  end func;


const func integer: decodeLiteralOrLengthValue (in string: stri,
    inout integer: bytePos, inout integer: bitPos) is func
  result
    var integer: resultValue is 0;
  begin
    resultValue := getBits(stri, bytePos, bitPos, 7);
    if resultValue <= 2#0010111 then
      resultValue +:= 256;
    else
      resultValue <<:= 1;
      resultValue +:= getBits(stri, bytePos, bitPos, 1);
      if resultValue <= 2#10111111 then
        resultValue -:= 2#00110000;
      elsif resultValue <= 2#11000111 then
        resultValue +:= 280 - 2#11000000;
      else
        resultValue <<:= 1;
        resultValue +:= getBits(stri, bytePos, bitPos, 1);
        resultValue -:= 2#110010000 - 144;
      end if;
    end if;
  end func;


const func integer: decodeLengthValue (in string: stri,
    inout integer: bytePos, inout integer: bitPos, in integer: code) is func
  result
    var integer: lengthValue is 0;
  local
    var integer: additionalBits is 0;
  begin
    if code <= 264 then
      lengthValue := code - 254;
    elsif code <= 268 then
      lengthValue := 11 + ((code - 265) << 1) + getBits(stri, bytePos, bitPos, 1);
    elsif code <= 272 then
      lengthValue := 19 + ((code - 269) << 2) + getBits(stri, bytePos, bitPos, 2);
    elsif code <= 276 then
      lengthValue := 35 + ((code - 273) << 3) + getBits(stri, bytePos, bitPos, 3);
    elsif code <= 280 then
      lengthValue := 67 + ((code - 277) << 4) + getBits(stri, bytePos, bitPos, 4);
    elsif code <= 284 then
      lengthValue := 131 + ((code - 281) << 5) + getBits(stri, bytePos, bitPos, 5);
    elsif code = 285 then
      lengthValue := 258;
    else
      raise RANGE_ERROR;
    end if;
  end func;


const func integer: decodeDistanceValue (in string: stri,
    inout integer: bytePos, inout integer: bitPos, in integer: code) is func
  result
    var integer: distanceValue is 0;
  local
    var integer: additionalBits is 0;
  begin
    if code <= 3 then
      distanceValue := succ(code);
    elsif code <= 5 then
      distanceValue := 5 + ((code - 4) << 1) + getBits(stri, bytePos, bitPos, 1);
    elsif code <= 7 then
      distanceValue := 9 + ((code - 6) << 2) + getBits(stri, bytePos, bitPos, 2);
    elsif code <= 9 then
      distanceValue := 17 + ((code - 8) << 3) + getBits(stri, bytePos, bitPos, 3);
    elsif code <= 11 then
      distanceValue := 33 + ((code - 10) << 4) + getBits(stri, bytePos, bitPos, 4);
    elsif code <= 13 then
      distanceValue := 65 + ((code - 12) << 5) + getBits(stri, bytePos, bitPos, 5);
    elsif code <= 15 then
      distanceValue := 129 + ((code - 14) << 6) + getBits(stri, bytePos, bitPos, 6);
    elsif code <= 17 then
      distanceValue := 257 + ((code - 16) << 7) + getBits(stri, bytePos, bitPos, 7);
    elsif code <= 19 then
      distanceValue := 513 + ((code - 18) << 8) + getBits(stri, bytePos, bitPos, 8);
    elsif code <= 21 then
      distanceValue := 1025 + ((code - 20) << 9) + getBits(stri, bytePos, bitPos, 9);
    elsif code <= 23 then
      distanceValue := 2049 + ((code - 22) << 10) + getBits(stri, bytePos, bitPos, 10);
    elsif code <= 25 then
      distanceValue := 4097 + ((code - 24) << 11) + getBits(stri, bytePos, bitPos, 11);
    elsif code <= 27 then
      distanceValue := 8193 + ((code - 26) << 12) + getBits(stri, bytePos, bitPos, 12);
    elsif code <= 29 then
      distanceValue := 16385 + ((code - 28) << 13) + getBits(stri, bytePos, bitPos, 13);
    else
      raise RANGE_ERROR;
    end if;
  end func;


const proc: decodeFixedHuffmanCodes (in string: stri,
    inout integer: bytePos, inout integer: bitPos, inout string: result) is func
  local
    var integer: literalOrLength is 0;
    var integer: length is 0;
    var integer: distance is 0;
    var integer: number is 0;
    var integer: nextPos is 0;
  begin
    literalOrLength := decodeLiteralOrLengthValue(stri, bytePos, bitPos);
    while literalOrLength <> 256 do
      if literalOrLength < 256 then
        result &:= str(chr(literalOrLength));
      else
        length := decodeLengthValue(stri, bytePos, bitPos, literalOrLength);
        distance := getBits(stri, bytePos, bitPos, 5);
        distance := decodeDistanceValue(stri, bytePos, bitPos, distance);
        if length > distance then
          nextPos := succ(length(result));
          result &:= "\0\" mult length;
          for number range nextPos to nextPos + length - 1 do
            write(result[number - distance]);
            result @:= [number] result[number - distance];
          end for;
        else # hopefully length(result) >= distance holds
          write(result[succ(length(result)) - distance len length]);
          result &:= result[succ(length(result)) - distance len length];
        end if;
      end if;
      literalOrLength := decodeLiteralOrLengthValue(stri, bytePos, bitPos);
    end while;
  end func;


const type: conversionEntry is new struct
    var integer: limit is 0;
    var array integer: table is 0 times 0;
  end struct;

const type: conversionTableType is array conversionEntry;


const func integer: getHuffmanValue (in string: stri,
    inout integer: bytePos, inout integer: bitPos,
    in conversionTableType: conversionTable) is func
  result
    var integer: result is 0;
  local
    var integer: bitLength is 1;
    var integer: limit is 0;
    var integer: code is 0;
  begin
    # writeln("--- " <& bytePos <& " " <& bitPos);
    while conversionTable[bitLength].limit = 0 do
      code <<:= 1;
      code +:= getBits(stri, bytePos, bitPos, 1);
      incr(bitLength);
    end while;
    limit := conversionTable[bitLength].limit >> 1;
    # code := getBits(stri, bytePos, bitPos, pred(bitLength));
    # writeln("code=" <& code <& " " <& str(code, 2) lpad0 pred(bitLength) <& " limit=" <& limit);
    while code >= limit do
      code <<:= 1;
      code +:= getBits(stri, bytePos, bitPos, 1);
      incr(bitLength);
      if bitLength <= length(conversionTable) then
        limit := conversionTable[bitLength].limit >> 1;
      else
        # writeln("****");
        limit := code + 1;
      end if;
      # writeln("code=" <& code <& " " <& str(code, 2) lpad0 pred(bitLength) <& " limit=" <& limit);
    end while;
    decr(bitLength);
    # write("bitLength=" <& bitLength <& " code=" <& code <& " " <&
    #      str(code, 2) lpad0 pred(bitLength) <& " limit=" <& conversionTable[bitLength].limit);
    # writeln(" result=" <& conversionTable[bitLength].table[code - conversionTable[bitLength].limit + 1]);
    result := conversionTable[bitLength].table[code - conversionTable[bitLength].limit + 1];
    # writeln("result=" <& result);
  end func;


const func conversionTableType: computeConversionTable (in array integer: codeLengths) is func
  result
    var conversionTableType: conversionTable is conversionTableType.value;
  local
    var integer: maxBits is 0;
    var integer: bits is 0;
    var integer: number is 0;
    var integer: code is 0;
    var array integer: bl_count is 0 times 0;
    var integer: length is 0;
    var array integer: nextCode is 0 times 0;
    var array integer: codeValues is 0 times 0;
  begin
(*
    writeln("minIdx(codeLengths)=" <& minIdx(codeLengths));
    writeln("maxIdx(codeLengths)=" <& maxIdx(codeLengths));
    for number range minIdx(codeLengths) to maxIdx(codeLengths) do
      write(" " <& codeLengths[number]);
    end for;
    writeln;
*)
    maxBits := 0;
    for number range minIdx(codeLengths) to maxIdx(codeLengths) do
      if codeLengths[number] > maxBits then
        maxBits := codeLengths[number];
      end if;
    end for;
    # writeln("maxBits=" <& maxBits);
    bl_count := [0 .. maxBits] times 0;
    for number range minIdx(codeLengths) to maxIdx(codeLengths) do
      incr(bl_count[codeLengths[number]]);
    end for;
(*
    for bits range 1 to maxBits do
      write(" " <& bl_count[bits]);
    end for;
    writeln;
*)
    code := 0;
    bl_count[0] := 0;
    nextCode := maxBits times 0;
    conversionTable := maxBits times conversionEntry.value;
    for bits range 1 to maxBits do
      code := (code + bl_count[bits-1]) << 1;
      conversionTable[bits].limit := code;
      # write(" " <& code);
      nextCode[bits] := conversionTable[bits].limit;
    end for;
    # writeln;
(*
    for number range minIdx(codeLengths) to maxIdx(codeLengths) do
      if codeLengths[number] <> 0 and
          conversionTable[codeLengths[number]].base = -1 then
        conversionTable[codeLengths[number]].base := number;
      end if;
    end for;
    for bits range 1 to maxBits do
      write(" " <& conversionTable[bits].base);
    end for;
    writeln;
*)
    codeValues := [minIdx(codeLengths) .. maxIdx(codeLengths)] times 0;
    for number range minIdx(codeLengths) to maxIdx(codeLengths) do
      length := codeLengths[number];
      if length <> 0 then
        codeValues[number] := nextCode[length];
        incr(nextCode[length]);
        conversionTable[length].table &:= [] (number);
      end if;
      # write(number lpad 4 <& " " <&
      #     str(codeValues[number], 2) lpad0 codeLengths[number] lpad maxBits);
      # writeln(" " <& codeValues[number] lpad 5 <& " " <&
      #     literal(str(codeValues[number], 2)));
    end for;
    # writeln;
(*
    for bits range 1 to maxBits do
      for number range minIdx(conversionTable[bits].table) to maxIdx(conversionTable[bits].table) do
        write(conversionTable[bits].table[number] lpad 4 <& " " <&
            str(conversionTable[bits].limit + number - 1, 2) lpad0 bits lpad maxBits);
        writeln(" " <& conversionTable[bits].limit + number - 1 lpad 5 <& " " <&
            literal(str(conversionTable[bits].limit + number - 1, 2)));
      end for;
    end for;
    writeln;
*)
  end func;


const proc: decodeDynamicHuffmanCodes (in string: stri,
    inout integer: bytePos, inout integer: bitPos, inout string: result) is func
  local
    const array integer: codeLengthAlphabet is []
        (16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15);
    var integer: hlit is 0;
    var integer: hdist is 0;
    var integer: hclen is 0;
    var array integer: lengthCodeLengths is [0 .. -1] times 0;
    var array integer: combinedCodeLengths is [0 .. -1] times 0;
    var array integer: literalOrLengthCodeLengths is [0 .. -1] times 0;
    var array integer: distanceCodeLengths is [0 .. -1] times 0;
    var integer: number is 0;
    var integer: codeLength is 0;
    var integer: factor is 0;
    var conversionTableType: lengthConversionTable is conversionTableType.value;
    var conversionTableType: literalOrLengthConversionTable is conversionTableType.value;
    var conversionTableType: distanceConversionTable is conversionTableType.value;
    var integer: literalOrLength is 0;
    var integer: length is 0;
    var integer: distance is 0;
    var integer: nextPos is 0;
  begin
    hlit := getBits(stri, bytePos, bitPos, 5);
    hdist := getBits(stri, bytePos, bitPos, 5);
    hclen := getBits(stri, bytePos, bitPos, 4);
    # writeln("hlit=" <& hlit);
    # writeln("hdist=" <& hdist);
    # writeln("hclen=" <& hclen);
    lengthCodeLengths := [0 .. 18] times 0;
    for number range 1 to hclen + 4 do
      lengthCodeLengths[codeLengthAlphabet[number]] := getBits(stri, bytePos, bitPos, 3);
      # write(" " <& lengthCodeLengths[codeLengthAlphabet[number]]);
    end for;
    # writeln;
    lengthConversionTable := computeConversionTable(lengthCodeLengths);
    number := 1;
    while number <= hlit + 257 + hdist + 1 do
      codeLength := getHuffmanValue(stri, bytePos, bitPos, lengthConversionTable);
      # write(" " <& codeLength);
      if codeLength <= 15 then
        combinedCodeLengths &:= [] (codeLength);
        incr(number);
      elsif codeLength = 16 then
        factor := getBits(stri, bytePos, bitPos, 2) + 3;
        combinedCodeLengths &:= factor times
            combinedCodeLengths[maxIdx(combinedCodeLengths)];
        number +:= factor;
      elsif codeLength = 17 then
        factor := getBits(stri, bytePos, bitPos, 3) + 3;
        combinedCodeLengths &:= factor times 0;
        number +:= factor;
      else # codeLength = 18
        factor := getBits(stri, bytePos, bitPos, 7) + 11;
        combinedCodeLengths &:= factor times 0;
        number +:= factor;
      end if;
    end while;
    # writeln;
    literalOrLengthCodeLengths := combinedCodeLengths[.. hlit + 256];
    distanceCodeLengths := combinedCodeLengths[hlit + 257 .. ];
    literalOrLengthConversionTable := computeConversionTable(literalOrLengthCodeLengths);
    distanceConversionTable := computeConversionTable(distanceCodeLengths);
    # writeln("************");
    literalOrLength := getHuffmanValue(stri, bytePos, bitPos, literalOrLengthConversionTable);
    while literalOrLength <> 256 do
      if literalOrLength < 256 then
        # write(chr(literalOrLength));
        result &:= str(chr(literalOrLength));
      else
        # write("<" <& literalOrLength <& ">");
        length := decodeLengthValue(stri, bytePos, bitPos, literalOrLength);
        # write("[" <& length <& "]");
        distance := getHuffmanValue(stri, bytePos, bitPos, distanceConversionTable);
        # write("(" <& distance <& ")");
        distance := decodeDistanceValue(stri, bytePos, bitPos, distance);
        # write("{" <& distance <& "}");
        if length > distance then
          nextPos := succ(length(result));
          result &:= "\0\" mult length;
          for number range nextPos to nextPos + length - 1 do
            # write(result[number - distance]);
            result @:= [number] result[number - distance];
          end for;
        else # hopefully length(result) >= distance holds
          # write(result[succ(length(result)) - distance len length]);
          result &:= result[succ(length(result)) - distance len length];
        end if;
      end if;
      literalOrLength := getHuffmanValue(stri, bytePos, bitPos, literalOrLengthConversionTable);
    end while;
    # writeln("************");
  end func;


const proc: processCompressedBlock (in string: stri,
    inout integer: bytePos, inout integer: bitPos, inout string: result,
    inout boolean: bfinal) is func
  local
    var integer: btype is 0;
    var integer: currValue is 0;
  begin
    bfinal := odd(getBits(stri, bytePos, bitPos, 1));
    btype := getBits(stri, bytePos, bitPos, 2);
    # writeln("bfinal=" <& bfinal <& " btype=" <& btype);
    case btype of
      when {0}:
        if bitPos <> 0 then
          incr(bytePos);
          bitPos := 0;
        end if;
        getNonCompressedBlock(stri, bytePos, result);
      when {1}:
        decodeFixedHuffmanCodes(stri, bytePos, bitPos, result);
      when {2}:
        decodeDynamicHuffmanCodes(stri, bytePos, bitPos, result);
      otherwise:
        raise RANGE_ERROR;
    end case;
  end func;


const func string: gunzip (in string: stri) is func
  result
    var string: result is "";
  local
    var integer: compressionMethod is 0;
    var integer: flags is 0;
    var boolean: flagFtext is FALSE;
    var boolean: flagFhcrc is FALSE;
    var boolean: flagFextra is FALSE;
    var boolean: flagFname is FALSE;
    var boolean: flagFcomment is FALSE;
    var integer: mtime is 0;
    var integer: extraFlags is 0;
    var integer: operatingSystem is 0;
    var integer: bytePos is 0;
    var integer: bitPos is 0;
    var integer: extraLength is 0;
    var string: originalFileName is "";
    var string: fileComment is "";
    var integer: crc16 is 0;
    var boolean: bfinal is FALSE;
  begin
    if stri[1 len 2] = "\31\\139\" then
      compressionMethod := ord(stri[3]);
      # writeln("CM=" <& compressionMethod);
      flags := ord(stri[4]);
      flagFtext    := odd(flags);
      flagFhcrc    := odd(flags >> 1);
      flagFextra   := odd(flags >> 2);
      flagFname    := odd(flags >> 3);
      flagFcomment := odd(flags >> 4);
      # writeln(flagFtext <& " " <& flagFhcrc <& " " <& flagFextra <& " " <&
      #     flagFname <& " " <& flagFcomment);
      mtime := ord(stri[5]) + (ord(stri[6]) << 8) + (ord(stri[7]) << 16) + (ord(stri[8]) << 24);
      # writeln(mtime);
      extraFlags := ord(stri[9]);
      operatingSystem := ord(stri[10]);
      # writeln(extraFlags <& " " <& operatingSystem);
      bytePos := 11;
      bitPos := 0;
      if flagFextra then
        extraLength := ord(stri[11]) + (ord(stri[12]) << 8);
        bytePos +:= 2 + extraLength;
      end if;
      if flagFname then
        originalFileName := getZeroTerminatedString(stri, bytePos);
      end if;
      if flagFcomment then
        fileComment := getZeroTerminatedString(stri, bytePos);
      end if;
      if flagFhcrc then
        crc16 := ord(stri[11]) + (ord(stri[12]) << 8);
      end if;
      repeat
        processCompressedBlock(stri, bytePos, bitPos, result, bfinal);
      until bfinal;
    end if;
  end func;
