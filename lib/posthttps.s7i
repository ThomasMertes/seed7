
(********************************************************************)
(*                                                                  *)
(*  posthttps.s7i Support to post data with the HTTPS protocol      *)
(*  Copyright (C) 2026  Thomas Mertes                               *)
(*                                                                  *)
(*  This file is part of the Seed7 Runtime Library.                 *)
(*                                                                  *)
(*  The Seed7 Runtime Library is free software; you can             *)
(*  redistribute it and/or modify it under the terms of the GNU     *)
(*  Lesser General Public License as published by the Free Software *)
(*  Foundation; either version 2.1 of the License, or (at your      *)
(*  option) any later version.                                      *)
(*                                                                  *)
(*  The Seed7 Runtime Library is distributed in the hope that it    *)
(*  will be useful, but WITHOUT ANY WARRANTY; without even the      *)
(*  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR *)
(*  PURPOSE.  See the GNU Lesser General Public License for more    *)
(*  details.                                                        *)
(*                                                                  *)
(*  You should have received a copy of the GNU Lesser General       *)
(*  Public License along with this program; if not, write to the    *)
(*  Free Software Foundation, Inc., 51 Franklin Street,             *)
(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)
(*                                                                  *)
(********************************************************************)

include "posthttp.s7i";
include "tls.s7i";

const func file: openHttpsPost (in httpLocation: locationData, in httpBody: body) is func
  result
    var file: sock is STD_NULL;
  begin
    if locationData.httpsProtocol then
      sock := openTlsSocket(locationData.serverName, locationData.portNumber);
    else
      sock := openInetSocket(locationData.serverName, locationData.portNumber);
    end if;
    if sock <> STD_NULL then
      sendPost(sock, locationData, body);
    end if;
  end func;

const func string: postHttps (in string: location, in httpBody: body, in var httpCreds: creds) is func
  result
    var string: data is "";
  local
    var httpLocation: locationData is httpLocation.value;
    var file: sock is STD_NULL;
    var string: statusCode is "";
    var boolean: okay is TRUE;
    var integer: repeatCount is 0;
  begin
    locationData := getHttpLocation(location, httpsDefaultPort);
    locationData.httpsProtocol := TRUE;
    if proxyServer <> "" then
      locationData.serverName := proxyServer;
      locationData.portNumber := proxyHttpPort;
    end if;
    # Bearer tokens can always be sent (whereas basic auth should only be sent when requested).
    if creds.username = "" then
      locationData.creds := creds;
    end if;
    repeat
      okay := TRUE;
      sock := openHttpsPost(locationData, body);
      if sock <> STD_NULL then
        statusCode := getHttpStatusCode(sock);
        if statusCode = "301" or statusCode = "302" or
            statusCode = "303" or statusCode = "307" then
          locationData := getHttpLocation(locationData, sock);
          close(sock);
          sock := STD_NULL;
          okay := FALSE;
          incr(repeatCount);
        elsif statusCode = "401" and creds.username <> "" then
          locationData.creds := creds;
          close(sock);
          sock := STD_NULL;
          okay := FALSE;
          creds.username := ""; # Only try once.
        end if;
      end if;
    until okay or repeatCount > 5;
    if sock <> STD_NULL then
      data := getHttp(sock);
      close(sock);
    end if;
  end func;

const func string: postHttps (in string: location, in httpBody: body) is
  return postHttps(location, body, httpCreds.value);

const func string: postHttps (in string: location, in string: plain, in httpCreds: creds) is func
  result
    var string: data is "";
  local
    var httpBody: body is httpBody.value;
  begin
    body.content := plain;
    data := postHttps(location, body, creds);
  end func;

const func string: postHttps (in string: location, in string: plain) is func
  result
    var string: data is "";
  local
    var httpBody: body is httpBody.value;
  begin
    body.content := plain;
    data := postHttps(location, body);
  end func;

const func string: postHttps (in string: location, in jsonValue: json, in httpCreds: creds) is func
  result
    var string: data is "";
  local
    var httpBody: body is httpBody.value;
  begin
    body.contentType := "application/json";
    body.content := string(json);
    data := postHttps(location, body, creds);
  end func;

const func string: postHttps (in string: location, in jsonValue: json) is func
  result
    var string: data is "";
  local
    var httpBody: body is httpBody.value;
  begin
    body.contentType := "application/json";
    body.content := string(json);
    data := postHttps(location, body);
  end func;

const func string: postHttps (in string: location, in hash [string] string: fields, in httpCreds: creds) is func
  result
    var string: data is "";
  local
    var httpBody: body is httpBody.value;
    var string: name is "";
    var string: value is "";
  begin
    body.contentType := "application/x-www-form-urlencoded";
    for value key name range fields do
      body.content &:= toHttpAscii(name) & "=" & toHttpAscii(value) & "&";
    end for;
    if endsWith(body.content, "&") then
      body.content := body.content[.. length(body.content)-1];
    end if;
    data := postHttps(location, body, creds);
  end func;

const func string: postHttps (in string: location, in hash [string] string: fields) is
  return postHttps(location, fields, httpCreds.value);
