
(********************************************************************)
(*                                                                  *)
(*  rational.s7i  Rational number support library                   *)
(*  Copyright (C) 1991 - 1994, 2005, 2007  Thomas Mertes            *)
(*                                                                  *)
(*  This file is part of the Seed7 Runtime Library.                 *)
(*                                                                  *)
(*  The Seed7 Runtime Library is free software; you can             *)
(*  redistribute it and/or modify it under the terms of the GNU     *)
(*  Lesser General Public License as published by the Free Software *)
(*  Foundation; either version 2.1 of the License, or (at your      *)
(*  option) any later version.                                      *)
(*                                                                  *)
(*  The Seed7 Runtime Library is distributed in the hope that it    *)
(*  will be useful, but WITHOUT ANY WARRANTY; without even the      *)
(*  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR *)
(*  PURPOSE.  See the GNU Lesser General Public License for more    *)
(*  details.                                                        *)
(*                                                                  *)
(*  You should have received a copy of the GNU Lesser General       *)
(*  Public License along with this program; if not, write to the    *)
(*  Free Software Foundation, Inc., 51 Franklin Street,             *)
(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)
(*                                                                  *)
(********************************************************************)


const type: rational is new object struct
    var integer: numerator is 0;
    var integer: denominator is 1;
  end struct;


const proc: normalize (inout rational: rat) is func
  begin
    if rat.denominator < 0 then
      rat.numerator := -rat.numerator;
      rat.denominator := -rat.denominator;
    end if;
  end func;


const proc: reduce (inout rational: rat) is func
  local
    var integer: a is 0;
    var integer: b is 0;
    var integer: help is 0;
  begin
    if rat.numerator >= 0 then
      a := rat.numerator;
    else
      a := -rat.numerator;
    end if;
    b := rat.denominator;
    while a <> 0 do
      help := b rem a;
      b := a;
      a := help;
    end while;
    rat.numerator := rat.numerator div b;
    rat.denominator := rat.denominator div b;
  end func;


const func integer: gcd1 (in var integer: a, in var integer: b) is func
  result
    var integer: result is 0;
  local
    var integer: help is 0;
  begin
    while a <> 0 do
      help := b rem a;
      b := a;
      a := help;
    end while;
    result := b;
  end func;


const func integer: gcd2 (in integer: numerator, in integer: denominator) is func
  result
    var integer: b is 0;
  local
    var integer: a is 0;
    var integer: help is 0;
  begin
    if numerator >= 0 then
      a := numerator;
    else
      a := -numerator;
    end if;
    b := denominator;
    while a <> 0 do
      help := b rem a;
      b := a;
      a := help;
    end while;
  end func;


const func rational: + (in rational: rat) is func
  result
    var rational: rat_val is rational.value;
  begin
    rat_val.numerator := rat.numerator;
    rat_val.denominator := rat.denominator;
  end func;


const func rational: - (in rational: rat) is func
  result
    var rational: rat_val is rational.value;
  begin
    rat_val.numerator := -rat.numerator;
    rat_val.denominator := rat.denominator;
  end func;


const func rational: (in rational: rat1) + (in rational: rat2) is func
  result
    var rational: rat_val is rational.value;
  local
    var integer: gcd_denominator is 0;
  begin
    gcd_denominator := gcd1(rat1.denominator, rat2.denominator);
    rat_val.numerator := (rat1.numerator * rat2.denominator +
        rat2.numerator * rat1.denominator) div gcd_denominator;
    rat_val.denominator := rat1.denominator div gcd_denominator * rat2.denominator;
  end func;


const func rational: (in rational: rat1) - (in rational: rat2) is func
  result
    var rational: rat_val is rational.value;
  local
    var integer: gcd_denominator is 0;
  begin
    gcd_denominator := gcd1(rat1.denominator, rat2.denominator);
    rat_val.numerator := (rat1.numerator * rat2.denominator -
        rat2.numerator * rat1.denominator) div gcd_denominator;
    rat_val.denominator := rat1.denominator div gcd_denominator * rat2.denominator;
  end func;


const func rational: (in rational: rat1) * (in rational: rat2) is func
  result
    var rational: rat_val is rational.value;
  local
    var integer: gcd1 is 0;
    var integer: gcd2 is 0;
  begin
    gcd1 := gcd2(rat1.numerator, rat2.denominator);
    gcd2 := gcd2(rat2.numerator, rat1.denominator);
    rat_val.numerator := (rat1.numerator div gcd1) * (rat2.numerator div gcd2);
    rat_val.denominator := (rat1.denominator div gcd2) * (rat2.denominator div gcd1);
  end func;


const func rational: (in rational: rat1) / (in rational: rat2) is func
  result
    var rational: rat_val is rational.value;
  begin
    rat_val.numerator := rat1.numerator * rat2.denominator;
    rat_val.denominator := rat1.denominator * rat2.numerator;
    normalize(rat_val);
    reduce(rat_val);
  end func;


const proc: (inout rational: rat1) +:= (in rational: rat2) is func
  local
    var integer: gcd_denominator is 0;
  begin
    gcd_denominator := gcd1(rat1.denominator, rat2.denominator);
    rat1.numerator := (rat1.numerator * rat2.denominator +
        rat2.numerator * rat1.denominator) div gcd_denominator;
    rat1.denominator *:= rat2.denominator div gcd_denominator;
  end func;


const proc: (inout rational: rat1) -:= (in rational: rat2) is func
  local
    var integer: gcd_denominator is 0;
  begin
    gcd_denominator := gcd1(rat1.denominator, rat2.denominator);
    rat1.numerator := (rat1.numerator * rat2.denominator -
        rat2.numerator * rat1.denominator) div gcd_denominator;
    rat1.denominator *:= rat2.denominator div gcd_denominator;
  end func;


const proc: (inout rational: rat1) *:= (in rational: rat2) is func
  begin
    rat1.numerator *:= rat2.numerator;
    rat1.denominator *:= rat2.denominator;
    reduce(rat1);
  end func;


const func rational: (in integer: int1) / (in integer: int2) is func
  result
    var rational: rat_val is rational.value;
  begin
    rat_val.numerator := int1;
    rat_val.denominator := int2;
    normalize(rat_val);
    reduce(rat_val);
  end func;


const func rational: (in rational: rat1) ** (in integer: int2) is func
  result
    var rational: rat_val is rational.value;
  begin
    if int2 >= 0 then
      rat_val.numerator := rat1.numerator ** int2;
      rat_val.denominator := rat1.denominator ** int2;
    else
      rat_val.numerator := rat1.denominator ** (-int2);
      rat_val.denominator := rat1.numerator ** (-int2);
      normalize(rat_val);
    end if;
  end func;


const func boolean: (in rational: rat1) = (in rational: rat2) is
  return rat1.numerator   = rat2.numerator and
         rat1.denominator = rat2.denominator;


const func boolean: (in rational: rat1) < (in rational: rat2) is
  return rat1.numerator * rat2.denominator <
         rat2.numerator * rat1.denominator;


const func boolean: (in rational: rat1) > (in rational: rat2) is
  return rat1.numerator * rat2.denominator >
         rat2.numerator * rat1.denominator;


const func boolean: (in rational: rat1) <= (in rational: rat2) is
  return rat1.numerator * rat2.denominator <=
         rat2.numerator * rat1.denominator;


const func boolean: (in rational: rat1) >= (in rational: rat2) is
  return rat1.numerator * rat2.denominator >=
         rat2.numerator * rat1.denominator;


const func boolean: (in rational: rat1) <> (in rational: rat2) is
  return rat1.numerator   <> rat2.numerator or
         rat1.denominator <> rat2.denominator;


const func integer: compare (in rational: rat1, in rational: rat2) is func
  result
    var integer: result is 0;
  begin
    if rat1.numerator * rat2.denominator <
        rat2.numerator * rat1.denominator then
      result := -1;
    elsif rat1.numerator * rat2.denominator >
        rat2.numerator * rat1.denominator then
      result := 1;
    end if;
  end func;


const func integer: hashCode (in rational: rat) is
  return rat.numerator * rat.denominator;


const func rational: rat (in integer: number) is func
  result
    var rational: rat_val is rational.value;
  begin
    rat_val.numerator := number;
    rat_val.denominator := 1;
  end func;


const func rational: abs (in rational: rat1) is func
  result
    var rational: rat_val is rational.value;
  begin
    rat_val.numerator := abs(rat1.numerator);
    rat_val.denominator := rat1.denominator;
  end func;


const func string: (in rational: rat1) digits (in integer: number) is func
  result
    var string: result is "";
  begin
    result := str((rat1.numerator * 10 ** number) div rat1.denominator);
    if number + 1 - length(result) > 0 then
      result := "0" mult (number + 1 - length(result)) & result;
    end if;
    result := result[ .. length(result) - number] & "." & result[length(result) - number + 1 .. ];
  end func;


const func string: str (in rational: rat1) is func
  result
    var string: str_val is "";
  begin
    str_val := str(rat1.numerator) & "/" & str(rat1.denominator);
  end func;


const func rational: (attr rational) parse (in var string: stri) is func
  result
    var rational: result is rational.value;
  begin
    result.numerator := integer parse getint(stri);
    if stri[1] <> '/' then
      raise RANGE_ERROR;
    end if;
    stri := stri[2 ..];
    result.denominator := integer parse getint(stri);
  end func;


enable_io(rational);


const func integer: floor (ref rational: rat1) is func
  result
    var integer: int_val is 0;
  begin
    int_val := rat1.numerator mdiv rat1.denominator;
  end func;


const func integer: ceil (ref rational: rat1) is func
  result
    var integer: int_val is 0;
  begin
    int_val := -(rat1.numerator mdiv -rat1.denominator);
  end func;


const func integer: trunc (ref rational: rat1) is func
  result
    var integer: int_val is 0;
  begin
    int_val := rat1.numerator div rat1.denominator;
  end func;


const func integer: round (ref rational: rat1) is func
  result
    var integer: int_val is 0;
  begin
    if rat1.numerator >= 0 then
      int_val := (2 * rat1.numerator + rat1.denominator) div (2 * rat1.denominator);
    else
      int_val := (2 * rat1.numerator - rat1.denominator) div (2 * rat1.denominator);
    end if;
  end func;
