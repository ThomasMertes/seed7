
(********************************************************************)
(*                                                                  *)
(*  socket.s7i    File implementation type for OS sockets           *)
(*  Copyright (C) 1989 - 2007  Thomas Mertes                        *)
(*                                                                  *)
(*  This file is part of the Seed7 Runtime Library.                 *)
(*                                                                  *)
(*  The Seed7 Runtime Library is free software; you can             *)
(*  redistribute it and/or modify it under the terms of the GNU     *)
(*  Lesser General Public License as published by the Free Software *)
(*  Foundation; either version 2.1 of the License, or (at your      *)
(*  option) any later version.                                      *)
(*                                                                  *)
(*  The Seed7 Runtime Library is distributed in the hope that it    *)
(*  will be useful, but WITHOUT ANY WARRANTY; without even the      *)
(*  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR *)
(*  PURPOSE.  See the GNU Lesser General Public License for more    *)
(*  details.                                                        *)
(*                                                                  *)
(*  You should have received a copy of the GNU Lesser General       *)
(*  Public License along with this program; if not, write to the    *)
(*  Free Software Foundation, Inc., 51 Franklin Street,             *)
(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)
(*                                                                  *)
(********************************************************************)


include "null_file.s7i";
include "enable_io.s7i";
include "duration.s7i";


const type: socketAddress is newtype;
IN_PARAM_IS_REFERENCE(socketAddress);

const proc: destroy (ref socketAddress param)                               is action "BST_DESTR";
const proc: (ref socketAddress param) ::= (ref socketAddress param)         is action "BST_CREATE";
const proc: (inout socketAddress param) := (ref socketAddress param)        is action "BST_CPY";

const func socketAddress: _GENERATE_EMPTY_SOCKET_ADDRESS                    is action "BST_EMPTY";
const socketAddress: (attr socketAddress) . value                           is _GENERATE_EMPTY_SOCKET_ADDRESS;

const func boolean: (ref socketAddress param) = (ref socketAddress param)   is action "BST_EQ";
const func boolean: (ref socketAddress param) <> (ref socketAddress param)  is action "BST_NE";

const func integer: addrFamily (in socketAddress param)                     is action "SOC_ADDR_FAMILY";


(**
 *  Get the numeric (IP) address of the host at ''sockAddr''.
 *  IPv4 addresses return the socketAddress in dot notation (e.g.:
 *  "192.0.2.235") and IPv6 addresses return the socketAddress in
 *  colon notation (e.g.: "fe80:0:0:0:202:b3ff:fe1e:8329").
 *  @return the IP address of the specified host.
 *)
const func string: numericAddress (in socketAddress: sockAddr)              is action "SOC_ADDR_NUMERIC";


const func string: service (in socketAddress param)                         is action "SOC_ADDR_SERVICE";


(**
 *  Create an internet socket address of a port at a host.
 *  The ''hostName'' is either a host name (e.g.: "www.example.org"),
 *  or an IPv4 address in standard dot notation (e.g.: "192.0.2.235").
 *  Operating systems supporting IPv6 may also accept an IPv6 address
 *  in colon notation.
 *  @return the internet socket address or socketAddress.value when
 *          the host cannot be found.
 *  @exception FILE_ERROR A system function returns an error.
 *  @exception RANGE_ERROR The port is not in the range 0 to 65535.
 *  @exception MEMORY_ERROR Not enough memory to convert ''hostName''.
 *             to the system representation or not enough memory to
 *             represent the result.
 *)
const func socketAddress: inetSocketAddress (in string: hostName,
                                             in integer: port)              is action "SOC_INET_ADDR";


(**
 *  Create an internet socket address of a port at localhost.
 *  @return the internet socket address.
 *  @exception FILE_ERROR A system function returns an error.
 *  @exception RANGE_ERROR The port is not in the range 0 to 65535.
 *  @exception MEMORY_ERROR Not enough memory to represent the result.
 *)
const func socketAddress: inetSocketAddress (in integer: port)              is action "SOC_INET_LOCAL_ADDR";


(**
 *  Create an internet listener socket address of a port at localhost.
 *  @return the internet listener socket address.
 *  @exception FILE_ERROR A system function returns an error.
 *  @exception RANGE_ERROR The port is not in the range 0 to 65535.
 *  @exception MEMORY_ERROR Not enough memory to represent the result.
 *)
const func socketAddress: inetListenerAddress (in integer: port)            is action "SOC_INET_SERV_ADDR";


(**
 *  Determine the hostname.
 *  @return the hostname.
 *  @exception MEMORY_ERROR Not enough memory to represent the result.
 *)
const func string: getHostname                                              is action "SOC_GET_HOSTNAME";


const type: PRIMITIVE_SOCKET is newtype;
IN_PARAM_IS_VALUE(PRIMITIVE_SOCKET);

const proc: destroy (ref PRIMITIVE_SOCKET param)                            is noop;
const proc: (ref PRIMITIVE_SOCKET param) ::= (ref PRIMITIVE_SOCKET param)   is action "SOC_CREATE";
const proc: (inout PRIMITIVE_SOCKET param) := (ref PRIMITIVE_SOCKET param)  is action "SOC_CPY";

const func boolean: (in PRIMITIVE_SOCKET param) = (in PRIMITIVE_SOCKET param)  is action "SOC_EQ";
const func boolean: (in PRIMITIVE_SOCKET param) <> (in PRIMITIVE_SOCKET param) is action "SOC_NE";

const func PRIMITIVE_SOCKET: _GENERATE_EMPTY_PRIMITIVE_SOCKET               is action "SOC_EMPTY";
const PRIMITIVE_SOCKET: (attr PRIMITIVE_SOCKET) . value                     is _GENERATE_EMPTY_PRIMITIVE_SOCKET;
const PRIMITIVE_SOCKET: PRIMITIVE_NULL_SOCKET                               is PRIMITIVE_SOCKET.value;

const proc: close (in PRIMITIVE_SOCKET param)                               is action "SOC_CLOSE";
# const func socketAddress: address (in PRIMITIVE_SOCKET param)               is action "SOC_GET_ADDR";
const func char: getc (in PRIMITIVE_SOCKET param, inout char param)         is action "SOC_GETC";
const func string: gets (in PRIMITIVE_SOCKET param, in integer param,
                         inout char param)                                  is action "SOC_GETS";
const func boolean: hasNext (in PRIMITIVE_SOCKET param)                     is action "SOC_HAS_NEXT";
const func string: word_read (in PRIMITIVE_SOCKET param, inout char param)  is action "SOC_WORD_READ";
const func string: line_read (in PRIMITIVE_SOCKET param, inout char param)  is action "SOC_LINE_READ";
const proc: write (in PRIMITIVE_SOCKET param, in string param)              is action "SOC_WRITE";
const func integer: recv (in PRIMITIVE_SOCKET param, inout string param,
                          in integer param, in integer param)               is action "SOC_RECV";
const func integer: recvfrom (in PRIMITIVE_SOCKET param, inout string param,
                          in integer param, in integer param,
                          inout socketAddress param)                        is action "SOC_RECVFROM";
const func bitset: selectInput (in array PRIMITIVE_SOCKET param)            is action "SOC_SELECT_INPUT";
const func integer: send (in PRIMITIVE_SOCKET param, in string param,
                          in integer param)                                 is action "SOC_SEND";
const func integer: sendto (in PRIMITIVE_SOCKET param, in string param,
                          in integer param, in socketAddress param)         is action "SOC_SENDTO";

const func PRIMITIVE_SOCKET: PRIMITIVE_SOCKET (in integer param,
                                               in integer param,
                                               in integer param)            is action "SOC_SOCKET";
const func PRIMITIVE_SOCKET: accept (in PRIMITIVE_SOCKET param,
                                     inout socketAddress param)             is action "SOC_ACCEPT";
const proc: bind (in PRIMITIVE_SOCKET param, in socketAddress param)        is action "SOC_BIND";
const proc: connect (in PRIMITIVE_SOCKET param, in socketAddress param)     is action "SOC_CONNECT";
const proc: listen (in PRIMITIVE_SOCKET param, in integer param)            is action "SOC_LISTEN";
const func boolean: inputReady (in PRIMITIVE_SOCKET param,
                                in integer param, in integer param)         is action "SOC_INPUT_READY";


const type: pollData is newtype;
IN_PARAM_IS_REFERENCE(pollData);

const proc: destroy (ref pollData param)                                    is action "POL_DESTR";
const proc: (ref pollData param) ::= (ref pollData param)                   is action "POL_CREATE";
const proc: (inout pollData param) := (ref pollData param)                  is action "POL_CPY";

const func pollData: _GENERATE_EMPTY_POLL_DATA (in file param)              is action "POL_EMPTY";
const pollData: (attr pollData) . value                                     is _GENERATE_EMPTY_POLL_DATA(STD_NULL);

const proc: clear (inout pollData param)                                    is action "POL_CLEAR";
const proc: addReadCheck (inout pollData param, in PRIMITIVE_SOCKET param,
                          in file param)                                    is action "POL_ADD_READ_CHECK";
const proc: addWriteCheck (inout pollData param, in PRIMITIVE_SOCKET param,
                          in file param)                                    is action "POL_ADD_WRITE_CHECK";
const proc: removeReadCheck (inout pollData param,
                             in PRIMITIVE_SOCKET param)                     is action "POL_REMOVE_READ_CHECK";
const proc: removeWriteCheck (inout pollData param,
                              in PRIMITIVE_SOCKET param)                    is action "POL_REMOVE_WRITE_CHECK";
const proc: poll (inout pollData param)                                     is action "POL_POLL";
const func boolean: readyForRead (inout pollData param,
                                  in PRIMITIVE_SOCKET param)                is action "POL_READY_FOR_READ";
const func boolean: readyForWrite (inout pollData param,
                                   in PRIMITIVE_SOCKET param)               is action "POL_READY_FOR_WRITE";
const func array file: files (in pollData param)                            is action "POL_FILES";
const func boolean: hasNextReadFile (inout pollData param)                  is action "POL_HAS_NEXT_READ_FILE";
const func boolean: hasNextWriteFile (inout pollData param)                 is action "POL_HAS_NEXT_WRITE_FILE";
const func file: nextReadFile (inout pollData param, in file param)         is action "POL_NEXT_READ_FILE";
const func file: nextWriteFile (inout pollData param, in file param)        is action "POL_NEXT_WRITE_FILE";
const func file: nextReadFile (inout pollData: aPollData) is
    return nextReadFile(aPollData, STD_NULL);
const func file: nextWriteFile (inout pollData: aPollData) is
    return nextWriteFile(aPollData, STD_NULL);


const integer: SOCK_STREAM is 1;
const integer: SOCK_DGRAM is 2;


(**
 *  Interface type for listeners.
 *  The listener interface is implemented with inetListener.
 *  A listener manages its accepted sockets.
 *)
const type: listener is sub object interface;

const proc: close (inout listener: aListener)                               is DYNAMIC;
const proc: listen (in listener: aListener, in integer: backlog)            is DYNAMIC;
const func file: accept (inout listener: aListener)                         is DYNAMIC;
const proc: signOff (inout listener: aListener, in PRIMITIVE_SOCKET: sock)  is DYNAMIC;
const proc: waitForRequest (inout listener: aListener)                      is DYNAMIC;
const func file: getExistingConnection (in listener: aListener)             is DYNAMIC;
const func file: getNewConnection (in listener: aListener)                  is DYNAMIC;


const type: baseListener is new struct
  end struct;

type_implements_interface(baseListener, listener);

const listener: (attr listener) . value is baseListener.value;


(* Operations for socket files *)


(**
 *  [[file|File]] implementation type for OS sockets.
 *  This type supports communication via sockets. A ''socket'' is
 *  not seekable. The functions [[#length(in_null_file)|length]],
 *  [[#seek(in_null_file,in_integer)|seek]] and [[#tell(in_null_file)|tell]]
 *  raise FILE_ERROR.
 *)
const type: socket is sub null_file struct
    var PRIMITIVE_SOCKET: sock is PRIMITIVE_NULL_SOCKET;
    var socketAddress: addr is socketAddress.value;
    var string: service is "";
    var listener: acceptedFrom is listener.value;
  end struct;


type_implements_interface(socket, file);


const func string: service (in file param) is DYNAMIC;
const func string: service (in socket: aSocket) is
  return aSocket.service;

# const func socketAddress: address (in file param) is DYNAMIC;
# const func socketAddress: address (in socket: aSocket) is
#   return address(aSocket.sock);

const func integer: port (in file param) is DYNAMIC;
const func integer: port (in socket: aSocket) is
#  return integer parse (aSocket.service);
  return integer parse service(aSocket.addr);


const func boolean: inputReady (in file param, in duration param) is DYNAMIC;
const func boolean: inputReady (in socket: aSocket, in duration: timeout) is func
  result
    var boolean: result is FALSE;
  begin
    result := inputReady(aSocket.sock, toSeconds(timeout), timeout.micro_second);
  end func;


const func socket: malloc (in socket: sock) is func
  result
    var socket: result is socket.value;
  begin
    result := sock;
  end func;


(**
 *  Return a connected socket file for the given address.
 *  @return the socket file opened, or STD_NULL if it could not be opened.
 *)
const func file: openSocket (in socketAddress: address) is func
  result
    var file: result is STD_NULL;
  local
    var PRIMITIVE_SOCKET: open_socket is PRIMITIVE_NULL_SOCKET;
    var socket: new_socket is socket.value;
  begin
    if address <> socketAddress.value then
      open_socket := PRIMITIVE_SOCKET(addrFamily(address), SOCK_STREAM, 0);
      if open_socket <> PRIMITIVE_NULL_SOCKET then
        block
          connect(open_socket, address);
          new_socket.addr := address;
          new_socket.service := service(address);
          new_socket.sock := open_socket;
          result := malloc(new_socket);
        exception
          catch FILE_ERROR:
            close(open_socket);
        end block;
      end if;
    end if;
  end func;


(**
 *  Return a connected internet socket file at a port at localhost.
 *  @return the socket file opened, or STD_NULL if it could not be opened.
 *  @exception FILE_ERROR A system function returns an error.
 *  @exception RANGE_ERROR The port is not in the range 0 to 65535.
 *  @exception MEMORY_ERROR An out of memory situation occurred.
 *)
const func file: openInetSocket (in integer: portNumber) is
  return openSocket(inetSocketAddress(portNumber));


(**
 *  Return a connected internet socket file at a port at ''hostName''.
 *  Here ''hostName'' is either a host name (e.g.: "www.example.org"),
 *  or an IPv4 address in standard dot notation (e.g.: "192.0.2.235").
 *  Operating systems supporting IPv6 may also accept an IPv6 address
 *  in colon notation.
 *  @return the socket file opened, or STD_NULL if it could not be opened.
 *  @exception FILE_ERROR A system function returns an error.
 *  @exception RANGE_ERROR The port is not in the range 0 to 65535.
 *  @exception MEMORY_ERROR An out of memory situation occurred.
 *)
const func file: openInetSocket (in string: hostName, in integer: portNumber) is
  return openSocket(inetSocketAddress(hostName, portNumber));


(**
 *  Close the socket ''aSocket''.
 *  A listener manages accepted sockets (its existing connections).
 *  When a socket was accepted from a listener it is signed off
 *  from the listener.
 *)
const proc: close (inout socket: aSocket) is func
  begin
    if aSocket.acceptedFrom <> listener.value then
      signOff(aSocket.acceptedFrom, aSocket.sock);
    end if;
    close(aSocket.sock);
    aSocket.sock := PRIMITIVE_NULL_SOCKET;
  end func;


const proc: release (inout file: aFile) is DYNAMIC;


const proc: release (inout socket: aSocket) is func
  begin
    aSocket.acceptedFrom := listener.value;
  end func;


(**
 *  Forces that all buffered data of ''aFile'' is sent to its destination.
 *  Flushing a socket has no effect.
 *)
const proc: flush (in socket: aSocket) is func
  begin
    noop; # flush(aSocket.sock);
  end func;


(**
 *  Write the string ''stri'' to ''aSocket''.
 *)
const proc: write (in socket: aSocket, in string: stri) is func
  begin
    write(aSocket.sock, stri);
  end func;


(**
 *  Write newline character ('\n') to ''aSocket''.
 *)
const proc: writeln (in socket: aSocket) is func
  begin
    write(aSocket.sock, "\n");
  end func;


const proc: backSpace (in socket: aSocket) is func
  begin
    write(aSocket.sock, "\b \b");
  end func;


(**
 *  Read a character from ''aSocket''.
 *  @return the character read.
 *)
const func char: getc (inout socket: aSocket) is
  return getc(aSocket.sock, aSocket.bufferChar);


(**
 *  Read a string with a maximum length from ''aSocket''.
 *  @return the string read.
 *  @exception RANGE_ERROR The length is negative.
 *  @exception MEMORY_ERROR Not enough memory to represent the result.
 *)
const func string: gets (inout socket: aSocket, in integer: maxLength) is
  return gets(aSocket.sock, maxLength, aSocket.bufferChar);


(**
 *  Read a word from ''aSocket''.
 *  Before reading the word it skips spaces and tabs. The function
 *  accepts words ending with " ", "\t", "\n", "\r\n" or [[char#EOF|EOF]].
 *  The word ending characters are not copied into the string.
 *  That means that the "\r" of a "\r\n" sequence is silently removed.
 *  When the function is left the aSocket.bufferChar contains ' ',
 *  '\t', '\n' or EOF.
 *  @return the word read.
 *  @exception MEMORY_ERROR Not enough memory to represent the result.
 *)
const func string: getwd (inout socket: aSocket) is
  return word_read(aSocket.sock, aSocket.bufferChar);


(**
 *  Read a line from 'aSocket'.
 *  The function accepts lines ending with "\n", "\r\n" or [[char#EOF|EOF]].
 *  The line ending characters are not copied into the string. That
 *  means that the "\r" of a "\r\n" sequence is silently removed. When
 *  the function is left the aSocket.bufferChar contains '\n' or EOF.
 *  @return the line read.
 *  @exception MEMORY_ERROR Not enough memory to represent the result.
 *)
const func string: getln (inout socket: aSocket) is
  return line_read(aSocket.sock, aSocket.bufferChar);


(**
 *  Determine the end-of-file indicator.
 *  The end-of-file indicator is set when at least one request to read
 *  from the socket failed. The socket functions ''getc'', ''gets'',
 *  ''getln'' and ''getwd'' indicate the end-of-file situation by
 *  setting ''bufferChar'' to [[char#EOF|EOF]].
 *  @return TRUE if the end-of-file indicator is set, FALSE otherwise.
 *)
const func boolean: eof (in socket: aSocket) is
  return aSocket.bufferChar = EOF;


(**
 *  Determine if at least one character can be read successfully.
 *  This function allows a socket to be handled like an iterator.
 *  Since ''hasNext'' peeks the next character from the socket
 *  it may block.
 *  @return FALSE if ''getc'' would return EOF, TRUE otherwise.
 *)
const func boolean: hasNext (in socket: aSocket) is
  return hasNext(aSocket.sock);


(* Operations for the listener *)

const type: inetListener is sub baseListener struct
    var PRIMITIVE_SOCKET: sock is PRIMITIVE_NULL_SOCKET;
    var socketAddress: addr is socketAddress.value;
    var string: service is "";
    var pollData: checkedSocks is pollData.value;
    (*! var array PRIMITIVE_SOCKET: socks is 0 times PRIMITIVE_NULL_SOCKET;
    var array file: files is 0 times STD_NULL; *)
    var file: existingConnection is STD_NULL;
    var file: newConnection is STD_NULL;
  end struct;


type_implements_interface(inetListener, listener);


const func inetListener: malloc (in inetListener: aListener) is func
  result
    var inetListener: result is inetListener.value;
  begin
    result := aListener;
  end func;


(**
 *  Create a bound internet listener for a port at localhost.
 *  The listerner is responsible for incoming connections of the
 *  specified port. The listener also manages its accepted sockets.
 *  Processing requests from port 1080 can be done with:
 *   inetListener := openInetListener(1080);
 *   listen(inetListener, 10);
 *   while TRUE do
 *     sock := accept(inetListener);
 *     # Read and process the request from sock.
 *     close(sock);
 *   end while;
 *  The example above manages requests from different clients
 *  sequentially. The function ''waitForRequest'' can be used to
 *  process interleaved requests from several clients.
 *  @return the bound internet listener.
 *  @exception FILE_ERROR A system function returns an error.
 *  @exception RANGE_ERROR The port is not in the range 0 to 65535.
 *  @exception MEMORY_ERROR An out of memory situation occurred.
 *)
const func listener: openInetListener (in integer: portNumber) is func
  result
    var listener: result is listener.value;
  local
    var socketAddress: address is socketAddress.value;
    var PRIMITIVE_SOCKET: open_socket is PRIMITIVE_NULL_SOCKET;
    var inetListener: new_listener is inetListener.value;
  begin
    address := inetListenerAddress(portNumber);
    open_socket := PRIMITIVE_SOCKET(addrFamily(address), SOCK_STREAM, 0);
    if open_socket <> PRIMITIVE_NULL_SOCKET then
      new_listener.addr := address;
      new_listener.service := service(address);
      bind(open_socket, new_listener.addr);
      new_listener.sock := open_socket;
      addReadCheck(new_listener.checkedSocks, open_socket, STD_NULL);
      (*! new_listener.socks := [] (open_socket);
      new_listener.files := [] (STD_NULL); *)
      result := malloc(new_listener);
    end if;
  end func;


(**
 *  Close the listener ''aListener''.
 *  A listener manages accepted sockets (its existing connections).
 *  When the listener is closed all references to the listener
 *  is removed from the accepted sockets.
 *)
const proc: close (inout inetListener: aListener) is func
  local
    var array file: managedFiles is 0 times STD_NULL;
    var integer: index is 0;
    var file: aFile is STD_NULL;
  begin
    close(aListener.sock);
    (*! managedFiles := files(aListener.checkedSocks);
    for key index range managedFiles do
      aFile := managedFiles[index];
      if aFile <> STD_NULL then
        release(aFile);
      end if;
    end for; *)
    clear(aListener.checkedSocks);
    (*! for index range 2 to length(aListener.files) do
      release(aListener.files[index]);
    end for; *)
    (*! aListener.socks := 0 times PRIMITIVE_NULL_SOCKET;
    aListener.files := 0 times STD_NULL; *)
  end func;


const proc: signOff (inout inetListener: aListener, in PRIMITIVE_SOCKET: sock) is func
  local
    var integer: index is 0;
    var integer: index_found is 0;
  begin
    removeReadCheck(aListener.checkedSocks, sock);
    (*! for index range 2 to length(aListener.socks) do
      if aListener.socks[index] = sock then
        index_found := index;
      end if;
    end for;
    aListener.socks := aListener.socks[.. pred(index_found)] &
                       aListener.socks[succ(index_found) ..];
    aListener.files := aListener.files[.. pred(index_found)] &
                       aListener.files[succ(index_found) ..]; *)
  end func;


(**
 *  Listen for socket connections and limit the incoming queue.
 *  The ''backlog'' argument defines the maximum length to which
 *  the queue of pending connections for ''aListener'' may grow.
 *  @exception FILE_ERROR A system function returns an error.
 *)
const proc: listen (in inetListener: aListener, in integer: backlog) is func
  begin
    listen(aListener.sock, backlog);
  end func;


(*
const type: listenerArray is array listener;
const array PRIMITIVE_SOCKET: select (in array PRIMITIVE_SOCKET: socks) is 0 times PRIMITIVE_NULL_SOCKET;


const func listener: select (in array listener: listeners) is func
  result
    var listener: result is listener.value;
  local
    var array PRIMITIVE_SOCKET: socks is 0 times PRIMITIVE_NULL_SOCKET;
    var integer: index is 0;
  begin
    if length(listeners) = 0 then
      raise RANGE_ERROR;
    else
      socks := length(listeners) times PRIMITIVE_NULL_SOCKET;
      for index range minIdx(listeners) to maxIdx(listeners) do
        socks[index] := listeners[index].sock;
      end for;
      socks := select(socks);
      for index range minIdx(listeners) to maxIdx(listeners) do
        if socks[1] = listeners[index].sock then
          result := listeners[index];
        end if;
      end for;
    end if;
  end func;


const func integer: selectOne (in array listener: listeners) is func
  result
    var listener: result is listener.value;
  local
    var array PRIMITIVE_SOCKET: socks is 0 times PRIMITIVE_NULL_SOCKET;
    var integer: index is 0;
  begin
    socks := length(listeners) times PRIMITIVE_NULL_SOCKET;
    for index range minIdx(listeners) to maxIdx(listeners) do
      socks[index] := listeners[index].sock;
    end for;
    result := selectOne(socks);
  end func;


const func file: selectOne (inout inetListener: aListener) is func
  result
    var file: result is STD_NULL;
  local
    var array PRIMITIVE_SOCKET: socks is 0 times PRIMITIVE_NULL_SOCKET;
  begin
    socks := succ(length(aListener.accepted)) times PRIMITIVE_NULL_SOCKET;
    for index range 1 to length(aListener.accepted) do
      socks[index] := aListener.accepted[index].sock;
    end for;
*)


(*
const func boolean: requestPresent (in listener: aListener, in duration: timeout) is func
  result
    var boolean: result is FALSE;
  begin
    result := inputReady(aListener.sock, toSeconds(timeout), timeout.micro_second);
  end func;
*)


(**
 *  Create a new accepted connection socket for 'aListener'.
 *  The function waits until at least one connection request is
 *  in the listeners queue of pending connections. Then it extracts
 *  the first connection request from the listeners queue. This
 *  request is accepted and a connection socket is created for it.
 *  A listener manages accepted sockets (its existing connections).
 *  When an accepted socket is closed it is signed off from the
 *  listener.
 *  @return the accepted connection socket.
 *  @exception FILE_ERROR A system function returns an error.
 *  @exception MEMORY_ERROR An out of memory situation occurred.
 *)
const func file: accept (inout inetListener: aListener) is func
  result
    var file: result is STD_NULL;
  local
    var PRIMITIVE_SOCKET: accepted_socket is PRIMITIVE_NULL_SOCKET;
    var socket: new_socket is socket.value;
  begin
    accepted_socket := accept(aListener.sock, new_socket.addr);
    if accepted_socket <> PRIMITIVE_NULL_SOCKET then
      new_socket.sock := accepted_socket;
      new_socket.service := aListener.service;
      new_socket.acceptedFrom := aListener;
      result := malloc(new_socket);
      addReadCheck(aListener.checkedSocks, accepted_socket, result);
      (* aListener.socks &:= accepted_socket;
      aListener.files &:= result; *)
    end if;
  end func;


(*
const func file: accept (in array listener: listeners) is func
  result
    var file: result is STD_NULL;
  local
    var integer: index is 0;
  begin
    index := selectOne(listeners);
    result := accept(listeners[index]);
  end func;
*)


const proc: waitForRequest (inout inetListener: aListener) is func
  local
    (*! var bitset: selectResult is EMPTY_SET; *)
    var integer: index is 0;
  begin
    poll(aListener.checkedSocks);
    if readyForRead(aListener.checkedSocks, aListener.sock) then
    (*! selectResult := selectInput(aListener.socks);
    if 1 in selectResult then *)
      aListener.newConnection := accept(aListener);
      # writeln("accepted");
    else
      aListener.newConnection := STD_NULL;
    end if;
    aListener.existingConnection := nextReadFile(aListener.checkedSocks);
    if aListener.existingConnection = STD_NULL then
      # When the listener is ready nextReadFile returns STD_NULL.
      aListener.existingConnection := nextReadFile(aListener.checkedSocks);
    end if;
    (*! excl(selectResult, 1);
    if selectResult <> EMPTY_SET then
      index := rand(selectResult);
      # writeln("select " <& index);
      aListener.existingConnection := aListener.files[index];
    else
      aListener.existingConnection := STD_NULL;
    end if; *)
  end func;


const func file: getExistingConnection (in inetListener: aListener) is
  return aListener.existingConnection;


const func file: getNewConnection (in inetListener: aListener) is
  return aListener.newConnection;


(**
 *  Wait until a request can be read or an incoming connection is accepted.
 *  The function ''waitForRequest'' can be used to process interleaved
 *  requests from several clients. A listener manages accepted sockets
 *  (its existing connections). This function checks the accepted
 *  sockets for available input (it is possible to read without
 *  blocking). The port of the listener is also checked for incoming
 *  connections. The function returns when input is available for an
 *  existing connection or when a new incoming connection was accepted.
 *  Processing requests from port 2021 can be done with:
 *   aListener := openInetListener(2021);
 *   listen(aListener, 10);
 *   while TRUE do
 *     waitForRequest(aListener, existingConnection, newConnection);
 *     if existingConnection <> STD_NULL then
 *       # Read and process the request from existingConnection.
 *     end if;
 *     if newConnection <> STD_NULL then
 *       # Send welcome message to newConnection
 *     end if;
 *   end while;
 *  @param existingConnection A random existing connection, were
 *         a read will not block, is assigned. When no existing
 *         connection has available input, STD_NULL is assigned.
 *  @param newConnection A new accepted connection is assigned.
 *         When no incoming connection is present, STD_NULL is
 *         assigned.
 *)
const proc: waitForRequest (inout listener: aListener,
    inout file: existingConnection, inout file: newConnection) is func
  begin
    waitForRequest(aListener);
    existingConnection := getExistingConnection(aListener);
    newConnection := getNewConnection(aListener);
  end func;
