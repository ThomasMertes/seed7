
(********************************************************************)
(*                                                                  *)
(*  socket.s7i    File implementation type for OS sockets           *)
(*  Copyright (C) 1989 - 2007  Thomas Mertes                        *)
(*                                                                  *)
(*  This file is part of the Seed7 Runtime Library.                 *)
(*                                                                  *)
(*  The Seed7 Runtime Library is free software; you can             *)
(*  redistribute it and/or modify it under the terms of the GNU     *)
(*  Lesser General Public License as published by the Free Software *)
(*  Foundation; either version 2.1 of the License, or (at your      *)
(*  option) any later version.                                      *)
(*                                                                  *)
(*  The Seed7 Runtime Library is distributed in the hope that it    *)
(*  will be useful, but WITHOUT ANY WARRANTY; without even the      *)
(*  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR *)
(*  PURPOSE.  See the GNU Lesser General Public License for more    *)
(*  details.                                                        *)
(*                                                                  *)
(*  You should have received a copy of the GNU Lesser General       *)
(*  Public License along with this program; if not, write to the    *)
(*  Free Software Foundation, Inc., 51 Franklin Street,             *)
(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)
(*                                                                  *)
(********************************************************************)


include "null_file.s7i";
include "enable_io.s7i";


const type: socketAddress is newtype;
IN_PARAM_IS_REFERENCE(socketAddress);

const proc: destroy (ref socketAddress param)                               is action "BST_DESTR";
const proc: (ref socketAddress param) ::= (ref socketAddress param)         is action "BST_CREATE";
const proc: (inout socketAddress param) := (ref socketAddress param)        is action "BST_CPY";

const func socketAddress: _GENERATE_EMPTY_SOCKET_ADDRESS                    is action "BST_EMPTY";
const socketAddress: (attr socketAddress) . value                           is _GENERATE_EMPTY_SOCKET_ADDRESS;
const func integer: addrFamily (in socketAddress param)                     is action "SOC_ADDR_FAMILY";
const func string: numericAddress (in socketAddress param)                  is action "SOC_ADDR_NUMERIC";
const func string: service (in socketAddress param)                         is action "SOC_ADDR_SERVICE";

(**
 *  Create an internet socket address of a port at a host.
 *  The ''hostName'' is either a host name ("e.g.: "www.example.org"),
 *  or an IPv4 address in standard dot notation (e.g.: "192.0.2.235").
 *  Operating systems supporting IPv6 may also accept an IPv6 address
 *  in colon notation.
 *  @return the internet socket address.
 *  @exception FILE_ERROR A system function returns an error.
 *  @exception RANGE_ERROR The port is not in the range 0 to 65535.
 *  @exception MEMORY_ERROR Not enough memory to convert ''hostName''.
 *             to the system representation or not enough memory to
 *             represent the result.
 *)
const func socketAddress: inetSocketAddress (in string: hostName,
                                             in integer: port)              is action "SOC_INET_ADDR";


(**
 *  Create an internet socket address of a port at localhost.
 *  @return the internet socket address.
 *  @exception FILE_ERROR A system function returns an error.
 *  @exception RANGE_ERROR The port is not in the range 0 to 65535.
 *  @exception MEMORY_ERROR Not enough memory to represent the result.
 *)
const func socketAddress: inetSocketAddress (in integer: port)              is action "SOC_INET_LOCAL_ADDR";


(**
 *  Create an internet listener socket address of a port at localhost.
 *  @return the internet listener socket address.
 *  @exception FILE_ERROR A system function returns an error.
 *  @exception RANGE_ERROR The port is not in the range 0 to 65535.
 *  @exception MEMORY_ERROR Not enough memory to represent the result.
 *)
const func socketAddress: inetListenerAddress (in integer: port)            is action "SOC_INET_SERV_ADDR";


const func string: getHostname                                              is action "SOC_GET_HOSTNAME";


const type: PRIMITIVE_SOCKET is newtype;
IN_PARAM_IS_VALUE(PRIMITIVE_SOCKET);

const proc: destroy (ref PRIMITIVE_SOCKET param)                            is noop;
const proc: (ref PRIMITIVE_SOCKET param) ::= (ref PRIMITIVE_SOCKET param)   is action "SOC_CREATE";
const proc: (inout PRIMITIVE_SOCKET param) := (ref PRIMITIVE_SOCKET param)  is action "SOC_CPY";

const func boolean: (in PRIMITIVE_SOCKET param) = (in PRIMITIVE_SOCKET param)  is action "SOC_EQ";
const func boolean: (in PRIMITIVE_SOCKET param) <> (in PRIMITIVE_SOCKET param) is action "SOC_NE";

const func PRIMITIVE_SOCKET: _GENERATE_EMPTY_PRIMITIVE_SOCKET               is action "SOC_EMPTY";
const PRIMITIVE_SOCKET: (attr PRIMITIVE_SOCKET) . value                     is _GENERATE_EMPTY_PRIMITIVE_SOCKET;
const PRIMITIVE_SOCKET: PRIMITIVE_NULL_SOCKET                               is PRIMITIVE_SOCKET.value;

const proc: close (in PRIMITIVE_SOCKET param)                               is action "SOC_CLOSE";
# const func socketAddress: address (in PRIMITIVE_SOCKET param)               is action "SOC_GET_ADDR";
const func char: getc (in PRIMITIVE_SOCKET param)                           is action "SOC_GETC";
const func string: gets (in PRIMITIVE_SOCKET param, in integer param)       is action "SOC_GETS";
const func string: word_read (in PRIMITIVE_SOCKET param, inout char param)  is action "SOC_WORD_READ";
const func string: line_read (in PRIMITIVE_SOCKET param, inout char param)  is action "SOC_LINE_READ";
const proc: write (in PRIMITIVE_SOCKET param, in string param)              is action "SOC_WRITE";
const func integer: recv (in PRIMITIVE_SOCKET param, inout string param,
                          in integer param, in integer param)               is action "SOC_RECV";
const func integer: recvfrom (in PRIMITIVE_SOCKET param, inout string param,
                          in integer param, in integer param,
                          inout socketAddress param)                        is action "SOC_RECVFROM";
const func integer: send (in PRIMITIVE_SOCKET param, in string param,
                          in integer param)                                 is action "SOC_SEND";
const func integer: sendto (in PRIMITIVE_SOCKET param, in string param,
                          in integer param, in socketAddress param)         is action "SOC_SENDTO";

const func PRIMITIVE_SOCKET: PRIMITIVE_SOCKET (in integer param,
                                               in integer param,
                                               in integer param)            is action "SOC_SOCKET";
const func PRIMITIVE_SOCKET: accept (in PRIMITIVE_SOCKET param,
                                     inout socketAddress param)             is action "SOC_ACCEPT";
const proc: bind (in PRIMITIVE_SOCKET param, in socketAddress param)        is action "SOC_BIND";
const proc: connect (in PRIMITIVE_SOCKET param, in socketAddress param)     is action "SOC_CONNECT";
const proc: listen (in PRIMITIVE_SOCKET param, in integer param)            is action "SOC_LISTEN";
const func boolean: inputReady (in PRIMITIVE_SOCKET param,
                                in integer param, in integer param)         is action "SOC_INPUT_READY";


const integer: SOCK_STREAM is 1;
const integer: SOCK_DGRAM is 2;


(* Operations for socket files *)


(**
 *  [[file|File]] implementation type for OS sockets.
 *  This type supports communication via sockets. A ''socket'' is
 *  not seekable. The functions ''length'', ''seek'' and ''tell''
 *  raise FILE_ERROR.
 *)
const type: socket is sub null_file struct
    var PRIMITIVE_SOCKET: sock is PRIMITIVE_NULL_SOCKET;
    var socketAddress: addr is socketAddress.value;
    var string: service is "";
  end struct;


type_implements_interface(socket, file);


const func string: service (in file param) is DYNAMIC;
const func string: service (in socket: aSocket) is
  return aSocket.service;

# const func socketAddress: address (in file param) is DYNAMIC;
# const func socketAddress: address (in socket: aSocket) is
#   return address(aSocket.sock);

const func integer: port (in file param) is DYNAMIC;
const func integer: port (in socket: aSocket) is
#  return integer parse (aSocket.service);
  return integer parse service(aSocket.addr);

(*
const func boolean: inputReady (in file param, in duration param) is DYNAMIC;
const func boolean: inputReady (in socket: aSocket, in duration: timeout) is func
  result
    var boolean: result is FALSE;
  begin
    result := inputReady(aSocket.sock, toSeconds(timeout), timeout.micro_seconds);
  end func;
*)


const func socket: malloc (in socket: sock) is func
  result
    var socket: result is socket.value;
  begin
    result := sock;
  end func;


(**
 *  Return a connected socket file for the given address.
 *  @return the socket file opened, or STD_NULL if it could not be opened.
 *)
const func file: openSocket (in socketAddress: address) is func
  result
    var file: result is STD_NULL;
  local
    var PRIMITIVE_SOCKET: open_socket is PRIMITIVE_NULL_SOCKET;
    var socket: new_socket is socket.value;
  begin
    open_socket := PRIMITIVE_SOCKET(addrFamily(address), SOCK_STREAM, 0);
    if open_socket <> PRIMITIVE_NULL_SOCKET then
      block
        connect(open_socket, address);
        new_socket.addr := address;
        new_socket.service := service(address);
        new_socket.sock := open_socket;
        result := malloc(new_socket);
      exception
        catch FILE_ERROR:
          close(open_socket);
      end block;
    end if;
  end func;


(**
 *  Return a connected internet socket file at a port at localhost.
 *  @return the socket file opened, or STD_NULL if it could not be opened.
 *  @exception FILE_ERROR A system function returns an error.
 *  @exception RANGE_ERROR The port is not in the range 0 to 65535.
 *  @exception MEMORY_ERROR An out of memory situation occurred.
 *)
const func file: openInetSocket (in integer: portNumber) is
  return openSocket(inetSocketAddress(portNumber));


(**
 *  Return a connected internet socket file at a port at ''hostName''.
 *  Here ''hostName'' is either a host name ("e.g.: "www.example.org"),
 *  or an IPv4 address in standard dot notation (e.g.: "192.0.2.235").
 *  Operating systems supporting IPv6 may also accept an IPv6 address
 *  in colon notation.
 *  @return the socket file opened, or STD_NULL if it could not be opened.
 *  @exception FILE_ERROR A system function returns an error.
 *  @exception RANGE_ERROR The port is not in the range 0 to 65535.
 *  @exception MEMORY_ERROR An out of memory situation occurred.
 *)
const func file: openInetSocket (in string: hostName, in integer: portNumber) is
  return openSocket(inetSocketAddress(hostName, portNumber));


(**
 *  Close the socket ''aSocket''.
 *)
const proc: close (in socket: aSocket) is func
  begin
    close(aSocket.sock);
  end func;


(**
 *  Forces that all buffered data of ''aFile'' is sent to its destination.
 *  Flushing a socket has no effect.
 *)
const proc: flush (in socket: aSocket) is func
  begin
    noop; # flush(aSocket.sock);
  end func;


(**
 *  Write the string ''stri'' to ''aSocket''.
 *)
const proc: write (in socket: aSocket, in string: stri) is func
  begin
    write(aSocket.sock, stri);
  end func;


(**
 *  Write newline character ('\n') to ''aSocket''.
 *)
const proc: writeln (in socket: aSocket) is func
  begin
    write(aSocket.sock, "\n");
  end func;


const proc: backSpace (in socket: aSocket) is func
  begin
    write(aSocket.sock, "\b \b");
  end func;


(**
 *  Read a character from ''aSocket''.
 *  @return the character read.
 *)
const func char: getc (in socket: aSocket) is
  return getc(aSocket.sock);


(**
 *  Read a string with a maximum length from ''aSocket''.
 *  @return the string read.
 *  @exception RANGE_ERROR The length is negative.
 *  @exception MEMORY_ERROR Not enough memory to represent the result.
 *)
const func string: gets (in socket: aSocket, in integer: maxLength) is
  return gets(aSocket.sock, maxLength);


(**
 *  Read a word from ''aSocket''.
 *  Before reading the word it skips spaces and tabs. The function
 *  accepts words ending with " ", "\t", "\n", "\r\n" or EOF.
 *  The word ending characters are not copied into the string.
 *  That means that the "\r" of a "\r\n" sequence is silently removed.
 *  When the function is left the aSocket.bufferChar contains ' ',
 *  '\t', '\n' or EOF.
 *  @return the word read.
 *  @exception MEMORY_ERROR Not enough memory to represent the result.
 *)
const func string: getwd (inout socket: aSocket) is
  return word_read(aSocket.sock, aSocket.bufferChar);


(**
 *  Read a line from 'aSocket'.
 *  The function accepts lines ending with "\n", "\r\n" or EOF.
 *  The line ending characters are not copied into the string. That
 *  means that the "\r" of a "\r\n" sequence is silently removed. When
 *  the function is left the aSocket.bufferChar contains '\n' or EOF.
 *  @return the line read.
 *  @exception MEMORY_ERROR Not enough memory to represent the result.
 *)
const func string: getln (inout socket: aSocket) is
  return line_read(aSocket.sock, aSocket.bufferChar);


(**
 *  Determine the end-of-file indicator.
 *  @return FALSE, since a socket never reaches end-of-file.
 *)
const func boolean: eof (in socket: aSocket) is
  return FALSE; # eof(aSocket.sock);


(**
 *  Determine if at least one character can be read successfully.
 *  @return TRUE, since the next 'getc' will never return EOF.
 *)
const func boolean: hasNext (in socket: aSocket) is
  return TRUE; # hasNext(aSocket.sock);


(* Operations for the listener *)

const type: listener is new struct
    var PRIMITIVE_SOCKET: sock is PRIMITIVE_NULL_SOCKET;
    var socketAddress: addr is socketAddress.value;
    var string: service is "";
  end struct;


(**
 *  Create a bound internet listener for a port at localhost.
 *  Processing requests from port 1080 can be done with:
 *   inetListener := openInetListener(1080);
 *   listen(inetListener, 10);
 *   while TRUE do
 *     sock := accept(inetListener);
 *     # Read and process the request from sock.
 *     close(sock);
 *   end while;
 *  @return the bound internet listener.
 *  @exception FILE_ERROR A system function returns an error.
 *  @exception RANGE_ERROR The port is not in the range 0 to 65535.
 *  @exception MEMORY_ERROR An out of memory situation occurred.
 *)
const func listener: openInetListener (in integer: portNumber) is func
  result
    var listener: result is listener.value;
  local
    var socketAddress: address is socketAddress.value;
    var PRIMITIVE_SOCKET: open_socket is PRIMITIVE_NULL_SOCKET;
  begin
    address := inetListenerAddress(portNumber);
    open_socket := PRIMITIVE_SOCKET(addrFamily(address), SOCK_STREAM, 0);
    if open_socket <> PRIMITIVE_NULL_SOCKET then
      result.addr := address;
      result.service := service(address);
      bind(open_socket, result.addr);
      result.sock := open_socket;
    end if;
  end func;


(**
 *  Listen for socket connections and limit the incoming queue.
 *  The ''backlog'' argument defines the maximum length to which
 *  the queue of pending connections for ''aListener'' may grow.
 *  @exception FILE_ERROR A system function returns an error.
 *)
const proc: listen (in listener: aListener, in integer: backlog) is func
  begin
    listen(aListener.sock, backlog);
  end func;


(*
const type: listenerArray is array listener;
const array PRIMITIVE_SOCKET: select (in array PRIMITIVE_SOCKET: socks) is 0 times PRIMITIVE_NULL_SOCKET;


const func listener: select (in array listener: listeners) is func
  result
    var listener: result is listener.value;
  local
    var array PRIMITIVE_SOCKET: socks is 0 times PRIMITIVE_NULL_SOCKET;
    var integer: index is 0;
  begin
    if length(listeners) = 0 then
      raise RANGE_ERROR;
    else
      socks := length(listeners) times PRIMITIVE_NULL_SOCKET;
      for index range minIdx(listeners) to maxIdx(listeners) do
        socks[index] := listeners[index].sock;
      end for;
      socks := select(socks);
      for index range minIdx(listeners) to maxIdx(listeners) do
        if socks[1] = listeners[index].sock then
          result := listeners[index];
        end if;
      end for;
    end if;
  end func;


const func integer: selectOne (in array listener: listeners) is func
  result
    var listener: result is listener.value;
  local
    var array PRIMITIVE_SOCKET: socks is 0 times PRIMITIVE_NULL_SOCKET;
    var integer: index is 0;
  begin
    socks := length(listeners) times PRIMITIVE_NULL_SOCKET;
    for index range minIdx(listeners) to maxIdx(listeners) do
      socks[index] := listeners[index].sock;
    end for;
    result := selectOne(socks);
  end func;
*)


(*
const func boolean: requestPresent (in listener: aListener, in duration: timeout) is func
  result
    var boolean: result is FALSE;
  begin
    result := inputReady(aListener.sock, toSeconds(timeout), timeout.micro_seconds);
  end func;
*)


(**
 *  Create a new accepted connection socket for 'aListener'.
 *  The function waits until at least one connection request is
 *  in the listeners queue of pending connections. Then it extracts
 *  the first connection request from the listeners queue. This
 *  request is accepted and a connection socket is created for it.
 *  @return the accepted connection socket.
 *  @exception FILE_ERROR A system function returns an error.
 *  @exception MEMORY_ERROR An out of memory situation occurred.
 *)
const func file: accept (in listener: aListener) is func
  result
    var file: result is STD_NULL;
  local
    var PRIMITIVE_SOCKET: open_socket is PRIMITIVE_NULL_SOCKET;
    var socket: new_socket is socket.value;
  begin
    open_socket := accept(aListener.sock, new_socket.addr);
    if open_socket <> PRIMITIVE_NULL_SOCKET then
      new_socket.service := aListener.service;
      new_socket.sock := open_socket;
      result := malloc(new_socket);
    end if;
  end func;


(*
const func file: accept (in array listener: listeners) is func
  result
    var file: result is STD_NULL;
  local
    var integer: index is 0;
  begin
    index := selectOne(listeners);
    result := accept(listeners[index]);
  end func;
*)
