
(********************************************************************)
(*                                                                  *)
(*  sha1.s7i      SHA-1 secure hash algorithm support library       *)
(*  Copyright (C) 1989 - 2013  Thomas Mertes                        *)
(*                                                                  *)
(*  This file is part of the Seed7 Runtime Library.                 *)
(*                                                                  *)
(*  The Seed7 Runtime Library is free software; you can             *)
(*  redistribute it and/or modify it under the terms of the GNU     *)
(*  Lesser General Public License as published by the Free Software *)
(*  Foundation; either version 2.1 of the License, or (at your      *)
(*  option) any later version.                                      *)
(*                                                                  *)
(*  The Seed7 Runtime Library is distributed in the hope that it    *)
(*  will be useful, but WITHOUT ANY WARRANTY; without even the      *)
(*  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR *)
(*  PURPOSE.  See the GNU Lesser General Public License for more    *)
(*  details.                                                        *)
(*                                                                  *)
(*  You should have received a copy of the GNU Lesser General       *)
(*  Public License along with this program; if not, write to the    *)
(*  Free Software Foundation, Inc., 51 Franklin Street,             *)
(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)
(*                                                                  *)
(********************************************************************)


include "bytedata.s7i";
include "bin32.s7i";


(**
 *  Compute a message digest with the SHA-1 secure hash algorithm.
 *  @return the message digest (a string of 20 bytes).
 *  @exception RANGE_ERROR When characters beyond '\255\' are present.
 *)
const func string: sha1 (in var string: message) is func
  result
    var string: digest is string parse (" " mult 20);
  local
    var integer: length is 0;
    var integer: chunkIndex is 0;
    var integer: index is 0;
    var array bin32: w is 80 times bin32.value;
    var integer: h0 is 16#67452301;
    var integer: h1 is 16#EFCDAB89;
    var integer: h2 is 16#98BADCFE;
    var integer: h3 is 16#10325476;
    var integer: h4 is 16#C3D2E1F0;
    var bin32: a is bin32(0);
    var bin32: b is bin32(0);
    var bin32: c is bin32(0);
    var bin32: d is bin32(0);
    var bin32: e is bin32(0);
    var bin32: f is bin32(0);
    var bin32: g is bin32(0);
    var integer: temp is 0;
    var integer: k is 0;
  begin
    length := length(message);
    # Append the bit '1' to the message.
    message &:= '\16#80\';
    # Append '0' bits, so that the resulting bit length is congruent to 448 (mod 512).
    message &:= "\0\" mult 64 - (length + 9) mod 64;
    # Append length of message (before pre-processing), in bits, as 64-bit big-endian integer.
    message &:= int64AsEightBytesBe(8 * length);

    # Process the message in successive 512-bit chunks:
    for chunkIndex range 1 to length(message) step 64 do
      # Break chunk into sixteen 32-bit big-endian words.
      for index range 1 to 16 do
        w[index] := bin32(bytesBeAsInt(message[chunkIndex + 4 * pred(index) len 4]));
      end for;

      # Extend the sixteen 32-bit words into eighty 32-bit words.
      for index range 17 to 80 do
        g := w[index-3] >< w[index-8] >< w[index-14] >< w[index-16];
        w[index] := (g << 1 | g >> 31) & bin32(16#ffffffff);  # Left rotate by 1
      end for;

      a := bin32(h0 mod 16#100000000);
      b := bin32(h1 mod 16#100000000);
      c := bin32(h2 mod 16#100000000);
      d := bin32(h3 mod 16#100000000);
      e := bin32(h4 mod 16#100000000);

      for index range 1 to 80 do
        if index <= 20 then
          f := d >< (b & (c >< d));
          k := 16#5A827999;
        elsif index <= 40 then
          f := b >< c >< d;
          k := 16#6ED9EBA1;
        elsif index <= 60 then
          f := (b & c) | (d & (b | c));
          k := 16#8F1BBCDC;
        else
          f := b >< c >< d;
          k := 16#CA62C1D6;
        end if;

        temp := ord((a << 5 | a >> 27) & bin32(16#ffffffff));  # Left rotate a by 5
        temp +:= ord(f) + ord(e) + k + ord(w[index]);
        e := d;
        d := c;
        c := (b << 30 | b >> 2) & bin32(16#ffffffff);  # Left rotate b by 30
        b := a;
        a := bin32(temp mod 16#100000000);
      end for;

      # Add this chunk's hash to result so far:
      h0 +:= ord(a);
      h1 +:= ord(b);
      h2 +:= ord(c);
      h3 +:= ord(d);
      h4 +:= ord(e);
    end for;

    # Produce the final hash value:
    digest := int32AsFourBytesBe(h0) &
              int32AsFourBytesBe(h1) &
              int32AsFourBytesBe(h2) &
              int32AsFourBytesBe(h3) &
              int32AsFourBytesBe(h4);
  end func;
