
(********************************************************************)
(*                                                                  *)
(*  tar.s7i       Tar archive library                               *)
(*  Copyright (C) 1994, 2004, 2005, 2010, 2014, 2016  Thomas Mertes *)
(*                                                                  *)
(*  This file is part of the Seed7 Runtime Library.                 *)
(*                                                                  *)
(*  The Seed7 Runtime Library is free software; you can             *)
(*  redistribute it and/or modify it under the terms of the GNU     *)
(*  Lesser General Public License as published by the Free Software *)
(*  Foundation; either version 2.1 of the License, or (at your      *)
(*  option) any later version.                                      *)
(*                                                                  *)
(*  The Seed7 Runtime Library is distributed in the hope that it    *)
(*  will be useful, but WITHOUT ANY WARRANTY; without even the      *)
(*  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR *)
(*  PURPOSE.  See the GNU Lesser General Public License for more    *)
(*  details.                                                        *)
(*                                                                  *)
(*  You should have received a copy of the GNU Lesser General       *)
(*  Public License along with this program; if not, write to the    *)
(*  Free Software Foundation, Inc., 51 Franklin Street,             *)
(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)
(*                                                                  *)
(********************************************************************)


include "stdio.s7i";
include "osfiles.s7i";
include "time.s7i";
include "getf.s7i";
include "gzip.s7i";


const string: TMAGIC is "ustar";
const string: NOMAGIC is "";

const char: REGTYPE      is '0';   # Regular file (preferred code)
const char: AREGTYPE     is '\0;'; # Regular file (alternate code)
const char: LNKTYPE      is '1';   # Hard link.
const char: SYMTYPE      is '2';   # Symbolic link
const char: CHRTYPE      is '3';   # Character special
const char: BLKTYPE      is '4';   # Block special
const char: DIRTYPE      is '5';   # Directory
const char: FIFOTYPE     is '6';   # Named pipe
const char: CONTTYPE     is '7';   # Contiguous file
const char: LONGNAMETYPE is 'L';   # Long (untruncated) filename of the next file

const type: tarHeader is new struct
    var string: name is "";
    var fileMode: mode is fileMode.value;
    var integer: uid is 0;
    var integer: gid is 0;
    var integer: size is 0;
    var integer: mtime is 0;
    var integer: chksum is 0;
    var char: typeflag is REGTYPE;
    var string: linkname is "";
    var string: magic is "";
    var string: version is "";
    var string: uname is "";
    var string: gname is "";
    var integer: devmajor is 0;
    var integer: devminor is 0;
    var string: prefix is "";
    var string: filePath is "";
    var string: fileTypeMarker is "";
  end struct;


const proc: showHeader (inout file: outFile, in tarHeader: header) is func
  begin
    writeln(outFile, "name: " <& header.name);
    writeln(outFile, "mode: " <& header.mode);
    writeln(outFile, "uid: " <& header.uid);
    writeln(outFile, "gid: " <& header.gid);
    writeln(outFile, "size: " <& header.size);
    writeln(outFile, "mtime: " <& header.mtime);
    writeln(outFile, "chksum: " <& header.chksum);
    writeln(outFile, "typeflag: " <& literal(header.typeflag));
    writeln(outFile, "linkname: " <& header.linkname);
    writeln(outFile, "magic: " <& literal(header.magic));
    writeln(outFile, "version: " <& literal(header.version));
    writeln(outFile, "uname: " <& header.uname);
    writeln(outFile, "gname: " <& header.gname);
    writeln(outFile, "devmajor: " <& header.devmajor);
    writeln(outFile, "devminor: " <& header.devminor);
    writeln(outFile, "prefix: " <& header.prefix);
    writeln(outFile, "filePath: " <& header.filePath);
  end func;


const func string: gets0 (inout file: inFile, in integer: length) is func
  result
    var string: stri is "";
  local
    var integer: zeroBytePos is 0;
  begin
    stri := gets(inFile, length);
    zeroBytePos := pos(stri, "\0;");
    if zeroBytePos <> 0 then
      stri := stri[ .. pred(zeroBytePos)];
    end if;
  end func;


const func string: gets0spc (inout file: inFile, in integer: length) is func
  result
    var string: stri is "";
  local
    var integer: zeroBytePos is 0;
    var integer: spacePos is 0;
  begin
    stri := gets(inFile, length);
    zeroBytePos := pos(stri, "\0;");
    if zeroBytePos <> 0 then
      stri := stri[ .. pred(zeroBytePos)];
    end if;
    spacePos := pos(stri, " ");
    if spacePos <> 0 then
      stri := stri[ .. pred(spacePos)];
    end if;
  end func;


const func integer: getoct (inout file: inFile, in integer: length) is func
  result
    var integer: number is 0;
  local
    var string: stri is "";
    var integer: start is 1;
    var integer: pos is 0;
  begin
    stri := gets(inFile, length);
    while start <= length(stri) and stri[start] = ' ' do
      incr(start);
    end while;
    pos := start;
    while pos <= length(stri) and stri[pos] >= '0' and stri[pos] <= '7' do
      incr(pos);
    end while;
    if pos > start then
      number := integer(stri[start .. pred(pos)], 8);
    end if;
  end func;


const proc: puts0 (inout string: out_stri, in string: stri, in integer: length) is func
  begin
    out_stri &:= stri[ .. length];
    if length(stri) < length then
      out_stri &:= "\0;" mult length - length(stri);
    end if;
  end func;


const proc: putspc (inout string: out_stri, in string: stri, in integer: length) is func
  begin
    out_stri &:= stri[ .. length] rpad length;
  end func;


const proc: putoct (inout string: out_stri, in integer: number, in integer: length) is func
  begin
    out_stri &:= number radix 8 lpad0 pred(length) <& "\0;";
  end func;


const func integer: chksum (in string: stri) is func
  result
    var integer: checkSum is 0;
  local
    var char: ch is ' ';
  begin
    for ch range stri do
      checkSum +:= ord(ch);
    end for;
    checkSum := checkSum mod 2 ** 16;
  end func;


const proc: readHeadBlock (inout file: inFile, inout tarHeader: header) is func
  local
    var string: stri is "";
  begin
    header := tarHeader.value;
    header.name :=                gets0(inFile,  100);
    header.mode := fileMode conv getoct(inFile,    8);
    header.uid :=                getoct(inFile,    8);
    header.gid :=                getoct(inFile,    8);
    header.size :=               getoct(inFile,   12);
    header.mtime :=              getoct(inFile,   12);
    header.chksum :=             getoct(inFile,    8);
    header.typeflag :=             getc(inFile);
    header.linkname :=            gets0(inFile,  100);
    header.magic :=            gets0spc(inFile,    6);
    header.version :=              gets(inFile,    2);
    header.uname :=               gets0(inFile,   32);
    header.gname :=               gets0(inFile,   32);
    header.devmajor :=           getoct(inFile,    8);
    header.devminor :=           getoct(inFile,    8);
    header.prefix :=              gets0(inFile,  155);
    stri :=                        gets(inFile,   12);
  end func;


const proc: readHead (inout file: inFile, inout tarHeader: header) is func
  local
    var string: filePath is "";
  begin
    readHeadBlock(inFile, header);
    # showHeader(STD_OUT, header);
    if header.name <> "" and header.magic = TMAGIC and
        header.typeflag = LONGNAMETYPE and header.size <> 0 then
      filePath := gets0(inFile, header.size);
      seek(inFile, tell(inFile) + 511 - pred(header.size) mod 512);
      readHeadBlock(inFile, header);
      # showHeader(STD_OUT, header);
      header.filePath := filePath;
      header.prefix := "";
    elsif header.prefix <> "" then
      header.filePath := header.prefix & "/" & header.name;
    else
      header.filePath := header.name;
    end if;
    if endsWith(header.filePath, "/") then
      header.filePath := header.filePath[.. pred(length(header.filePath))];
      header.fileTypeMarker := "/";
    end if;
  end func;


const proc: writeHeadBlock (inout file: outFile, in tarHeader: header) is func
  local
    var string: out_stri is "";
    var string: chksum is "";
  begin
    puts0  (out_stri, header.name,      100);
    putoct (out_stri, integer conv (header.mode), 8);
    putoct (out_stri, header.uid,         8);
    putoct (out_stri, header.gid,         8);
    putoct (out_stri, header.size,       12);
    putoct (out_stri, header.mtime,      12);
    putspc (out_stri, "",               8);
    out_stri &:=      header.typeflag; (* 1*)
    puts0  (out_stri, header.linkname,  100);
    puts0  (out_stri, header.magic,       6);
    putspc (out_stri, header.version,     2);
    puts0  (out_stri, header.uname,      32);
    puts0  (out_stri, header.gname,      32);
    putoct (out_stri, header.devmajor,    8);
    putoct (out_stri, header.devminor,    8);
    puts0  (out_stri, header.prefix,    155);
    puts0  (out_stri, "",              12);
    putoct (chksum,   chksum(out_stri), 8);
    out_stri := out_stri[ .. 148] & chksum & out_stri[157 .. ];
    write(outFile, out_stri);
  end func;


const proc: writeHead (inout file: outFile, in tarHeader: header) is func
  local
    var tarHeader: longNameHead is tarHeader.value;
  begin
    if length(header.filePath) > 100 then
      longNameHead.name     := "././@LongLink";
      longNameHead.mode     := fileMode.value;
      longNameHead.uid      := 0;
      longNameHead.gid      := 0;
      longNameHead.size     := length(header.filePath);
      longNameHead.mtime    := 0;
      longNameHead.typeflag := LONGNAMETYPE;
      longNameHead.linkname := "";
      longNameHead.magic    := TMAGIC;
      longNameHead.version  := "  ";
      longNameHead.uname    := "root";
      longNameHead.gname    := "root";
      longNameHead.devmajor := 0;
      longNameHead.devminor := 0;
      longNameHead.prefix   := "";
      writeHeadBlock(outFile, longNameHead);
      write(outFile, header.filePath);
      write(outFile, "\0;" mult 511 - pred(longNameHead.size) mod 512);
    end if;
    writeHeadBlock(outFile, header);
  end func;


const proc: setUpHead (in string: basePath, in string: name,
    in string: fileTypeMarker, inout tarHeader: header) is func
  begin
    header.name     := name & fileTypeMarker;
    header.mode     := fileMode(basePath & name);
    header.uid      := 100;
    header.gid      := 100;
    header.size     := 0;
    header.mtime    := timestamp1970(getMTime(basePath & name));
    header.chksum   := 0;  # Filled later
    header.typeflag := REGTYPE;
    header.linkname := "";
    header.magic    := TMAGIC;
    header.version  := "  ";
    header.uname    := "";
    header.gname    := "";
    header.devmajor := 0;
    header.devminor := 0;
    header.prefix   := "";
  end func;


const type: tarRegisterType is hash [string] integer;
const type: tarCatalogType is hash [string] tarHeader;


(**
 *  Describes a TAR archive.
 *)
const type: tarArchive is new struct
    var file: tarFile is STD_NULL;
    var tarRegisterType: register is tarRegisterType.value;
    var tarCatalogType: catalog is tarCatalogType.value;
  end struct;


(**
 *  Open a TAR archive with the given tarFile.
 *  @param tarFile File that contains a TAR archive.
 *)
const func tarArchive: openTar (inout file: tarFile) is func
  result
    var tarArchive: tar is tarArchive.value;
  local
    var tarHeader: header is tarHeader.value;
    var integer: headPos is 1;
  begin
    seek(tarFile, 1);
    readHead(tarFile, header);
    if header.filePath <> "" and (header.magic = TMAGIC or header.magic = NOMAGIC) then
      tar.tarFile := tarFile;
      repeat
        # writeln(header.filePath <& " " <& headPos);
        tar.register @:= [header.filePath] headPos;
        if header.size <> 0 then
          seek(tarFile, tell(tarFile) + succ(pred(header.size) mdiv 512) * 512);
        end if;
        headPos := tell(tarFile);
        readHead(tarFile, header);
      until header.filePath = "" or (header.magic <> TMAGIC and header.magic <> NOMAGIC);
    end if;
  end func;


(**
 *  Open a TAR archive with the given tarFile.
 *  @param tarFileName Name of the TAR archive to be opened.
 *)
const func tarArchive: openTar (in string: tarFileName) is func
  result
    var tarArchive: tar is tarArchive.value;
  local
    var file: tarFile is STD_NULL;
  begin
    tarFile := open(tarFileName, "r");
    tar := openTar(tarFile);
  end func;


(**
 *  Close a TAR archive.
 *)
const proc: close (inout tarArchive: tar) is func
  begin
    close(tar.tarFile);
    tar.tarFile := STD_NULL;
  end func;


(**
 *  Determine the file names in a directory inside a TAR archive.
 *  Note that the function returns only the file names.
 *  Additional information must be obtained with other calls.
 *  @param tar Open TAR archive.
 *  @param dirPath path of a directory in the TAR archive.
 *  @return an array with the file names.
 *  @exception FILE_ERROR The file triggers an error.
 *  @exception RANGE_ERROR DirPath ends with a slash.
 *)
const func array string: readDir (inout tarArchive: tar, in var string: dirPath) is func
  result
    var array string: fileNames is 0 times "";
  local
    var string: filePath is "";
    var set of string: fileNameSet is (set of string).value;
    var string: fileName is "";
    var integer: slashPos is 0;
  begin
    if dirPath <> "/" and endsWith(dirPath, "/") then
      raise RANGE_ERROR
    else
      if dirPath = "." then
        dirPath := "";
      end if;
      for key filePath range tar.register do
        if startsWith(filePath, dirPath) then
          fileName := filePath[succ(length(dirPath)) ..];
          if startsWith(fileName, "/") then
            fileName := fileName[2 ..];
          elsif dirPath <> "" then
            fileName := "";  # A file name <> dirPath starts with dirPath.
          end if;
          slashPos := pos(fileName, '/');
          if slashPos <> 0 then
            fileName := fileName[.. pred(slashPos)];
          end if;
          if fileName <> "" and fileName not in fileNameSet then
            incl(fileNameSet, fileName);
          end if;
        end if;
      end for;
      fileNames := sort(toArray(fileNameSet));
    end if;
  end func;


(**
 *  Determine the file names in the top directory of a TAR archive.
 *  Note that the function returns only the file names.
 *  Additional information must be obtained with other calls.
 *  @param tar Open TAR archive.
 *  @return an array with the file names.
 *  @exception FILE_ERROR The file triggers an error.
 *)
const func array string: readDir (inout tarArchive: tar) is
  return readDir(tar, "");


(**
 *  Determine the file paths in a TAR archive.
 *  Note that the function returns only the file paths.
 *  Additional information must be obtained with other calls.
 *  @param tar Open TAR archive.
 *  @return an array with the file paths.
 *)
const func array string: readDir (inout tarArchive: tar, RECURSIVE) is
  return sort(keys(tar.register));


(**
 *  Determine the type of a file in a TAR archive.
 *  The function does follow symbolic links. When the chain of
 *  symbolic links is too long the function returns ''FILE_SYMLINK''.
 *  When a symbolic link refers to a place where the permission
 *  is denied the function returns ''FILE_SYMLINK''.
 *  A return value of ''FILE_ABSENT'' does not imply that a file
 *  with this name can be created, since missing directories and
 *  illegal file names cause also ''FILE_ABSENT''.
 *  @return the type of the file.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation.
 *)
const func fileType: fileType (inout tarArchive: tar, in string: filePath) is func
  result
    var fileType: aFileType is FILE_UNKNOWN;
  local
    var tarHeader: header is tarHeader.value;
    var char: typeflag is ' ';
  begin
    if filePath <> "/" and endsWith(filePath, "/") then
      raise RANGE_ERROR
    else
      if filePath in tar.catalog then
        typeflag := tar.catalog[filePath].typeflag;
      elsif filePath in tar.register then
        seek(tar.tarFile, tar.register[filePath]);
        readHead(tar.tarFile, header);
        typeflag := header.typeflag;
        tar.catalog @:= [filePath] header;
      else
        aFileType := FILE_ABSENT;
      end if;
      if aFileType = FILE_UNKNOWN then
        case typeflag of
          when {REGTYPE}:  aFileType := FILE_REGULAR;
          when {AREGTYPE}: aFileType := FILE_REGULAR;
          when {CHRTYPE}:  aFileType := FILE_CHAR;
          when {BLKTYPE}:  aFileType := FILE_BLOCK;
          when {DIRTYPE}:  aFileType := FILE_DIR;
          when {FIFOTYPE}: aFileType := FILE_FIFO;
          when {CONTTYPE}: aFileType := FILE_UNKNOWN;
          otherwise:
            raise RANGE_ERROR;
        end case;
      end if;
    end if;
  end func;


(**
 *  Determine the type of a file in a TAR archive.
 *  The function does not follow symbolic links. Therefore it may
 *  return ''FILE_SYMLINK''. A return value of ''FILE_ABSENT'' does
 *  not imply that a file with this name can be created, since missing
 *  directories and illegal file names cause also ''FILE_ABSENT''.
 *  @return the type of the file.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation.
 *)
const func fileType: fileTypeSL (inout tarArchive: tar, in string: filePath) is func
  result
    var fileType: aFileType is FILE_UNKNOWN;
  local
    var tarHeader: header is tarHeader.value;
    var char: typeflag is ' ';
  begin
    if filePath <> "/" and endsWith(filePath, "/") then
      raise RANGE_ERROR
    else
      if filePath in tar.catalog then
        typeflag := tar.catalog[filePath].typeflag;
      elsif filePath in tar.register then
        seek(tar.tarFile, tar.register[filePath]);
        readHead(tar.tarFile, header);
        typeflag := header.typeflag;
        tar.catalog @:= [filePath] header;
      else
        aFileType := FILE_ABSENT;
      end if;
      if aFileType = FILE_UNKNOWN then
        case typeflag of
          when {REGTYPE}:  aFileType := FILE_REGULAR;
          when {AREGTYPE}: aFileType := FILE_REGULAR;
          when {LNKTYPE}:  aFileType := FILE_SYMLINK;
          when {SYMTYPE}:  aFileType := FILE_SYMLINK;
          when {CHRTYPE}:  aFileType := FILE_CHAR;
          when {BLKTYPE}:  aFileType := FILE_BLOCK;
          when {DIRTYPE}:  aFileType := FILE_DIR;
          when {FIFOTYPE}: aFileType := FILE_FIFO;
          when {CONTTYPE}: aFileType := FILE_UNKNOWN;
          otherwise:
            raise RANGE_ERROR;
        end case;
      end if;
    end if;
  end func;


(**
 *  Determine the file mode (permissions) of a file in a TAR archive.
 *  @return the file mode.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation or it is not present in the TAR archive.
 *)
const func fileMode: fileMode (inout tarArchive: tar, in string: filePath) is func
  result
    var fileMode: mode is fileMode.value;
  local
    var tarHeader: header is tarHeader.value;
  begin
    if filePath <> "/" and endsWith(filePath, "/") then
      raise RANGE_ERROR
    else
      if filePath in tar.catalog then
        mode := tar.catalog[filePath].mode;
      elsif filePath in tar.register then
        seek(tar.tarFile, tar.register[filePath]);
        readHead(tar.tarFile, header);
        mode := header.mode;
        tar.catalog @:= [filePath] header;
      else
        raise RANGE_ERROR;
      end if;
    end if;
  end func;


(**
 *  Determine the size of a file in a TAR archive.
 *  The file size is measured in bytes.
 *  For directories a size of 0 is returned.
 *  @return the size of the file.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation or it is not present in the TAR archive.
 *)
const func integer: fileSize (inout tarArchive: tar, in string: filePath) is func
  result
    var integer: size is 0;
  local
    var tarHeader: header is tarHeader.value;
  begin
    if filePath <> "/" and endsWith(filePath, "/") then
      raise RANGE_ERROR
    else
      if filePath in tar.catalog then
        size := tar.catalog[filePath].size;
      elsif filePath in tar.register then
        seek(tar.tarFile, tar.register[filePath]);
        readHead(tar.tarFile, header);
        size := header.size;
        tar.catalog @:= [filePath] header;
      else
        raise RANGE_ERROR;
      end if;
    end if;
  end func;


(**
 *  Determine the modification time of a file in a TAR archive.
 *  @return the modification time of the file.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation or it is not present in the TAR archive.
 *)
const func time: getMTime (inout tarArchive: tar, in string: filePath) is func
  result
    var time: modificationTime is time.value;
  local
    var tarHeader: header is tarHeader.value;
    var integer: mtime is 0;
  begin
    if filePath <> "/" and endsWith(filePath, "/") then
      raise RANGE_ERROR
    else
      if filePath in tar.catalog then
        mtime := tar.catalog[filePath].mtime;
      elsif filePath in tar.register then
        seek(tar.tarFile, tar.register[filePath]);
        readHead(tar.tarFile, header);
        mtime := header.mtime;
        tar.catalog @:= [filePath] header;
      else
        raise RANGE_ERROR;
      end if;
      modificationTime := timestamp1970ToTime(mtime);
    end if;
  end func;


const proc: tarTell (inout file: inFile, in array string: arg_list,
    in boolean: do_view) is func
  local
    var tarHeader: header is tarHeader.value;
    var time: modTime is time.value;
  begin
    readHead(inFile, header);
    while header.filePath <> "" and (header.magic = TMAGIC or header.magic = NOMAGIC) do
      if do_view then
        if header.typeflag = DIRTYPE then
          write("d");
        else
          write("-");
        end if;
        write(header.mode);
        write(" ");
        if header.uname <> "" then
          write(header.uname);
        else
          write(header.uid);
        end if;
        write("/");
        if header.gname <> "" then
          write(header.gname);
        else
          write(header.gid);
        end if;
        write(header.size lpad 14);
        write(" ");
        modTime := timestamp1970ToTime(header.mtime);
        write(strDate(modTime));
        write(" ");
        write(str_hh_mm(modTime, ":"));
        write(" ");
        # write(strTimeZone(modTime) rpad 12);
      end if;
      writeln(header.filePath <& header.fileTypeMarker);
      if header.size <> 0 then
        seek(inFile, tell(inFile) + succ(pred(header.size) mdiv 512) * 512);
      end if;
      readHead(inFile, header);
    end while;
  end func;


const proc: tarTell (in string: inFileName, in array string: arg_list,
    in boolean: do_view, in boolean: do_unzip) is func
  local
    var file: inFile is STD_NULL;
    var string: magicBytes is "";
  begin
    inFile := open(inFileName, "r");
    if inFile <> STD_NULL then
      magicBytes := gets(inFile, 2);
      seek(inFile, 1);
      if magicBytes = "\31;\139;" then
        inFile := gunzip(inFile);
      elsif do_unzip then
        write("tar7: File \"");
        write(inFileName);
        writeln("\" not in gzip format.");
      end if;
    end if;
    if inFile <> STD_NULL then
      tarTell(inFile, arg_list, do_view);
    else
      write("tar7: Cannot open \"");
      write(inFileName);
      writeln("\".");
    end if;
  end func;


const proc: tarXtract (inout file: inFile, in array string: arg_list,
    in boolean: do_view) is func
  local
    var string: stri is "";
    var tarHeader: header is tarHeader.value;
    var time: modTime is time.value;
    var array tarHeader: dirHeaderList is 0 times tarHeader.value;
    var integer: index is 0;
    var boolean: okay is TRUE;
  begin
    readHead(inFile, header);
    while header.filePath <> "" and (header.magic = TMAGIC or header.magic = NOMAGIC) and okay do
      if do_view then
        write("x ");
        writeln(header.filePath <& header.fileTypeMarker);
      end if;
      if header.typeflag = DIRTYPE then
        if fileType(header.filePath) = FILE_DIR then
          dirHeaderList &:= [] (header);
        elsif fileType(header.filePath) = FILE_ABSENT then
          mkdir(header.filePath);
          dirHeaderList &:= [] (header);
        else
          writeln("*** The file " <& literal(header.filePath) <& " exists, but is not a directory");
          okay := FALSE;
        end if;
      elsif header.typeflag = REGTYPE or header.typeflag = AREGTYPE then
        if header.size <> 0 then
          stri := gets(inFile, succ(pred(header.size) mdiv 512) * 512);
          if fileType(header.filePath) = FILE_REGULAR then
            removeFile(header.filePath);
          end if;
          if fileType(header.filePath) = FILE_ABSENT then
            putf(header.filePath, stri[ .. header.size]);
            setFileMode(header.filePath, header.mode);
            modTime := timestamp1970ToTime(header.mtime);
            setMTime(header.filePath, modTime);
          else
            writeln("*** The file " <& literal(header.filePath) <& " exists, but is not a regular file");
            okay := FALSE;
          end if;
        end if;
      end if;
      readHead(inFile, header);
    end while;
    for index range length(dirHeaderList) downto 1 do
      setFileMode(dirHeaderList[index].filePath, dirHeaderList[index].mode);
      modTime := timestamp1970ToTime(dirHeaderList[index].mtime);
      setMTime(dirHeaderList[index].filePath, modTime);
    end for;
  end func;


const proc: tarXtract (in string: inFileName, in array string: arg_list,
    in boolean: do_view, in boolean: do_unzip) is func
  local
    var file: inFile is STD_NULL;
    var string: magicBytes is "";
  begin
    inFile := open(inFileName, "r");
    if inFile <> STD_NULL then
      magicBytes := gets(inFile, 2);
      seek(inFile, 1);
      if magicBytes = "\31;\139;" then
        inFile := gunzip(inFile);
      elsif do_unzip then
        write("tar7: File \"");
        write(inFileName);
        writeln("\" not in gzip format.");
      end if;
    end if;
    if inFile <> STD_NULL then
      tarXtract(inFile, arg_list, do_view);
    else
      write("tar7: Cannot open \"");
      write(inFileName);
      writeln("\".");
    end if;
  end func;


const proc: tarXtract (in string: inFileName, in boolean: do_view) is func
  begin
    tarXtract(inFileName, 0 times "", do_view, FALSE);
  end func;


const proc: tarXtract (in string: inFileName) is func
  begin
    tarXtract(inFileName, 0 times "", FALSE, FALSE);
  end func;


const proc: tarCreate (inout file: outFile, in string: basePath, in string: pathFromBase,
    in array string: arg_list, in boolean: do_view) is func
  local
    var string: name is "";
    var array string: dir_content is 0 times "";
    var string: stri is "";
    var tarHeader: header is tarHeader.value;
  begin
    for name range arg_list do
      name := pathFromBase & name;
      if do_view then
        write("c ");
        writeln(name);
      end if;
      if fileType(basePath & name) = FILE_DIR then
        dir_content := readDir(basePath & name);
        setUpHead(basePath, name, "/", header);
        header.typeflag := DIRTYPE;
        writeHead(outFile, header);
        tarCreate(outFile, basePath, name & "/", dir_content, do_view);
      else
        stri := getf(basePath & name);
        setUpHead(basePath, name, "", header);
        header.size := length(stri);
        writeHead(outFile, header);
        write(outFile, stri);
        write(outFile, "\0;" mult 511 - pred(header.size) mod 512);
      end if;
    end for;
  end func;


const proc: tarCreate (in string: outFileName, in array string: arg_list,
    in boolean: do_view, in boolean: do_zip) is func
  local
    var file: outFile is STD_NULL;
    var string: name is "";
    var integer: lastSlashPos is 0;
    var string: uncompressed is "";
  begin
    outFile := open(outFileName, "w");
    if outFile <> STD_NULL and do_zip then
      outFile := openGzipFile(outFile);
    end if;
    if outFile <> STD_NULL then
      for name range arg_list do
        lastSlashPos := rpos(name, "/");
        if lastSlashPos = 0 then
          tarCreate(outFile, "", "", [] name, do_view);
        else
          tarCreate(outFile, name[ .. lastSlashPos],
              "", [] (name[succ(lastSlashPos) ..]), do_view);
        end if;
      end for;
      close(outFile);
    end if;
  end func;


const proc: tarCreate (in string: outFileName, in array string: arg_list,
    in boolean: do_view) is func
  begin
    tarCreate(outFileName, arg_list, do_view, FALSE);
  end func;


const proc: tarCreate (in string: outFileName, in array string: arg_list) is func
  begin
    tarCreate(outFileName, arg_list, FALSE, FALSE);
  end func;
