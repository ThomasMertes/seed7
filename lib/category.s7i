
(********************************************************************)
(*                                                                  *)
(*  category.s7i  Category support library                          *)
(*  Copyright (C) 1991 - 1994, 2004, 2005, 2012  Thomas Mertes      *)
(*                                                                  *)
(*  This file is part of the Seed7 Runtime Library.                 *)
(*                                                                  *)
(*  The Seed7 Runtime Library is free software; you can             *)
(*  redistribute it and/or modify it under the terms of the GNU     *)
(*  Lesser General Public License as published by the Free Software *)
(*  Foundation; either version 2.1 of the License, or (at your      *)
(*  option) any later version.                                      *)
(*                                                                  *)
(*  The Seed7 Runtime Library is distributed in the hope that it    *)
(*  will be useful, but WITHOUT ANY WARRANTY; without even the      *)
(*  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR *)
(*  PURPOSE.  See the GNU Lesser General Public License for more    *)
(*  details.                                                        *)
(*                                                                  *)
(*  You should have received a copy of the GNU Lesser General       *)
(*  Public License along with this program; if not, write to the    *)
(*  Free Software Foundation, Inc., 51 Franklin Street,             *)
(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)
(*                                                                  *)
(********************************************************************)


(**
 *  Describes the category of a ''reference''.
 *)
const type: category is newtype;


IN_PARAM_IS_VALUE(category);

const proc: (ref category: dest) ::= (ref category: source)     is action "INT_CREATE";
const proc: destroy (ref category: aValue)                      is action "GEN_DESTR";
const proc: (inout category: dest) := (in category: source)     is action "INT_CPY";


(**
 *  Check if two ''category'' values are equal.
 *  @return TRUE if both values are equal, FALSE otherwise.
 *)
const func boolean: (in category: cat1) = (in category: cat2)   is action "INT_EQ";


(**
 *  Check if two ''category'' values are not equal.
 *  @return FALSE if both values are equal, TRUE otherwise.
 *)
const func boolean: (in category: cat1) <> (in category: cat2)  is action "INT_NE";


(**
 *  Determine the ordinal number of a ''category''.
 *  @return a small [[integer]] which corresponds to ''aCategory''.
 *)
const func integer: ord (in category: aCategory)                is action "INT_ORD";


(**
 *  Convert an [[integer]] number to ''category''.
 *  @return the ''category'' result of the conversion.
 *)
const func category: (attr category) conv (in integer: number)  is action "INT_CONV";


(**
 *  Convert a ''category'' to a [[string]].
 *  @param aCategory Category to be converted.
 *  @return the [[string]] result of the conversion.
 *  @exception MEMORY_ERROR Not enough memory to represent the result.
 *)
const func string: str (in category: aCategory)                 is action "REF_CAT_STR";


(**
 *  Convert a [[string]] to a ''category''.
 *  @param catName Name of a category to be converted.
 *  @return the ''category'' result fo the conversion.
 *  @exception RANGE_ERROR When there is no corresponding ''category''.
 *)
const func category: (attr category) parse (in string: catName) is action "REF_CAT_PARSE";


const category: (attr category) . value is category parse "SYMBOLOBJECT";

const category: SYMBOLOBJECT      is category parse "SYMBOLOBJECT";
const category: DECLAREDOBJECT    is category parse "DECLAREDOBJECT";
const category: FORWARDOBJECT     is category parse "FORWARDOBJECT";
const category: FWDREFOBJECT      is category parse "FWDREFOBJECT";
const category: BLOCKOBJECT       is category parse "BLOCKOBJECT";
const category: CALLOBJECT        is category parse "CALLOBJECT";
const category: MATCHOBJECT       is category parse "MATCHOBJECT";
const category: TYPEOBJECT        is category parse "TYPEOBJECT";
const category: FORMPARAMOBJECT   is category parse "FORMPARAMOBJECT";
const category: INTOBJECT         is category parse "INTOBJECT";
const category: BIGINTOBJECT      is category parse "BIGINTOBJECT";
const category: CHAROBJECT        is category parse "CHAROBJECT";
const category: STRIOBJECT        is category parse "STRIOBJECT";
const category: BSTRIOBJECT       is category parse "BSTRIOBJECT";
const category: ARRAYOBJECT       is category parse "ARRAYOBJECT";
const category: HASHOBJECT        is category parse "HASHOBJECT";
const category: STRUCTOBJECT      is category parse "STRUCTOBJECT";
const category: CLASSOBJECT       is category parse "CLASSOBJECT";
const category: INTERFACEOBJECT   is category parse "INTERFACEOBJECT";
const category: SETOBJECT         is category parse "SETOBJECT";
const category: FILEOBJECT        is category parse "FILEOBJECT";
const category: SOCKETOBJECT      is category parse "SOCKETOBJECT";
const category: POLLOBJECT        is category parse "POLLOBJECT";
const category: LISTOBJECT        is category parse "LISTOBJECT";
const category: FLOATOBJECT       is category parse "FLOATOBJECT";
const category: WINOBJECT         is category parse "WINOBJECT";
const category: PROCESSOBJECT     is category parse "PROCESSOBJECT";
const category: ENUMLITERALOBJECT is category parse "ENUMLITERALOBJECT";
const category: CONSTENUMOBJECT   is category parse "CONSTENUMOBJECT";
const category: VARENUMOBJECT     is category parse "VARENUMOBJECT";
const category: REFOBJECT         is category parse "REFOBJECT";
const category: REFLISTOBJECT     is category parse "REFLISTOBJECT";
const category: EXPROBJECT        is category parse "EXPROBJECT";
const category: ACTOBJECT         is category parse "ACTOBJECT";
const category: VALUEPARAMOBJECT  is category parse "VALUEPARAMOBJECT";
const category: REFPARAMOBJECT    is category parse "REFPARAMOBJECT";
const category: RESULTOBJECT      is category parse "RESULTOBJECT";
const category: LOCALVOBJECT      is category parse "LOCALVOBJECT";
const category: DATABASEOBJECT    is category parse "DATABASEOBJECT";
const category: SQLSTMTOBJECT     is category parse "SQLSTMTOBJECT";
const category: PROGOBJECT        is category parse "PROGOBJECT";

const proc: for (inout category: variable) range (in category: startValue) to (in category: endValue) do
              (in proc: statements)
            end for                                                     is action "PRC_FOR_TO";
const proc: for (inout category: variable) range (in category: startValue) downto (in category: endValue) do
              (in proc: statements)
            end for                                                     is action "PRC_FOR_DOWNTO";

CASE_DECLS(category);
