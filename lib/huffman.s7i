
(********************************************************************)
(*                                                                  *)
(*  huffman.s7i   Support for Huffman coding.                       *)
(*  Copyright (C) 2021, 2022, 2024  Thomas Mertes                   *)
(*                                                                  *)
(*  This file is part of the Seed7 Runtime Library.                 *)
(*                                                                  *)
(*  The Seed7 Runtime Library is free software; you can             *)
(*  redistribute it and/or modify it under the terms of the GNU     *)
(*  Lesser General Public License as published by the Free Software *)
(*  Foundation; either version 2.1 of the License, or (at your      *)
(*  option) any later version.                                      *)
(*                                                                  *)
(*  The Seed7 Runtime Library is distributed in the hope that it    *)
(*  will be useful, but WITHOUT ANY WARRANTY; without even the      *)
(*  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR *)
(*  PURPOSE.  See the GNU Lesser General Public License for more    *)
(*  details.                                                        *)
(*                                                                  *)
(*  You should have received a copy of the GNU Lesser General       *)
(*  Public License along with this program; if not, write to the    *)
(*  Free Software Foundation, Inc., 51 Franklin Street,             *)
(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)
(*                                                                  *)
(********************************************************************)


include "bitdata.s7i";


const type: huffmanSymbolArray is array [0 ..] integer;
const type: msbHuffmanCodeLengthArray is array [0 ..] integer;


(**
 *  Type do describe huffman decoding from a [[bitdata#msbBitStream|msbBitStream]].
 *  This Huffman decoding is used by [[jpeg|JPEG]] files.
 *)
const type: msbHuffmanDecoder is new struct
    var integer: maxBitWidth is 0;
    var huffmanSymbolArray: symbols is huffmanSymbolArray.value;
    var msbHuffmanCodeLengthArray: codeLengths is msbHuffmanCodeLengthArray.value;
  end struct;


(**
 *  Create a Huffman decoder for reading in MSB-First order.
 *  This Huffman decoding is used by [[jpeg|JPEG]] files. It can happen that
 *  ''huffmanValues'' contains the same value twice. In that case
 *  the same symbol is encoded in two ways. This makes absolutely no
 *  sense but it can happen. For that reason it is necessary to use
 *  decoder.codeLengths with the same index as decoder.symbols.
 *  @param numberOfCodesWithLength Array to map bit width to number
 *                                 of symbols that use this bit width.
 *  @param huffmanValues String with symbols ordered by the bit width.
 *)
const func msbHuffmanDecoder: createHuffmanTableMsb (in integer: maximumCodeLength,
    in array integer: numberOfCodesWithLength, in string: huffmanValues) is func
  result
    var msbHuffmanDecoder: decoder is msbHuffmanDecoder.value;
  local
    var integer: currentCode is 0;
    var integer: codeLength is 0;
    var integer: valueIndexStart is 0;
    var integer: valueIndexEnd is 0;
    var integer: valueIndex is 0;
    var integer: huffmanValue is 0;
    var integer: tableIndex is 0;
  begin
    decoder.maxBitWidth := maximumCodeLength;
    decoder.symbols := huffmanSymbolArray[.. pred(1 << maximumCodeLength)] times 0;
    decoder.codeLengths := msbHuffmanCodeLengthArray[.. pred(1 << maximumCodeLength)] times 0;
    for codeLength range 1 to maximumCodeLength do
      valueIndexStart := succ(valueIndexEnd);
      valueIndexEnd +:= numberOfCodesWithLength[codeLength];
      for valueIndex range valueIndexStart to valueIndexEnd do
        huffmanValue := ord(huffmanValues[valueIndex]);
        while currentCode = tableIndex >> (maximumCodeLength - codeLength) do
          decoder.symbols[tableIndex] := huffmanValue;
          decoder.codeLengths[tableIndex] := codeLength;
          incr(tableIndex);
        end while;
        incr(currentCode);
      end for;
      currentCode <<:= 1;
    end for;
    huffmanValue := ord(huffmanValues[length(huffmanValues)]);
    while tableIndex <= pred(1 << maximumCodeLength) do
      decoder.symbols[tableIndex] := ord(huffmanValues[length(huffmanValues)]);
      decoder.codeLengths[tableIndex] := maximumCodeLength;
      incr(tableIndex);
    end while;
  end func;


(**
 *  Get a huffman symbol from a [[bitdata#msbBitStream|msbBitStream]] using the huffman ''decoder''.
 *  The read direction is from MSB (most significant bit) to LSB (least significant bit).
 *  The function peeks bits from ''inBitStream''. By default ''inBitStream'' appends some
 *  '\16#ff;' bytes to allow that bits can be peeked always.
 *  @param inBitStream MSB orderd bit stream from which the bits are skipped.
 *  @param decoder Huffman decoder defining the bit sequences that encode the symbols.
 *)
const func integer: getHuffmanSymbol (inout msbBitStream: inBitStream,
    in msbHuffmanDecoder: decoder) is func
  result
    var integer: symbol is 0;
  local
    var integer: index is 0;
  begin
    index := peekBits(inBitStream, decoder.maxBitWidth);
    symbol := decoder.symbols[index];
    skipBits(inBitStream, decoder.codeLengths[index]);
  end func;


(**
 *  Type do describe huffman decoding from a [[bitdata#lsbBitStream|lsbBitStream]].
 *  This Huffman decoding is used by the inflate (deflate) algorithm.
 *)
const type: lsbHuffmanDecoder is new struct
    var integer: maxBitWidth is 0;
    var huffmanSymbolArray: symbols is huffmanSymbolArray.value;
    var array integer: codeLengths is 0 times 0;
  end struct;

const type: symbolsWithCodeLengthType is array array integer;


const func lsbHuffmanDecoder: createHuffmanTableLsb (in array integer: codeLengths,
    in integer: maximumCodeLength,
    in symbolsWithCodeLengthType: symbolsWithCodeLength) is func
  result
    var lsbHuffmanDecoder: decoder is lsbHuffmanDecoder.value;
  local
    var integer: codeLength is 0;
    var integer: symbol is 0;
    var integer: currentCode is 0;
    var integer: reversedCode is 0;
    var integer: highBits is 0;
  begin
    decoder.maxBitWidth := maximumCodeLength;
    decoder.symbols := huffmanSymbolArray[.. pred(1 << maximumCodeLength)] times 0;
    decoder.codeLengths := codeLengths;
    for codeLength range 1 to maximumCodeLength do
      for symbol range symbolsWithCodeLength[codeLength] do
        reversedCode := reverseBits(codeLength, currentCode);
        for highBits range 0 to pred(1 << maximumCodeLength) step 1 << codeLength do
          decoder.symbols[highBits + reversedCode] := symbol;
        end for;
        incr(currentCode);
      end for;
      currentCode <<:= 1;
    end for;
  end func;


const func symbolsWithCodeLengthType: computeSymbolsWithCodeLength (in array integer: codeLengths) is func
  result
    var symbolsWithCodeLengthType: symbolsWithCodeLength is 0 times 0 times 0;
  local
    var integer: codeLength is 0;
    var integer: maximumCodeLength is 0;
    var integer: numberOfCodes is 0;
    var array integer: numberOfCodesWithLength is 0 times 0;
    var array integer: valueIndex is 0 times 0;
    var integer: symbol is 0;
  begin
    for codeLength range codeLengths do
      if codeLength > maximumCodeLength then
        maximumCodeLength := codeLength;
      end if;
    end for;
    numberOfCodesWithLength := [1 .. maximumCodeLength] times 0;
    for codeLength range codeLengths do
      if codeLength <> 0 then
        incr(numberOfCodesWithLength[codeLength]);
      end if;
    end for;
    symbolsWithCodeLength := [1 .. maximumCodeLength] times 0 times 0;
    for numberOfCodes key codeLength range numberOfCodesWithLength do
      if numberOfCodes <> 0 then
        symbolsWithCodeLength[codeLength] := numberOfCodes times 0;
      end if;
    end for;
    valueIndex := [1 .. maximumCodeLength] times 1;
    for codeLength key symbol range codeLengths do
      if codeLength <> 0 then
        symbolsWithCodeLength[codeLength][valueIndex[codeLength]] := symbol;
        incr(valueIndex[codeLength]);
      end if;
    end for;
  end func;


(**
 *  Create a Huffman decoder for reading in LSB-First order.
 *  This Huffman decoding is used by the inflate (deflate) algorithm.
 *  E.g.: The code lengths (in bits) of
 *   4 0 0 6 5 3 3 3 3 3 4 3 0 0 0 0 5 5 6
 *  describe that 0 is encoded with 4 bits, 3 with 6 bits, etc.
 *  This leads to the following encoding lengths:
 *   length 3: (5, 6, 7, 8, 9, 11)
 *   length 4: (0, 10)
 *   length 5: (4, 16, 17)
 *   length 6: (3, 18)
 *  Beginning with the lowest length the following encodings are generated:
 *   000: 5
 *   001: 6
 *   ...
 *   101: 11
 *  For the next length (4 instead of 3) the value is incremented and shifted:
 *   1100: 0
 *  The encoder should be able fetch the maximum length of bits and to
 *  use it as index. In order to allow that the data must be transformed.
 *  The bits must be flipped and all variants of higher bits must be added:
 *   000000 encodes 5
 *   000001 encodes 9
 *   000010 encodes 7
 *   000011 encodes 0
 *   000100 encodes 6
 *   ...
 *   001000 encodes 5
 *   001001 encodes 9
 *   001010 encodes 7
 *   ...
 *  @param codeLengths Array to map the codes to the number of bits used
 *                     to encode this code. Zero means: This code is not used.
 *)
const func lsbHuffmanDecoder: createHuffmanTableLsb (in array integer: codeLengths) is func
  result
    var lsbHuffmanDecoder: decoder is lsbHuffmanDecoder.value;
  local
    var symbolsWithCodeLengthType: symbolsWithCodeLength is 0 times 0 times 0;
  begin
    symbolsWithCodeLength := computeSymbolsWithCodeLength(codeLengths);
    decoder := createHuffmanTableLsb(codeLengths, maxIdx(symbolsWithCodeLength),
                                   symbolsWithCodeLength);
  end func;


(**
 *  Get a huffman symbol from a [[bitdata#lsbBitStream|lsbBitStream]] using the huffman ''decoder''.
 *  The read direction is from LSB (least significant bit) to MSB (most significant bit).
 *  The function peeks bits from ''inBitStream''. By default ''inBitStream'' appends some
 *  '\16#ff;' bytes to allow that bits can be peeked always.
 *  @param inBitStream LSB orderd bit stream from which the bits are skipped.
 *  @param decoder Huffman decoder defining the bit sequences that encode the symbols.
 *)
const func integer: getHuffmanSymbol (inout lsbBitStream: inBitStream,
    in lsbHuffmanDecoder: decoder) is func
  result
    var integer: symbol is 0;
  local
    var integer: index is 0;
  begin
    index := peekBits(inBitStream, decoder.maxBitWidth);
    symbol := decoder.symbols[index];
    skipBits(inBitStream, decoder.codeLengths[symbol]);
  end func;
