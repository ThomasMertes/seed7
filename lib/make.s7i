
(********************************************************************)
(*                                                                  *)
(*  make.s7i      Make library to manage the compilation process    *)
(*  Copyright (C) 2010 - 2012  Thomas Mertes                        *)
(*                                                                  *)
(*  This file is part of the Seed7 Runtime Library.                 *)
(*                                                                  *)
(*  The Seed7 Runtime Library is free software; you can             *)
(*  redistribute it and/or modify it under the terms of the GNU     *)
(*  Lesser General Public License as published by the Free Software *)
(*  Foundation; either version 2.1 of the License, or (at your      *)
(*  option) any later version.                                      *)
(*                                                                  *)
(*  The Seed7 Runtime Library is distributed in the hope that it    *)
(*  will be useful, but WITHOUT ANY WARRANTY; without even the      *)
(*  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR *)
(*  PURPOSE.  See the GNU Lesser General Public License for more    *)
(*  details.                                                        *)
(*                                                                  *)
(*  You should have received a copy of the GNU Lesser General       *)
(*  Public License along with this program; if not, write to the    *)
(*  Free Software Foundation, Inc., 51 Franklin Street,             *)
(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)
(*                                                                  *)
(********************************************************************)


include "stdio.s7i";
include "osfiles.s7i";
include "scanfile.s7i";
include "scanstri.s7i";
include "time.s7i";
include "getf.s7i";
include "shell.s7i";


const set of char: target_name_char is {'!' .. '~'} - {':', '='};
const set of char: dependency_name_char is {'!' .. '~'};
const set of char: macro_name_char is {'!' .. '~'} - {')', '='};
const set of char: parameter_char is {'!' .. '~'} - {'<', '>', '|', ';'};
const set of char: dos_parameter_char is {'!' .. '~'} - {'&', '<', '>', '|'};

const type: makeFlag is new enum
    ignoreErrors. dontExecute, silentMode
  end enum;

const type: makeFlags is set of makeFlag;

const type: ruleType is new struct
    var string: name is "";
    var array string: dependencies is 0 times "";
    var array string: commands is 0 times "";
    var boolean: commandsDone is FALSE;
  end struct;

const type: rule_hash is hash [string] ruleType;
const type: string_hash is hash [string] string;

const type: makeDataType is new struct
    var file: makefile is STD_NULL;
    var rule_hash: rules is rule_hash.value;
    var rule_hash: patternRules is rule_hash.value;
    var string_hash: macros is string_hash.value;
    var string: nameOfFirstRule is "";
    var boolean: executeCommands is TRUE;
    var boolean: inSilentMode is FALSE;
    var boolean: doIgnoreErrors is FALSE;
  end struct;


const func boolean: wildcard_match (in string: main_stri, in string: pattern) is func
  result
    var boolean: result is FALSE;
  local
    var integer: main_length is 0;
    var integer: main_index is 1;
    var string: pattern_tail is "";
  begin
    if pattern = "" then
      result := main_stri = "";
    else
      case pattern[1] of
        when {'*'}:
          if pattern = "*" then
            result := TRUE;
          else
            main_length := length(main_stri);
            pattern_tail := pattern[2 .. ];
            while main_index <= main_length and not result do
              result := wildcard_match(main_stri[main_index .. ], pattern_tail);
              incr(main_index);
            end while;
          end if;
        when {'?'}:
          if main_stri <> "" then
            result := wildcard_match(main_stri[2 .. ], pattern[2 .. ]);
          end if;
        otherwise:
          if main_stri <> "" and main_stri[1] = pattern[1] then
            result := wildcard_match(main_stri[2 .. ], pattern[2 .. ]);
          end if;
      end case;
    end if;
  end func;


const func array string: findMatchingFiles (in string: pattern) is func
  result
    var array string: result is 0 times "";
  local
    var integer: slashPos is 0;
    var string: path is "";
    var array string: dirContent is 0 times "";
    var string: filePattern is "";
    var string: fileName is "";
  begin
    slashPos := rpos(pattern, '/');
    if slashPos <> 0 then
      path := pattern[.. pred(slashPos)];
      filePattern := pattern[succ(slashPos) ..];
      dirContent := readDir(path);
      path &:= "/";
    else
      filePattern := pattern;
      dirContent := readDir(".");
    end if;
    for fileName range dirContent do
      if wildcard_match(fileName, filePattern) then
        result &:= [] (path & fileName);
      end if;
    end for;
  end func;


const func string: getCommandParameter (inout string: stri) is func
  result
    var string: symbol is "";
  local
    var integer: leng is 0;
    var integer: pos is 1;
  begin
    leng := length(stri);
    if pos <= leng then
      incr(pos);
      while pos <= leng and stri[pos] in parameter_char do
        incr(pos);
      end while;
      symbol := stri[.. pred(pos)];
      stri := stri[pos ..];
    end if;
  end func;


const func string: getTargetName (inout file: makefile) is func
  result
    var string: symbol is "";
  begin
    symbol := str(makefile.bufferChar);
    makefile.bufferChar := getc(makefile);
    while makefile.bufferChar in target_name_char do
      symbol &:= makefile.bufferChar;
      makefile.bufferChar := getc(makefile);
    end while;
  end func;


const func string: getTargetName (inout string: stri) is func
  result
    var string: symbol is "";
  local
    var integer: leng is 0;
    var integer: pos is 1;
  begin
    leng := length(stri);
    if pos <= leng then
      incr(pos);
      while pos <= leng and stri[pos] in target_name_char do
        incr(pos);
      end while;
      symbol := stri[.. pred(pos)];
      stri := stri[pos ..];
    end if;
  end func;


const func string: getDependencyName (inout string: stri) is func
  result
    var string: symbol is "";
  local
    var integer: leng is 0;
    var integer: pos is 1;
  begin
    leng := length(stri);
    if pos <= leng then
      incr(pos);
      while pos <= leng and stri[pos] in dependency_name_char do
        incr(pos);
      end while;
      symbol := stri[.. pred(pos)];
      stri := stri[pos ..];
    end if;
  end func;


const func string: getMacroName (inout file: makefile) is func
  result
    var string: symbol is "";
  begin
    symbol := str(makefile.bufferChar);
    makefile.bufferChar := getc(makefile);
    while makefile.bufferChar in macro_name_char do
      symbol &:= makefile.bufferChar;
      makefile.bufferChar := getc(makefile);
    end while;
  end func;


(**
 *  Read a parameter for a dos command from a 'string'.
 *  When the function is called it is assumed that stri[1] contains
 *  the first character of the parameter. When the function is left
 *  'stri' is empty or stri[1] contains the character after the parameter.
 *  @return the next parameter for a dos command.
 *)
const func string: getDosCommandParameter (inout string: stri, in set of char: allowed) is func
  result
    var string: symbol is "";
  local
    var integer: sourcePos is 1;
  begin
    repeat
      # writeln("source char: " <& stri[sourcePos]);
      if stri[sourcePos] = '"' then
        # Inside quotation mode
        repeat
          symbol &:= stri[sourcePos];
          incr(sourcePos);
        until sourcePos > length(stri) or stri[sourcePos] = '"';
        if sourcePos <= length(stri) then
          # Consume the terminating quotation mark
          symbol &:= '"';
          incr(sourcePos);
        end if;
      else
        # Outside quotation mode
        repeat
          if stri[sourcePos] = '^' then
            incr(sourcePos);
            if sourcePos <= length(stri) then
              symbol &:= stri[sourcePos];
            end if;
          else
            symbol &:= stri[sourcePos];
          end if;
          incr(sourcePos);
        until sourcePos > length(stri) or stri[sourcePos] not in allowed or stri[sourcePos] = '"';
      end if;
    until sourcePos > length(stri) or stri[sourcePos] not in allowed;
    stri := stri[sourcePos ..];
  end func;


(**
 *  Reads the text of a quoted unix string literal from a 'string'.
 *  When the function is called it is assumed that stri[1] contains
 *  the introducing " . When the function is left 'stri' is empty or
 *  stri[1] contains the character after the closing " .
 *  @return the text of the string literal without introducing or
 *          closing " .
 *)
const func string: getUnixString (inout string: stri) is func
  result
    var string: symbol is "";
  local
    var integer: leng is 0;
    var integer: startPos is 2;
    var integer: pos is 2;
    var boolean: reading_string is TRUE;
  begin
    leng := length(stri);
    repeat
      startPos := pos;
      while pos <= leng and stri[pos] in no_escape_char do
        incr(pos);
      end while;
      symbol &:= stri[startPos .. pred(pos)];
      if pos > leng or stri[pos] = '\n' or stri[pos] = '\r' then
        reading_string := FALSE;
      elsif stri[pos] = '\"' then
        incr(pos);
        if pos <= leng and stri[pos] = '\"' then
          incr(pos);
        else
          reading_string := FALSE;
        end if;
      elsif stri[pos] = '\\' then
        incr(pos);
        if pos <= leng and stri[pos] = '\\' or stri[pos] = '"' then
          symbol &:= str(stri[pos]);
          incr(pos);
        else
          symbol &:= "\\";
        end if;
      else
        repeat
          symbol &:= str(stri[pos]);
          incr(pos);
        until pos > leng or stri[pos] >= ' ' and stri[pos] <= '~';
      end if;
    until not reading_string;
    stri := stri[pos ..];
  end func;


const func string: applyMacros (in string_hash: macros, in string: stri, in boolean: leaveUndefMacros) is func
  result
    var string: result is "";
  local
    var integer: dollarPos is 0;
    var integer: closeParenPos is 0;
    var string: name is "";
  begin
    result := stri;
    dollarPos := pos(result, '$');
    while dollarPos <> 0 do
      if dollarPos < length(result) then
        if result[succ(dollarPos)] in {'(', '{'} then
          if result[succ(dollarPos)] = '(' then
            closeParenPos := pos(result, ')', dollarPos + 2);
          else
            closeParenPos := pos(result, '}', dollarPos + 2);
          end if;
          if closeParenPos <> 0 then
            name := result[dollarPos + 2 .. pred(closeParenPos)];
            if name in macros then
              result := result[.. pred(dollarPos)] &
                  applyMacros(macros, macros[name], leaveUndefMacros) & result[succ(closeParenPos) ..];
            elsif not leaveUndefMacros then
              result := result[.. pred(dollarPos)] & result[succ(closeParenPos) ..];
            end if;
          end if;
        elsif result[succ(dollarPos)] = '$' then
          incr(dollarPos);
        end if;
      end if;
      dollarPos := pos(result, '$', succ(dollarPos));
    end while;
  end func;


const func string: getMacro (inout file: makefile, in string_hash: macros) is func
  result
    var string: result is "";
  local
    var string: name is "";
    var array string: matches is 0 times "";
  begin
    makefile.bufferChar := getc(makefile);
    if makefile.bufferChar = '(' then
      makefile.bufferChar := getc(makefile);
      name := getMacroName(makefile);
      if makefile.bufferChar = ')' then
        makefile.bufferChar := getc(makefile);
        if name in macros then
          result := macros[name];
        else
          result := "$(" & name & ")";
        end if;
      elsif makefile.bufferChar in space_or_tab then
        skipSpaceOrTab(makefile);
        if name = "wildcard" then
          matches := findMatchingFiles(getMacroName(makefile));
          if length(matches) <> 0 then
            result := join(matches, ' ');
          end if;
        elsif name = "strip" then
          result := trim(getMacroName(makefile));
        end if;
      end if;
    else
      result := "$";
    end if;
  end func;


const func string: getLineWithMacrosApplied (inout makeDataType: makeData) is func
  result
    var string: data is "";
  local
    var file: makefile is STD_NULL;
  begin
    makefile := makeData.makefile;
    data := "";
    while makefile.bufferChar <> '\n' and makefile.bufferChar <> EOF do
      if makefile.bufferChar = '\r' then
        makefile.bufferChar := getc(makefile);
        if makefile.bufferChar <> '\n' then
          data &:= '\r';
        end if;
      elsif makefile.bufferChar = '\\' then
        makefile.bufferChar := getc(makefile);
        if makefile.bufferChar = '\r' then
          makefile.bufferChar := getc(makefile);
          if makefile.bufferChar = '\n' then
            makefile.bufferChar := getc(makefile);
          else
            data &:= "\\\r";
          end if;
        elsif makefile.bufferChar = '\n' then
          makefile.bufferChar := getc(makefile);
        else
          data &:= '\\';
        end if;
      elsif makefile.bufferChar = '$' then
        data &:= getMacro(makefile, makeData.macros);
      else
        data &:= makefile.bufferChar;
        makefile.bufferChar := getc(makefile);
      end if;
    end while;
  end func;


const func string: getExpression (inout file: makefile, in string_hash: macros) is func
  result
    var string: exprResult is "";
  begin
    skipSpaceOrTab(makefile);
    if makefile.bufferChar = '$' then
      exprResult := getMacro(makefile, macros);
    else
      exprResult := getName(makefile);
    end if;
  end func;


const proc: find_endif (inout file: makefile) is func
  local
    var string: command is "";
  begin
    repeat
      skipLine(makefile);
      makefile.bufferChar := getc(makefile);
      command := getTargetName(makefile);
      if command = "ifeq" or command = "ifneq" then
        find_endif(makefile);
        command := getTargetName(makefile);
      end if;
    until command = "endif";
    skipLine(makefile);
    makefile.bufferChar := getc(makefile);
  end func;


const proc: execIfeq (inout file: makefile, in string_hash: macros, in boolean: equal) is func
  local
    var string: value1 is "";
    var string: value2 is "";
    var boolean: cond is FALSE;
    var string: command is "";
  begin
    skipSpaceOrTab(makefile);
    if makefile.bufferChar = '(' then
      makefile.bufferChar := getc(makefile);
      value1 := getExpression(makefile, macros);
      # writeln("value1=" <& literal(value1));
      skipSpaceOrTab(makefile);
      if makefile.bufferChar = ',' then
        makefile.bufferChar := getc(makefile);
        value2 := getExpression(makefile, macros);
        # writeln("value2=" <& literal(value2));
        skipSpaceOrTab(makefile);
        if (value1 = value2) <> equal then
          repeat
            skipLine(makefile);
            makefile.bufferChar := getc(makefile);
            command := getTargetName(makefile);
            if command = "ifeq" or command = "ifneq" then
              find_endif(makefile);
              command := getTargetName(makefile);
            end if;
          until command = "endif" or command = "else";
        end if;
        skipLine(makefile);
        makefile.bufferChar := getc(makefile);
      end if;
    end if;
  end func;


const proc: readRule (inout makeDataType: makeData, in string: name) is func
  local
    var file: makefile is STD_NULL;
    var string: dependencies is "";
    var string: dependency is "";
    var string: command is "";
    var ruleType: rule is ruleType.value;
  begin
    makefile := makeData.makefile;
    rule.name := name;
    skipSpaceOrTab(makefile);
    dependencies := getLineWithMacrosApplied(makeData);
    # write(name <& ":");
    while dependencies <> "" do
      dependency := getDependencyName(dependencies);
      rule.dependencies &:= [] (dependency);
      skipSpaceOrTab(dependencies);
      # write(" " <& dependency);
    end while;
    # writeln;
    makefile.bufferChar := getc(makefile);
    while makefile.bufferChar = '\t' or makefile.bufferChar = ' ' or
        makefile.bufferChar = '\r' or makefile.bufferChar = '\n' do
      skipSpaceOrTab(makefile);
      if makefile.bufferChar = '\r' then
        makefile.bufferChar := getc(makefile);
      end if;
      if makefile.bufferChar = '\n' then
        makefile.bufferChar := getc(makefile);
      else
        command := getLineWithMacrosApplied(makeData);
        rule.commands &:= [] (command);
        makefile.bufferChar := getc(makefile);
        # writeln("\t" <& command);
      end if;
    end while;
    if length(makeData.rules) = 0 then
      makeData.nameOfFirstRule := name;
    end if;
    if pos(name, '%') <> 0 then
      if name not in makeData.patternRules then
        makeData.patternRules @:= [name] rule;
      end if;
    elsif name in makeData.rules then
      if rule.commands = 0 times "" then
        makeData.rules[name].dependencies &:= rule.dependencies;
      else
        writeln(" *** Rule " <& name <& " redefined");
      end if;
    else
      makeData.rules @:= [name] rule;
    end if;
  end func;


const proc: readMakefile (inout makeDataType: makeData, in string: fileName) is func
  local
    var file: makefile is STD_NULL;
    var string: name is "";
    var array file: surroundingFiles is 0 times STD_NULL;
    var array string: alternateTargets is 0 times "";
    var string: data is "";
  begin
    makefile := open(fileName, "r");
    if makefile = STD_NULL then
      writeln(" *** Makefile " <& fileName <& " not found.");
    else
      makeData.makefile := makefile;
      makefile.bufferChar := getc(makefile);
      while makefile.bufferChar <> EOF do
        skipWhiteSpace(makefile);
        # writeln(literal(makefile.bufferChar));
        if makefile.bufferChar = '#' then
          skipLineComment(makefile);
          makefile.bufferChar := getc(makefile);
        elsif makefile.bufferChar = '!' then
          # nmake commands like if, include, endif, ...
          # currently ignored
          skipLineComment(makefile);
          makefile.bufferChar := getc(makefile);
        elsif makefile.bufferChar in target_name_char then
          name := getTargetName(makefile);
          # writeln(name);
          if name = "ifeq" then
            execIfeq(makefile, makeData.macros, TRUE);
          elsif name = "ifneq" then
            execIfeq(makefile, makeData.macros, FALSE);
          elsif name = "else" then
            find_endif(makefile);
          elsif name = "endif" then
            skipLine(makefile);
            makefile.bufferChar := getc(makefile);
          elsif name = "include" or name = "-include" then
            skipSpace(makefile);
            name := getTargetName(makefile);
            # writeln("include " <& name);
            skipLine(makefile);
            makefile.bufferChar := getc(makefile);
            if fileType(name) = FILE_REGULAR then
              surroundingFiles := [] (makefile) & surroundingFiles;
              makefile := open(name, "r");
              if makefile <> STD_NULL then
                makeData.makefile := makefile;
                makefile.bufferChar := getc(makefile);
              else
                makefile := surroundingFiles[1];
                surroundingFiles := surroundingFiles[2 ..];
              end if;
            end if;
          elsif name = ".SILENT" then
            makeData.inSilentMode := TRUE;
            skipLine(makefile);
            makefile.bufferChar := getc(makefile);
          else
            skipSpace(makefile);
            if makefile.bufferChar = '=' then
              makefile.bufferChar := getc(makefile);
              skipSpace(makefile);
              data := getLineWithMacrosApplied(makeData);
              makeData.macros @:= [name] data;
              # writeln(name <& " = " <& data);
              makefile.bufferChar := getc(makefile);
            elsif makefile.bufferChar = '+' then
              makefile.bufferChar := getc(makefile);
              if makefile.bufferChar = '=' then
                makefile.bufferChar := getc(makefile);
                skipSpace(makefile);
                data := getLineWithMacrosApplied(makeData);
                if name in makeData.macros then
                  makeData.macros @:= [name] makeData.macros[name] & data;
                else
                  makeData.macros @:= [name] data;
                end if;
                # writeln(name <& " = " <& data);
                makefile.bufferChar := getc(makefile);
              end if;
            elsif makefile.bufferChar = ':' then
              makefile.bufferChar := getc(makefile);
              if makefile.bufferChar = '=' then
                makefile.bufferChar := getc(makefile);
                skipSpace(makefile);
                data := getLineWithMacrosApplied(makeData);
                makeData.macros @:= [name] data;
                # writeln(name <& " := " <& data);
                makefile.bufferChar := getc(makefile);
              else
                name := applyMacros(makeData.macros, name, TRUE);
                readRule(makeData, name);
              end if;
            else
              name := applyMacros(makeData.macros, name, TRUE);
              alternateTargets := 0 times "";
              while makefile.bufferChar in target_name_char do
                alternateTargets &:= getTargetName(makefile);
                skipSpace(makefile);
              end while;
              if makefile.bufferChar = ':' then
                makefile.bufferChar := getc(makefile);
                readRule(makeData, name);
              else
                writeln(" *** Illegal character " <& literal(makefile.bufferChar) <& ", ignored");
                makefile.bufferChar := getc(makefile);
              end if;
            end if;
          end if;
        elsif makefile.bufferChar <> EOF then
          writeln(" *** Illegal character " <& literal(makefile.bufferChar) <& ", ignored");
          makefile.bufferChar := getc(makefile);
        end if;
        if makefile.bufferChar = EOF and length(surroundingFiles) <> 0 then
          close(makefile);
          makefile := surroundingFiles[1];
          makeData.makefile := makefile;
          surroundingFiles := surroundingFiles[2 ..];
        end if;
      end while;
      close(makefile);
    end if;
  end func;


const func boolean: doOneCommand (inout string: command,
    inout string: commandOutput, in boolean: doLog) is forward;


const func string: execBacktickCommands (in string: stri) is func
  result
    var string: result is "";
  local
    var integer: backtickPos is 0;
    var integer: closingBacktickPos is 0;
    var string: command is "";
    var file: commandFile is STD_NULL;
    var string: commandOutput is "";
  begin
    result := stri;
    backtickPos := pos(result, '`');
    while backtickPos <> 0 do
      closingBacktickPos := pos(result, '`', succ(backtickPos));
      if closingBacktickPos <> 0 then
        command := result[succ(backtickPos) .. pred(closingBacktickPos)];
        if not doOneCommand(command, commandOutput, FALSE) then
          commandFile := popen(command, "r");
          if commandFile <> STD_NULL then
            commandOutput := gets(commandFile, 999999999);
            while endsWith(commandOutput, "\r\n") do
              commandOutput := commandOutput[.. length(commandOutput) - 2];
            end while;
            while endsWith(commandOutput, "\n") do
              commandOutput := commandOutput[.. pred(length(commandOutput))];
            end while;
          else
            commandOutput := "";
          end if;
        end if;
        result := result[.. pred(backtickPos)] & commandOutput & result[succ(closingBacktickPos) ..];
      end if;
      backtickPos := pos(result, '`', succ(backtickPos));
    end while;
  end func;


const proc: doRm (in string: commandName, inout string: command, in boolean: doLog) is func
  local
    var string: parameter is "";
    var boolean: force is FALSE;
    var string: fileName is "";
  begin
    if doLog then
      write(commandName);
    end if;
    skipWhiteSpace(command);
    while command <> "" do
      parameter := getCommandParameter(command);
      if doLog then
        write(" " <& parameter);
      end if;
      if parameter = "-f" then
        force := TRUE;
      else
        parameter := convDosPath(parameter);
        if pos(parameter, "*") <> 0 or pos(parameter, "?") <> 0 then
          for fileName range findMatchingFiles(parameter) do
            removeFile(fileName);
          end for;
        else
          if fileType(parameter) <> FILE_ABSENT then
            removeFile(parameter);
          end if;
        end if;
      end if;
      skipWhiteSpace(command);
    end while;
  end func;


const proc: doCp (inout string: command, in boolean: cpCommand, in boolean: doLog) is func
  local
    var string: parameter is "";
    var boolean: overwriteExisting is FALSE;
    var string: fileName is "";
    var array string: fileList is 0 times "";
    var string: destination is "";
    var string: destFileName is "";
    var integer: slashPos is 0;
  begin
    if doLog then
      write([]("copy", "cp")[ord(cpCommand)]);
    end if;
    overwriteExisting := cpCommand;
    skipWhiteSpace(command);
    while command <> "" do
      parameter := getCommandParameter(command);
      if doLog then
        write(" " <& parameter);
      end if;
      if parameter = "/Y" then
        overwriteExisting := TRUE;
      elsif parameter = "-n" then
        overwriteExisting := FALSE;
      else
        parameter := convDosPath(parameter);
        if pos(parameter, "*") <> 0 or pos(parameter, "?") <> 0 then
          for fileName range findMatchingFiles(parameter) do
            fileList &:= [] (fileName);
          end for;
        else
          fileList &:= [] (parameter);
        end if;
      end if;
      skipWhiteSpace(command);
    end while;
    if length(fileList) >= 2 then
      destination := fileList[length(fileList)];
      fileList := fileList[.. pred(length(fileList))];
      if fileType(destination) = FILE_DIR then
        for fileName range fileList do
          if fileType(fileName) = FILE_REGULAR or fileType(fileName) = FILE_DIR then
            slashPos := rpos(fileName, "/");
            if slashPos = 0 then
              destFileName := destination & "/" & fileName;
            else
              destFileName := destination & "/" & fileName[succ(slashPos) ..];
            end if;
            if fileType(destFileName) = FILE_REGULAR and overwriteExisting then
              block
                removeFile(destFileName);
              exception
                catch FILE_ERROR:
                  writeln(" *** Cannot remove " <& destFileName);
              end block;
            end if;
            if fileType(destFileName) = FILE_ABSENT then
              # write("copyFile " <& fileName <& " " <& destination);
              copyFile(fileName, destFileName);
            end if;
          end if;
        end for;
      elsif length(fileList) = 1 then
        fileName := fileList[1];
        if fileType(fileName) = FILE_REGULAR or fileType(fileName) = FILE_DIR then
          if fileType(destination) = FILE_REGULAR and overwriteExisting then
            block
              removeFile(destination);
            exception
              catch FILE_ERROR:
                writeln(" *** Cannot remove " <& destFileName);
            end block;
          end if;
          if fileType(destination) = FILE_ABSENT then
            # write("copyFile " <& fileName <& " " <& destination);
            copyFile(fileName, destination);
          end if;
        end if;
      end if;
    end if;
  end func;


const func string: doPwd (inout string: command, in boolean: doLog) is func
  result
    var string: result is "";
  begin
    if doLog then
      write("pwd");
    end if;
    skipWhiteSpace(command);
    if startsWith(command, "-W") then
      if doLog then
        write(" -W");
      end if;
      command := command[3 ..];
      skipWhiteSpace(command);
    end if;
    result := getcwd;
  end func;


const func string: doEcho (inout string: command, in boolean: doLog) is func
  result
    var string: result is "";
  local
    var string: whiteSpace is "";
    var string: parameter is "";
  begin
    whiteSpace := getWhiteSpace(command);
    if command <> "" and command[1] = '"' then
      while command <> "" and command[1] in parameter_char do
        if result <> "" then
          result &:= whiteSpace;
        end if;
        parameter := getUnixString(command);
        result &:= execBacktickCommands(parameter);
        whiteSpace := getWhiteSpace(command);
      end while;
    else
      while command <> "" and command[1] in parameter_char do
        result &:= getDosCommandParameter(command, dos_parameter_char);
        result &:= getWhiteSpace(command);
      end while;
    end if;
    if doLog then
      write("echo " <& result);
    end if;
  end func;


const proc: doCd (inout string: command, in boolean: doLog) is func
  local
    var string: parameter is "";
  begin
    skipWhiteSpace(command);
    if command <> "" then
      parameter := getCommandParameter(command);
      if doLog then
        write("cd " <& parameter);
      end if;
      parameter := convDosPath(parameter);
      if fileType(parameter) = FILE_DIR then
        chdir(parameter);
      else
        writeln(" *** cd " <& parameter <& " - No such file or directory");
        # writeln(getcwd);
        # writeln(fileType(parameter));
      end if;
    end if;
  end func;


const proc: make (in string: makefile, in string: target, in makeFlags: flags) is forward;


const proc: doMake (inout string: command, in boolean: doLog) is func
  local
    var string: parameter is "";
    var string: makefile is "";
    var string: target is "";
    var makeFlags: flags is makeFlags.value;
    var string: savedCurrentDir is "";
  begin
    skipWhiteSpace(command);
    if doLog then
      write("make");
    end if;
    while command <> "" do
      parameter := getCommandParameter(command);
      if doLog then
        write(" " <& parameter);
      end if;
      if length(parameter) >= 2 and parameter[1] = '-' then
        if parameter = "-f" then
          skipWhiteSpace(command);
          makefile := getCommandParameter(command);
          if doLog then
            write(" " <& makefile);
          end if;
        elsif parameter = "-i" then
          incl(flags, ignoreErrors);
        elsif parameter = "-n" then
          incl(flags, dontExecute);
        elsif parameter = "-s" then
          incl(flags, silentMode);
        end if;
      elsif target = "" then
        target := parameter;
      end if;
      skipWhiteSpace(command);
    end while;
    if doLog then
      writeln;
    end if;
    if makefile = "" then
      if fileType("makefile") = FILE_REGULAR then
        makefile := "makefile";
      elsif fileType("Makefile") = FILE_REGULAR then
        makefile := "Makefile";
      end if;
    end if;
    savedCurrentDir := getcwd;
    make(makefile, target, flags);
    chdir(savedCurrentDir);
  end func;


const func boolean: doOneCommand (inout string: command,
    inout string: commandOutput, in boolean: doLog) is func
  result
    var boolean: result is TRUE;
  local
    var string: commandName is "";
  begin
    if command <> "" and command[1] = '#' then
      command := "";
      commandOutput := "";
    else
      commandName := lower(getWord(command));
      # writeln("doOneCommand: " <& commandName);
      if commandName = "rm" or commandName = "del" then
        doRm(commandName, command, doLog);
        commandOutput := "";
      elsif commandName = "cp" then
        doCp(command, TRUE, doLog);
        commandOutput := "";
      elsif commandName = "copy" then
        doCp(command, FALSE, doLog);
        commandOutput := "";
      elsif commandName = "pwd" then
        commandOutput := doPwd(command, doLog);
      elsif commandName = "echo" then
        commandOutput := doEcho(command, doLog);
      elsif commandName = "cd" then
        doCd(command, doLog);
        commandOutput := "";
      elsif commandName = "make" or commandName = "make7" then
        doMake(command, doLog);
        commandOutput := "";
      else
        result := FALSE;
        commandOutput := "";
      end if;
    end if;
  end func;


const proc: appendToFile (in string: file_name, in string: stri) is func
  local
    var file: work_file is STD_NULL;
  begin
    if stri <> "" then
      work_file := open(file_name, "a");
      if work_file <> STD_NULL then
        write(work_file, stri);
        close(work_file);
      end if;
    end if;
  end func;


const func boolean: doCommands (inout string: command, in boolean: doLog) is func
  result
    var boolean: result is TRUE;
  local
    var integer: quotePos is 0;
    var string: commandOutput is "";
    var string: redirect is "";
    var string: fileName is "";
  begin
    if startsWith(command, "\"") then
      quotePos := rpos(command, "\"");
      if quotePos <> 0 and quotePos <> 1 then
        command := command[2 .. pred(quotePos)] & command[succ(quotePos) ..];
      end if;
    end if;
    repeat
      result := doOneCommand(command, commandOutput, doLog);
      if result then
        skipWhiteSpace(command);
        redirect := getWord(command);
        if redirect = ">" then
          skipWhiteSpace(command);
          fileName := getCommandParameter(command);
          if doLog then
            writeln(" > " <& fileName);
          end if;
          if fileName <> "/dev/null" and fileName <> "NUL:" and fileName <> "NUL" then
            fileName := convDosPath(fileName);
            putf(fileName, commandOutput & "\n");
          end if;
        elsif redirect = ">>" then
          skipWhiteSpace(command);
          fileName := getCommandParameter(command);
          if doLog then
            writeln(" >> " <& fileName);
          end if;
          if fileName <> "/dev/null" and fileName <> "NUL:" and fileName <> "NUL" then
            fileName := convDosPath(fileName);
            appendToFile(fileName, commandOutput & "\n");
          end if;
        elsif commandOutput <> "" then
          writeln(commandOutput);
        end if;
        skipWhiteSpace(command);
        if command <> "" and command[1] = ';' then
          command := command[2 ..];
          skipWhiteSpace(command);
        end if;
      end if;
    until command = "" or not result;
  end func;


const func integer: processCommand (in makeDataType: makeData, in var string: command,
    in boolean: doLog) is func
  result
    var integer: commandStatus is 0;
  local
    var string: fullCommand is "";
    var integer: gtPos is 0;
    var boolean: doRedirect is FALSE;
    var boolean: doAppend is FALSE;
    var string: fileName is "";
    var file: aFile is STD_NULL;
    var string: commandOutput is "";
  begin
    # writeln("process command: " <& command);
    command := applyMacros(makeData.macros, command, FALSE);
    # writeln("macros applied: " <& command);
    fullCommand := command;
    if not doCommands(command, doLog) then
      gtPos := rpos(fullCommand, ">");
      if gtPos >= 2 then
        fileName := fullCommand[succ(gtPos) ..];
        skipSpace(fileName);
        if fullCommand[pred(gtPos)] = '>' and gtPos >= 3 and
            fullCommand[gtPos - 2] not in {'\\', '^'} then
          doAppend := TRUE;
          fullCommand := fullCommand[.. gtPos - 2];
        elsif fullCommand[pred(gtPos)] not in {'\\', '^', '2'} then
          doRedirect := TRUE;
          fullCommand := fullCommand[.. pred(gtPos)];
        end if;
      end if;
      if doRedirect or doAppend then
        if doLog then
          write(fullCommand);
          if doAppend then
            write(">");
          end if;
          writeln("> " & fileName);
        end if;
        command := getWord(fullCommand);
        fullCommand := convDosPath(command) & fullCommand;
        aFile := popen(fullCommand, "r");
        if aFile <> STD_NULL then
          commandOutput := gets(aFile, 999999999);
          close(aFile);
          if fileName <> "/dev/null" and fileName <> "NUL:" and fileName <> "NUL" then
            if doAppend then
              appendToFile(fileName, commandOutput);
            else
              putf(fileName, commandOutput);
            end if;
          end if;
        end if;
      else
        if doLog then
          writeln(fullCommand);
          flush(STD_OUT);
        end if;
        command := getWord(fullCommand);
        commandStatus := shell(convDosPath(command), fullCommand);
      end if;
    end if;
  end func;


const func string: applyInternalMacros (in ruleType: rule, in string: stri) is func
  result
    var string: result is "";
  local
    var integer: dollarPos is 0;
    var integer: closeParenPos is 0;
    var string: dependency is "";
    var set of string: dependencySet is (set of string).value;
    var array string: strictDependencies is 0 times "";
  begin
    for dependency range rule.dependencies do
      if dependency not in dependencySet then
        strictDependencies &:= dependency;
        incl(dependencySet, dependency);
      end if;
    end for;
    result := stri;
    dollarPos := pos(result, '$');
    while dollarPos <> 0 do
      if dollarPos < length(result) then
        if result[succ(dollarPos)] = '@' then
          result := result[.. pred(dollarPos)] & rule.name & result[dollarPos + 2 ..];
        elsif result[succ(dollarPos)] = '<' then
          if length(rule.dependencies) <> 0 then
            result := result[.. pred(dollarPos)] & rule.dependencies[1] & result[dollarPos + 2 ..];
          end if;
        elsif result[succ(dollarPos)] = '?' then
          result := result[.. pred(dollarPos)] & join(strictDependencies, " ") & result[dollarPos + 2 ..];
        elsif result[succ(dollarPos)] = '^' then
          result := result[.. pred(dollarPos)] & join(strictDependencies, " ") & result[dollarPos + 2 ..];
        elsif result[succ(dollarPos)] = '+' then
          result := result[.. pred(dollarPos)] & join(rule.dependencies, " ") & result[dollarPos + 2 ..];
        elsif result[succ(dollarPos)] = '$' then
          result := result[.. pred(dollarPos)] & result[succ(dollarPos) ..];
        end if;
      end if;
      dollarPos := pos(result, '$', succ(dollarPos));
    end while;
  end func;


const proc: processCommands (in makeDataType: makeData, inout ruleType: rule) is func
  local
    var string: command is "";
    var integer: commandStatus is 0;
    var boolean: printCommand is TRUE;
    var boolean: ignoreError is FALSE;
  begin
    for command range rule.commands do
      command := applyInternalMacros(rule, command);
      if startsWith(command, "@-") or startsWith(command, "-@")then
        printCommand := FALSE;
        ignoreError := TRUE;
        command := command[3 ..];
      elsif startsWith(command, "@") then
        printCommand := FALSE;
        command := command[2 ..];
      elsif startsWith(command, "-") then
        ignoreError := TRUE;
        command := command[2 ..];
      end if;
      if printCommand and not makeData.inSilentMode then
        writeln(applyMacros(makeData.macros, command, TRUE));
        flush(STD_OUT);
      end if;
      if makeData.executeCommands then
        commandStatus := processCommand(makeData, command, FALSE);
        if commandStatus <> 0 and not makeData.doIgnoreErrors then
          writeln(" *** [" <& rule.name <& "] Error " <& commandStatus);
          exit(PROGRAM);
        end if;
      end if;
    end for;
    rule.commandsDone := TRUE;
  end func;


const func string: pattern_match (in string: main_stri, in string: pattern) is func
  result
    var string: stem is "";
  local
    var integer: percentPos is 0;
    var integer: main_index is 2;
    var string: pattern_tail is "";
  begin
    percentPos := pos(pattern, '%');
    if percentPos = rpos(pattern, '%') then
      if  startsWith(main_stri, pattern[.. pred(percentPos)]) and
          endsWith(main_stri, pattern[succ(percentPos) ..]) then
        stem := main_stri[percentPos .. length(main_stri) - length(pattern) + percentPos];
      end if;
    end if;
  end func;


const proc: processRule (inout makeDataType: makeData, in string: targetName) is forward;


const proc: processRule (inout makeDataType: makeData, inout ruleType: rule) is func
  local
    var string: dependency is "";
    var string: dependencyFile is "";
    var string: ruleFile is "";
    var time: targetTime is time.value;
    var boolean: commandsNecessary is FALSE;
  begin
    for dependency range rule.dependencies do
      processRule(makeData, dependency);
    end for;
    if makeData.executeCommands or not rule.commandsDone then
      ruleFile := convDosPath(rule.name);
      if fileType(ruleFile) = FILE_ABSENT then
        processCommands(makeData, rule);
      else
        targetTime := getMTime(ruleFile);
        for dependency range rule.dependencies do
          dependencyFile := convDosPath(applyMacros(makeData.macros, dependency, FALSE));
          if dependencyFile <> "" then
            if not makeData.executeCommands then
              commandsNecessary := TRUE;
            elsif fileType(dependencyFile) = FILE_ABSENT then
              writeln(" *** File " <& dependencyFile <& " missing");
            elsif getMTime(dependencyFile) > targetTime then
              commandsNecessary := TRUE;
            end if;
          end if;
        end for;
        if commandsNecessary then
          processCommands(makeData, rule);
        end if;
      end if;
    end if;
  end func;


const proc: processPatternRule (inout makeDataType: makeData, in string: targetName,
    inout ruleType: dependencyRule) is func
  local
    var string: ruleName is "";
    var boolean: finished is FALSE;
    var string: stem is "";
    var ruleType: patternRule is ruleType.value;
    var ruleType: actualRule is ruleType.value;
    var string: dependency is "";
  begin
    for key ruleName range makeData.patternRules do
      if not finished then
        stem := pattern_match(targetName, ruleName);
        if stem <> "" then
          patternRule := makeData.patternRules[ruleName];
          actualRule.name := targetName;
          for dependency range patternRule.dependencies do
            actualRule.dependencies &:= replace(dependency, "%", stem);
          end for;
          for dependency range dependencyRule.dependencies do
            actualRule.dependencies &:= dependency;
          end for;
          actualRule.commands := patternRule.commands;
          processRule(makeData, actualRule);
          finished := TRUE;
        end if;
      end if;
    end for;
    if not finished then
      processRule(makeData, dependencyRule);
    end if;
  end func;


const proc: processRule (inout makeDataType: makeData, in string: targetName) is func
  local
    var string: ruleName is "";
    var ruleType: emptyRule is ruleType.value;
  begin
    ruleName := applyMacros(makeData.macros, targetName, FALSE);
    if ruleName <> "" then
      # writeln("process rule: " <& ruleName);
      if ruleName in makeData.rules then
        if length(makeData.rules[ruleName].commands) <> 0 then
          processRule(makeData, makeData.rules[ruleName]);
        else
          processPatternRule(makeData, ruleName, makeData.rules[ruleName]);
        end if;
      else
        processPatternRule(makeData, ruleName, emptyRule);
      end if;
    end if;
  end func;


const proc: make (in string: makefile, in string: target, in makeFlags: flags) is func
  local
    var ruleType: rule is ruleType.value;
    var makeDataType: makeData is makeDataType.value;
  begin
    # writeln("make -f " <& makefile <& " " <& target);
    makeData.executeCommands := dontExecute not in flags;
    makeData.inSilentMode := silentMode in flags;
    makeData.doIgnoreErrors := ignoreErrors in flags;
    makeData.macros @:= ["CPPFLAGS"] "";
    makeData.macros @:= ["CFLAGS"] "";
    makeData.macros @:= ["CC"] "cc";
    makeData.macros @:= ["MAKE"] "make7";
    readMakefile(makeData, makefile);
    if ".c.o" in makeData.rules and "%.o" not in makeData.patternRules then
      rule.name := "%.o";
      rule.dependencies := [] ("%.c");
      rule.commands := makeData.rules[".c.o"].commands;
      makeData.patternRules @:= [rule.name] rule;
      excl(makeData.rules, ".c.o");
    elsif "%.o" not in makeData.patternRules then
      rule.name := "%.o";
      rule.dependencies := [] ("%.c");
      rule.commands := [] (applyMacros(makeData.macros, "$(CC) -c $(CPPFLAGS) $(CFLAGS) $< -o $@", TRUE));
      makeData.patternRules @:= [rule.name] rule;
    end if;
    if ".c.obj" in makeData.rules and "%.obj" not in makeData.patternRules then
      rule.name := "%.obj";
      rule.dependencies := [] ("%.c");
      rule.commands := makeData.rules[".c.obj"].commands;
      makeData.patternRules @:= [rule.name] rule;
      excl(makeData.rules, ".c.obj");
    elsif "%.obj" not in makeData.patternRules then
      rule.name := "%.obj";
      rule.dependencies := [] ("%.c");
      rule.commands := [] (applyMacros(makeData.macros, "$(CC) -c $(CPPFLAGS) $(CFLAGS) $< -o $@", TRUE));
      makeData.patternRules @:= [rule.name] rule;
    end if;
    if target = "" then
      processRule(makeData, makeData.nameOfFirstRule);
    else
      processRule(makeData, target);
    end if;
  end func;
