
(********************************************************************)
(*                                                                  *)
(*  dom.s7i       Simple dom parser                                 *)
(*  Copyright (C) 2009  Thomas Mertes                               *)
(*                                                                  *)
(*  This file is part of the Seed7 Runtime Library.                 *)
(*                                                                  *)
(*  The Seed7 Runtime Library is free software; you can             *)
(*  redistribute it and/or modify it under the terms of the GNU     *)
(*  Lesser General Public License as published by the Free Software *)
(*  Foundation; either version 2.1 of the License, or (at your      *)
(*  option) any later version.                                      *)
(*                                                                  *)
(*  The Seed7 Runtime Library is distributed in the hope that it    *)
(*  will be useful, but WITHOUT ANY WARRANTY; without even the      *)
(*  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR *)
(*  PURPOSE.  See the GNU Lesser General Public License for more    *)
(*  details.                                                        *)
(*                                                                  *)
(*  You should have received a copy of the GNU Lesser General       *)
(*  Public License along with this program; if not, write to the    *)
(*  Free Software Foundation, Inc., 51 Franklin Street,             *)
(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)
(*                                                                  *)
(********************************************************************)


const type: attrHashType is hash [string] string;

const type: xmlTag is sub object interface;

const func string: getAttrValue (in xmlTag: aTag, in string: attrName) is DYNAMIC;
const func attrHashType: getAttributes (in xmlTag: aTag)               is DYNAMIC;
const proc: writeXml (inout file: outFile, in xmlTag: aTag)            is DYNAMIC;
const varfunc string:        (in xmlTag: aTag) . name                  is DYNAMIC;
# const varfunc attrHashType: (in xmlTag: aTag) . attributes           is DYNAMIC;


const type: baseTag is new struct
    var integer: dummy is 0;
  end struct;

type_implements_interface(baseTag, xmlTag);

const proc: writeXml (inout external_file: outFile, in baseTag: aTag) is func
  begin
    writeln("baseTag");
  end func;


const baseTag: NULL_TAG is baseTag.value;
const xmlTag: (attr xmlTag) . value is NULL_TAG;


const type: singleTag is sub baseTag struct
    var string: name is "";
    var attrHashType: attributes is attrHashType.value;
  end struct;

type_implements_interface(singleTag, xmlTag);

const func singleTag: malloc (ref singleTag: aTag) is func
  result
    var singleTag: result is singleTag.value;
  begin
    result := aTag;
  end func;

const func string: getAttrValue (in singleTag: aTag, in string: attrName) is
  return aTag.attributes[attrName];

const func attrHashType: getAttributes (in singleTag: aTag) is
  return aTag.attributes;

const proc: writeXml (inout external_file: outFile, in singleTag: aTag) is func
  local
    var string: attributeName is "";
    var string: attributeValue is "";
  begin
    write(outFile, "<" <& aTag.name);
    for attributeName range sort(keys(aTag.attributes)) do
      attributeValue := aTag.attributes[attributeName];
      write(outFile, " " <& attributeName <& "=" <& literal(attributeValue));
    end for;
    writeln(outFile, "/>");
  end func;


const type: containerTag is sub singleTag struct
    var array xmlTag: subTags is 0 times NULL_TAG;
  end struct;

type_implements_interface(containerTag, xmlTag);

const func containerTag: malloc (ref containerTag: aTag) is func
  result
    var containerTag: result is containerTag.value;
  begin
    result := aTag;
  end func;

const proc: writeXml (inout external_file: outFile, in containerTag: aTag) is func
  local
    var string: attributeName is "";
    var string: attributeValue is "";
    var xmlTag: subTag is NULL_TAG;
  begin
    write(outFile, "<" <& aTag.name);
    for attributeName range sort(keys(aTag.attributes)) do
      attributeValue := aTag.attributes[attributeName];
      write(outFile, " " <& attributeName <& "=" <& literal(attributeValue));
    end for;
    writeln(outFile, ">");
    for subTag range aTag.subTags do
      # TRACE_OBJ(subTag);
      writeXml(outFile, subTag);
    end for;
    writeln(outFile, "</" <& aTag.name <& ">");
  end func;

const func xmlTag: readXmlTag (inout file: inFile, inout string: symbol) is func
  result
    var xmlTag: result is NULL_TAG;
  local
    var containerTag: currentTag is containerTag.value;
    var singleTag: currentSingleTag is singleTag.value;
    var string: attributeName is "";
    var string: attributeValue is "";
    var string: endTagHead is "";
  begin
    # write(symbol);
    if startsWith(symbol, "<") then
      currentTag.name := symbol[2 ..];
      getNextXmlAttribute(inFile, attributeName, attributeValue);
      while attributeName <> "" do
        # write(" " <& attributeName <& "=" <& literal(attributeValue));
        currentTag.attributes @:= [attributeName] attributeValue[2 ..];
        getNextXmlAttribute(inFile, attributeName, attributeValue);
      end while;
      if attributeValue = "/" then
        # writeln("/>");
        currentSingleTag.name := currentTag.name;
        currentSingleTag.attributes := currentTag.attributes;
        result := malloc(currentSingleTag);
      else
        # writeln(">");
        endTagHead := "</" & currentTag.name;
        skipWhiteSpace(inFile);
        symbol := getXmlTagHeadOrContent(inFile);
        while symbol <> "" and symbol <> endTagHead do
          currentTag.subTags &:= [] (readXmlTag(inFile, symbol));
          skipWhiteSpace(inFile);
          symbol := getXmlTagHeadOrContent(inFile);
        end while;
        if symbol = endTagHead then
          skipXmlTag(inFile);
          # writeln(symbol <& ">");
        end if;
        result := malloc(currentTag);
      end if;
    end if;
    # TRACE_OBJ(result); writeln;
  end func;

const func xmlTag: readXml (inout file: inFile) is func
  result
    var xmlTag: result is NULL_TAG;
  local
    var string: symbol is "";
  begin
    skipWhiteSpace(inFile);
    symbol := getXmlTagHeadOrContent(inFile);
    while startsWith(symbol, "<?") do
      skipXmlTag(inFile);
      skipWhiteSpace(inFile);
      symbol := getXmlTagHeadOrContent(inFile);
    end while;
    result := readXmlTag(inFile, symbol);
    # TRACE_OBJ(result); writeln;
  end func;
