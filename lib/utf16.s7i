
(********************************************************************)
(*                                                                  *)
(*  utf16.s7i     Read and write utf-16 files                       *)
(*  Copyright (C) 2009  Thomas Mertes                               *)
(*                                                                  *)
(*  This file is part of the Seed7 Runtime Library.                 *)
(*                                                                  *)
(*  The Seed7 Runtime Library is free software; you can             *)
(*  redistribute it and/or modify it under the terms of the GNU     *)
(*  Lesser General Public License as published by the Free Software *)
(*  Foundation; either version 2.1 of the License, or (at your      *)
(*  option) any later version.                                      *)
(*                                                                  *)
(*  The Seed7 Runtime Library is distributed in the hope that it    *)
(*  will be useful, but WITHOUT ANY WARRANTY; without even the      *)
(*  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR *)
(*  PURPOSE.  See the GNU Lesser General Public License for more    *)
(*  details.                                                        *)
(*                                                                  *)
(*  You should have received a copy of the GNU Lesser General       *)
(*  Public License along with this program; if not, write to the    *)
(*  Free Software Foundation, Inc., 51 Franklin Street,             *)
(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)
(*                                                                  *)
(********************************************************************)


const type: utf16le_file is sub null_file struct
    var PRIMITIVE_FILE: ext_file is PRIMITIVE_NULL_FILE;
    var string: name is "";
  end struct;


const type: utf16be_file is sub null_file struct
    var PRIMITIVE_FILE: ext_file is PRIMITIVE_NULL_FILE;
    var string: name is "";
  end struct;


const func utf16le_file: malloc (ref utf16le_file: ext_file) is func
  result
    var utf16le_file: result is utf16le_file.value;
  begin
    result := ext_file;
  end func;


const func utf16be_file: malloc (ref utf16be_file: ext_file) is func
  result
    var utf16be_file: result is utf16be_file.value;
  begin
    result := ext_file;
  end func;


const func file: open_utf16 (in string: fileName, in string: access) is func
  result
    var file: result is STD_NULL;
  local
    var PRIMITIVE_FILE: open_file is PRIMITIVE_NULL_FILE;
    var utf16le_file: new_le_file is utf16le_file.value;
    var utf16be_file: new_be_file is utf16be_file.value;
    var string: bom is "";
  begin
    open_file := PRIMITIVE_FILE_OPEN(fileName, access);
    if open_file <> PRIMITIVE_NULL_FILE then
      bom := gets(open_file, 2);
      if bom = "\16#FF\\16#FE\" then
        new_le_file.ext_file := open_file;
        new_le_file.name := fileName;
        result := malloc(new_le_file);
      elsif bom = "\16#FE\\16#FF\" then
        new_be_file.ext_file := open_file;
        new_be_file.name := fileName;
        result := malloc(new_be_file);
      end if;
    end if;
  end func;


const func file: open_utf16le (in string: fileName, in string: access) is func
  result
    var file: result is STD_NULL;
  local
    var PRIMITIVE_FILE: open_file is PRIMITIVE_NULL_FILE;
    var utf16le_file: new_le_file is utf16le_file.value;
    var string: bom is "";
  begin
    open_file := PRIMITIVE_FILE_OPEN(fileName, access);
    if open_file <> PRIMITIVE_NULL_FILE then
      write(open_file, "\16#FF\\16#FE\");
      new_le_file.ext_file := open_file;
      new_le_file.name := fileName;
      result := malloc(new_le_file);
    end if;
  end func;


const proc: write (in utf16le_file: aFile, in string: stri) is func
  local
    var char: ch is ' ';
    var integer: number is 0;
    var char: ch1 is ' ';
    var char: ch2 is ' ';
  begin
    for ch range stri do
      if ch <= '\16#FFFF\' then
        write(aFile.ext_file, str(chr(ord(ch) mod 256)));
        write(aFile.ext_file, str(chr(ord(ch) mdiv 256)));
      elsif ch <= '\16#10FFFF\' then
        number := ord(ch) - 16#10000;
        ch1 := chr(16#D800 + (number >> 10));
        write(aFile.ext_file, str(chr(ord(ch1) mod 256)));
        write(aFile.ext_file, str(chr(ord(ch1) mdiv 256)));
        ch2 := chr(16#DC00 + (number mod 16#400));
        write(aFile.ext_file, str(chr(ord(ch2) mod 256)));
        write(aFile.ext_file, str(chr(ord(ch2) mdiv 256)));
      else
        raise RANGE_ERROR;
      end if;
    end for;
  end func;


const func string: gets (in utf16le_file: aFile, in integer: leng) is func
  result
    var string: result is "";
  local
    var string: stri is "";
    var integer: index is 0;
    var char: ch1 is ' ';
    var char: ch2 is ' ';
  begin
    stri := gets(aFile.ext_file, 2 * leng);
    for index range 1 to length(stri) div 2 do
      ch1 := chr(ord(stri[index * 2]) * 256 + ord(stri[pred(index * 2)]));
      if ch1 >= '\16#D800\' and ch1 <= '\16#DBFF\' then
        if index < length(stri) div 2 then
          incr(index);
          ch2 := chr(ord(stri[index * 2]) * 256 + ord(stri[pred(index * 2)]));
          if ch2 >= '\16#DC00\' and ch2 <= '\16#DFFF\' then
            result &:= str(chr((ord(ch1) - 16#D800) << 10 +
                               (ord(ch2) - 16#DC00) + 16#10000));
          else
            raise RANGE_ERROR;
          end if;
        else
          raise RANGE_ERROR;
        end if;
      else
        result &:= str(ch1);
      end if;
    end for;
  end func;


const func boolean: eof (in utf16le_file: aFile) is
  return eof(aFile.ext_file);


const func file: open_utf16be (in string: fileName, in string: access) is func
  result
    var file: result is STD_NULL;
  local
    var PRIMITIVE_FILE: open_file is PRIMITIVE_NULL_FILE;
    var utf16be_file: new_be_file is utf16be_file.value;
    var string: bom is "";
  begin
    open_file := PRIMITIVE_FILE_OPEN(fileName, access);
    if open_file <> PRIMITIVE_NULL_FILE then
      write(open_file, "\16#FE\\16#FF\");
      new_be_file.ext_file := open_file;
      new_be_file.name := fileName;
      result := malloc(new_be_file);
    end if;
  end func;


const proc: write (in utf16be_file: aFile, in string: stri) is func
  local
    var char: ch is ' ';
    var integer: number is 0;
    var char: ch1 is ' ';
    var char: ch2 is ' ';
  begin
    for ch range stri do
      if ch <= '\16#FFFF\' then
        write(aFile.ext_file, str(chr(ord(ch) mdiv 256)));
        write(aFile.ext_file, str(chr(ord(ch) mod 256)));
      elsif ch <= '\16#10FFFF\' then
        number := ord(ch) - 16#10000;
        ch1 := chr(16#D800 + (number >> 10));
        write(aFile.ext_file, str(chr(ord(ch1) mdiv 256)));
        write(aFile.ext_file, str(chr(ord(ch1) mod 256)));
        ch2 := chr(16#DC00 + (number mod 16#400));
        write(aFile.ext_file, str(chr(ord(ch2) mdiv 256)));
        write(aFile.ext_file, str(chr(ord(ch2) mod 256)));
      else
        raise RANGE_ERROR;
      end if;
    end for;
  end func;


const func string: gets (in utf16be_file: aFile, in integer: leng) is func
  result
    var string: result is "";
  local
    var string: stri is "";
    var integer: index is 0;
    var char: ch1 is ' ';
    var char: ch2 is ' ';
  begin
    stri := gets(aFile.ext_file, 2 * leng);
    for index range 1 to length(stri) div 2 do
      ch1 := chr(ord(stri[pred(index * 2)]) * 256 + ord(stri[index * 2]));
      if ch1 >= '\16#D800\' and ch1 <= '\16#DBFF\' then
        if index < length(stri) div 2 then
          incr(index);
          ch2 := chr(ord(stri[pred(index * 2)]) * 256 + ord(stri[index * 2]));
          if ch2 >= '\16#DC00\' and ch2 <= '\16#DFFF\' then
            result &:= str(chr((ord(ch1) - 16#D800) << 10 +
                               (ord(ch2) - 16#DC00) + 16#10000));
          else
            raise RANGE_ERROR;
          end if;
        else
          raise RANGE_ERROR;
        end if;
      else
        result &:= str(ch1);
      end if;
    end for;
  end func;


const func boolean: eof (in utf16be_file: aFile) is
  return eof(aFile.ext_file);
