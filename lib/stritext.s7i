
(********************************************************************)
(*                                                                  *)
(*  stritext.s7i  string text library (uses an array string)        *)
(*  Copyright (C) 2007  Thomas Mertes                               *)
(*                                                                  *)
(*  This file is part of the Seed7 Runtime Library.                 *)
(*                                                                  *)
(*  The Seed7 Runtime Library is free software; you can             *)
(*  redistribute it and/or modify it under the terms of the GNU     *)
(*  Lesser General Public License as published by the Free Software *)
(*  Foundation; either version 2.1 of the License, or (at your      *)
(*  option) any later version.                                      *)
(*                                                                  *)
(*  The Seed7 Runtime Library is distributed in the hope that it    *)
(*  will be useful, but WITHOUT ANY WARRANTY; without even the      *)
(*  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR *)
(*  PURPOSE.  See the GNU Lesser General Public License for more    *)
(*  details.                                                        *)
(*                                                                  *)
(*  You should have received a copy of the GNU Lesser General       *)
(*  Public License along with this program; if not, write to the    *)
(*  Free Software Foundation, Inc., 51 Franklin Street,             *)
(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)
(*                                                                  *)
(********************************************************************)


include "text.s7i";


const type: stritext is sub null_file struct
    var array string: content is 0 times "";
    var integer: line is 1;
    var integer: column is 1;
  end struct;

type_implements_interface(stritext, text);


const func stritext: malloc (in stritext: aStritext) is func
  result
    var stritext: result is stritext.value;
  begin
    result := aStritext;
  end func;


(**
 *  Open a 'stritext' with the given string array content.
 *  @return the file opened.
 *)
const func file: openStritext (in array string: content) is func
  result
    var file: result is STD_NULL;
  local
    var stritext: new_stritext is stritext.value;
  begin
    new_stritext.content := content;
    result := malloc(new_stritext);
  end func;


(**
 *  Close a 'stritext'.
 *)
const proc: close (in stritext: aStritext) is noop;


const proc: flush (in stritext: aStritext) is noop;


(**
 *  Write the string 'stri' to 'aStritext'.
 *)
const proc: write (inout stritext: aStritext, in string: stri) is func
  begin
    if aStritext.line > length(aStritext.content) then
      while aStritext.line > length(aStritext.content) do
        aStritext.content &:= [] ("");
      end while;
    end if;
    if aStritext.column > succ(length(aStritext.content[aStritext.line])) then
      aStritext.content[aStritext.line] &:=
          "" lpad (aStritext.column - succ(length(aStritext.content[aStritext.line])));
    end if;
    aStritext.content[aStritext.line] :=
        aStritext.content[aStritext.line][.. pred(aStritext.column)] &
        stri &
        aStritext.content[aStritext.line][aStritext.column ..];
    aStritext.column +:= length(stri);
  end func;


const proc: writeln (inout stritext: aStritext) is func
  begin
    if aStritext.line <= length(aStritext.content) then
      aStritext.content[aStritext.line] := aStritext.content[aStritext.line][.. aStritext.column];
      aStritext.content := aStritext.content[.. aStritext.line] &
          [] (aStritext.content[aStritext.line][aStritext.column ..]) &
          aStritext.content[succ(aStritext.line) ..];
    else
      while aStritext.line > length(aStritext.content) do
        aStritext.content &:= [] ("");
      end while;
      aStritext.content &:= [] ("");
    end if;
    incr(aStritext.line);
    aStritext.column := 1;
  end func;


const proc: backSpace (inout stritext: aStritext) is func
  begin
    if aStritext.column > 1 then
      decr(aStritext.column);
    elsif aStritext.line > 1 then
      decr(aStritext.line);
      if aStritext.line <= length(aStritext.content) then
        aStritext.column := succ(length(aStritext.content[aStritext.line]));
      else
        aStritext.column := 1;
      end if;
    end if;
  end func;


(**
 *  Read a character from 'aStritext'.
 *  @return the character read.
 *)
const func char: getc (inout stritext: aStritext) is func
  result
    var char: charRead is ' ';
  begin
    if aStritext.line <= length(aStritext.content) then
      if aStritext.column <= length(aStritext.content[aStritext.line]) then
        charRead := aStritext.content[aStritext.line][aStritext.column];
        incr(aStritext.column);
      else
        charRead := '\n';
        incr(aStritext.line);
        aStritext.column := 1;
      end if;
    else
      charRead := EOF;
    end if;
  end func;


(**
 *  Read a string with a maximum length from 'aStritext'.
 *  @return the string read.
 *)
const func string: gets (inout stritext: aStritext, in var integer: maxLength) is func
  result
    var string: striRead is "";
  begin
    if aStritext.line <= length(aStritext.content) then
      if maxLength > succ(length(aStritext.content[aStritext.line]) - aStritext.column) then
        striRead := aStritext.content[aStritext.line][aStritext.column ..];
        striRead &:= "\n";
        maxLength -:= length(aStritext.content[aStritext.line]) - aStritext.column + 2;
        incr(aStritext.line);
        while aStritext.line <= length(aStritext.content) and
            maxLength > length(aStritext.content[aStritext.line]) do
          striRead &:= aStritext.content[aStritext.line];
          striRead &:= "\n";
          maxLength -:= succ(length(aStritext.content[aStritext.line]));
          incr(aStritext.line);
        end while;
        if aStritext.line <= length(aStritext.content) and maxLength > 0 then
          striRead &:= aStritext.content[aStritext.line][aStritext.column len maxLength];
          aStritext.column := succ(maxLength);
        else
          aStritext.column := 1;
        end if;
      else
        striRead := aStritext.content[aStritext.line][aStritext.column len maxLength];
        aStritext.column +:= maxLength;
      end if;
    end if;
  end func;


const func string: getwd (inout stritext: aStritext) is func
  result
    var string: stri is "";
  begin
    noop; # todo
  end func;


(**
 *  Read a line from 'aStritext'.
 *  A stritext works as if all lines end with '\n'.
 *  The line ending character is not copied into the string. When
 *  the function is left inFile.bufferChar contains '\n' or EOF.
 *  @return the line read.
 *)
const func string: getln (inout stritext: aStritext) is func
  result
    var string: stri is "";
  begin
    if aStritext.line <= length(aStritext.content) then
      stri := aStritext.content[aStritext.line][aStritext.column .. ];
      incr(aStritext.line);
      aStritext.column := 1;
      aStritext.bufferChar := '\n';
    else
      stri := "";
      aStritext.bufferChar := EOF;
    end if;
  end func;


(**
 *  Determine the end-of-file indicator.
 *  The end-of-file indicator is set when at least one request to read
 *  from the file failed.
 *  @return TRUE if the end-of-file indicator is set, FALSE otherwise.
 *)
const func boolean: eof (in stritext: aStritext) is
  return aStritext.line > length(aStritext.content);


(**
 *  Determine if at least one character can be read successfully.
 *  This function allows a file to be handled like an iterator.
 *  @return FALSE if 'getc' would return EOF, TRUE otherwise.
 *)
const func boolean: hasNext (in stritext: aStritext) is
  return aStritext.line <= length(aStritext.content);


const func integer: length (in stritext: aStritext) is func
  result
    var integer: result is 0;
  local
    var integer: line is 0;
  begin
    for line range 1 to length(aStritext.content) do
      result +:= succ(length(aStritext.content[line]));
    end for;
  end func;


const proc: seek (in stritext: aStritext, in integer: pos) is func
  begin
    noop; # todo
  end func;


const func integer: tell (in stritext: aStritext) is func
  result
    var integer: result is 0;
  local
    var integer: line is 0;
  begin
    for line range 1 to pred(aStritext.line) do
      result +:= succ(length(aStritext.content[aStritext.line]));
    end for;
    result +:= aStritext.column;
  end func;


const func integer: height (in stritext: aStritext) is
  return aStritext.line;


const func integer: width (in stritext: aStritext) is func
  result
    var integer: result is 0;
  local
    var integer: line is 0;
  begin
    for line range 1 to length(aStritext.content) do
      if length(aStritext.content[line]) > result then
        result := length(aStritext.content[line]);
      end if;
    end for;
  end func;


const func integer: line (in stritext: aStritext) is
  return aStritext.line;


const func integer: column (in stritext: aStritext) is
  return aStritext.column;


const proc: setPos (inout stritext: aStritext, in integer: line, in integer: column) is func
  begin
    aStritext.line := line;
    aStritext.column := column;
  end func;


const proc: setLine (inout stritext: aStritext, in integer: line) is func
  begin
    aStritext.line := line;
  end func;


const proc: setColumn (inout stritext: aStritext, in integer: column) is func
  begin
    aStritext.column := column;
  end func;


const proc: clear (inout stritext param) is noop;
const proc: clear (in stritext param, in integer param, in integer param,
    in integer param, in integer param) is noop;
const proc: v_scroll (inout stritext param, in integer param) is noop;
const proc: v_scroll (inout stritext param, in integer param, in integer param,
    in integer param, in integer param, in integer param) is noop;
const proc: h_scroll (ref stritext param, in integer param) is noop;
const proc: h_scroll (ref stritext param, in integer param, in integer param,
    in integer param, in integer param, in integer param) is noop;
const proc: color (ref stritext param, ref color param) is noop;
const proc: color (ref stritext param, ref color param, ref color param) is noop;
const proc: setPosXY (inout stritext param, in integer param, in integer param) is noop;
