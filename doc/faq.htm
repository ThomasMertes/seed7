<p></p><hr><b><big><p align="center">
Frequently asked questions
</p></big></b><hr><!-- ========================== -->
<p></p><!--(*-->
<ul>
<li><a href="#new_language"><b>
Why a new programming language?
</b></a></li>
<li><a href="#license"><b>
Which license does Seed7 use?
</b></a></li>
<li><a href="#free"><b>
But Java and C# are also free?
</b></a></li>
<li><a href="#os"><b>
On which operating systems does Seed7 run?
</b></a></li>
<li><a href="#errors"><b>
I got errors when compiling Seed7. What should I do?
</b></a></li>
<li><a href="#bytecode"><b>
Does the interpreter use bytecode?
</b></a></li>
<li><a href="#analyze"><b>
How does the analyze phase of the interpreter work?
</b></a></li>
<li><a href="#compile"><b>
Is it possible to compile Seed7 programs?
</b></a></li>
<li><a href="#statements"><b>
Why does Seed7 not use the C statements like C++ and Java?
</b></a></li>
<li><a href="#declare_later"><b>
Can I use something and declare it later?
</b></a></li>
<li><a href="#static_type_checking"><b>
Why does Seed7 use static type checking?
</b></a></li>
<li><a href="#automatic_casts"><b>
Are there automatic casts to the right type?
</b></a></li>
<li><a href="#overloading"><b>
Can functions be overloaded?
</b></a></li>
<li><a href="#overload_result"><b>
Can I overload two functions which just differ by the result type?
</b></a></li>
<li><a href="#lisp_comparison"><b>
Hasn't Lisp already user defined statements and operators?
</b></a></li>
<li><a href="#variable_parameters"><b>
Can functions have variable parameter lists?
</b></a></li>
<li><a href="#initialize_variables"><b>
Why is it necessary to initialize all variables?
</b></a></li>
<li><a href="#garbage_collection"><b>
Is there a garbage collection?
</b></a></li>
<li><a href="#object_oriented"><b>
Is Seed7 object oriented?
</b></a></li>
<li><a href="#inherited_from_object"><b>
Is everything inherited from object?
</b></a></li>
<li><a href="#multiple_dispatch"><b>
What is multiple dispatch?
</b></a></li>
<li><a href="#container_classes"><b>
What container classes do exist?
</b></a></li>
<li><a href="#primitive_types"><b>
Are there primitive types?
</b></a></li>
<li><a href="#object_and_primitive_types"><b>
What is the difference between object and primitive types?
</b></a></li>
<li><a href="#when_use_object_or_primitive_types"><b>
When to use an object type and when a primitive type?
</b></a></li>
<li><a href="#how_does_the_assignment_work"><b>
How does the assignment work?
</b></a></li>
<li><a href="#two_forms_of_assignment"><b>
Why are there two forms of assignment?
</b></a></li>
<li><a href="#types of parameters"><b>
What types of parameters does Seed7 have?
</b></a></li>
<li><a href="#constructors"><b>
Where are the constructors?
</b></a></li>
<li><a href="#static_methods"><b>
Are there static methods / class methods?
</b></a></li>
<li><a href="#generics"><b>
Are there generics / templates?
</b></a></li>
<li><a href="#exceptions"><b>
Are there exceptions?
</b></a></li>
<li><a href="#action"><b>
What does action "XYZ_SOMETHING" mean?
</b></a></li>
<li><a href="#dollar_signs"><b>
Why are there dollar signs at some places?
</b></a></li>
<li><a href="#seed7_version_number"><b>
Why does "seed7_05.s7i" contain a version number?
</b></a></li>
<li><a href="#boot_a_language"><b>
Can I use an "abc.s7i" include file to boot to the abc language?
</b></a></li>
</ul><hr>
<p></p><!--*)-->

<a name="new_language"><b>Why a new programming language?
</b></a><hr><!-- =============================== -->
<p>
Because Seed7 has several features which are not found in other
programming languages:
</p><ul>
<li><!--  -  -->The possibility to declare new statements (syntactical and
   semantically) in the same way as functions are declared (There are
   also user definable operators with priority and associativity).</li>
<li><!--  -  -->Declaration constructs for constant-, variable-, function-,
   parameter-, and other declarations are described in Seed7 (The user
   can change existing declaration constructs or invent new ones).</li>
<li><!--  -  -->Templates use no special syntax. They are just functions
   with type parameters or a type result (For example: array, hash, struct
   and set use a Pascal inspired syntax and semantic. In Seed7 they are
   not hard coded in the compiler but are templates described in Seed7).</li>
<li><!--  -  -->Seed7 is a syntactically and semantically extensible
   language: Almost all of the Seed7 language (statements, operators,
   declaration constructs, and more) is defined in Seed7 in an include
   file (seed7_05.s7i).</li>
<li><!--  -  -->The application program contains an include statement and
   the hi interpreter is booted with the language description when it
   starts. This way it is possible to define language variants or a
   totally different language.</li>
</ul><p></p>

<a name="license"><b>Which license does Seed7 use?
</b></a><hr><!-- ============================= -->
<p>
The hi Interpreter and the example programs (extension .sd7) are under the
GPL (General Public License, see also the file COPYING).
</p><p>
The Seed7 Runtime Library is under the LGPL (Lesser General Public License,
see also the file LGPL). The Seed7 include files (extension .s7i) are a part
of the Seed7 Runtime Library.
</p><p>
Seed7 allows the interpretation and compilation of programs with any license.
There is no restriction on the license of your Seed7 programs.
</p><p>
For the development of the Seed7 compiler it will be necessary to move some
source code from the hi Interpreter (under GPL) to the Seed7 Runtime Library
(under LGPL). This will only be done to for the Seed7 runtime library and only
as far as necessary to make no restriction on the license of compiled Seed7
programs.
</p><p>
If you send me patches (I would be very pleased), it is assumed that you
accept license changes from GPL to LGPL for parts of code which need to be
in the runtime library to support compilation of Seed7 programs.
</p>

<a name="free"><b>But Java and C# are also free?
</b></a><hr><!-- ============================== -->
<p>
Seed7 is "Free as in Freedom" and not only "Free as in Free Beer" and this can
make a big difference. Undocumented native interfaces are just not possible.
</p>

<a name="os"><b>On which operating systems does Seed7 run?
</b></a><hr><!-- ========================================== -->
<p>
Linux is supported out of the box (because the development is done using
Linux). For other operating systems it might be necessary to write driver
modules for screen (=text console), graphics, time or other aspects of Seed7.
The package contains various older driver modules which are not up to date,
but can be used as base to write such driver modules.
</p>

<a name="errors"><b>I got errors when compiling Seed7. What should I do?
</b></a><hr><!-- ==================================================== -->
<p>
In most cases errors indicate that some development package of your
distribution is missing. If your operating system is linux, bsd or unix
not all development packages with header files might be installed. In
this case you get some errors after typing 'make depend'. Errors such as
</p><pre>
  scr_inf.c:57:18: error: term.h: No such file or directory
  kbd_inf.c:55:18: error: term.h: No such file or directory
  trm_inf.c:47:18: error: term.h: No such file or directory
</pre><p>
indicate that the curses or ncurses development package is missing.
I don't know the name of this package in your distribution
(under Ubuntu it has the name libncurses5-dev), but you
can search in your package manager for a curses/ncurses
package which mentions that it contains the header files.
To execute programs you need also to install the non-developer
package of curses/ncurses (in most cases it will already
be installed because it is needed by other packages).
</p><p>
Errors such as
</p><pre>
  drw_x11.c:38:19: error: X11/X.h: No such file or directory
  drw_x11.c:39:22: error: X11/Xlib.h: No such file or directory
  drw_x11.c:40:23: error: X11/Xutil.h: No such file or directory
  drw_x11.c:45:24: error: X11/keysym.h: No such file or directory
</pre><p>
indicate that the X11 development package is missing.
Under Ubuntu this package has the name libx11-dev and is
described as: X11 client-side library (development headers)
Note that under X11 'client' means: The program which wants to
draw. A X11 'server' is the place where the drawings are displayed.
So you have to search for a X11 client developer package with
headers. If you use X11 in some way (you don't do everything
from the text console) the non-developer package of X11 will
already be installed.
</p><p>
When you got other errors I would like to know about. Please send
a mail with detailed information (name and version) of your
operating system, distribution, compiler, the version of Seed7
you wanted to compile and the complete log of error messages to
seed7-users@lists.sourceforge.net .
</p>

<a name="bytecode"><b>Does the interpreter use bytecode?
</b></a><hr><!-- ================================== -->
<p>
No, the analyze phase of the Seed7 interpreter produces call-code which consists
of values and function calls. This call-code is just handled in memory and
never written to a file. After the analyze phase the call-code is interpreted.
</p>

<a name="analyze"><b>How does the analyze phase of the interpreter work?
</b></a><hr><!-- =================================================== -->
<p>
The analyzer reads successive expressions according to the syntax definitions.
For each expression the analyzer searches the internal database of declared
objects (this search process is called matching) and generates call-code for
this expression. Then the call code for this expression is executed. Normally
this expressions are declaration statements. In that case new declared objects
are added to the internal database.
</p>

<a name="compile"><b>Is it possible to compile Seed7 programs?
</b></a><hr><!-- ========================================= -->
<p>
Generally Seed7 is designed to allow the compilation from Seed7 to C. The Seed7
compiler (written in Seed7) uses the analyze phase of the interpreter to convert
a program to call-code and then generates a corresponding C program. This C
program is compiled and linked afterwards.
(Note that the compiler is currently not finished)
</p>

<a name="statements"><b>Why does Seed7 not use the C statements like C++ and Java?
</b></a><hr><!-- ========================================================== -->
<p>
The C statements have some weaknesses which are avoided with the Seed7 statements:
</p><p>
<!--  1.  -->The C if-statement
</p><pre>
      <font color=blue>if</font> (condition)
        statement;
</pre><p>
    allows just one statement after the condition. By using the compound statement
    it is possible to have several statements after the condition
</p><pre>
      <font color=blue>if</font> (condition) {
        statement1;
        statement2;
      }
</pre><p>
    Adding or removing a statement in the second if-statement is always possible.
    In the first if-statement you must add braces if you add a statement otherwise
    you get an undesired effect. Adding statements to an if-statement is quite common.
</p><p>
    Since both forms are legal and adding a statement to the first form can lead to
    errors Seed7 closes this possible source of errors with its if-statement:
</p><pre>
      <font color=blue>if</font> condition <font color=blue>then</font>
        statement
      <font color=blue>end if</font>;
</pre><p>
<!--  2.  -->The following switch statement is formally correct but probably wrong
</p><pre>
      <font color=blue>switch</font> (number) {
        <font color=blue>case</font> 1:
        <font color=blue>case</font> 2:
          result = 5;
        <font color=blue>case</font> 3:
        <font color=blue>case</font> 4:
          result = 8;
          <font color=blue>break</font>;
        <font color=blue>default</font>:
          result = 0;
      }
</pre><p>
    Forgetting break statements in a switch is another possible source of errors which
    is avoided in Seed7:
</p><pre>
      <font color=blue>case</font> number <font color=blue>of</font>
        <font color=blue>when</font> {1, 2}:
          result = 5;
        <font color=blue>when</font> {3, 4}:
          result = 8;
        <font color=blue>otherwise</font>:
          result = 0;
      <font color=blue>end case</font>;
</pre><p></p>

<a name="declare_later"><b>Can I use something and declare it later?
</b></a><hr><!-- ========================================= -->
<p>
No, everything must be declared before it is used. The possibility to declare new
statements and new operators on one side and the static typing requirements with
compile time checks of the parameters on the other side would make the job of analyzing
expressions with undeclared functions very complex.
</p><p>
Forward declarations help, if something needs to be used before it can be declared fully.
</p>

<a name="static_type_checking"><b>Why does Seed7 use static type checking?
</b></a><hr><!-- ======================================== -->
<p>
With static type checking all type checks are performed during compile-time.
Typing errors can be caught earlier without the need to execute the program.
This increases the reliability of the program.
With dynamic typing it would be necessary to reach 100% code coverage to
find all typing errors. Additionally the program execution can be more efficient
with static type checking since there are no type checks necessary at run-time.
</p><p>
Interface types can be used when an object can have several types at runtime.
</p>

<a name="automatic_casts"><b>Are there automatic casts to the right type?
</b></a><hr><!-- ============================================ -->
<p>
No, because Seed7 is strong typed. This means that for every expression (and sub expression)
you know its type at compile time without knowing where this expression is used.
Although this means that you have to convert types explicit (for example from integer
to float) it has more advantages than disadvantages:
</p><ol>
<li><!--  1.  -->The overloading rules are much simpler.</li>
<li><!--  2.  -->An expression can be understood without it's calling context.</li>
<li><!--  3.  -->Errors caused by unplanned automatic type conversions cannot happen.</li>
<li><!--  4.  -->Since you have to do type conversions explicit you are more aware of the
    run time overhead.</li>
</ol>

<a name="overloading"><b>Can functions be overloaded?
</b></a><hr><!-- ============================ -->
<p>
Yes, functions, operators and statements can be overloaded. Additionally it is possible
to define new operators and statements.
</p>

<a name="overload_result"><b>Can I overload two functions which just differ by the result type?
</b></a><hr><!-- ================================================================== -->
<p>
No, it is not possible to overload a function (operator, statement) which has
the same parameter types and just a different result type as another function. This is
necessary to reach the goal of knowing the type of every expression without knowing
where the expression is used.
</p>

<a name="lisp_comparison"><b>Hasn't Lisp already user defined statements and operators?
</b></a><hr><!-- ========================================================== -->
<p>
Defining the semantic of a new 'statement' in Lisp is a classic example.
Normally such 'statements' still use the list notation with lots of parentheses.
The read macros of Lisp could be used to define the syntax of a statement, but
read macros make no type checks at compile time. Any type checking must be written
by the programmer and is not mandated by Lisp. The type checks will be performed
at runtime and might issue warnings at compile time (this is implementation
dependent). In general: Lisp 'statement' declarations do not force compile time
checks and look less elegant. Seed7 statement declarations force a type check at
compile time.
</p><p>
While Lisp allows new and overloaded functions, the Lisp 'operators' are
functions which use the prefix notation (with lots of parentheses).
Again read macros could be used to support infix operators with priority
and associativity. This read macros would have the same problems as above.
Although Lisp fanatics would never admit it, infix operators with priority
and associativity are not really supported by Lisp. If somebody tells you
that everything can be done in Lisp, send him to the next advocacy group.
In general: Seed7 supports user definable infix operators with priority and
associativity. Such operators can be overloaded and the type checks are done
at compile time. In Lisp all this would be a hack.
</p><p></p>

<a name="variable_parameters"><b>Can functions have variable parameter lists?
</b></a><hr><!-- ============================================ -->
<p>
No, because functions with variable parameter lists as the C printf function have
some problems:
</p><ul>
<li><!--  -  -->Type checking is only possible at run time.</li>
<li><!--  -  -->The recognition of overloaded functions becomes more complicated.</li>
</ul><p>
Instead Seed7 has array aggregates and allows functions with arrays as parameters.
So you could declare a function
</p><pre>
  <font color=blue>const</font> <font color=red>proc</font>: print_list (<font color=blue>in</font> <font color=red>array integer</font>: arr) <font color=blue>is func</font>
    <font color=blue>local</font>
      <font color=blue>var</font> <font color=red>integer</font>: number <font color=blue>is</font> 0;
    <font color=blue>begin</font>
      <font color=blue>for</font> number <font color=blue>range</font> arr <font color=blue>do</font>
        writeln(number);
      <font color=blue>end for</font>;
    <font color=blue>end func</font>;
</pre><p>
and call it with
</p><pre>
  print_list([](1, 1, 2, 3, 5, 8, 13, 21, 34, 55));
</pre><p></p>

<a name="initialize_variables"><b>Why is it necessary to initialize all variables?
</b></a><hr><!-- ================================================ -->
<p>
Forgetting to initialize a variable is a common source of errors. In some programming
languages uninitialized variables have a random value which could lead to errors.
To avoid errors caused by uninitialized variables in Seed7 each variable must be
initialized when it is declared.
</p>

<a name="garbage_collection"><b>Is there a garbage collection?
</b></a><hr><!-- ============================== -->
<p>
There is no garbage collection process that interrupts the normal processing to
free some memory. Seed7 uses a different mechanism to manage the memory.
</p><p>
Memory used by local variables and parameters is automatically freed when leaving
a function.
</p><p>
Although functions can return arbitrary complex values (e.g. arrays of structures
with string elements) the memory allocated for all intermediate results is freed
automatically without the help of a garbage collector.
</p>

<a name="object_oriented"><b>Is Seed7 object oriented?
</b></a><hr><!-- ========================= -->
<p>
Yes, but object orientation is organized different compared to other object
oriented languages.
</p><p>
An example of an object oriented type is <tt>'<font color=red>file</font>'</tt>. A <tt>'<font color=red>file</font>'</tt> describes references to
values with some other type. A value of a <tt>'<font color=red>file</font>'</tt> can have one of the following types:
null_file, external_file, echo_file, line_file, etc. Each of this <tt>'<font color=red>file</font>'</tt> value types
acts differently to the same requests.
</p><p>
For the type <tt>'<font color=red>file</font>'</tt> two kinds of functions are defined:
<ol>
<li><!--  1.  -->Functions which work for all files the same way.</li>
<li><!--  2.  -->Dynamic functions which are just an interface. At run time the corresponding
    function defined for the type of the value is used.</li>
</ol></p><p>
Compared to Java the type file can be seen as interface or abstract class, while the
type of the file value can be seen as the class implementing the interface.
</p>

<a name="inherited_from_object"><b>Is everything inherited from object?
</b></a><hr><!-- ==================================== -->
<p>
There can be several base types, each with their own hierarchy. In many object
oriented languages the class <tt>'<font color=red>object</font>'</tt> is used as element of all container classes.
Abstract data types provide a better and type save solution for containers and
other uses of the root class <tt>'<font color=red>object</font>'</tt>. Therefore a single rooted hierarchy is not
needed.
</p><p></p>

<a name="multiple_dispatch"><b>What is multiple dispatch?
</b></a><hr><!-- ========================== -->
<p>
Multiple dispatch means that a function or method is connected to more
than one type. The decision which method is called at runtime is done
based on more than one of its arguments. The classic object orientation
is a special case where a method is connected to one class and the dispatch
decision is done based on the type of the <tt>'self'</tt> or <tt>'this'</tt> parameter.
The classic object orientation is a single dispatch system.
</p><p>
In a multiple dispatch system the methods cannot be grouped to one class
and it makes no sense to have a <tt>'self'</tt> or <tt>'this'</tt> parameter.
All parameters are taken into account when the dispatch decision is done.
In the following example the interface type <tt>'<font color=red>Number</font>'</tt> uses multiple dispatch:
</p><pre>
  <font color=blue>const</font> <font color=red>type</font>: Number <font color=blue>is sub</font> <font color=red>object</font> <font color=blue>interface</font>;

  <font color=blue>const</font> <font color=red>func Number</font>: (<font color=blue>in</font> <font color=red>Number</font> <font color=blue>param</font>) + (<font color=blue>in</font> <font color=red>Number</font> <font color=blue>param</font>) <font color=blue>is DYNAMIC</font>;
</pre><p>
The <tt>'<font color=blue>DYNAMIC</font>'</tt> declaration creates an interface function for the <tt>'+'</tt> operator.
The interface type <tt>'<font color=red>Number</font>'</tt> can represent an <tt>'<font color=red>Integer</font>'</tt> or a <tt>'<font color=red>Float</font>'</tt>:
</p><pre>
  <font color=blue>const</font> <font color=red>type</font>: Integer <font color=blue>is new struct</font>
      <font color=blue>var</font> <font color=red>integer</font>: val <font color=blue>is</font> 0;
    <font color=blue>end struct</font>;

  type_implements_interface(<font color=red>Integer</font>, <font color=red>Number</font>);

  <font color=blue>const</font> <font color=red>type</font>: Float <font color=blue>is new struct</font>
      <font color=blue>var</font> <font color=red>float</font>: val <font color=blue>is</font> 0.0;
    <font color=blue>end struct</font>;

  type_implements_interface(<font color=red>Float</font>, <font color=red>Number</font>);
</pre><p>
The declarations of the converting <tt>'+'</tt> operators are:
</p><pre>
  <font color=blue>const</font> <font color=red>func Float</font>: (<font color=blue>in</font> <font color=red>Integer</font>: a) + (<font color=blue>in</font> <font color=red>Float</font>: b) <font color=blue>is func</font>
    <font color=blue>result</font>
      <font color=blue>var</font> <font color=red>Float</font>: result <font color=blue>is</font> <font color=red>Float</font>.value;
    <font color=blue>begin</font>
      result.val := flt(a.val) + b.val;
    <font color=blue>end func</font>;

  <font color=blue>const</font> <font color=red>func Float</font>: (<font color=blue>in</font> <font color=red>Float</font>: a) + (<font color=blue>in</font> <font color=red>Integer</font>: b) <font color=blue>is func</font>
    <font color=blue>result</font>
      <font color=blue>var</font> <font color=red>Float</font>: result <font color=blue>is</font> <font color=red>Float</font>.value;
    <font color=blue>begin</font>
      result.val := a.val + flt(b.val);
    <font color=blue>end func</font>;
</pre><p>
The declarations of the normal <tt>'+'</tt> operators (which do not convert) are:
</p><pre>
  <font color=blue>const</font> <font color=red>func Integer</font>: (<font color=blue>in</font> <font color=red>Integer</font>: a) + (<font color=blue>in</font> <font color=red>Integer</font>: b) <font color=blue>is func</font>
    <font color=blue>result</font>
      <font color=blue>var</font> <font color=red>Integer</font>: result <font color=blue>is</font> <font color=red>Integer</font>.value;
    <font color=blue>begin</font>
      result.val := a.val + b.val;
    <font color=blue>end func</font>;

  <font color=blue>const</font> <font color=red>func Float</font>: (<font color=blue>in</font> <font color=red>Float</font>: a) + (<font color=blue>in</font> <font color=red>Float</font>: b) <font color=blue>is func</font>
    <font color=blue>result</font>
      <font color=blue>var</font> <font color=red>Float</font>: result <font color=blue>is</font> <font color=red>Float</font>.value;
    <font color=blue>begin</font>
      result.val := a.val + b.val;
    <font color=blue>end func</font>;
</pre><p>
The decision which <tt>'+'</tt> operator should be called at runtime is based on the
implementation type (<tt>'<font color=red>Integer</font>'</tt> or a <tt>'<font color=red>Float</font>'</tt>) of both arguments of the <tt>'+'</tt>.
</p>

<a name="container_classes"><b>What container classes do exist?
</b></a><hr><!-- ================================ -->
<p>
Abstract data types are used to replace container classes. When using an
abstract data type as container you have to specify the type of the element
in the type declaration. Therefore abstract data types are always type safe.
Typeless container classes with object elements do not exist. The only thing
which comes near to this is the <tt>'<font color=red>ref_list</font>'</tt> which is used in the reflection.
A <tt>'<font color=red>ref_list</font>'</tt> should not be misused as container class. Examples of abstract
data types are:
</p><pre>
  <font color=red>array string</font>
  <font color=red>array [boolean] string</font>
  <font color=red>set of char</font>
  <font color=red>set of integer</font>
  <font color=red>hash [string] boolean</font>
  <font color=red>hash [string] array array string</font>
</pre><p></p>

<a name="primitive_types"><b>Are there primitive types?
</b></a><hr><!-- ========================== -->
<p>
As in C++, Java, C# and other hybrid object oriented languages there are
predefined primitive types in Seed7. These are integer, char, boolean, string,
float, rational, time and others. Additionally to the predefined primitive
types there is also the possibility to declare new primitive types.
</p>

<a name="object_and_primitive_types"><b>What is the difference between object and primitive types?
</b></a><hr><!-- ========================================================== -->
<p>
Variables with object types contain references to object values. This means
that after
</p><pre>
  a := b
</pre><p>
the variable 'a' refers to the same object as variable 'b'. Therefore changes
on variable 'a' will effect variable 'b' as well (and vice versa) because both
variables refer to the same object.
</p><p>
For primitive types a different logic is used. Variables with primitive types
contain the value itself. This means that after
</p><pre>
  a := b
</pre><p>
both variables are still distinct and changing one variable has no effect on
the other.
</p><p>
If 'a' and 'b' are declared to have type <tt>'<font color=red>aType</font>'</tt> which contains the integer
field 'property' you can do the following:
</p><pre>
  b.property := 1;
  a := b;
  b.property := 2;
</pre><p>
Everything boils down to the question: What value does a.property have now.
</p><ul>
<li><!--  -  -->When <tt>'<font color=red>aType</font>'</tt> is an object type a.property has the value 2 because 'a' and 'b'
   both refer to the same object.</li>
<li><!--  -  -->When <tt>'<font color=red>aType</font>'</tt> is a primitive type a.property has still the value 1 because 'a'
   and 'b' are distinct objects.</li>
</ul>

<a name="when_use_object_or_primitive_types"><b>When to use an object type and when a primitive type?
</b></a><hr><!-- ===================================================== -->
<p>
You should declare a new primitive type if you don't need the object
oriented paradigm that a variable (and a constant) is just a reference
to the object. Another indication is: If you don't need two concepts of
what is equal (An == operator and an equal method).
</p>

<a name="how_does_the_assignment_work"><b>How does the assignment work?
</b></a><hr><!-- ============================= -->
<p>
For object types just the reference to the object value is copied. For
primitive types the value itself is copied. Since values can be very big
(think of arrays of structs with string elements) value copies can be time
consuming.
</p><p>
In pure object oriented languages the effect of independent objects after
the assignment is reached in a different way: Every change to an object
creates a new object and therefore the time consuming copy takes place with
every change. Because usually changes to an object are more frequent than
assignments this approach can be even more time consuming than the approach
using value copies for the assignment.
</p>

<a name="two_forms_of_assignment"><b>Why are there two forms of assignment?
</b></a><hr><!-- ====================================== -->
<p>
Seed7 has an approach for the assignment where practical arguments count
more than the classic object oriented principles. In Seed7 every type has
its own logic for the assignment where sometimes a value copy and sometimes
a reference copy is the right thing to do. Exactly speaking there are many
forms of assignment since every type can define its own assignment. If a
value copy works like a deep or a shallow copy can also be defined depending
on the type. 
</p><p>
For example: For <tt>'<font color=red>integer</font>'</tt>, <tt>'<font color=red>char</font>'</tt>, <tt>'<font color=red>string</font>'</tt> variables a value copy is what most
people expect. For files you don't expect the whole file to be copied with
an assignment, therefore a reference copy seems appropriate.
</p><p>
And by the way:
Although it is always stated that in object oriented languages everything
is done with methods, this is just not true. Besides statements and operators
in C++ and Java which are special even Smalltalk treats the assignment and
the comparison special. Seed7 does not have such special treatment for the
assignment and the comparison operators.
</p>

<a name="types of parameters"><b>What types of parameters does Seed7 have?
</b></a><hr><!-- ========================================= -->
<p>
There are value and reference parameters. The formal parameter can be constant or
variable. The combination of this features allows four types of parameters:
</p><pre>
    +-----------+-----------+--------------+
    | parameter |  call by  | access right |
    +-----------+-----------+--------------+
    | val       |   value   | const        |
    | ref       | reference | const        |
    | in var    |   value   | var          |
    | inout     | reference | var          |
    +-----------+-----------+--------------+
</pre><p>
Additionally every type defines an <tt>'<font color=blue>in</font>'</tt> parameter which is either a <tt>'<font color=blue>val</font>'</tt> or a
<tt>'<font color=blue>ref</font>'</tt> parameter. Types with little memory requirements like <tt>'<font color=red>integer</font>'</tt>, <tt>'<font color=red>char</font>'</tt>
or <tt>'<font color=red>boolean</font>'</tt> use a <tt>'<font color=blue>val</font>'</tt> parameter as <tt>'<font color=blue>in</font>'</tt>. Other types like <tt>'<font color=red>string</font>'</tt>, arrays
and structs use a <tt>'<font color=blue>ref</font>'</tt> parameter as <tt>'<font color=blue>in</font>'</tt>. Usually it is not necessary to
care if an <tt>'<font color=blue>in</font>'</tt> parameter is by value or by reference.
</p>

<a name="constructors"><b>Where are the constructors?
</b></a><hr><!-- =========================== -->
<p>
Seed7 does not need constructors, but you can define normal functions which
create a new value in a similar way as constructors do it.
</p><p>
Seed7 uses a special create statement ( ::= ) to initialize objects.
Explicit calls of the create statement are not needed.
</p><p>
The lifetime of an object goes like this:
</p><ol><li>
<!-- 1.  -->Memory is reserved for the new object (stack or heap memory make no difference here).
</li><li>
<!-- 2.  -->The content of the new memory is undefined (It may contain garbage), therefore a
   create statement is necessary instead of an assignment.
</li><li>
<!-- 3.  -->The create statements copies the right expression to the left expression taking
   into account that the left expression is undefined.
</li><li>
<!-- 4.  -->If the object is variable other values can be assigned using the assign statement ( := ).
   The assignment can assume that the left expression contains a legal value. This allows
   that for strings (and some other types which are just references to a memory area) the
   memory containing the old string value (and not the memory of the object itself) can
   be freed when necessary.
</li><li>
<!-- 5.  -->At the end of the lifetime of an object the destroy statement is executed.
   For strings (and some other types which are just references to a memory area) the memory
   containing the string value (and not the memory of the object itself) is freed.
</li><li>
<!-- 6.  -->The memory of the object is freed.
</li></ol><p>
The first three steps are usually hidden in the declaration statement.
</p>

<a name="static_methods"><b>Are there static methods / class methods?
</b></a><hr><!-- ========================================= -->
<p>
Seed7 allows to define functions (procedures and statements) without corresponding
class. When this is not desired Seed7 uses a special parameter, the attr (attribute)
parameter, to archive the functionality of static methods (elsewhere named class
methods) in a more general way. How a static method is declared is shown in the
following example:
</p><pre>
  <font color=blue>const</font> <font color=red>func integer</font>: convert_to (<font color=blue>attr</font> <font color=red>integer</font>, <font color=blue>in</font> <font color=red>char</font>: ch) <font color=blue>is func</font>
    <font color=blue>result</font>
      <font color=blue>var</font> <font color=red>integer</font>: result <font color=blue>is</font> 0;
    <font color=blue>begin</font>
      result := ord(ch);
    <font color=blue>end func</font>;
</pre><p>
The function convert_to can be called as
</p><pre>
  number := convert_to(<font color=red>integer</font>, 'a');
</pre><p>
Since the result of a function is not used to determine an overloaded function, this
is sometimes the only way to use the same function name for different purposes as in:
</p><pre>
  ch   := convert_to(<font color=red>char</font>,    1);
  stri := convert_to(<font color=red>string</font>,  1);
  ok   := convert_to(<font color=red>boolean</font>, 1);
  num  := convert_to(typeof(num), 1);
</pre><p>
Attribute parameters allow a function to be attached to a certain type. But this concept
is much more flexible than static methods (or class methods). A function can also
have several attr parameters and attr parameters can be at any parameter position (not
just the first parameter). Furthermore the type can be the result of a function as for
example typeof(num).
</p>

<a name="generics"><b>Are there generics / templates?
</b></a><hr><!-- =============================== -->
<p>
In Ada, C++ and Java generics (templates) use a special syntax to express this feature.
In Seed7 you get this functionality for free without special syntax or other magic:
</p><p>
In Seed7 a function can contain declarations which are executed when the function is called.
This way objects can be declared by calling a function (which contains the actual
declarations). Additionally types are first class objects which can be used in type
variables, constants, parameters and functions with types as result.
</p><p>
By combining this features the generic (template) functionality can be done easily.
</p>

<a name="exceptions"><b>Are there exceptions?
</b></a><hr><!-- ===================== -->
<p>
Yes, Seed7 has exceptions which are similar to the Ada and Java exceptions.
</p>

<a name="action"><b>What does action "XYZ_SOMETHING" mean?
</b></a><hr><!-- ====================================== -->
<p>
Actions are used to call a corresponding C function in the interpreter.
For example:
</p><p>
The action "INT_ADD" corresponds to the function 'int_add' in the file
seed7/src/intlib.c .
</p><p>
In the interpreter all action functions get the parameters as list.
The action functions take the parameters they need from the list, perform
the action and deliver a result.
</p>

<a name="dollar_signs"><b>Why are there dollar signs at some places?
</b></a><hr><!-- ========================================== -->
<p>
The $ is used to force the analyzer to use a hard coded expression recognition
instead of the configurable one. This mechanism is used to boot the Seed7 language:
</p><p>
At the beginning of the seed7_05.s7i file nothing is declared. This means that
no statements, no functions, no operators, no types and no variables are predeclared.
To boot the Seed7 language the file syntax.s7i is included. The file syntax.s7i
contains only $ commands. First the type <tt>'<font color=red>type</font>'</tt> is declared. Declarations of other
types, system variables and syntax descriptions of operators and statements follow.
After finishing the include of syntax.s7i the file seed7_05.s7i contains some $
declarations until the <tt>'<font color=blue>const</font>'</tt> declaration statement is established. From that point
onward almost no $ statements are needed.
</p>

<a name="seed7_version_number"><b>Why does "seed7_05.s7i" contain a version number?
</b></a><hr><!-- ================================================= -->
<p>
The number 05 is actually a 'branch info'. As if C had headers like
</p><pre>
  &lt;stdlib_c78.h> /* For K&amp;R C programs */
  &lt;stdlib_c89.h> /* For ANSI C */
  &lt;stdlib_c99.h> /* For C99 */
</pre><p>
and your program must include one of these three headers
as first include file (Other include files have no version/branch
info in the name). That way nobody is forced to upgrade
an old program (to get no warnings or to make it compile).
You can leave your old K&amp;R program from 1980 as is.
When you decide to rewrite your K&amp;R program to use
prototypes, you change the <stdlib...> include file as well.
</p><p>
Programming languages change over long time periods.
This results in different language standards.
Seed7 tries to address this problem from the beginning.
Since most of the Seed7's constructs (statements, operators, types, ... )
are defined in "seed7_05.s7i" this is the right place to do it.
</p>

<a name="boot_a_language"><b>Can I use an "abc.s7i" include file to boot to the abc language?
</b></a><hr><!-- ================================================================ -->
<p>
Theoretically yes. In practice there would be several problems. For example:
</p><ul>
<li> <!-- - --> All primitive actions are defined such that they fit to Seed7.</li>
<li> <!-- - --> Some concepts like goto's, return's, brake's are not supported.</li>
<li> <!-- - --> Some things like comments and $ pragmas are hard coded.</li>
</ul><p>
But basically booting various languages was one of the goals of the extensible
programming language Seed7 and the hi Interpreter.
</p><p>
In practice it turned out to be a better approach to steal concepts from other
programming languages and to integrate them in Seed7 than to split the development
in different branches.
</p><p>
The capability to boot a language can be used to allow slightly different
future versions of Seed7 to coexist with the current version. This is also the
reason why the file seed7_05.s7i contains a version number (05).
</p>
