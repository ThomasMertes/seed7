<p></p><hr><h1 align="center">
Frequently asked questions
</h1><hr><!-- ========================== -->
<p></p><!--(*-->
<ul>
<li><a href="#new_language"><b>
Why a new programming language?
</b></a></li>
<li><a href="#extensible_programming"><b>
What is an extensible programming language?
</b></a></li>
<li><a href="#portable"><b>
Are Seed7 programs portable?
</b></a></li>
<li><a href="#license"><b>
Which license does Seed7 use?
</b></a></li>
<li><a href="#free"><b>
But Java and C# are also free?
</b></a></li>
<li><a href="#os"><b>
On which operating systems does Seed7 run?
</b></a></li>
<li><a href="#uncompress"><b>
How do I uncompress the *.tgz file from the release?
</b></a></li>
<li><a href="#compile_interpreter"><b>
How do I compile the Seed7 interpreter?
</b></a></li>
<li><a href="#errors"><b>
I got errors when compiling Seed7. What should I do?
</b></a></li>
<li><a href="#bytecode"><b>
Does the interpreter use bytecode?
</b></a></li>
<li><a href="#analyze"><b>
How does the analyze phase of the interpreter work?
</b></a></li>
<li><a href="#compile"><b>
Is it possible to compile Seed7 programs?
</b></a></li>
<li><a href="#reserved_words"><b>
What are the reserved words of Seed7?
</b></a></li>
<li><a href="#statements"><b>
Why does Seed7 not use the C statements like C++ and Java?
</b></a></li>
<li><a href="#everybody_invents_statements"><b>
Isn't the code unreadable if everybody invents new statements?
</b></a></li>
<li><a href="#lisp_comparison"><b>
Hasn't Lisp already user defined statements and operators?
</b></a></li>
<li><a href="#static_type_checking"><b>
Why does Seed7 use static type checking?
</b></a></li>
<li><a href="#development_speed_and_type_checking"><b>
Is the program development slowed down with static type checking?
</b></a></li>
<li><a href="#type_inference"><b>
Why does Seed7 not use type inference?
</b></a></li>
<li><a href="#automatic_casts"><b>
Are there automatic casts to the right type?
</b></a></li>
<li><a href="#declare_later"><b>
Can I use something and declare it later?
</b></a></li>
<li><a href="#overloading"><b>
Can functions be overloaded?
</b></a></li>
<li><a href="#overload_result"><b>
Can I overload two functions which just differ by the result type?
</b></a></li>
<li><a href="#variable_parameters"><b>
Can functions have variable parameter lists?
</b></a></li>
<li><a href="#initialize_variables"><b>
Why is it necessary to initialize all variables?
</b></a></li>
<li><a href="#garbage_collection"><b>
Is there a garbage collection?
</b></a></li>
<li><a href="#object_oriented"><b>
Is Seed7 object oriented?
</b></a></li>
<li><a href="#inherited_from_object"><b>
Is everything inherited from object?
</b></a></li>
<li><a href="#multiple_dispatch"><b>
What is multiple dispatch?
</b></a></li>
<li><a href="#container_classes"><b>
What container classes do exist?
</b></a></li>
<li><a href="#primitive_types"><b>
Are there primitive types?
</b></a></li>
<li><a href="#object_and_primitive_types"><b>
What is the difference between object and primitive types?
</b></a></li>
<li><a href="#when_use_object_or_primitive_types"><b>
When to use an object type and when a primitive type?
</b></a></li>
<li><a href="#how_does_the_assignment_work"><b>
How does the assignment work?
</b></a></li>
<li><a href="#two_forms_of_assignment"><b>
Why are there two forms of assignment?
</b></a></li>
<li><a href="#types of parameters"><b>
What types of parameters does Seed7 have?
</b></a></li>
<li><a href="#constructors"><b>
Where are the constructors?
</b></a></li>
<li><a href="#static_methods"><b>
Are there static methods / class methods?
</b></a></li>
<li><a href="#generics"><b>
Are there generics / templates?
</b></a></li>
<li><a href="#exceptions"><b>
Are there exceptions?
</b></a></li>
<li><a href="#action"><b>
What does action "XYZ_SOMETHING" mean?
</b></a></li>
<li><a href="#dollar_signs"><b>
Why are there dollar signs at some places?
</b></a></li>
<li><a href="#seed7_version_number"><b>
Why does "seed7_05.s7i" contain a version number?
</b></a></li>
<li><a href="#boot_a_language"><b>
Can I use an "abc.s7i" include file to boot to the abc language?
</b></a></li>
</ul><hr>
<p></p><!--*)-->

<p><br><a name="new_language"><h3>Why a new programming language?
</h3></a><hr><!-- =============================== -->
<p>
Because Seed7 has several features which are not found in other
programming languages:
</p><ul>
<li><!--  -  -->The possibility to declare new statements (syntactical and
   semantically) in the same way as functions are declared (There are
   also user definable operators with priority and associativity).</li>
<li><!--  -  -->Declaration constructs for constant-, variable-, function-,
   parameter-, and other declarations are described in Seed7 (The user
   can change existing declaration constructs or invent new ones).</li>
<li><!--  -  -->Templates use no special syntax. They are just functions
   with type parameters or a type result.</li>
<li><!--  -  -->Seed7 has abstract data types. For example the types
   array, hash, struct and set. They are not hard coded in the compiler,
   but are templates written in Seed7. User defined abstract datatypes
   are also possible.</li>
<li><!--  -  -->The object orientation of Seed7 allows multiple
   dispatch. That means that a function or method is connected to more
   than one type.</li>
<li><!--  -  -->Seed7 is a syntactically and semantically extensible
   language: Almost all of the Seed7 language (statements, operators,
   declaration constructs, and more) is defined in Seed7 in an include
   file (seed7_05.s7i).</li>
<li><!--  -  -->The application program contains an include statement and
   the hi interpreter is booted with the language description when it
   starts. This way it is possible to define language variants or a
   totally different language.</li>
</ul></p>

<p><br><a name="extensible_programming"><h3>What is an extensible programming language?
</h3></a><hr><!-- =========================================== -->
<p>
An extensible programming language supports mechanisms to extend the
programming language, compiler/interpreter and runtime environment.
The programmer is allowed to define new language constructs such as
statements, declaration constructs and operators syntactically
and semantically. Most programming languages allow user defined
variables, functions and types, but they also use constructs which
are hardcoded in the compiler/interpreter. An extensible programming
language trys to avoid such hardcoded constructs in normal programs.
</p><p>
Extensible programming was an area of active research in the 1960s,
but in the 1970s the extensibility movement was displaced by the
abstraction movement. Todays software history gives almost no hint
that the extensible languages movement had ever occurred. In the
historical movement an extensible programming language consisted of
a base language providing elementary computing facilities, and a
meta-language capable of modifying the base language. A program then
consisted of meta-language modifications and code in the modified
base language. A popular approach to do language extension was the
use of macro definitions. The constructs of the base language were
implemented with hardcoded technics.
</p><p>
The design and development of Seed7 is based on independ research
which was done without knowing that the historic extensible
programming language movement existed. Although Seed7 has different
roots it reaches many of the original extensible programming language
goals. Seed7 differentiates between syntactic and semantic extensions.
</p></p>

<p><br><a name="portable"><h3>Are Seed7 programs portable?
</h3></a><hr><!-- ============================ -->
<p>
Yes. Seed7 spares no effort to support portable programming.
Several driver librarys assure that the access to operating system
resources such as files, directorys, network, clock, keyboard,
console and graphics are done in a portable way. Many functions
are defined to avoid the need to use shell (and cmd.exe) commands.
</p><ul>
<li><!--  -  -->Different ways to encode unicode strings (e.g.: UTF-8 or
   UTF-16) in system calls (e.g. fopen()/wopen()) are hidden from the
   programmer.</li>
<li><!--  -  -->Seed7 defines portable funtions to copy, move and remove
   files, directory trees and files with other types.</li>
<li><!--  -  -->The propertys of files such as size, type, time and mode
   can be obtained and changed with portable functions.</li>
<li><!--  -  -->A forward slash is used as path delimiter on all
   operating systems and an attempt to use a backslash as path delimiter
   is an error.</li>
<li><!--  -  -->Differences between UNIX sockets and winsockets
   are hidden and Seed7 sockets are files (as in UNIX).</li>
<li><!--  -  -->Reading keys and key combinations such as ctrl-F1 from
   a text console or a graphic window under different operating systems
   always delivers the same character code.</li>
<li><!--  -  -->Alternate code paths are provided to hide weaknesses
   of operating systems (E.g.: The windows utime() function does
   not work on directorys, but Seed7 allows to modify directory access
   and modification times also under windows).</li>
</ul></p>

<p><br><a name="license"><h3>Which license does Seed7 use?
</h3></a><hr><!-- ============================= -->
<p>
The hi Interpreter and the example programs (extension .sd7) are under the
GPL (General Public License, see also the file COPYING).
</p><p>
The Seed7 Runtime Library is under the LGPL (Lesser General Public License,
see also the file LGPL). The Seed7 include files (extension .s7i) are a part
of the Seed7 Runtime Library.
</p><p>
Seed7 allows the interpretation and compilation of programs with any license.
There is no restriction on the license of your Seed7 programs.
</p><p>
For the development of the Seed7 compiler it will be necessary to move some
source code from the hi Interpreter (under GPL) to the Seed7 Runtime Library
(under LGPL). This will only be done to for the Seed7 runtime library and only
as far as necessary to make no restriction on the license of compiled Seed7
programs.
</p><p>
If you send me patches (I would be very pleased), it is assumed that you
accept license changes from GPL to LGPL for parts of code which need to be
in the runtime library to support compilation of Seed7 programs.
</p></p>

<p><br><a name="free"><h3>But Java and C# are also free?
</h3></a><hr><!-- ============================== -->
<p>
Seed7 is "Free as in Freedom" and not only "Free as in Free Beer" and this can
make a big difference. Undocumented native interfaces are just not possible.
</p></p>

<p><br><a name="os"><h3>On which operating systems does Seed7 run?
</h3></a><hr><!-- ========================================== -->
<p>
Linux is supported out of the box (because the development is done using
Linux). I used Seed7 also under various UNIX variants, so it is probably
easy to port Seed7 to a UNIX variant. Windows is supported with MinGW,
Cygwin (it may be necessary to change some include or library paths),
the stand alone compiler of MSVC (cl.exe) and the stand alone compiler of
the BDS (bcc32.exe). For other operating systems it might be necessary to
write driver modules for screen (=text console), graphics, time or other
aspects of Seed7. The package contains various older driver modules
which are not up to date, but can be used as base to write such driver
modules. For more detailed information look at the files <nobr>'seed7/read_me'</nobr>
and <nobr>'seed7/src/read_me.txt'</nobr>.
</p></p>

<p><br><a name="uncompress"><h3>How do I uncompress the *.tgz file from the release?
</h3></a><hr><!-- ==================================================== -->
<p>
When you have a gnu <tt>'tar'</tt> program available you can just do
</p><pre>
  $ tar -xvzf seed7_05_yyyymmdd.tgz
</pre><p>
If your <tt>'tar'</tt> command does not accept the <tt>'z'</tt> option
you need to uncompress the file first with <tt>'gunzip'</tt>:
</p><pre>
  $ gunzip seed7_05_yyyymmdd.tgz
  $ tar -xvf seed7_05_yyyymmdd.tar
</pre><p>
Sometimes the browser downloads a *.gz file instead of a *.tgz file.
In that case you could also use <tt>'gunzip'</tt> as shown above. As
an alternative you can also use <tt>'zcat'</tt>:
</p><pre>
  $ zcat seed7_05_yyyymmdd.gz > s7.tar
  $ tar -xvf s7.tar
</pre><p>
Under windows you can use the 7-Zip compression/decompression utility
(there is no relationship to Seed7). 7-Zip is open source software and is
available at: <a href="http://www.7-zip.org">www.7-zip.org</a>.
</p></p>

<p><br><a name="compile_interpreter"><h3>How do I compile the Seed7 interpreter?
</h3></a><hr><!-- ======================================= -->
<p>
The way to compile the interpreter is dependend on the
operating system and the development tools used. You need a
stand alone C compiler and a make utility to compile the
interpreter. A C compiler which is only usable from an IDE
is not so useful, since some Seed7 programs (e.g. The
Seed7 to C compiler comp.sd7) need to call the C compiler
as well. To compile the interpreter under Linux just go to
the 'src' directory and type:
</p><pre>
    make depend
    make
</pre><p>
For other cases several makefiles are prepared for various
combinations of operating system, make utility, C compiler
and shell:
</p><pre>
  makefile name|operating system |make prog|compiler|shell
  -------------+-----------------+---------+--------+--------
  mk_linux.mak | linux/unix/bsd  | (g)make | gcc    | sh
  mk_cygw.mak  | windows (Cygwin)| (g)make | gcc    | sh
  mk_msys.mak  | windows (MinGW) | (g)make | gcc    | sh
  mk_mingw.mak | windows (MinGW) | (g)make | gcc    | cmd.exe
  mk_nmake.mak | windows (MinGW) | nmake   | gcc    | cmd.exe
  mk_msvc.mak  | windows (MSVC)  | nmake   | cl     | cmd.exe
  mk_bcc32.mak | windows (bcc32) | make    | bcc32  | cmd.exe
  mk_osx.mak   | Mac OS X (Xcode)| make    | gcc    | sh
</pre><p>
  In the optimal case you just copy one of this files to
  'makefile' and do:
</p><pre>
    make depend
    make
</pre><p>
  If you try different makefiles in succession you need to do
</p><pre>
    make clean
</pre><p>
  before you start a new attempt. More details about the
  compilation process can be found in the file
  <nobr>'seed7/src/read_me.txt'</nobr>.
</p></p>

<p><br><a name="errors"><h3>I got errors when compiling Seed7. What should I do?
</h3></a><hr><!-- ==================================================== -->
<p>
In most cases errors indicate that some development package of your
distribution is missing. If your operating system is Linux, BSD or UNIX
not all development packages with header files might be installed. In
this case you get some errors after typing 'make depend'. Errors such as
</p><pre>
  scr_inf.c:57:18: error: term.h: No such file or directory
  kbd_inf.c:55:18: error: term.h: No such file or directory
  trm_inf.c:47:18: error: term.h: No such file or directory
</pre><p>
indicate that the curses or ncurses development package is missing.
I don't know the name of this package in your distribution
(under Ubuntu it has the name libncurses5-dev), but you
can search in your package manager for a curses/ncurses
package which mentions that it contains the header files.
To execute programs you need also to install the non-developer
package of curses/ncurses (in most cases it will already
be installed because it is needed by other packages).
</p><p>
Errors such as
</p><pre>
  drw_x11.c:38:19: error: X11/X.h: No such file or directory
  drw_x11.c:39:22: error: X11/Xlib.h: No such file or directory
  drw_x11.c:40:23: error: X11/Xutil.h: No such file or directory
  drw_x11.c:45:24: error: X11/keysym.h: No such file or directory
</pre><p>
indicate that the X11 development package is missing.
Under Ubuntu this package has the name libx11-dev and is
described as: X11 client-side library (development headers)
Note that under X11 'client' means: The program which wants to
draw. A X11 'server' is the place where the drawings are displayed.
So you have to search for a X11 client developer package with
headers. If you use X11 in some way (you don't do everything
from the text console) the non-developer package of X11 will
already be installed.
</p><p>
Errors such as
</p><pre>
  echo char *getcwd(char *buf, size_t size); >> seed7lib.c
  /usr/bin/sh: -c: line 0: syntax error near unexpected token `('
</pre><p>
indicate that your makefile contains commands for the cmd.exe
(or command.com) windows console, but your 'make' program uses
a UNIX shell (/usr/bin/sh) to execute them. Either use a
makefile which uses UNIX shell commands (e.g. mk_msys.mak or
mk_cygw.mak) or take care that the 'make' program uses cmd.exe
(or command.com) to execute the commands.
</p><p>
Errors such as
</p><pre>
  hi.c:28:21: error: version.h: No such file or directory
</pre><p>
indicate that you forgot to run 'make depend' before running
'make'. Since such an attempt produces several unneeded files it
is necessary now to run 'make clean', 'make depend' and 'make'.
</p><p>
When you got other errors I would like to know about. Please
send a mail with detailed information (name and version) of
your operating system, distribution, compiler, the version of
Seed7 you wanted to compile and the complete log of error
messages to seed7-users@lists.sourceforge.net .
</p></p>

<p><br><a name="bytecode"><h3>Does the interpreter use bytecode?
</h3></a><hr><!-- ================================== -->
<p>
No, the analyze phase of the Seed7 interpreter produces call-code which consists
of values and function calls. This call-code is just handled in memory and
never written to a file. After the analyze phase the call-code is interpreted.
</p></p>

<p><br><a name="analyze"><h3>How does the analyze phase of the interpreter work?
</h3></a><hr><!-- =================================================== -->
<p>
The analyzer reads successive expressions according to the syntax definitions.
For each expression the analyzer searches the internal database of declared
objects (this search process is called matching) and generates call-code for
this expression. Then the call code for this expression is executed. Normally
this expressions are declaration statements. In that case new declared objects
are added to the internal database.
</p></p>

<p><br><a name="compile"><h3>Is it possible to compile Seed7 programs?
</h3></a><hr><!-- ========================================= -->
<p>
Generally Seed7 is designed to allow the compilation from Seed7 to C. The Seed7
compiler (written in Seed7) uses the analyze phase of the interpreter to convert
a program to call-code and then generates a corresponding C program. This C
program is compiled and linked afterwards.
(Note that the compiler is currently not finished)
</p></p>

<p><br><a name="reserved_words"><h3>What are the reserved words of Seed7?
</h3></a><hr><!-- ===================================== -->
<p>
In Seed7 there are no reserved words. Instead there are keywords which are used
at various places. Some keywords introduce statements or other constructs (such
as declarations). E.g.: The keywords <tt>'<font color=blue>if</font>'</tt>, <tt>'<font color=blue>while</font>'</tt>, <tt>'<font color=blue>repeat</font>'</tt>, <tt>'<font color=blue>for</font>'</tt>, and some
others introduce statements. Other keywords like <tt>'<font color=blue>do</font>'</tt>, <tt>'<font color=blue>range</font>'</tt>, <tt>'<font color=blue>result</font>'</tt>, etc.
are used in the middle of statements (or other constructs). Finally there are
also keywords like <tt>'<font color=blue>div</font>'</tt>, <tt>'<font color=blue>rem</font>'</tt>, <tt>'<font color=blue>lpad</font>'</tt>, <tt>'<font color=blue>times</font>'</tt>, etc. which are used as
operator symbols.
</p><p>
Seed7 uses syntax declarations to specify the syntax of statements. A keyword
is a name which is used somewhere in a syntax declaration. Syntax declarations
reduce the possibilities to use a keyword out of context. E.g.: After the keyword
<tt>'<font color=blue>if</font>'</tt> the parser expects always an expression. This makes <tt>'<font color=blue>if</font>'</tt> unusable as
variable name. This way you get error messages when you try to use <tt>'<font color=blue>if</font>'</tt> or
other keywords as variable name. That behaviour is just the same as in other
languages which have reserved words. It can be summarized that Seed7 reaches
the goal of avoiding the misuse of keywords in other ways and not by reserving
them altogether.
</p><p>
In a classic compiler (e.g. a Pascal compiler) there is a distinction between
reserved words and identifiers. Pascal compilers and probably also Ada, C/C++,
Java and C# compilers use an enumeration type to represent the reserved words.
Since Seed7 allows user defined statements (which may introduce new keywords)
it is not possible to hard code reserved words in the compiler as it is done in
Pascal, Ada, C/C++, Java and many other compilers.
</p></p>

<p><br><a name="statements"><h3>Why does Seed7 not use the C statements like C++ and Java?
</h3></a><hr><!-- ========================================================== -->
<p>
The C statements have some weaknesses which are avoided with the Seed7 statements:
</p><p>
<!--  1.  -->The C if-statement
</p><pre>
      <font color=blue>if</font> (condition)
        statement;
</pre><p>
    allows just one statement after the condition. By using the compound statement
    it is possible to have several statements after the condition
</p><pre>
      <font color=blue>if</font> (condition) {
        statement1;
        statement2;
      }
</pre><p>
    Adding or removing a statement in the second if-statement is always possible.
    In the first if-statement you must add braces if you add a statement otherwise
    you get an undesired effect. Adding statements to an if-statement is quite common.
</p><p>
    Since both forms are legal and adding a statement to the first form can lead to
    errors Seed7 closes this possible source of errors with its if-statement:
</p><pre>
      <font color=blue>if</font> condition <font color=blue>then</font>
        statement
      <font color=blue>end if</font>;
</pre><p>
<!--  2.  -->The following switch statement is formally correct but probably wrong
</p><pre>
      <font color=blue>switch</font> (number) {
        <font color=blue>case</font> 1:
        <font color=blue>case</font> 2:
          result = 5;
        <font color=blue>case</font> 3:
        <font color=blue>case</font> 4:
          result = 8;
          <font color=blue>break</font>;
        <font color=blue>default</font>:
          result = 0;
      }
</pre><p>
    Forgetting break statements in a switch is another possible source of errors which
    is avoided in Seed7:
</p><pre>
      <font color=blue>case</font> number <font color=blue>of</font>
        <font color=blue>when</font> {1, 2}:
          result = 5;
        <font color=blue>when</font> {3, 4}:
          result = 8;
        <font color=blue>otherwise</font>:
          result = 0;
      <font color=blue>end case</font>;
</pre></p>

<p><br><a name="everybody_invents_statements"><h3>Isn't the code unreadable if everybody invents new statements?
</h3></a><hr><!-- ============================================================== -->
<p>
There are lots of possibilities to write unreadable code without
using the extension features of Seed7. The programmer is (as always)
responsible to write readable programs. The variable/type/function
names and other things chosen by the programmer can always lead to
obfuscated code.
</p><p>
Defining new statements and operators is a feature which should not
be used in every program by every programmer. It is a feature which
allows experienced programmers, to write libraries which use statement
or operator syntax instead of function syntax, in areas where such a
notation is already accepted practice.
</p><p>
Statements to access a database or operators for vector arithmetic
would be such an example. Another example is a construct which can
be used in the definition of text adventure games.
</p><p>
The possibility to define statements allows also a more precise language
definition. The C++ for/while/if statements are described in the C++
manuals using BNF and an English description. Seed7 statements can be
defined in Seed7. For example:
</p><pre>
  $ <font color=blue>syntax</font> <font color=red>expr</font>: while.().do.().end.while <font color=blue>is</font> -> 25;

  <font color=blue>const</font> <font color=red>proc</font>: while (<font color=blue>ref</font> <font color=red>func boolean</font>: condition) do
                (<font color=blue>ref</font> <font color=red>proc</font>: statement)
              end while <font color=blue>is func</font>
    <font color=blue>begin</font>
      <font color=blue>if</font> condition <font color=blue>then</font>
        statement;
        <font color=blue>while</font> condition <font color=blue>do</font>
          statement;
        <font color=blue>end while</font>;
      <font color=blue>end if</font>;
    <font color=blue>end func</font>;
</pre><p>
The syntax and semantic of a while statement is described using an
if statement and recursion. For performance reasons the implementation
will usually use a different approach to implement a while loop, but
this example shows the expressive power of Seed7.
</p></p>

<p><br><a name="lisp_comparison"><h3>Hasn't Lisp already user defined statements and operators?
</h3></a><hr><!-- ========================================================== -->
<p>
Defining the semantic of a new 'statement' in Lisp is a classic example.
Normally such 'statements' still use the list notation with lots of parentheses.
The read macros of Lisp could be used to define the syntax of a statement, but
read macros make no type checks at compile time. Any type checking must be written
by the programmer and is not mandated by Lisp. The type checks will be performed
at runtime and might issue warnings at compile time (this is implementation
dependent). In general: Lisp 'statement' declarations do not force compile time
checks and look less elegant. Seed7 statement declarations force a type check at
compile time.
</p><p>
While Lisp allows new and overloaded functions, the Lisp 'operators' are
functions which use the prefix notation (with lots of parentheses).
Again read macros could be used to support infix operators with priority
and associativity. This read macros would have the same problems as above.
Although Lisp fanatics would never admit it, infix operators with priority
and associativity are not really supported by Lisp. If somebody tells you
that everything can be done in Lisp, send him to the next advocacy group.
In general: Seed7 supports user definable infix operators with priority and
associativity. Such operators can be overloaded and the type checks are done
at compile time. In Lisp all this would be a hack.
</p></p>

<p><br><a name="static_type_checking"><h3>Why does Seed7 use static type checking?
</h3></a><hr><!-- ======================================== -->
<p>
With static type checking all type checks are performed during compile-time.
Type errors, such as an attempt to divide an integer by a string, can be
caught earlier (unless this unusual operation has been defined). The key point
is that type errors are found without the need to execute the program. Some
type errors can be hidden in rarely executed code paths. Static type checking
can find such errors easily. With dynamic type checking extensive tests are
necessary to find all type errors. Even tests with 100% code coverage are not
enough since the combination of all places where values are created and all
places where these values are used must be taken into account. That means that
testing cannot guarantee to find all type errors that a static type checker
can find. Additionally it would be necessary to repeat all tests every time
the program is changed. Naturally there are doubts that enough tests are done
and that the tests are adjusted and repeated for every change in the program.
Therefore it can be said that compile-time type checks increase the reliability
of the program.
</p><p>
Seed7 makes sure that the object values always have the type of the object.
This goal is reached with mechanisms like mandatory initialisation, runtime
checks and the impossibility to change arbitrary places in memory. When the
generation of garbage values is avoided, it can be guaranteed that only legal
values of the correct type are used as object values. This way runtime type
checks are unnecessary and the program execution can be more efficient.
</p><p>
Type declarations can also serve as a form of documentation, because they can
illustrate the intent of the programmer. Although static type checking is very
helpful in finding type errors, it cannot replace a careful program design.
Some operations, allowed by the static type system, can still be wrong because
of different measurement units or other reasons. In the end there are also
other possible sources of errors, such as range violations.
</p><p>
Interface types can be used when an object can have several types at runtime.
In this case the interface type of the object can be determined at compile-time
and the type of the object value (implementation type) can vary at runtime.
The static type checking can still check the interface type and the presence
of interface functions. Additionally the compiler can also check that all
functions granted by the interface type are defined for the implementation type.
</p></p>

<p><br><a name="development_speed_and_type_checking"><h3>Is the program development slowed down with static type checking?
</h3></a><hr><!-- ======================================== -->
<p>
No, especially when the time spent to debug a program is taken into account.
Except for artificial corner cases all type errors found by a "nitpicking"
compiler correspond to runtime type errors that can happen in a dynamically
typed language under some circumstances. That way the compile-time type checks
save the time necessary to find and debug those errors. The time that a compiler
needs to find and flag type errors is so small that it can be ignored in this
comparison.
</p><p>
Some people claim, that adding type information to a program is a time consuming
process. This is only true when the type information is added afterwards, but
it is wrong when type considerations take place during the program development.
Every good programmer has some concepts about what values will be hold by
variables or parameters and what values will be returned by functions. A good
type system helps to formalize the type concepts which are already in the mind of
the programmer. That way the ideas of the programmer are also documented.
</p><p>
When comparing compile-time and runtime type checking it can be concluded that
dynamic typed languages save some programming time by omitting type
declarations, but this time must be paid back with massive interest rates to do
the debugging.
</p></p>

<p><br><a name="type_inference"><h3>Why does Seed7 not use type inference?
</h3></a><hr><!-- ====================================== -->
<p>
Seed7 has a basic principle that would break if type
inference would be used:
</p><pre>
  For every expression (and sub expression) you know its type at
  compile time without knowing where this expression is used.
</pre><p>
It is exactly the violation of this principle that makes type
inference possible. As long as this principle holds you need
to know the global and local declarations to find out the result
type of an expression. With type inference it is necessary to
take other expressions in the local function and even expressions
in other functions into account. I do not say that this is not
possible (for sure it is an interesting challenge to invent an
algorithm to do this). But the reader of the program needs to use
this algorithm also every time he/she reads the program. And that
is very bad since a program is more often read than written.
</p></p>

<p><br><a name="automatic_casts"><h3>Are there automatic casts to the right type?
</h3></a><hr><!-- ============================================ -->
<p>
No, because Seed7 is strong typed. This means that for every expression (and sub expression)
you know its type at compile time without knowing where this expression is used.
Although this means that you have to convert types explicit (for example from integer
to float) it has more advantages than disadvantages:
</p><ol>
<li><!--  1.  -->The overloading rules are much simpler.</li>
<li><!--  2.  -->An expression can be understood without it's calling context.</li>
<li><!--  3.  -->Errors caused by unplanned automatic type conversions cannot happen.</li>
<li><!--  4.  -->Since you have to do type conversions explicit you are more aware of the
    run time overhead.</li>
</ol></p>

<p><br><a name="declare_later"><h3>Can I use something and declare it later?
</h3></a><hr><!-- ========================================= -->
<p>
No, everything must be declared before it is used. The possibility to declare new
statements and new operators on one side and the static typing requirements with
compile time checks of the parameters on the other side would make the job of analyzing
expressions with undeclared functions very complex.
</p><p>
Forward declarations help, if something needs to be used before it can be declared fully.
</p></p>

<p><br><a name="overloading"><h3>Can functions be overloaded?
</h3></a><hr><!-- ============================ -->
<p>
Yes, functions, operators and statements can be overloaded. Additionally it is possible
to define new operators and statements.
</p></p>

<p><br><a name="overload_result"><h3>Can I overload two functions which just differ by the result type?
</h3></a><hr><!-- ================================================================== -->
<p>
No, it is not possible to overload a function (operator, statement) which has
the same parameter types and just a different result type as another function. This is
necessary to reach the goal of knowing the type of every expression without knowing
where the expression is used.
</p></p>

<p><br><a name="variable_parameters"><h3>Can functions have variable parameter lists?
</h3></a><hr><!-- ============================================ -->
<p>
No, because functions with variable parameter list as the C printf function have
some problems:
</p><ul>
<li><!--  -  -->Normally type checking is only possible at run time.</li>
<li><!--  -  -->The recognition of overloaded functions becomes more complicated.</li>
</ul><p>
Instead Seed7 has array aggregates and allows functions with arrays as parameters.
So you could declare a function
</p><pre>
  <font color=blue>const</font> <font color=red>proc</font>: print_list (<font color=blue>in</font> <font color=red>array integer</font>: arr) <font color=blue>is func</font>
    <font color=blue>local</font>
      <font color=blue>var</font> <font color=red>integer</font>: number <font color=blue>is</font> 0;
    <font color=blue>begin</font>
      <font color=blue>for</font> number <font color=blue>range</font> arr <font color=blue>do</font>
        writeln(number);
      <font color=blue>end for</font>;
    <font color=blue>end func</font>;
</pre><p>
and call it with
</p><pre>
  print_list([](1, 1, 2, 3, 5, 8, 13, 21, 34, 55));
</pre></p>

<p><br><a name="initialize_variables"><h3>Why is it necessary to initialize all variables?
</h3></a><hr><!-- ================================================ -->
<p>
Forgetting to initialize a variable is a common source of errors. In some programming
languages uninitialized variables have a random value which could lead to errors.
To avoid errors caused by uninitialized variables in Seed7 each variable must be
initialized when it is declared.
</p></p>

<p><br><a name="garbage_collection"><h3>Is there a garbage collection?
</h3></a><hr><!-- ============================== -->
<p>
There is no garbage collection process that interrupts the normal processing to
free some memory. Seed7 uses a different mechanism to manage the memory.
</p><p>
Memory used by local variables and parameters is automatically freed when leaving
a function.
</p><p>
Although functions can return arbitrary complex values (e.g. arrays of structures
with string elements) the memory allocated for all intermediate results is freed
automatically without the help of a garbage collector. This is done in a stack
like manner. The same way as arithmetic expressions like (1+2)*3+4 can be evaluated
with the help of a stack (which stores the intermediate results 3 and 9), it is
possible to maintain a stack of pointers to arbitrary complex values. Note that
the point where such intermediate results should be freed can be determined at
compile time. Functions such as the assignment, can abstain from freeing the
intermediate result and just assign it to the variable. This way it is not
always necessary to copy arbitrary complex values. All this things can be decided
at compile time.
</p></p>

<p><br><a name="object_oriented"><h3>Is Seed7 object oriented?
</h3></a><hr><!-- ========================= -->
<p>
Yes, but object orientation is organized different compared to other object
oriented languages.
</p><p>
An example of an object oriented type is <tt>'<font color=red>file</font>'</tt>. A <tt>'<font color=red>file</font>'</tt> describes references to
values with some other type. A value of a <tt>'<font color=red>file</font>'</tt> can have one of the following types:
null_file, external_file, echo_file, line_file, etc. Each of this <tt>'<font color=red>file</font>'</tt> value types
acts differently to the same requests.
</p><p>
For the type <tt>'<font color=red>file</font>'</tt> two kinds of functions are defined:
<ol>
<li><!--  1.  -->Functions which work for all files the same way.</li>
<li><!--  2.  -->Dynamic functions which are just an interface. At run time the corresponding
    function defined for the type of the value is used.</li>
</ol></p><p>
Compared to Java the type file can be seen as interface or abstract class, while the
type of the file value can be seen as the class implementing the interface.
</p></p>

<p><br><a name="inherited_from_object"><h3>Is everything inherited from object?
</h3></a><hr><!-- ==================================== -->
<p>
There can be several base types, each with their own hierarchy. In many object
oriented languages the class <tt>'<font color=red>object</font>'</tt> is used as element of all container classes.
Abstract data types provide a better and type safe solution for containers and
other uses of the root class <tt>'<font color=red>object</font>'</tt>. Therefore a single rooted hierarchy is not
needed.
</p></p>

<p><br><a name="multiple_dispatch"><h3>What is multiple dispatch?
</h3></a><hr><!-- ========================== -->
<p>
Multiple dispatch means that a function or method is connected to more
than one type. The decision which method is called at runtime is done
based on more than one of its arguments. The classic object orientation
is a special case where a method is connected to one class and the dispatch
decision is done based on the type of the <tt>'self'</tt> or <tt>'this'</tt> parameter.
The classic object orientation is a single dispatch system.
</p><p>
In a multiple dispatch system the methods cannot be grouped to one class
and it makes no sense to have a <tt>'self'</tt> or <tt>'this'</tt> parameter.
All parameters are taken into account when the dispatch decision is done.
In the following example the interface type <tt>'<font color=red>Number</font>'</tt> uses multiple dispatch:
</p><pre>
  <font color=blue>const</font> <font color=red>type</font>: Number <font color=blue>is sub</font> <font color=red>object</font> <font color=blue>interface</font>;

  <font color=blue>const</font> <font color=red>func Number</font>: (<font color=blue>in</font> <font color=red>Number</font> <font color=blue>param</font>) + (<font color=blue>in</font> <font color=red>Number</font> <font color=blue>param</font>) <font color=blue>is DYNAMIC</font>;
</pre><p>
The <tt>'<font color=blue>DYNAMIC</font>'</tt> declaration creates an interface function for the <tt>'+'</tt> operator.
The interface type <tt>'<font color=red>Number</font>'</tt> can represent an <tt>'<font color=red>Integer</font>'</tt> or a <tt>'<font color=red>Float</font>'</tt>:
</p><pre>
  <font color=blue>const</font> <font color=red>type</font>: Integer <font color=blue>is new struct</font>
      <font color=blue>var</font> <font color=red>integer</font>: val <font color=blue>is</font> 0;
    <font color=blue>end struct</font>;

  type_implements_interface(<font color=red>Integer</font>, <font color=red>Number</font>);

  <font color=blue>const</font> <font color=red>type</font>: Float <font color=blue>is new struct</font>
      <font color=blue>var</font> <font color=red>float</font>: val <font color=blue>is</font> 0.0;
    <font color=blue>end struct</font>;

  type_implements_interface(<font color=red>Float</font>, <font color=red>Number</font>);
</pre><p>
The declarations of the converting <tt>'+'</tt> operators are:
</p><pre>
  <font color=blue>const</font> <font color=red>func Float</font>: (<font color=blue>in</font> <font color=red>Integer</font>: a) + (<font color=blue>in</font> <font color=red>Float</font>: b) <font color=blue>is func</font>
    <font color=blue>result</font>
      <font color=blue>var</font> <font color=red>Float</font>: result <font color=blue>is</font> <font color=red>Float</font>.value;
    <font color=blue>begin</font>
      result.val := flt(a.val) + b.val;
    <font color=blue>end func</font>;

  <font color=blue>const</font> <font color=red>func Float</font>: (<font color=blue>in</font> <font color=red>Float</font>: a) + (<font color=blue>in</font> <font color=red>Integer</font>: b) <font color=blue>is func</font>
    <font color=blue>result</font>
      <font color=blue>var</font> <font color=red>Float</font>: result <font color=blue>is</font> <font color=red>Float</font>.value;
    <font color=blue>begin</font>
      result.val := a.val + flt(b.val);
    <font color=blue>end func</font>;
</pre><p>
The declarations of the normal <tt>'+'</tt> operators (which do not convert) are:
</p><pre>
  <font color=blue>const</font> <font color=red>func Integer</font>: (<font color=blue>in</font> <font color=red>Integer</font>: a) + (<font color=blue>in</font> <font color=red>Integer</font>: b) <font color=blue>is func</font>
    <font color=blue>result</font>
      <font color=blue>var</font> <font color=red>Integer</font>: result <font color=blue>is</font> <font color=red>Integer</font>.value;
    <font color=blue>begin</font>
      result.val := a.val + b.val;
    <font color=blue>end func</font>;

  <font color=blue>const</font> <font color=red>func Float</font>: (<font color=blue>in</font> <font color=red>Float</font>: a) + (<font color=blue>in</font> <font color=red>Float</font>: b) <font color=blue>is func</font>
    <font color=blue>result</font>
      <font color=blue>var</font> <font color=red>Float</font>: result <font color=blue>is</font> <font color=red>Float</font>.value;
    <font color=blue>begin</font>
      result.val := a.val + b.val;
    <font color=blue>end func</font>;
</pre><p>
The decision which <tt>'+'</tt> operator should be called at runtime is based on the
implementation type (<tt>'<font color=red>Integer</font>'</tt> or a <tt>'<font color=red>Float</font>'</tt>) of both arguments of the <tt>'+'</tt>.
</p></p>

<p><br><a name="container_classes"><h3>What container classes do exist?
</h3></a><hr><!-- ================================ -->
<p>
Abstract data types are used to replace container classes. When using an
abstract data type as container you have to specify the type of the element
in the type declaration. Therefore abstract data types are always type safe.
Typeless container classes with object elements do not exist. The only thing
which comes near to this is the <tt>'<font color=red>ref_list</font>'</tt> which is used in the reflection.
A <tt>'<font color=red>ref_list</font>'</tt> should not be misused as container class. Predefined abstract
data types are:
</p><dl>
<dt><!--  -  --><a href="manual/types.htm#array">array</a></dt><dd>
   The type <tt>'<font color=red>array baseType</font>'</tt> describes sequences of identical elements of
   a <tt>'<font color=red>baseType</font>'</tt></dd>

<dt><!--  -  --><a href="manual/types.htm#hash">hash</a></dt><dd>
   The type <tt>'<font color=red>hash [keyType] baseType</font>'</tt> describes hash tables with elements
   of <tt>'<font color=red>baseType</font>'</tt> which can be accessed using an index of <tt>'<font color=red>keyType</font>'</tt></dd>

<dt><!--  -  --><a href="manual/types.htm#set">set</a></dt><dd>
   The type <tt>'<font color=red>set of baseType</font>'</tt> describes a set of elements of a <tt>'<font color=red>baseType</font>'</tt></dd>

<dt><!--  -  --><a href="manual/types.htm#struct">struct</a></dt><dd>
   The type <tt>'<font color=red>struct ... end struct</font>'</tt> describes all structured types.</dd>
</dl><p>
Usage examples of abstract data types are:
</p><pre>
  <font color=red>array string</font>
  <font color=red>array [boolean] string</font>
  <font color=red>hash [string] boolean</font>
  <font color=red>hash [string] array array string</font>
  <font color=red>set of char</font>
  <font color=red>set of integer</font>
</pre></p>

<p><br><a name="primitive_types"><h3>Are there primitive types?
</h3></a><hr><!-- ========================== -->
<p>
As in C++, Java, C# and other hybrid object oriented languages there are
predefined primitive types in Seed7. These are <a href="manual/types.htm#integer">integer</a>, <a href="manual/types.htm#char">char</a>, <a href="manual/types.htm#boolean">boolean</a>, <a href="manual/types.htm#string">string</a>,
<a href="manual/types.htm#float">float</a>, <a href="manual/types.htm#rational">rational</a>, <a href="manual/types.htm#time">time</a>, <a href="manual/types.htm#duration">duration</a> and others. Additionally to the predefined
primitive types there is also the possibility to declare new primitive types.
</p></p>

<p><br><a name="object_and_primitive_types"><h3>What is the difference between object and primitive types?
</h3></a><hr><!-- ========================================================== -->
<p>
Variables with object types contain references to object values. This means
that after
</p><pre>
  a := b
</pre><p>
the variable 'a' refers to the same object as variable 'b'. Therefore changes
of the object value that 'a' refers to, will effect variable 'b' as well (and
vice versa) because both variables refer to the same object.
</p><p>
For primitive types a different logic is used. Variables with primitive types
contain the value itself. This means that after
</p><pre>
  a := b
</pre><p>
both variables are still distinct and changing one variable has no effect on
the other.
</p><p>
If 'a' and 'b' are declared to have type <tt>'<font color=red>aType</font>'</tt> which contains the integer
field 'property' you can do the following:
</p><pre>
  b.property := 1;
  a := b;
  b.property := 2;
</pre><p>
Everything boils down to the question: What value does <tt>'a.property'</tt> have now.
</p><ul>
<li><!--  -  -->When <tt>'<font color=red>aType</font>'</tt> is an object type a.property has the value 2 because 'a' and 'b'
   both refer to the same object.</li>
<li><!--  -  -->When <tt>'<font color=red>aType</font>'</tt> is a primitive type a.property has still the value 1 because 'a'
   and 'b' are distinct objects.</li>
</ul></p>

<p><br><a name="when_use_object_or_primitive_types"><h3>When to use an object type and when a primitive type?
</h3></a><hr><!-- ===================================================== -->
<p>
You should declare a new primitive type if you don't need the object
oriented paradigm that a variable (and a constant) is just a reference
to the object. Another indication is: If you don't need two concepts of
what is equal (An == operator and an equal method).
</p></p>

<p><br><a name="how_does_the_assignment_work"><h3>How does the assignment work?
</h3></a><hr><!-- ============================= -->
<p>
For object types just the reference to the object value is copied. For
primitive types the value itself is copied. Since values can be very big
(think of arrays of structs with string elements) value copies can be time
consuming.
</p><p>
In pure object oriented languages the effect of independent objects after
the assignment is reached in a different way: Every change to an object
creates a new object and therefore the time consuming copy takes place with
every change. Because usually changes to an object are more frequent than
assignments this approach can be even more time consuming than the approach
using value copies for the assignment.
</p></p>

<p><br><a name="two_forms_of_assignment"><h3>Why are there two forms of assignment?
</h3></a><hr><!-- ====================================== -->
<p>
Seed7 has an approach for the assignment where practical arguments count
more than the classic object oriented principles. In Seed7 every type has
its own logic for the assignment where sometimes a value copy and sometimes
a reference copy is the right thing to do. Exactly speaking there are many
forms of assignment since every type can define its own assignment. If a
value copy works like a deep or a shallow copy can also be defined depending
on the type. 
</p><p>
For example: For <tt>'<font color=red>integer</font>'</tt>, <tt>'<font color=red>char</font>'</tt>, <tt>'<font color=red>string</font>'</tt> variables a value copy is what most
people expect. For files you don't expect the whole file to be copied with
an assignment, therefore a reference copy seems appropriate.
</p><p>
And by the way:
Although it is always stated that in object oriented languages everything
is done with methods, this is just not true. Besides statements and operators
in C++ and Java which are special even Smalltalk treats the assignment and
the comparison special. Seed7 does not have such special treatment for the
assignment and the comparison operators.
</p></p>

<p><br><a name="types of parameters"><h3>What types of parameters does Seed7 have?
</h3></a><hr><!-- ========================================= -->
<p>
There are value and reference parameters. The formal parameter can be constant or
variable. The combination of these features allows four types of parameters:
</p><pre>
    +-----------+-----------+--------------+
    | parameter |  call by  | access right |
    +-----------+-----------+--------------+
    | val       |   value   | const        |
    | ref       | reference | const        |
    | in var    |   value   | var          |
    | inout     | reference | var          |
    +-----------+-----------+--------------+
</pre><p>
Additionally every type defines an <tt>'<font color=blue>in</font>'</tt> parameter which is either a <tt>'<font color=blue>val</font>'</tt> or a
<tt>'<font color=blue>ref</font>'</tt> parameter. Types with little memory requirements like <tt>'<font color=red>integer</font>'</tt>, <tt>'<font color=red>char</font>'</tt>
or <tt>'<font color=red>boolean</font>'</tt> use a <tt>'<font color=blue>val</font>'</tt> parameter as <tt>'<font color=blue>in</font>'</tt>. Other types like <tt>'<font color=red>string</font>'</tt>, arrays
and structs use a <tt>'<font color=blue>ref</font>'</tt> parameter as <tt>'<font color=blue>in</font>'</tt>. Usually it is not necessary to
care if an <tt>'<font color=blue>in</font>'</tt> parameter is by value or by reference.
</p></p>

<p><br><a name="constructors"><h3>Where are the constructors?
</h3></a><hr><!-- =========================== -->
<p>
Seed7 does not need constructors, but you can define normal functions which
create a new value in a similar way as constructors do it.
</p><p>
Seed7 uses a special create statement ( ::= ) to initialize objects.
Explicit calls of the create statement are not needed.
</p><p>
The lifetime of an object goes like this:
</p><ol><li>
<!-- 1.  -->Memory is reserved for the new object (stack or heap memory make no difference here).
</li><li>
<!-- 2.  -->The content of the new memory is undefined (It may contain garbage), therefore a
   create statement is necessary instead of an assignment.
</li><li>
<!-- 3.  -->The create statements copies the right expression to the left expression taking
   into account that the left expression is undefined.
</li><li>
<!-- 4.  -->If the object is variable other values can be assigned using the assign statement ( := ).
   The assignment can assume that the left expression contains a legal value. This allows
   that for strings (and some other types which are just references to a memory area) the
   memory containing the old string value (and not the memory of the object itself) can
   be freed when necessary.
</li><li>
<!-- 5.  -->At the end of the lifetime of an object the destroy statement is executed.
   For strings (and some other types which are just references to a memory area) the memory
   containing the string value (and not the memory of the object itself) is freed.
</li><li>
<!-- 6.  -->The memory of the object is freed.
</li></ol><p>
The first three steps are usually hidden in the declaration statement.
</p></p>

<p><br><a name="static_methods"><h3>Are there static methods / class methods?
</h3></a><hr><!-- ========================================= -->
<p>
Seed7 allows defining functions (procedures and statements) without corresponding
class. When this is not desired Seed7 uses a special parameter, the <tt>'attr'</tt> (attribute)
parameter, to archive the functionality of static methods (elsewhere named class
methods) in a more general way. How a static method is declared is shown in the
following example:
</p><pre>
  <font color=blue>const</font> <font color=red>func integer</font>: convert_to (<font color=blue>attr</font> <font color=red>integer</font>, <font color=blue>in</font> <font color=red>char</font>: ch) <font color=blue>is func</font>
    <font color=blue>result</font>
      <font color=blue>var</font> <font color=red>integer</font>: result <font color=blue>is</font> 0;
    <font color=blue>begin</font>
      result := ord(ch);
    <font color=blue>end func</font>;
</pre><p>
The function <tt>'convert_to'</tt> can be called as
</p><pre>
  number := convert_to(<font color=red>integer</font>, 'a');
</pre><p>
Since the result of a function is not used to determine an overloaded function, this
is sometimes the only way to use the same function name for different purposes as in:
</p><pre>
  ch   := convert_to(<font color=red>char</font>,    1);
  stri := convert_to(<font color=red>string</font>,  1);
  ok   := convert_to(<font color=red>boolean</font>, 1);
  num  := convert_to(typeof(num), 1);
</pre><p>
Attribute parameters allow a function to be attached to a certain type. But this concept
is much more flexible than static methods (or class methods). A function can also
have several <tt>'attr'</tt> parameters and <tt>'attr'</tt> parameters can be at any parameter position (not
just the first parameter). Furthermore the type can be the result of a function as for
example typeof(num).
</p>

<p><br><a name="generics"><h3>Are there generics / templates?
</h3></a><hr><!-- =============================== -->
<p>
The generics (templates) of Ada, C++ and Java use a special
syntax. In Seed7 you get this functionality for free without
special syntax or other magic.
</p><p>
Generally all Seed7 functions can be executed at compile time
or at runtime. The time of the function execution depends on
the place of the call. A Seed7 program consists of a sequence
of declarations, which are executed one by one at compile time.
Since declarations are just a form of statement it can be
concluded that other statements can as well be used at the top
level.
</p><p>
Seed7 uses the word template to describe a function which is
executed at compile time and declares some things while
executing (at compile time). Naturally a template function can
have parameters. Especially types as parameters are useful with
template functions. That way a template function can declare
objects with the type value of a parameter.
</p><p>
It is necessary to call template functions explicit.
They are not invoked implicit as the C++ template functions.
The explicit calls of template functions make it obvious
what it is going on. This way the program is easier to read.
</p></p>

<p><br><a name="exceptions"><h3>Are there exceptions?
</h3></a><hr><!-- ===================== -->
<p>
Yes, Seed7 has exceptions which are similar to the Ada and Java exceptions.
</p></p>

<p><br><a name="action"><h3>What does action "XYZ_SOMETHING" mean?
</h3></a><hr><!-- ====================================== -->
<p>
Actions are used to call a corresponding C function in the interpreter.
For example:
</p><p>
The action "INT_ADD" corresponds to the function 'int_add' in the file
<nobr>seed7/src/intlib.c</nobr> .
</p><p>
In the interpreter all action functions get the parameters as list.
The action functions take the parameters they need from the list, perform
the action and deliver a result.
</p></p>

<p><br><a name="dollar_signs"><h3>Why are there dollar signs at some places?
</h3></a><hr><!-- ========================================== -->
<p>
The $ is used to force the analyzer to use a hard coded expression recognition
instead of the configurable one. This mechanism is used to boot the Seed7 language:
</p><p>
At the beginning of the seed7_05.s7i file nothing is declared. This means that
no statements, no functions, no operators, no types and no variables are predefined.
To boot the Seed7 language the file syntax.s7i is included. The file syntax.s7i
contains only $ commands. First the type <tt>'<font color=red>type</font>'</tt> is declared. Declarations of other
types, system variables and syntax descriptions of operators and statements follow.
After finishing the inclusion of syntax.s7i the file seed7_05.s7i contains some $
declarations until the <tt>'<font color=blue>const</font>'</tt> declaration statement is established. From that point
onward almost no $ statements are needed.
</p></p>

<p><br><a name="seed7_version_number"><h3>Why does "seed7_05.s7i" contain a version number?
</h3></a><hr><!-- ================================================= -->
<p>
The number 05 is actually a 'branch info'. As if C had headers like
</p><pre>
  &lt;stdlib_c78.h> /* For K&amp;R C programs */
  &lt;stdlib_c89.h> /* For ANSI C */
  &lt;stdlib_c99.h> /* For C99 */
</pre><p>
and your program must include one of these three headers
as first include file (Other include files have no version/branch
info in the name). That way nobody is forced to upgrade
an old program (to get no warnings or to make it compile).
You can leave your old K&amp;R program from 1980 as is.
When you decide to rewrite your K&amp;R program to use
prototypes, you change the <stdlib...> include file as well.
</p><p>
Programming languages change over long time periods.
This results in different language standards.
Seed7 tries to address this problem from the beginning.
Since most of the Seed7's constructs (statements, operators, types, ... )
are defined in "seed7_05.s7i" this is the right place to do it.
</p></p>

<p><br><a name="boot_a_language"><h3>Can I use an "abc.s7i" include file to boot to the abc language?
</h3></a><hr><!-- ================================================================ -->
<p>
Theoretically yes. In practice there would be several problems. For example:
</p><ul>
<li> <!-- - --> All primitive actions are defined such that they fit to Seed7.</li>
<li> <!-- - --> Some concepts like goto's, return's and break's are not supported.</li>
<li> <!-- - --> Some things like comments and $ pragmas are hard coded.</li>
</ul><p>
But basically booting various languages was one of the goals of the extensible
programming language Seed7 and the hi Interpreter.
</p><p>
In practice it turned out to be a better approach to steal concepts from other
programming languages and to integrate them in Seed7 than to split the development
in different branches.
</p><p>
The capability to boot a language can be used to allow slightly different
future versions of Seed7 to coexist with the current version. This is also the
reason why the file seed7_05.s7i contains a version number (05).
</p></p>
