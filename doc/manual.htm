<!-- (********************************************************************)
(*                                                                  *)
(*  manual.txt                                                      *)
(*                                                                  *)
(*  Copyright (C) 1989 - 2009  Thomas Mertes                        *)
(*  All rights reserved.                                            *)
(*                                                                  *)
(*  Documentation:  --><p></p><hr><p align="center"><big><b>Manual for the Seed7 programming language</b></big></p><hr><!--         *)
(*                                                                  *)
(*  This file is distributed "AS IS" in the hope that it will be    *)
(*  useful, but WITHOUT ANY WARRANTY; without even the implied      *)
(*  warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.*)
(*                                                                  *)
(********************************************************************) -->


<p></p>
<big><b>CONTENTS</b></big>
<!-- ======== -->
<p><ol>
<li><!--   1.     --><a href="#INTRODUCTION"><big><b>INTRODUCTION</b></big></a><ol>
<li><!--   1.1      --><a href="#What_is_Seed7"><b>What is Seed7?</b></a></li>
<li><!--   1.2      --><a href="#Why_a_new_programming_language"><b>Why a new programming language?</b></a></li>
<li><!--   1.3      --><a href="#Features_of_Seed7"><b>Features of Seed7</b></a></li>
<li><!--   1.4      --><a href="#How_to_read_the_manual"><b>How to read the manual</b></a></li></ol></li>
<li><!--   2.     --><a href="#TUTORIAL"><big><b>TUTORIAL</b></big></a><ol>
<li><!--   2.1      --><a href="#Hello_world"><b>Hello world</b></a></li>
<li><!--   2.2      --><a href="#Local_declarations_and_expressions"><b>Local declarations and expressions</b></a></li>
<li><!--   2.3      --><a href="#For_loop_and_float_expressions"><b>For loop and float expressions</b></a></li>
<li><!--   2.4      --><a href="#Parameters"><b>Parameters</b></a></li>
<li><!--   2.5      --><a href="#Declare_a_statement"><b>Declare a statement</b></a></li>
<li><!--   2.6      --><a href="#Template_declaring_a_statement"><b>Template declaring a statement</b></a></li></ol></li>
<li><!--   3.     --><a href="#DECLARATIONS"><big><b>DECLARATIONS</b></big></a><ol>
<li><!--   3.1      --><a href="#Normal_declarations"><b>Normal declarations</b></a></li>
<li><!--   3.2      --><a href="#Syntax_declarations"><b>Syntax declarations</b></a></li>
<li><!--   3.3      --><a href="#System_declarations"><b>System declarations</b></a></li></ol></li>
<li><!--   4.     --><a href="#PREDEFINED_STATEMENTS"><big><b>PREDEFINED STATEMENTS</b></big></a><ol>
<li><!--   4.1      --><a href="#Assignment"><b>Assignment</b></a></li>
<li><!--   4.2      --><a href="#while-statement"><b>while-statement</b></a></li>
<li><!--   4.3      --><a href="#repeat-statement"><b>repeat-statement</b></a></li>
<li><!--   4.4      --><a href="#for-statement"><b>for-statement</b></a></li>
<li><!--   4.5      --><a href="#for-each-statement"><b>for-each-statement</b></a></li>
<li><!--   4.6      --><a href="#if-statement"><b>if-statement</b></a></li>
<li><!--   4.7      --><a href="#case-statement"><b>case-statement</b></a></li></ol></li>
<li><!--   5.     --><a href="#PREDEFINED_TYPES"><big><b>PREDEFINED TYPES</b></big></a><ol>
<li><!--   5.1      --><a href="#boolean"><b>boolean</b></a></li>
<li><!--   5.2      --><a href="#integer"><b>integer</b></a></li>
<li><!--   5.3      --><a href="#bigInteger"><b>bigInteger</b></a></li>
<li><!--   5.4      --><a href="#rational"><b>rational</b></a></li>
<li><!--   5.5      --><a href="#bigRational"><b>bigRational</b></a></li>
<li><!--   5.6      --><a href="#float"><b>float</b></a></li>
<li><!--   5.7      --><a href="#complex"><b>complex</b></a></li>
<li><!--   5.8      --><a href="#char"><b>char</b></a></li>
<li><!--   5.9      --><a href="#string"><b>string</b></a></li>
<li><!--   5.10     --><a href="#array"><b>array</b></a></li>
<li><!--   5.11     --><a href="#hash"><b>hash</b></a></li>
<li><!--   5.12     --><a href="#set"><b>set</b></a></li>
<li><!--   5.13     --><a href="#struct"><b>struct</b></a></li>
<li><!--   5.14     --><a href="#category"><b>category</b></a></li>
<li><!--   5.15     --><a href="#reference"><b>reference</b></a></li>
<li><!--   5.16     --><a href="#ref_list"><b>ref_list</b></a></li>
<li><!--   5.17     --><a href="#program"><b>program</b></a></li>
<li><!--   5.18     --><a href="#ptr"><b>ptr</b></a></li>
<li><!--   5.19     --><a href="#ENUMERATION"><b>ENUMERATION</b></a></li>
<li><!--   5.20     --><a href="#color"><b>color</b></a></li>
<li><!--   5.21     --><a href="#time"><b>time</b></a></li>
<li><!--   5.22     --><a href="#duration"><b>duration</b></a></li>
<li><!--   5.23     --><a href="#file"><b>file</b></a></li>
<li><!--   5.24     --><a href="#text"><b>text</b></a></li>
<li><!--   5.25     --><a href="#func"><b>func</b></a></li>
<li><!--   5.26     --><a href="#varfunc"><b>varfunc</b></a></li>
<li><!--   5.27     --><a href="#void"><b>void</b></a></li>
<li><!--   5.28     --><a href="#proc"><b>proc</b></a></li>
<li><!--   5.29     --><a href="#type"><b>type</b></a></li>
<li><!--   5.30     --><a href="#object"><b>object</b></a></li>
<li><!--   5.31     --><a href="#expr"><b>expr</b></a></li></ol></li>
<li><!--   6.     --><a href="#PARAMETERS"><big><b>PARAMETERS</b></big></a><ol>
<li><!--   6.1      --><a href="#val_parameter"><b>'val' parameter</b></a></li>
<li><!--   6.2      --><a href="#ref_parameter"><b>'ref' parameter</b></a></li>
<li><!--   6.3      --><a href="#in_parameter"><b>'in' parameter</b></a></li>
<li><!--   6.4      --><a href="#in_var_parameter"><b>'in var' parameter</b></a></li>
<li><!--   6.5      --><a href="#inout_parameter"><b>'inout' parameter</b></a></li>
<li><!--   6.6      --><a href="#Symbol_parameter"><b>Symbol parameter</b></a></li>
<li><!--   6.7      --><a href="#attr_parameter"><b>'attr' parameter</b></a></li></ol></li>
<li><!--   7.     --><a href="#OBJECT_ORIENTATION"><big><b>OBJECT ORIENTATION</b></big></a><ol>
<li><!--   7.1      --><a href="#interface_and_implementation"><b>Interface and implementation</b></a></li>
<li><!--   7.2      --><a href="#dynamic_dispatch"><b>Dynamic dispatch</b></a></li>
<li><!--   7.3      --><a href="#inheritance"><b>Inheritance</b></a></li>
<li><!--   7.4      --><a href="#class_methods"><b>Class methods</b></a></li>
<li><!--   7.5      --><a href="#multiple_dispatch"><b>Multiple dispatch</b></a></li>
<li><!--   7.6      --><a href="#replacing_pointers"><b>Replacing pointers with interface types</b></a></li></ol></li>
<li><!--   8.     --><a href="#THE_FILE_SYSTEM"><big><b>THE FILE SYSTEM</b></big></a><ol>
<li><!--   8.1      --><a href="#Conversion_to_strings_and_back"><b>Conversion to strings and back</b></a></li>
<li><!--   8.2      --><a href="#Basic_input_and_output_operations"><b>Basic input and output operations</b></a></li>
<li><!--   8.3      --><a href="#Input_and_output_with_conversion"><b>Input and output with conversion</b></a></li>
<li><!--   8.4      --><a href="#Simple_read_and_write_statements"><b>Simple read and write statements</b></a></li>
<li><!--   8.5      --><a href="#Standard_input_and_output_files"><b>Standard input and output files</b></a></li>
<li><!--   8.6      --><a href="#Access_to_operating_system_files"><b>Access to operating system files</b></a></li>
<li><!--   8.7      --><a href="#Keyboard_file"><b>Keyboard file</b></a></li>
<li><!--   8.8      --><a href="#Files_with_line_structure"><b>Files with line structure</b></a></li>
<li><!--   8.9      --><a href="#Sockets"><b>Sockets</b></a></li>
<li><!--   8.10     --><a href="#User_defined_file_types"><b>User defined file types</b></a></li>
<li><!--   8.11     --><a href="#Scanning_a_file"><b>Scanning a file</b></a></li></ol></li>
<li><!--   9.     --><a href="#STRUCTURED_SYNTAX_DEFINITION"><big><b>STRUCTURED SYNTAX DEFINITION</b></big></a><ol>
<li><!--   9.1      --><a href="#The_Extended_Backus-Naur_Form"><b>The Extended Backus-Naur Form</b></a></li>
<li><!--   9.2      --><a href="#The_syntax_of_a_statement"><b>The syntax of a statement</b></a></li>
<li><!--   9.3      --><a href="#Priority_and_associativity"><b>Priority and associativity</b></a></li>
<li><!--   9.4      --><a href="#The_syntax_of_operators"><b>The syntax of operators</b></a></li>
<li><!--   9.5      --><a href="#Syntax_of_predefined_statements"><b>Syntax of predefined statements</b></a></li>
<li><!--   9.6      --><a href="#Advanced_syntax_definitions"><b>Advanced syntax definitions</b></a></li>
<li><!--   9.7      --><a href="#Comparison_of_EBNF_and_S7SSD"><b>Comparison of EBNF and S7SSD</b></a></li></ol></li>
<li><!--   10.    --><a href="#TOKENS"><big><b>TOKENS</b></big></a><ol>
<li><!--   10.1     --><a href="#White_space"><b>White space</b></a><ol>
<li><!--   10.1.1     --><a href="#Spaces"><b><i>Spaces</i></b></a></li>
<li><!--   10.1.2     --><a href="#Comments"><b><i>Comments</i></b></a></li>
<li><!--   10.1.3     --><a href="#Line_comments"><b><i>Line comments</i></b></a></li></ol></li>
<li><!--   10.2     --><a href="#Identifiers"><b>Identifiers</b></a><ol>
<li><!--   10.2.1     --><a href="#Name_identifiers"><b><i>Name identifiers</i></b></a></li>
<li><!--   10.2.2     --><a href="#Special_identifiers"><b><i>Special identifiers</i></b></a></li>
<li><!--   10.2.3     --><a href="#Parentheses"><b><i>Parentheses</i></b></a></li></ol></li>
<li><!--   10.3     --><a href="#Literals"><b>Literals</b></a><ol>
<li><!--   10.3.1     --><a href="#Integer_literals"><b><i>Integer literals</i></b></a></li>
<li><!--   10.3.2     --><a href="#String_literals"><b><i>String literals</i></b></a></li>
<li><!--   10.3.3     --><a href="#Character_literals"><b><i>Character literals</i></b></a></li></ol></li></ol></li>
<li><!--   11.    --><a href="#EXPRESSIONS"><big><b>EXPRESSIONS</b></big></a><ol>
<li><!--   11.1     --><a href="#EXPRESSION_Parentheses"><b>Parentheses</b></a></li>
<li><!--   11.2     --><a href="#Call_expressions"><b>Call expressions</b></a></li>
<li><!--   11.3     --><a href="#Dot_expressions"><b>Dot expressions</b></a></li></ol></li>
<li><!--   12.    --><a href="#OPERATING_SYSTEM_ACCESS"><big><b>OPERATING SYSTEM ACCESS</b></big></a><ol>
<li><!--   12.1     --><a href="#Directory_access"><b>Directory access</b></a></li>
<li><!--   12.2     --><a href="#Other_directory_operations"><b>Other directory operations</b></a></li>
<li><!--   12.3     --><a href="#fileType"><b>fileType</b></a></li>
<li><!--   12.4     --><a href="#fileMode"><b>fileMode</b></a></li>
<li><!--   12.5     --><a href="#setFileMode"><b>setFileMode</b></a></li>
<li><!--   12.6     --><a href="#fileSize"><b>fileSize</b></a></li>
<li><!--   12.7     --><a href="#getATime"><b>getATime</b></a></li>
<li><!--   12.8     --><a href="#getCTime"><b>getCTime</b></a></li>
<li><!--   12.9     --><a href="#getMTime"><b>getMTime</b></a></li>
<li><!--   12.10    --><a href="#setATime"><b>setATime</b></a></li>
<li><!--   12.11    --><a href="#setMTime"><b>setMTime</b></a></li>
<li><!--   12.12    --><a href="#readlink"><b>readlink</b></a></li>
<li><!--   12.13    --><a href="#symlink"><b>symlink</b></a></li>
<li><!--   12.14    --><a href="#removeAnyFile"><b>removeAnyFile</b></a></li>
<li><!--   12.15    --><a href="#Other_functions"><b>Other functions</b></a></li>
<li><!--   12.16    --><a href="#argv"><b>argv</b></a></li>
<li><!--   12.17    --><a href="#getenv"><b>getenv</b></a></li></ol></li>
<li><!--   13.    --><a href="#PRIMITIVE_ACTIONS"><big><b>PRIMITIVE ACTIONS</b></big></a><ol>
<li><!--   13.1     --><a href="#ACTION"><b>Actions for the type ACTION</b></a></li>
<li><!--   13.2     --><a href="#array"><b>Actions for array types</b></a></li>
<li><!--   13.3     --><a href="#bigInteger"><b>Actions for the type bigInteger</b></a></li>
<li><!--   13.4     --><a href="#boolean"><b>Actions for the type boolean</b></a></li>
<li><!--   13.5     --><a href="#bstring"><b>Actions for byte strings</b></a></li>
<li><!--   13.6     --><a href="#char"><b>Actions for the type char</b></a></li>
<li><!--   13.7     --><a href="#commands"><b>Actions for various directory, file and other commands</b></a></li>
<li><!--   13.8     --><a href="#declarations"><b>Actions for declarations</b></a></li>
<li><!--   13.9     --><a href="#graphic_output"><b>Actions to do graphic output</b></a></li>
<li><!--   13.10    --><a href="#enumeration"><b>Actions for enumeration types</b></a></li>
<li><!--   13.11    --><a href="#PRIMITIVE_FILE"><b>Actions for the type PRIMITIVE_FILE</b></a></li>
<li><!--   13.12    --><a href="#float"><b>Actions for the type float</b></a></li>
<li><!--   13.13    --><a href="#graphic_keyboard"><b>Actions to support the graphic keyboard</b></a></li>
<li><!--   13.14    --><a href="#hash"><b>Actions for hash types</b></a></li>
<li><!--   13.15    --><a href="#integer"><b>Actions for the type integer</b></a></li>
<li><!--   13.16    --><a href="#interface"><b>Actions for interface types</b></a></li>
<li><!--   13.17    --><a href="#console_keyboard"><b>Actions to support the text (console) screen keyboard</b></a></li>
<li><!--   13.18    --><a href="#list"><b>Actions for the list type</b></a></li>
<li><!--   13.19    --><a href="#proc"><b>Actions for proc operations and statements</b></a></li>
<li><!--   13.20    --><a href="#program"><b>Actions for the type program</b></a></li>
<li><!--   13.21    --><a href="#reference"><b>Actions for the type reference</b></a></li>
<li><!--   13.22    --><a href="#ref_list"><b>Actions for the type ref_list</b></a></li>
<li><!--   13.23    --><a href="#console_output"><b>Actions for text (console) screen output</b></a></li>
<li><!--   13.24    --><a href="#struct"><b>Actions for struct types</b></a></li>
<li><!--   13.25    --><a href="#set"><b>Actions for set types</b></a></li>
<li><!--   13.26    --><a href="#PRIMITIVE_SOCKET"><b>Actions for the type PRIMITIVE_SOCKET</b></a></li>
<li><!--   13.27    --><a href="#string"><b>Actions for the type string</b></a></li>
<li><!--   13.28    --><a href="#time"><b>Actions for the type time</b></a></li>
<li><!--   13.29    --><a href="#type"><b>Actions for the type type</b></a></li>
<li><!--   13.30    --><a href="#utf8_file"><b>Actions for the type utf8_file</b></a></li></ol></li>
<li><!--   14.    --><a href="#ERRORS"><big><b>ERRORS</b></big></a><ol>
<li><!--   14.1     --><a href="#Compile_time_errors"><b>Compile time errors</b></a></li>
<li><!--   14.2     --><a href="#Exceptions"><b>Exceptions</b></a></li>
<li><!--   14.3     --><a href="#Handlers"><b>Handlers</b></a></li>
<li><!--   14.4     --><a href="#Stack_trace"><b>Stack trace</b></a></li>
<li><!--   14.5     --><a href="#Other_errors_and_warnings"><b>Other errors and warnings</b></a></li></ol></li>
</ol></p>
<hr>

<p></p>
<a name="INTRODUCTION"><h2>1. INTRODUCTION</h2></a>
<!-- =============== -->
<p></p>

<a name="What_is_Seed7"><h3>1.1 What is Seed7?</h3></a>
<p>
    Seed7 is a general-purpose programming language. It is a
  higher level language compared to Ada, C++ and Java. In Seed7
  new statements and operators can be declared easily. Functions
  with type results and type parameters are more elegant than
  the usual template or generics concept. Object orientation is
  used when it brings advantages and not in places when other
  solutions are more obvious. Although Seed7 contains several
  concepts of other programming languages it is generally not
  considered as a direct descendant of any other programming
  language.
</p><p>
  The programmer should concentrate on problem solving instead
  of administration or the fulfillment of some paradigm.
  Therefore Seed7 allows programming in the "problem space"
  instead of bending everything into a small syntactic or
  semantic concept. The predefined constructs of Seed7 are
  defined in a way to be easy readable and understandable. This
  practical approach can be summarized as:
</p><pre>
    "Programming should be fun"
</pre><p>
  Seed7 programs can be interpreted or compiled. Therefore Seed7
  can be used for scripting and for "real" programs.
</p>

<a name="Why_a_new_programming_language"><h3>1.2 Why a new programming language?</h3></a>
<p>
    Conventional programming languages have a firmly given
  syntactic structure. The form of the statements, operators,
  declarations, procedures and functions is fixed in the
  language definition and cannot be changed by the user. It is
  only possible to declare new procedures, functions and in
  some languages also new operators. However the syntax of
  procedure-, function and operator calls cannot be changed.
  Although this rigid pattern is favorable for the portability
  of programs, the improvement of a programming language is
  almost impossible. Extensions are however desirable, in order
  to repair existing weaknesses, to introduce new more obvious
  constructs and to adapt the programming language to different
  application areas. E.g.: In the area of mathematics the
  readability of a program can be substantially increased by
  the introduction of matrix and vector operators. After
  declaring an inner product and an outer (or cross) product for
  vectors it is possible to write e.g.
</p><pre>
    v1: = v2 <font color=blue>cross</font> v3;   write(v1 * v2);
</pre><p>
  Programs searching some data can become more understandable
  by using a search statement instead of a search procedure. A
  call of a new declared search statement could be:
</p><pre>
    <font color=blue>search</font> person1.age = person2.age <font color=blue>and</font>
       person1.mother = person2.mother <font color=blue>and</font>
       person1 &lt;> person2
    <font color=blue>when found</font>
       write(<font color=maroon>"Twins: "</font> <& person1.name <& <font color=maroon>" and "</font> <& person2.name);
    <font color=blue>else</font>
       write(<font color=maroon>"No twins found."</font>);
    <font color=blue>end search</font>;
</pre><p>
  Such extensions make understanding, changing and debugging of
  a program easier.
</p>

<a name="Features_of_Seed7"><h3>1.3 Features of Seed7</h3></a>
<p>
  Seed7 has the following features
</p><ul>
    <li><!-- -  -->User defined statements and operators.</li>

    <li><!-- -  -->Types are first class objects and therefore templates and
      generics can be defined easily without special syntax.</li>

    <li><!-- -  -->Predefined constructs like arrays or for-loops are
      declared in the language itself.</li>

    <li><!-- -  -->Object orientation is based on interfaces, supports
      multiple dispatch and allows to connect methods to objects.</li>

    <li><!-- -  -->Static type checking and no automatic casts.</li>

    <li><!-- -  -->exception handling</li>

    <li><!-- -  -->overloading of procedures/functions/operators/statements</li>

    <li><!-- -  -->Various predefined types like resizable arrays, hashes,
      bitsets, structs, etc.</li>
</ul><p>
  But a new programming language differs not only from existing
  ones by new features. The real advantage comes from omitting
  features which are outdated.
</p><p>
  Several concepts in use by other languages are not present
</p><ul>
    <li><!-- -  -->There is no goto statement.
      Hidden goto's like break- and continue-statements are
      also omitted.</li>

    <li><!-- -  -->There is no return statement. Instead a result variable
      can be declared to which the result of a function can
      be assigned.</li>

    <li><!-- -  -->There are no automatic type conversions.
      When a subprogram should be used for different types
      it must be overloaded.</li>

    <li><!-- -  -->There are no variable length parameter lists.
      Instead it is possible to use arrays as parameters.</li>

    <li><!-- -  -->There are no default parameters.
      But it is easy to define two subprograms: One with and
      one without an additional parameter.</li>

    <li><!-- -  -->There is no special "parameter" called "self" or "this".
      In a procedure the receiving object is declared as
      formal parameter with a user-defined name.</li>

    <li><!-- -  -->There is no macro feature since this mechanism is too
      similar to the subprogram feature. Instead subprograms
      can be used in a more flexible way than in other languages.</li>

    <li><!-- -  -->There are no reserved words.</li>

    <li><!-- -  -->There is no conceptual distinction between functions,
      operators, procedures and statements.</li>

    <li><!-- -  -->The procedure calling mechanism is not based on a concept
      with an object-message pair (An object receives a message).
      Instead a match is done over a list of objects. This more
      general (and powerful) mechanism is called multiple dispatch
      and it includes the simple object-message mechanism as
      special case.</li>
</ul><p>
  There are several concepts which are also used by other languages:
</p><ul>
    <li><!-- -  -->Comments start with <font color=green>(* and end with *)</font> and may be nested.</li>

    <li><!-- -  -->Comments start with <font color=green># and are terminated with the end of the line.</font></li>
</ul><p>
  There are several concepts which are new
</p><ul>
    <li><!-- -  -->Variables and constants must be initialized when they are
      declared.</li>

    <li><!-- -  -->Every expression has exactly one type.
      That means that overloaded functions are resolved with
      their actual parameters and not with the context of their
      call. (This is different to the overloading mechanism
      used by ADA)</li>

    <li><!-- -  -->With a syntax declaration new operators and statements
      can be defined.</li>

    <li><!-- -  -->Not only predefined operator symbols can be
      overloaded. Additionally it is possible to invent
      completely new operator symbols.</li>
</ul><p>
  Several restrictions of other languages are released
</p><ul>
    <li><!-- -  -->There is no limitation in the length of an identifier and
      all characters of an identifier are significant.</li>

    <li><!-- -  -->Statements and parentheses can be nested without limitation
      in depth.</li>

    <li><!-- -  -->The number of parameters and local variables is not
      limited.</li>

    <li><!-- -  -->Strings can contain any characters (also the NUL character)
      This allows holding binary information in strings.</li>

    <li><!-- -  -->Although strings are not NUL terminated they have
      no size limitation. (Except there is no more memory)</li>

    <li><!-- -  -->String literals can have any length.</li>

    <li><!-- -  -->There is no limitation in the length of a source line.</li>

    <li><!-- -  -->There is no level limitation for nesting includes.</li>
</ul>

<a name="How_to_read_the_manual"><h3>1.4 How to read the manual</h3></a>
<p>
    You can have several views of the Seed7 programming language.
  Dependent on the view you can concentrate on specific
  chapters.
</p><p>
  For example Seed7 can be used as conventional programming language.
  In this case you are interested in how the statements look like,
  which types are available, which operators are predefined, how
  to declare variables and procedures and other things like these.
  The statements and the predefined types are described in <a href="stats.htm">chapter
  4 (Predefined statements)</a> and <a href="types.htm">chapter 5 (Predefined types)</a> and the
  declaration mechanism is described in <a href="decls.htm">chapter 3 (Declarations)</a>.
</p><p>
  But Seed7 is also an object oriented programming language.
  In this case you are interested in how to define new classes,
  how instances are generated, the method calling mechanism,
  the predefined class hierarchy and other things like these.
  The object orientation of Seed7 is described in <a href="objects.htm">chapter 7
  (Object orientation)</a>. A good example for classes and instances
  is the file system which is described in <a href="file.htm">chapter 8 (The file
  system)</a>.
</p><p>
  And Seed7 is also an extensible programming language.
  In this case you are interested in how to declare new
  statements, how to define new operators, assigning a priority
  and an associativity to operators and other things like these.
  An overview about syntax declarations can be found in
  <a href="decls.htm#Syntax_declarations">Chapter 3.2 (Syntax declarations)</a>. A detailed description
  of the Seed7 syntax definitions can be found in <a href="syntax.htm">chapter 9
  (Structured syntax definition)</a>. <a href="stats.htm">Chapter 4 (Predefined
  statements)</a> contains various examples of syntax and semantic
  declarations. The basic parts of the syntax are described in
  <a href="tokens.htm">chapter 10 (Tokens)</a> and <a href="expr.htm">chapter 11 (Expressions)</a>.
</p>

<p></p>
<a name="TUTORIAL"><h2>2. TUTORIAL</h2></a>
<!-- =========== -->
<p>
    We begin with a tutorial introduction to Seed7. In
  this chapter we want to show the principal ideas that
  make Seed7 work. At this point, we are not trying to be
  complete or precise. We just want to give a clear view
  to the primary philosophic ideas of Seed7. When the
  primary ideas are understood a complete and precise
  reference can be learned easier.
</p>

<a name="Hello_world"><h3>2.1 Hello world</h3></a>
<p>
    A Seed7 program consists of a sequence of declarations.
  With each declaration a type and a name is attached to the
  new object. In addition every new declared object gets an
  initial value. 
</p><p>
  Here is an example of an object declaration:
</p><pre>
    <font color=blue>const</font> <font color=red>proc</font>: main <font color=blue>is func</font>
      <font color=blue>begin</font>
        writeln(<font color=maroon>"hello world"</font>);
      <font color=blue>end func</font>;
</pre><p>
  The object <tt>'main'</tt> is declared as constant and <tt>'<font color=red>proc</font>'</tt>
  is the type of <tt>'main'</tt>. Declaring <tt>'main'</tt> with the type
  <tt>'<font color=red>proc</font>'</tt> makes a procedure out of it. The object <tt>'main'</tt> gets a
</p><pre>
    <font color=blue>func</font> ... <font color=blue>end func</font>
</pre><p>
  construct as value. The <tt>'<font color=blue>func</font>'</tt> construct is similar to
  <tt><font color=blue>begin</font> ... <font color=blue>end</font></tt> in PASCAL and <tt>{ ... }</tt> in C. Inside the <tt>'<font color=blue>func</font>'</tt> is a
  <tt>'writeln'</tt> statement with the <tt><font color=maroon>"hello world"</font></tt> string. The
  <tt>'writeln'</tt> statement is used to write a string followed by a
  newline character. To use this declaration as the standard
  hello world example program, we have to add a few things:
</p><pre>
    $ <font color=blue>include</font> <font color=maroon>"seed7_05.s7i"</font>;

    <font color=blue>const</font> <font color=red>proc</font>: main <font color=blue>is func</font>
      <font color=blue>begin</font>
        writeln(<font color=maroon>"hello world"</font>);
      <font color=blue>end func</font>;
</pre><p>
  The first line includes all definitions of the standard
  library. In contrast to other standard libraries the seed7_05.s7i
  library contains not only function declarations but also
  declarations of statements and operators.
  Additionally the seed7_05.s7i library defines the '<tt>main</tt>' function
  as entry point for a Seed7 program.
</p><p>
  If you write this program in a file called hello.sd7
  and execute the command
</p><pre>
    hi hello
</pre><p>
  The Seed7 interpreter writes something like
</p><pre>
    HI INTERPRETER Version 4.5.79  Copyright (c) 1990-2005 Thomas Mertes
       245 syntax.s7i
      2635 seed7_05.s7i
        33 hello.sd7
      2913 lines total
     29130 lines per second
    1184171 bytes
    hello world
</pre><p>
  You get information about the Seed7 interpreter, a list of
  libraries included and how many lines they contain, the
  number of bytes used by the hello.sd7 program and finally
  the output of the hello.sd7 program itself:
</p><pre>
    hello world
</pre><p></p>

<a name="Local_declarations_and_expressions"><h3>2.2 Local declarations and expressions</h3></a>
<p>
    To write a Fahrenheit to Celsius conversion table we use
  the following program:
</p><pre>
    <font color=green>(* Print a Fahrenheit-Celsius table
       for Fahrenheit values between 0 and 300 *)</font>

    $ <font color=blue>include</font> <font color=maroon>"seed7_05.s7i"</font>;

    <font color=blue>const</font> <font color=red>proc</font>: main <font color=blue>is func</font>
      <font color=blue>local</font>
        <font color=blue>const</font> <font color=red>integer</font>: lower <font color=blue>is</font> 0;
        <font color=blue>const</font> <font color=red>integer</font>: upper <font color=blue>is</font> 300;
        <font color=blue>const</font> <font color=red>integer</font>: increment <font color=blue>is</font> 20;
        <font color=blue>var</font> <font color=red>integer</font>: fahr <font color=blue>is</font> 0;
        <font color=blue>var</font> <font color=red>integer</font>: celsius <font color=blue>is</font> 0;
      <font color=blue>begin</font>
        fahr := lower;
        <font color=blue>while</font> fahr &lt;= upper <font color=blue>do</font>
          celsius := 5 * (fahr - 32) <font color=blue>div</font> 9;
          write(fahr);
          write(<font color=maroon>" "</font>);
          writeln(celsius);
          fahr := fahr + increment;
        <font color=blue>end while</font>;
      <font color=blue>end func</font>;
</pre><p>
  Everything between <font color=green>(* and *)</font> is a comment which is ignored.
  This program contains local constants and variables of the
  type <tt>'<font color=red>integer</font>'</tt>. The constants and variables must be
  initialized when they are declared. This program contains
  also an assignment, a while loop and the expression to
  compute the <tt>'celsius'</tt> value. Note that the statements inside
  the <tt>'<font color=blue>while</font>'</tt> loop are between <tt>'<font color=blue>do</font>'</tt> and <tt>'<font color=blue>end while</font>'</tt>. The
  expression to compute the <tt>'celsius'</tt> value uses an integer
  division (<tt>'<font color=blue>div</font>'</tt>). The <tt>'write'</tt> statement can be used to write
  strings and integers without a newline character. The output
  produced by this program is
</p><pre>
    0 -17
    20 -6
    40 4
    60 15
    80 26
    100 37
    120 48
    140 60
    160 71
    180 82
    200 93
    220 104
    240 115
    260 126
    280 137
    300 148
</pre><p></p>

<a name="For_loop_and_float_expressions"><h3>2.3 For loop and float expressions</h3></a>
<p>
    An improved version of the program to write the Fahrenheit
  to Celsius conversion table is:
</p><pre>
    $ <font color=blue>include</font> <font color=maroon>"seed7_05.s7i"</font>;
      <font color=blue>include</font> <font color=maroon>"float.s7i"</font>;

    <font color=blue>const</font> <font color=red>proc</font>: main <font color=blue>is func</font>
      <font color=blue>local</font>
        <font color=blue>const</font> <font color=red>integer</font>: lower <font color=blue>is</font> 0;
        <font color=blue>const</font> <font color=red>integer</font>: upper <font color=blue>is</font> 300;
        <font color=blue>const</font> <font color=red>integer</font>: increment <font color=blue>is</font> 20;
        <font color=blue>var</font> <font color=red>integer</font>: fahr <font color=blue>is</font> 0;
        <font color=blue>var</font> <font color=red>float</font>: celsius <font color=blue>is</font> 0.0;
      <font color=blue>begin</font>
        <font color=blue>for</font> fahr <font color=blue>range</font> lower <font color=blue>to</font> upper <font color=blue>step</font> increment <font color=blue>do</font>
          celsius := flt(5 * (fahr - 32)) / 9.0;
          writeln(fahr <font color=blue>lpad</font> 3 <& <font color=maroon>" "</font> <& celsius <font color=blue>digits</font> 2 <font color=blue>lpad</font> 6);
        <font color=blue>end for</font>;
      <font color=blue>end func</font>;
</pre><p>
  To use the type <tt>'<font color=red>float</font>'</tt> it is necessary to include
  <tt><font color=maroon>"float.s7i"</font></tt>. The <tt>'<font color=red>float</font>'</tt> variable <tt>'celsius'</tt> must be
  initialized with 0.0 (instead of 0). The <tt>'for'</tt> loop is
  written as:
</p><pre>
    <font color=blue>for</font> ... <font color=blue>range</font> ... <font color=blue>to </font>... <font color=blue>step</font> ... <font color=blue>do</font>
      ...
    <font color=blue>end for</font>
</pre><p>
  To specify a lower and an upper limit together with a step
  value. For a step value of 1 the for loop it is written as:
</p><pre>
    <font color=blue>for</font> ... <font color=blue>range</font> ... <font color=blue>to</font> ... <font color=blue>do</font>
      ...
    <font color=blue>end for</font>
</pre><p>
  And for a step value of -1 it can be written as:
</p><pre>
    <font color=blue>for</font> ... <font color=blue>range</font> ... <font color=blue>downto</font> ... <font color=blue>do</font>
      ...
    <font color=blue>end for</font>
</pre><p>
  Since Seed7 is strong typed <tt>'<font color=red>integer</font>'</tt> and <tt>'<font color=red>float</font>'</tt> values
  cannot be mixed in expressions. Therefore the <tt>'<font color=red>integer</font>'</tt>
  expression <tt>'5 * (fahr - 32)'</tt> is converted to <tt>'<font color=red>float</font>'</tt> with
  the <tt>'flt'</tt> function. For the same reason a <tt>'/'</tt> division and
  the value <tt>'9.0'</tt> must be used. The <tt>'<&'</tt> operator is used to
  concatenate elements before writing. If the right operand of
  the <tt>'<&'</tt> operator has not the type <tt>'<font color=red>string</font>'</tt> it is converted to
  a <tt>'<font color=red>string</font>'</tt> using the <tt>'str'</tt> function. The <tt>'<font color=blue>lpad</font>'</tt> operator
  converts the value of <tt>'fahr'</tt> to a string and pads spaces to
  the left until the string has length 3. The <tt>'<font color=blue>digits</font>'</tt> operator
  converts the value of <tt>'celsius'</tt> to a string with 2 decimal
  digits. The resulting string is padded left up to a length
  of 6.
</p>

<a name="Parameters"><h3>2.4 Parameters</h3></a>
<p>
    Most parameters are not changed inside a function. To
  express this explicit Seed7 uses the <tt>'<font color=blue>in</font>'</tt> parameter as in the
  following examples:
</p><pre>
    <font color=blue>const</font> <font color=red>func integer</font>: negate (<font color=blue>in</font> <font color=red>integer</font>: num1) <font color=blue>is</font>
      <font color=blue>return</font> -num1;

    <font color=blue>const</font> <font color=red>func integer</font>: fib (<font color=blue>in</font> <font color=red>integer</font>: num1) <font color=blue>is func</font>
      <font color=blue>result</font>
        <font color=blue>var</font> <font color=red>integer</font>: result <font color=blue>is</font> 1;
      <font color=blue>begin</font>
        <font color=blue>if</font> num1 &lt;> 1 <font color=blue>and</font> num1 &lt;> 2 <font color=blue>then</font>
          result := fib(pred(num1)) + fib(num1 - 2);
        <font color=blue>end if</font>;
      <font color=blue>end func</font>;
</pre><p>
  In both cases the formal parameter <tt>'num1'</tt> is used in the
  function but no assignment is done to <tt>'num1'</tt>. Inside the
  functions the parameter <tt>'num1'</tt> behaves like a constant.
</p><p>
  When a function should change the value of the actual
  parameter we can use the <tt>'<font color=blue>inout</font>'</tt> parameter as in the
  following example:
</p><pre>
    <font color=blue>const</font> <font color=red>proc</font>: reset (<font color=blue>inout</font> <font color=red>integer</font>: num2) <font color=blue>is func</font>
      <font color=blue>begin</font>
        num2 := 0;
      <font color=blue>end func</font>;
</pre><p>
  If you call this function with
</p><pre>
    reset(number)
</pre><p>
  the variable <tt>'number'</tt> has the value 0 afterwards. By the way,
  writing <tt>'<font color=blue>in</font>'</tt> instead of <tt>'<font color=blue>inout</font>'</tt> would have been illegal in
  the example above.
</p><p>
  Sometimes an <tt>'<font color=blue>in</font>'</tt> parameter is needed, but you need to change
  the formal parameter in the function without affecting the
  actual parameter. In this case we use the <tt>'<font color=blue>in var</font>'</tt> parameter:
</p><pre>
    <font color=blue>const</font> <font color=red>func string</font>: oct_str (<font color=blue>in var</font> <font color=red>integer</font>: number) <font color=blue>is func</font>
      <font color=blue>result</font>
        <font color=blue>var</font> <font color=red>string</font>: result <font color=blue>is</font> <font color=maroon>""</font>;
      <font color=blue>begin</font>
        <font color=blue>while</font> number >= 0 <font color=blue>do</font>
          result := str(number <font color=blue>rem</font> 8) & result;
          number := number <font color=blue>div</font> 8;
        <font color=blue>end while</font>;
      <font color=blue>end func</font>;
</pre><p>
  As you can see this works like a combination of an <tt>'<font color=blue>in</font>'</tt>
  parameter with a local <tt>'<font color=blue>var</font>'</tt>.
</p><p>
  Conventionally there are two kinds of parameters:
  <tt>'call by value'</tt> and <tt>'call by reference'</tt>. When taking the
  access right (constant or variable) into account we get
  the following table:
</p><pre>
    +-----------+-----------+--------------+
    | parameter |  call by  | access right |
    +-----------+-----------+--------------+
    | val       |   value   | const        |
    | ref       | reference | const        |
    | in        | val / ref | const        |
    | in var    |   value   | var          |
    | inout     | reference | var          |
    +-----------+-----------+--------------+
</pre><p>
  Additionally to the parameters we already know this table
  describes also <tt>'<font color=blue>val</font>'</tt> and <tt>'<font color=blue>ref</font>'</tt> parameters which use
  'call by value' and 'call by reference' and have a constant
  formal parameter. The <tt>'<font color=blue>in</font>'</tt> parameter is called by
  <tt>'val / ref'</tt> in this table which is easily explained:
</p><pre>
    An <tt>'<font color=blue>in</font>'</tt> parameter is either a <tt>'<font color=blue>val</font>'</tt> or a <tt>'<font color=blue>ref</font>'</tt> parameter
    depending on the type of the parameter.
</pre><p>
  The parameter
</p><pre>
    <font color=blue>in</font> <font color=red>integer</font>: number
</pre><p>
  is a 'val' parameter which could also be declared as
</p><pre>
    <font color=blue>val</font> <font color=red>integer</font>: number
</pre><p>
  while the parameter
</p><pre>
    <font color=blue>in</font> <font color=red>string</font>: stri
</pre><p>
  is a 'ref' parameter which could also be declared as
</p><pre>
    <font color=blue>ref</font> <font color=red>string</font>: stri
</pre><p>
  The meaning of the <tt>'<font color=blue>in</font>'</tt> parameter is predefined for most
  types. Usually types with small amounts of data use <tt>'<font color=blue>val</font>'</tt>
  as <tt>'<font color=blue>in</font>'</tt> parameter while types with bigger data amounts use
  <tt>'<font color=blue>ref</font>'</tt>. Most of the time it is not necessary to care if an
  <tt>'<font color=blue>in</font>'</tt> parameter is really a <tt>'<font color=blue>val</font>'</tt> or <tt>'<font color=blue>ref</font>'</tt> parameter. 
</p><p>
  In rare cases a <tt>'<font color=blue>ref</font>'</tt> parameter would have undesired side
  effects with global variables or other <tt>'<font color=blue>ref</font>'</tt> parameters.
  In these cases an explicit <tt>'<font color=blue>val</font>'</tt> parameter instead of an
  <tt>'<font color=blue>in</font>'</tt> parameter makes sense.
</p><p>
  In all normal cases an <tt>'<font color=blue>in</font>'</tt> parameter should be preferred
  over an explicit <tt>'<font color=blue>val</font>'</tt> and <tt>'<font color=blue>ref</font>'</tt> parameter.
</p>

<a name="Declare_a_statement"><h3>2.5 Declare a statement</h3></a>
<p>
    This example program writes its arguments
</p><pre>
    $ <font color=blue>include</font> <font color=maroon>"seed7_05.s7i"</font>;       <font color=green># Standard Seed7 library</font>

    <font color=blue>const</font> <font color=red>proc</font>: main <font color=blue>is func</font>
      <font color=blue>local</font>
        <font color=blue>var</font> <font color=red>string</font>: stri <font color=blue>is</font> <font color=maroon>""</font>;
      <font color=blue>begin</font>
        <font color=blue>for</font> stri <font color=blue>range</font> argv(PROGRAM) <font color=blue>do</font>
          write(stri &lt;& <font color=maroon>" "</font>);
        <font color=blue>end for</font>;
        writeln;
      <font color=blue>end func</font>;
</pre><p>
  The <tt>'<font color=blue>for</font>'</tt> statement iterates over <tt>'argv(PROGRAM)'</tt>.
  The <tt>'argv(PROGRAM)'</tt> function returns an <tt>'<font color=red>array string</font>'</tt>
  (=<font color=red>array</font> of <font color=red>string</font> elements). The <tt>'<font color=blue>for</font>'</tt> statement is overloaded
  for various collection types. In the standard Seed7 library
  <font color=maroon>"seed7_05.s7i"</font> the <tt>'<font color=blue>for</font>'</tt> statement for <font color=red>array</font>s is declared as
  follows:
</p><pre>
    <font color=blue>const</font> <font color=red>proc</font>: for (<font color=blue>inout</font> <font color=red>baseType</font>: variable) range (<font color=blue>in</font> <font color=red>arrayType</font>: arr_obj) do
                  (<font color=blue>in</font> <font color=red>proc</font>: statements)
                end for <font color=blue>is func</font>
      <font color=blue>local</font>
        <font color=blue>var</font> <font color=red>integer</font>: number <font color=blue>is</font> 0;
      <font color=blue>begin</font>
        <font color=blue>for</font> number <font color=blue>range</font> 1 <font color=blue>to</font> length(arr_obj) <font color=blue>do</font>
          variable := arr_obj[number];
          statements;
        <font color=blue>end for</font>;
      <font color=blue>end func</font>;
</pre><p>
  The syntax of this <tt>'<font color=blue>for</font>'</tt> statement is declared as:
</p><pre>
    $ <font color=blue>syntax</font> <font color=red>expr</font>: .for.().range.().to.().do.().end.for <font color=blue>is</font>              -> 25;
</pre><p>
  Additionally everybody can overload the <tt>'<font color=blue>for</font>'</tt> statement also.
  Because of these powerful features Seed7 does not need Iterators.
</p>

<a name="Template_declaring_a_statement"><h3>2.6 Template declaring a statement</h3></a>
<p>
  Templates are just normal functions with <font color=red>type</font>s as parameters.
  The following template function declares <tt>'<font color=blue>for</font>'</tt> statements:
</p><pre>
    <font color=blue>const</font> <font color=red>proc</font>: FOR_DECLS (<font color=blue>in</font> <font color=red>type</font>: aType) <font color=blue>is func</font>
      <font color=blue>begin</font>

        <font color=blue>const</font> <font color=red>proc</font>: for (<font color=blue>inout</font> <font color=red>aType</font>: variable) range (<font color=blue>in</font> <font color=red>aType</font>: low) to (<font color=blue>in</font> <font color=red>aType</font>: high) do
            (<font color=blue>in</font> <font color=red>proc</font>: statements) end for <font color=blue>is func</font>
          <font color=blue>begin</font>
            variable := low;
            <font color=blue>if</font> variable <= high <font color=blue>then</font>
              statements;
              <font color=blue>while</font> variable < high <font color=blue>do</font>
                incr(variable);
                statements;
              <font color=blue>end while</font>;
            <font color=blue>end if</font>;
          <font color=blue>end func</font>;

      <font color=blue>end func</font>;
 
    FOR_DECLS(<font color=red>char</font>);
    FOR_DECLS(<font color=red>boolean</font>);
</pre><p>
  The body of the 'FOR_DECLS' function contains a declaration of
  the <tt>'<font color=blue>for</font>'</tt> statement for the type <font color=red>aType</font>. Calling 'FOR_DECLS' with
  <font color=red>char</font> and <font color=red>boolean</font> as parameter creates corresponding declarations
  of <tt>'<font color=blue>for</font>'</tt> statements. The example above is a simplified part of
  the standard Seed7 library <font color=maroon>"seed7_05.s7i"</font>.
</p>

<p></p>
<a name="DECLARATIONS"><h2>3. DECLARATIONS</h2></a>
<!-- =============== -->
<p>
    A declaration specifies the identifier, type, and other
  aspects of language elements such as variables, constants
  and functions. In Seed7 everything must be declared before
  it is used. Seed7 uses three kinds of declarations:
</p><ul>
    <li><!-- -  -->Normal declarations</li>
    <li><!-- -  -->Syntax declarations</li>
    <li><!-- -  -->System declarations</li>
</ul><p>
  which are described in detail in the following subchapters.
</p>

<a name="Normal_declarations"><h3>3.1 Normal declarations</h3></a>
<p>
    Normal declarations are the most commonly used form of
  declarations. To contrast them to the syntax declarations normal
  declarations are sometimes called semantic declarations. Seed7
  uses uniform looking declaration constructs to declare variables,
  constants, types, functions and parameters. For example:
</p><pre>
    <font color=blue>const</font> <font color=red>integer</font>: ONE <font color=blue>is</font> 1;
</pre><p>
  declares the <tt>'<font color=red>integer</font>'</tt> constant <tt>'ONE'</tt> which is initialized with the
  value 1. Variable declarations are also possible. For example:
</p><pre>
    <font color=blue>var</font> <font color=red>integer</font>: number <font color=blue>is</font> 0;
</pre><p>
  declares the <tt>'<font color=red>integer</font>'</tt> variable <tt>'number'</tt> which is initialized with
  the value 0. Type declarations are done as constant declarations
  where the type of the declared constant is <tt>'<font color=red>type</font>'</tt>:
</p><pre>
    <font color=blue>const</font> <font color=red>type</font>: myChar <font color=blue>is</font> <font color=red>char</font>;
</pre><p>
  Function declarations are also a form of constant declaration:
</p><pre>
    <font color=blue>const</font> <font color=red>func boolean</font>: flipCoin <font color=blue>is</font>
      <font color=blue>return</font> rand(FALSE, TRUE);
</pre><p>
  Each object declared with a <tt>'<font color=blue>const</font>'</tt> or <tt>'<font color=blue>var</font>'</tt> declaration obtains
  an initial value. It is not possible to use <tt>'<font color=blue>const</font>'</tt> or <tt>'<font color=blue>var</font>'</tt>
  declarations without initial value. Declarations with
  initialisation expressions are also possible. For example
</p><pre>
    <font color=blue>var</font> <font color=red>string</font>: fileName <font color=blue>is</font> NAME & <font color=maroon>".txt"</font>;
</pre><p>
  The expression is evaluated and the result is assigned to
  the new object. This is done in the analyze phase of the
  interpreter or compiler, before the execution of the program
  starts. The initialisation expressions may contain any
  function (or operator) call. That way user defined functions
  can also be used to initialize a constant or variable:
</p><pre>
    <font color=blue>const</font> <font color=red>boolean</font>: maybe <font color=blue>is</font> flipCoin;
</pre><p>
  Constant and variable declarations can be global or local.
  The mechanism to define a parameter like <tt>'x'</tt> is similar to the
  <tt>'<font color=blue>const</font>'</tt> or <tt>'<font color=blue>var</font>'</tt> declarations:
</p><pre>
    <font color=blue>const</font> <font color=red>func float</font>: inverse (<font color=blue>in</font> <font color=red>float</font>: x) <font color=blue>is</font>
      <font color=blue>return</font> 1/x;
</pre><p>
  Function parameters, such as the parameter <tt>'statement'</tt> in
  the example below, act as closures:
</p><pre>
    <font color=blue>const</font> <font color=red>proc</font>: possiblyDo (<font color=blue>in</font> <font color=red>proc</font>: statement) <font color=blue>is func</font>
      <font color=blue>begin</font>
        <font color=blue>if</font> flipCoin <font color=blue>then</font>
          statement;
        <font color=blue>end if</font>;
      <font color=blue>end func</font>;
</pre><p>
  Abstract data types such as <tt>'<font color=red>subtype</font>'</tt>, <tt>'<font color=red>struct</font>'</tt>, <tt>'<font color=red>subrange</font>'</tt>, <tt>'<font color=red>array</font>'</tt>, <tt>'<font color=red>hash</font>'</tt>, <tt>'<font color=red>set</font>'</tt>,
  <tt>'<font color=red>interface</font>'</tt> and <tt>'<font color=red>enum</font>'</tt> are realized as
  functions which return a type. E.g.: The type <tt>'<font color=red>array</font>'</tt> is defined in the
  <font color=maroon>"seed7_05.s7i"</font> library with the following header:
</p><pre>
    <font color=blue>const</font> <font color=red>func type</font>: array (<font color=blue>in</font> <font color=red>type</font>: baseType) <font color=blue>is func</font>
</pre><p>
  User defined abstract data types are also possible.
</p><p>
  The initialisation uses the creation operation ( ::= ).
  Explicit calls of the create operation are not needed.
</p><p>
  The lifetime of an object goes like this:
</p><ol><li>
  <!-- 1.  -->Memory is reserved for the new object (stack or heap memory
     make no difference here).
</li><li>
  <!-- 2.  -->The content of the new memory is undefined (It may contain
     garbage), therefore a create statement is necessary instead of
     an assignment.
</li><li>
  <!-- 3.  -->The create statements copies the right expression to the left
     expression taking into account that the left expression is
     undefined.
</li><li>
  <!-- 4.  -->If the object is variable other values can be assigned using
     the assign statement ( := ). The assignment can assume that the
     left expression contains a legal value. This allows that for
     strings (and some other types which are just references to a
     memory area) the memory containing the old string value (and
     not the memory of the object itself) can be freed when
     necessary.
</li><li>
  <!-- 5.  -->At the end of the lifetime of an object the destroy statement
     is executed. For strings (and some other types which are just
     references to a memory area) the memory containing the string
     value (and not the memory of the object itself) is freed.
</li><li>
  <!-- 6.  -->The memory of the object is freed.
</li></ol><p>
  The first three steps are usually hidden in the declaration
  statement. The expression
</p><pre>
    ONE . ::= . 1
</pre><p>
  is executed to assign 1 to the object ONE. There are two
  reasons to use ::= instead of := to assign the initialisation
  value.
</p><ol><li>
  <!-- 1.  -->The assignment ( := ) can only be used to assign a value
    to a variable and initialisation is also needed for
    constants.
</li><li>
  <!-- 2.  -->Sometimes some initialisations are needed for the new
    object in addition to the pure assignment.
</li></ol><p>
  For all predefined types the creation operator ( ::= )
  is already defined. To allow the declaration of objects of a
  new user defined type the constructor operation for this type
  must be defined.
</p>

<a name="Syntax_declarations"><h3>3.2 Syntax declarations</h3></a>
<p>
    Syntax declarations are used to specify the syntax, priority
  and associativity of operators, statements, declarations and
  other constructs. A syntax declaration which defines the
  <tt>'+'</tt> operator is:
</p><pre>
    $ <font color=blue>syntax</font> <font color=red>expr</font>: .(). + .()   <font color=blue>is</font> ->  7;
</pre><p>
  Most syntax definitions can be found in the file <font color=maroon>"syntax.s7i"</font>.
  A detailed description of the syntax declarations can be
  found in <a href="syntax.htm">chapter 9 (Structured syntax definition)</a>
  There is also a hard coded syntax for function calls with
  a parenthesis enclosed parameter list where the parameters
  are separated by commas. The hard coded syntax is described
  in <a href="expr.htm">chapter 11 (Expressions)</a>.
  Here we use a more complex syntax description:
</p>

<a name="System_declarations"><h3>3.3 System declarations</h3></a>
<p>
    With system declarations the analyzer and the interpreter
  are informed about which objects should be used for various system
  internal purposes. An example of a system declaration is
</p><pre>
    $ <font color=blue>system</font> <font color=maroon>"integer"</font> <font color=blue>is </font><font color=red>integer</font>;
</pre><p>
  This defines that the type of all integer literals is <tt>'<font color=red>integer</font>'</tt>.
  Additionally <tt>'<font color=red>integer</font>'</tt> is used as type for all integers generated
  by primitive actions.
  There are different objects which are defined by a
  system declaration
</p><ul>
    <li><!-- -  -->The types of literals and simple expressions for example:
        <tt>'<font color=red>string</font>'</tt> for strings and <tt>'<font color=red>integer</font>'</tt> for integers</li>

    <li><!-- -  -->Which objects should be used as result values for
      primitive actions for example:<pre>
        TRUE, FALSE and empty</pre></li>

    <li><!-- -  -->The EXCEPTIONS which are to be raised by
      primitive actions for example:<pre>
        NUMERIC_ERROR and MEMORY_ERROR</pre></li>

    <li><!-- -  -->Which objects should be used for several implicit
      actions for example:<pre>
        := ::= <tt>'destroy'</tt> <tt>'write'</tt> and <tt>'flush'</tt></pre></li>
</ul><p>
  The following system declarations exist
</p><pre>
    $ <font color=blue>system</font> <font color=maroon>"type"</font> <font color=blue>is</font> <font color=red>type</font>;
    $ <font color=blue>system</font> <font color=maroon>"expr"</font> <font color=blue>is</font> <font color=red>expr</font>;
    $ <font color=blue>system</font> <font color=maroon>"integer"</font> <font color=blue>is</font> <font color=red>integer</font>;
    $ <font color=blue>system</font> <font color=maroon>"char"</font> <font color=blue>is</font> <font color=red>char</font>;
    $ <font color=blue>system</font> <font color=maroon>"string"</font> <font color=blue>is</font> <font color=red>string</font>;
    $ <font color=blue>system</font> <font color=maroon>"proc"</font> <font color=blue>is</font> <font color=red>proc</font>;
    $ <font color=blue>system</font> <font color=maroon>"float"</font> <font color=blue>is</font> <font color=red>float</font>;

    $ <font color=blue>system</font> <font color=maroon>"true"</font> <font color=blue>is</font> TRUE;
    $ <font color=blue>system</font> <font color=maroon>"false"</font> <font color=blue>is</font> FALSE;
    $ <font color=blue>system</font> <font color=maroon>"empty"</font> <font color=blue>is</font> empty;

    $ <font color=blue>system</font> <font color=maroon>"memory_error"</font> <font color=blue>is</font> MEMORY_ERROR;
    $ <font color=blue>system</font> <font color=maroon>"numeric_error"</font> <font color=blue>is</font> NUMERIC_ERROR;
    $ <font color=blue>system</font> <font color=maroon>"range_error"</font> <font color=blue>is</font> RANGE_ERROR;
    $ <font color=blue>system</font> <font color=maroon>"io_error"</font> <font color=blue>is</font> IO_ERROR;
    $ <font color=blue>system</font> <font color=maroon>"illegal_action"</font> <font color=blue>is</font> ILLEGAL_ACTION;

    $ <font color=blue>system</font> <font color=maroon>"assign"</font> <font color=blue>is</font> := ;
    $ <font color=blue>system</font> <font color=maroon>"create"</font> <font color=blue>is</font> ::= ;
    $ <font color=blue>system</font> <font color=maroon>"destroy"</font> <font color=blue>is</font> destroy;
    $ <font color=blue>system</font> <font color=maroon>"ord"</font> <font color=blue>is</font> ord;
    $ <font color=blue>system</font> <font color=maroon>"in"</font> <font color=blue>is</font> <font color=blue>in</font>;
    $ <font color=blue>system</font> <font color=maroon>"prot_outfile"</font> <font color=blue>is</font> PROT_OUTFILE;
    $ <font color=blue>system</font> <font color=maroon>"flush"</font> <font color=blue>is</font> flush;
    $ <font color=blue>system</font> <font color=maroon>"write"</font> <font color=blue>is</font> write;
    $ <font color=blue>system</font> <font color=maroon>"writeln"</font> <font color=blue>is</font> writeln;
    $ <font color=blue>system</font> <font color=maroon>"main"</font> <font color=blue>is</font> main;
</pre><p></p>

<p></p>
<a name="PREDEFINED_STATEMENTS"><h2>4. PREDEFINED STATEMENTS</h2></a>
<!-- ======================== -->
<p>
    The library contains several predefined statements:
  assignment, while-statement, repeat-statement, for-statement,
  if-statement, case-statement and procedure call.

</p><p>
  Syntax:
</p><pre>
    statement ::=
      single_statement [ ';' [ statement ] ] .

    single_statement ::=
      assignment_statement | while_statement | repeat_statement |
      for_statement | if_statement | case_statement |
      procedure_call | empty_statement .

    empty_statement ::=
      'noop' .
</pre><p>
  Everywhere where one statement can be written a sequence of
  statements can also be used. The semicolon-operator concatenates
  two statements giving a new statement. The semicolon operator
  can also be used behind the last statement of a statement
  sequence. In this case the semicolon is just ignored.

</p><p>
  Declaration:
</p><pre>
    $ <font color=blue>syntax</font> <font color=red>expr</font>: .(). ; .() <font color=blue>is</font>            &lt;- 50;
    $ <font color=blue>syntax</font> <font color=red>expr</font>: .(). ; <font color=blue>is</font>                &lt;- 50 [1];

    <font color=blue>const</font> <font color=red>proc</font>: (<font color=blue>ref</font> <font color=red>void</font> <font color=blue>param</font>) ; (<font color=blue>ref</font> <font color=red>void</font> <font color=blue>param</font>) <font color=blue>is</font> noop;
</pre><p></p>

<a name="Assignment"><h3>4.1 Assignment</h3></a>
<p>
  For example:
</p><pre>
    minimum := maximum <font color=blue>div</font> 2;
</pre><p></p><dl><dt>
  Semantics:</dt><dd>
    The expression at the right side of the assignment symbol is
    evaluated and assigned to the variable at the left side.
</dd></dl><p>

  Syntax:
</p><pre>
    assignment_statement ::=
      designator ':=' expression .
</pre><p>
  The assignment statement is defined for every standard type.
</p><p>
  If an assignment for a new user defined type is needed it
  must be defined additionally.

</p><p>
  Declaration:
</p><pre>
    $ <font color=blue>syntax</font> <font color=red>expr</font>: .(). := .() <font color=blue>is</font>                     &lt;-> 20;

    <font color=blue>const</font> <font color=red>proc</font>: (<font color=blue>inout</font> <font color=red>type</font> <font color=blue>param</font>) := (<font color=blue>ref</font> <font color=red>type</font> <font color=blue>param</font>) <font color=blue>is</font>           action <font color=maroon>"TYP_CPY"</font>;
    <font color=blue>const</font> <font color=red>proc</font>: (<font color=blue>inout</font> <font color=red>proc</font> <font color=blue>param</font>) := (<font color=blue>ref</font> <font color=red>proc</font> <font color=blue>param</font>) <font color=blue>is</font>           action <font color=maroon>"PRC_CPY"</font>;
    <font color=blue>const</font> <font color=red>proc</font>: (<font color=blue>inout</font> <font color=red>func aType</font> <font color=blue>param</font>) := (<font color=blue>ref</font> <font color=red>func aType</font> <font color=blue>param</font>) <font color=blue>is</font> action <font color=maroon>"PRC_CPY"</font>;
    <font color=blue>const</font> <font color=red>proc</font>: (<font color=blue>inout</font> <font color=red>varfunc aType</font> <font color=blue>param</font>) := (<font color=blue>ref</font> <font color=red>varfunc aType</font> <font color=blue>param</font>) <font color=blue>is</font> action <font color=maroon>"PRC_CPY"</font>;
    <font color=blue>const</font> <font color=red>proc</font>: (<font color=blue>inout</font> <font color=red>ACTION</font> <font color=blue>param</font>) := (<font color=blue>in</font> <font color=red>ACTION</font> <font color=blue>param</font>) <font color=blue>is</font>        action <font color=maroon>"ACT_CPY"</font>;
    <font color=blue>const</font> <font color=red>proc</font>: (<font color=blue>inout</font> <font color=red>boolean</font> <font color=blue>param</font>) := (<font color=blue>in</font> <font color=red>boolean</font> <font color=blue>param</font>) <font color=blue>is</font>      action <font color=maroon>"BLN_CPY"</font>;
    <font color=blue>const</font> <font color=red>proc</font>: (<font color=blue>inout</font> <font color=red>integer</font> <font color=blue>param</font>) := (<font color=blue>in</font> <font color=red>integer</font> <font color=blue>param</font>) <font color=blue>is</font>      action <font color=maroon>"INT_CPY"</font>;
    <font color=blue>const</font> <font color=red>proc</font>: (<font color=blue>inout</font> <font color=red>char</font> <font color=blue>param</font>) := (<font color=blue>ref</font> <font color=red>char</font> <font color=blue>param</font>) <font color=blue>is</font>           action <font color=maroon>"CHR_CPY"</font>;
    <font color=blue>const</font> <font color=red>proc</font>: (<font color=blue>inout</font> <font color=red>string</font> <font color=blue>param</font>) := (<font color=blue>ref</font> <font color=red>string</font> <font color=blue>param</font>) <font color=blue>is</font>       action <font color=maroon>"STR_CPY"</font>;
    <font color=blue>const</font> <font color=red>proc</font>: (<font color=blue>inout</font> <font color=red>reference</font> <font color=blue>param</font>) := (<font color=blue>ref</font> <font color=red>reference</font> <font color=blue>param</font>) <font color=blue>is</font> action <font color=maroon>"REF_CPY"</font>;
    <font color=blue>const</font> <font color=red>proc</font>: (<font color=blue>inout</font> <font color=red>ref_list</font> <font color=blue>param</font>) := (<font color=blue>in</font> <font color=red>ref_list</font> <font color=blue>param</font>) <font color=blue>is</font>    action <font color=maroon>"RFL_CPY"</font>;
    <font color=blue>const</font> <font color=red>proc</font>: (<font color=blue>inout</font> <font color=red>ptrType</font> <font color=blue>param</font>) := (<font color=blue>in</font> <font color=red>ptrType</font> <font color=blue>param</font>) <font color=blue>is</font>      action <font color=maroon>"REF_CPY"</font>;
    <font color=blue>const</font> <font color=red>proc</font>: (<font color=blue>inout</font> <font color=red>varptrType</font> <font color=blue>param</font>) := (<font color=blue>in</font> <font color=red>varptrType</font> <font color=blue>param</font>) <font color=blue>is</font> action <font color=maroon>"REF_CPY"</font>;
    <font color=blue>const</font> <font color=red>proc</font>: (<font color=blue>inout</font> <font color=red>arrayType</font> <font color=blue>param</font>) := (<font color=blue>in</font> <font color=red>arrayType</font> <font color=blue>param</font>) <font color=blue>is</font>  action <font color=maroon>"ARR_CPY"</font>;
    <font color=blue>const</font> <font color=red>proc</font>: (<font color=blue>inout</font> <font color=red>bitset</font> <font color=blue>param</font>) := (<font color=blue>in</font> <font color=red>bitset</font> <font color=blue>param</font>) <font color=blue>is</font>        action <font color=maroon>"SET_CPY"</font>;
    <font color=blue>const</font> <font color=red>proc</font>: (<font color=blue>inout</font> <font color=red>structType</font> <font color=blue>param</font>) := (<font color=blue>in</font> <font color=red>structType</font> <font color=blue>param</font>) <font color=blue>is</font> action <font color=maroon>"SCT_CPY"</font>;
    <font color=blue>const</font> <font color=red>proc</font>: (<font color=blue>inout</font> <font color=red>enumType</font> <font color=blue>param</font>) := (<font color=blue>in</font> <font color=red>enumType</font></font> <font color=blue>param</font>) <font color=blue>is</font>    action <font color=maroon>"ENU_CPY"</font>;
    <font color=blue>const</font> <font color=red>proc</font>: (<font color=blue>inout</font> <font color=red>PRIMITIVE_FILE</font> <font color=blue>param</font>) := (<font color=blue>ref</font> <font color=red>PRIMITIVE_FILE</font> <font color=blue>param</font>) <font color=blue>is</font> action <font color=maroon>"FIL_CPY"</font>;
    <font color=blue>const</font> <font color=red>proc</font>: (<font color=blue>inout</font> <font color=red>file</font> <font color=blue>param</font>) := (<font color=blue>ref</font> <font color=red>file</font> <font color=blue>param</font>) <font color=blue>is</font>           action <font color=maroon>"CLS_CPY"</font>;
    <font color=blue>const</font> <font color=red>proc</font>: (<font color=blue>inout</font> <font color=red>file</font> <font color=blue>param</font>) := (<font color=blue>ref</font> <font color=red>null_file</font> <font color=blue>param</font>) <font color=blue>is</font>      action <font color=maroon>"CLS_CPY2"</font>;
    <font color=blue>const</font> <font color=red>proc</font>: (<font color=blue>inout</font> <font color=red>file</font> <font color=blue>param</font>) := (<font color=blue>ref</font> <font color=red>external_file</font> <font color=blue>param</font>) <font color=blue>is</font>  action <font color=maroon>"CLS_CPY2"</font>;
</pre><p></p>

<a name="while-statement"><h3>4.2 while-statement</h3></a>
<p>
  For example:
</p><pre>
    <font color=blue>while</font> maximum > minimum <font color=blue>do</font>
      minimum := 2 * minimum + stepValue;
      decr(stepValue);
    <font color=blue>end while</font>;
</pre><p></p><dl><dt>
  Semantics:</dt><dd>
    First the condition between <tt>'<font color=blue>while</font>'</tt> and <tt>'<font color=blue>do</font>'</tt> is evaluated.
    When this evaluation yields <tt>'FALSE'</tt>, the while-statement is
    finished. When the evaluation yields '<tt>TRUE'</tt>, the statement
    between <tt>'<font color=blue>do</font>'</tt> and <tt>'<font color=blue>end</font>'</tt> is executed and the whole while-statement
    is executed again.
</dd></dl><p>

  Syntax:
</p><pre>
    while_statement ::=
      '<font color=blue>while</font>' expression '<font color=blue>do</font>'
        statement
      '<font color=blue>end</font>' '<font color=blue>while</font>' .
</pre><p>
  The expression must be of type <tt>'<font color=blue>boolean</font>'</tt>.

</p><p>
  Declaration:
</p><pre>
    $ <font color=blue>syntax</font> <font color=red>expr</font>: .while.().do.().end.while <font color=blue>is</font>       -> 25;

    <font color=blue>const</font> <font color=red>proc</font>: while (<font color=blue>ref</font> <font color=red>func boolean</font> <font color=blue>param</font>) do (<font color=blue>ref</font> <font color=red>proc</font> <font color=blue>param</font>) end while <font color=blue>is action</font> <font color=maroon>"PRC_WHILE"</font>;
    <font color=blue>const</font> <font color=red>proc</font>: while (<font color=blue>ref</font> <font color=red>boolean</font> <font color=blue>param</font>)  do (<font color=blue>ref</font> <font color=red>proc</font> <font color=blue>param</font>) end while <font color=blue>is     action</font> <font color=maroon>"PRC_WHILE"</font>;
</pre><p>
  Alternate declaration:
</p><pre>
    <font color=blue>const</font> <font color=red>proc</font>: while (<font color=blue>ref</font> <font color=red>func boolean</font>: condition) do (<font color=blue>ref</font> <font color=red>proc</font>: statement) end while <font color=blue>is func</font>
      <font color=blue>begin</font>
        <font color=blue>if</font> condition <font color=blue>then</font>
          statement;
          <font color=blue>while</font> condition <font color=blue>do</font>
            statement;
          <font color=blue>end while</font>;
        <font color=blue>end if</font>;
      <font color=blue>end func</font>;
</pre><p></p>

<a name="repeat-statement"><h3>4.3 repeat-statement</h3></a>
<p>
  For example:
</p><pre>
    <font color=blue>repeat</font>
      incr(minimum);
      maximum := maximum - stepValue;
    <font color=blue>until</font> 2 * minimum > maximum;
</pre><p></p><dl><dt>
  Semantics:</dt><dd>
    The statement between <tt>'<font color=blue>repeat</font>'</tt> and <tt>'<font color=blue>until</font>'</tt> is executed.
    Then the condition after <tt>'<font color=blue>until</font>'</tt> is evaluated. When this
    evaluation yields <tt>'TRUE'</tt>, the repeat-statement is finished.
    When the evaluation yields <tt>'FALSE'</tt> the repeat-statement is
    executed again.
</dd></dl><p>

  Syntax:
</p><pre>
    repeat_statement ::=
      '<font color=blue>repeat</font>'
        statement
      '<font color=blue>until</font>' expression .
</pre><p>
  The expression must be of type <tt>'<font color=blue>boolean</font>'</tt>.

</p><p>
  Declaration:
</p><pre>
    $ <font color=blue>syntax</font> <font color=red>expr</font>: .repeat.().until.() <font color=blue>is</font>             -> 25;

    <font color=blue>const</font> <font color=red>proc</font>: repeat (<font color=blue>ref</font> <font color=red>proc</font> <font color=blue>param</font>) until (<font color=blue>ref</font> <font color=red>func boolean</font> <font color=blue>param</font>) <font color=blue>is action</font> <font color=maroon>"PRC_REPEAT"</font>;
    <font color=blue>const</font> <font color=red>proc</font>: repeat (<font color=blue>ref</font> <font color=red>proc</font> <font color=blue>param</font>) until (<font color=blue>ref</font> <font color=red>boolean</font> <font color=blue>param</font>) <font color=blue>is      action</font> <font color=maroon>"PRC_REPEAT"</font>;
</pre><p>
  Alternate declaration:
</p><pre>
    <font color=blue>const</font> <font color=red>proc</font>: repeat (<font color=blue>ref</font> <font color=red>proc</font>: statement) until (<font color=blue>ref</font> <font color=red>func boolean</font>: condition) <font color=blue>is func</font>
      <font color=blue>begin</font>
        statement;
        <font color=blue>if not</font> condition <font color=blue>then</font>
          <font color=blue>repeat</font>
            statement;
          <font color=blue>until</font> condition;
        <font color=blue>end if</font>;
      <font color=blue>end func</font>;
</pre><p></p>

<a name="for-statement"><h3>4.4 for-statement</h3></a>
<p>
  For example:
</p><pre>
    <font color=blue>for</font> index <font color=blue>range</font> min_index <font color=blue>to</font> max_index <font color=blue>do</font>
      sumValue +:= field[index];
    <font color=blue>end for</font>;
</pre><p></p><dl><dt>
  Semantics:</dt><dd><dl><dt>
    When the <tt>'<font color=blue>to</font>'</tt> symbol is used the for-statement is defined as
    follows:</dt><dd>
      First the lower limit and the upper limit which stand behind
      <tt>'<font color=blue>range</font>'</tt> and <tt>'<font color=blue>to</font>'</tt> are evaluated. Then the lower limit is assigned
      to the control variable which stands behind <tt>'<font color=blue>for</font>'</tt>. If the value
      of the control variable is less than or equal the upper limit
      the statements behind <tt>'<font color=blue>do</font>'</tt> are executed. After that the control
      variable is incremented and compared with the upper limit
      again. This compare - execute - increment cycle is repeated
      until the control variable is greater than the upper limit.</dd><dt>
    When the <tt>'<font color=blue>downto</font>'</tt> symbol is used the for-statement is defined as
    follows:</dt><dd>
      First the upper limit and the lower limit which stand behind
      <tt>'<font color=blue>range</font>'</tt> and <tt>'<font color=blue>downto</font>'</tt> are evaluated. Then the upper limit is
      assigned to the control variable which stands behind <tt>'<font color=blue>for</font>'</tt>. If
      the value of the control variable is greater than or equal the
      lower limit the statements behind <tt>'<font color=blue>do</font>'</tt> are executed. After that
      the control variable is decremented and compared with the lower
      limit again. This compare - execute - increment cycle is
      repeated until the control variable is less than the lower limit.</dd></dl>
</dd></dl><p>

  Syntax:
</p><pre>
    for_statement ::=
      '<font color=blue>for</font>' identifier '<font color=blue>range</font>' expression [ '<font color=blue>to</font>' | '<font color=blue>downto</font>' ] expression '<font color=blue>do</font>'
        statement
      '<font color=blue>end</font>' '<font color=blue>for</font>' .
</pre><p>

  Declaration:
</p><pre>
    $ <font color=blue>syntax</font> <font color=red>expr</font>: .for.().range.().to.().do.().end.for <font color=blue>is</font>     -> 25;
    $ <font color=blue>syntax</font> <font color=red>expr</font>: .for.().range.().downto.().do.().end.for <font color=blue>is</font> -> 25;

    <font color=blue>const</font> <font color=red>proc</font>: FOR_DECLS (<font color=blue>in</font> <font color=red>type</font>: aType) <font color=blue>is func</font>
      <font color=blue>begin</font>
        <font color=blue>const</font> <font color=red>proc</font>: for (<font color=blue>inout</font> <font color=red>aType</font>: variable) range
            (<font color=blue>in</font> <font color=red>aType</font>: lower_limit) to (<font color=blue>in</font> <font color=red>aType</font>: upper_limit) do
            (<font color=blue>in</font> <font color=red>proc</font>: statements) end for <font color=blue>is func</font>
          <font color=blue>begin</font>
            variable := lower_limit;
            <font color=blue>if</font> variable &lt;= upper_limit <font color=blue>then</font>
              statements;
              <font color=blue>while</font> variable &lt; upper_limit <font color=blue>do</font>
                incr(variable);
                statements;
              <font color=blue>end while</font>;
            <font color=blue>end if</font>;
          <font color=blue>end func</font>;

        <font color=blue>const</font> <font color=red>proc</font>: for (<font color=blue>inout</font> <font color=red>aType</font>: variable) range
            (<font color=blue>in</font> <font color=red>aType</font>: upper_limit) downto (<font color=blue>in</font> <font color=red>aType</font>: lower_limit) do
            (<font color=blue>in</font> <font color=red>proc</font>: statements) end for <font color=blue>is func</font>
          <font color=blue>begin</font>
            variable := upper_limit;
            <font color=blue>if</font> variable >= lower_limit <font color=blue>then</font>
              statements;
              <font color=blue>while</font> variable > lower_limit <font color=blue>do</font>
                decr(variable);
                statements;
              <font color=blue>end while</font>;
            end if;
          <font color=blue>end func</font>;
      <font color=blue>end func</font>;

    FOR_DECLS(<font color=red>integer</font>);
    FOR_DECLS(<font color=red>char</font>);
    FOR_DECLS(<font color=red>boolean</font>);
</pre><p></p>

<a name="for-each-statement"><h3>4.5 for-each-statement</h3></a>
<p>
  For example:
</p><pre>
    <font color=blue>for</font> currObject <font color=blue>range</font> element_list <font color=blue>do</font>
      result &:= " " & str(currObject);
    <font color=blue>end for</font>;
</pre><p></p><dl><dt>
  Semantics:</dt><dd>
    First the element list which stands behind <tt>'<font color=blue>range</font>'</tt> is evaluated.
    If the element list is empty the for-each-statement is finished.
    Otherwise the first element of the element list is assigned
    to the control variable which stands behind <tt>'<font color=blue>for</font>'</tt>. Then the
    statements behind <tt>'<font color=blue>do</font>'</tt> are executed. If there is no next element
    in the element the for-each-statement is finished. Otherwise
    the next element of the element list is assigned to the control
    variable. This check for next element - execute cycle is repeated
    until there is no next element in the element list.
</dd></dl><p>

  Syntax:
</p><pre>
    for_statement ::=
      '<font color=blue>for</font>' identifier '<font color=blue>range</font>' expression '<font color=blue>do</font>'
        statement
      '<font color=blue>end</font>' '<font color=blue>for</font>' .
</pre><p>

  Declaration:
</p><pre>
    $ <font color=blue>syntax</font> <font color=red>expr</font>: .for.().range.().do.().end.for <font color=blue>is</font>          -> 25;

    <font color=blue>const</font> <font color=red>proc</font>: for (<font color=blue>ref</font> <font color=red>reference</font> <font color=blue>param</font>) range (<font color=blue>ref</font> <font color=red>ref_list</font> <font color=blue>param</font>) do
                  (<font color=blue>ref</font> <font color=red>proc</font> <font color=blue>param</font>)
                end for <font color=blue>is action</font> <font color=maroon>"RFL_FOR"</font>;

    <font color=blue>const</font> <font color=red>proc</font>: for (<font color=blue>inout</font> <font color=red>baseType</font>: variable) range (<font color=blue>in</font> <font color=red>arrayType</font>: arr_obj) do
                  (<font color=blue>in</font> <font color=red>proc</font>: statements)
                end for <font color=blue>is func</font>
      <font color=blue>local</font>
        <font color=blue>var</font> <font color=red>integer</font>: number <font color=blue>is</font> 0;
      <font color=blue>begin</font>
        <font color=blue>for</font> number <font color=blue>range</font> 1 <font color=blue>to</font> length(arr_obj) <font color=blue>do</font>
          variable := arr_obj[number];
          statements;
        <font color=blue>end for</font>;
      <font color=blue>end func</font>;

    <font color=blue>const</font> <font color=red>proc</font>: for (<font color=blue>inout</font> <font color=red>baseType</font>: variable) range (<font color=blue>in</font> <font color=red>setType</font>: a_set) do
                  (<font color=blue>in</font> <font color=red>proc</font>: statements)
                end for <font color=blue>is func</font>
      <font color=blue>begin</font>
        <font color=blue>for</font> variable <font color=blue>range</font> min(a_set) <font color=blue>to</font> max(a_set) <font color=blue>do</font>
          <font color=blue>if</font> variable <font color=blue>in</font> a_set <font color=blue>then</font>
            statements;
          <font color=blue>end if</font>;
        <font color=blue>end for</font>;
      <font color=blue>end func</font>;
</pre><p></p>

<a name="if-statement"><h3>4.6 if-statement</h3></a>
<p>
  For example:
</p><pre>
    <font color=blue>if</font> sumValue &lt; minimum <font color=blue>then</font>
      factor := sumValue;
      sumValue := minimum;
    <font color=blue>elsif</font> sumValue > maximum <font color=blue>then</font>
      factor := -sumValue;
      sumValue := maximum;
    <font color=blue>else</font>
      factor := 0;
    <font color=blue>end if</font>;
</pre><p></p><dl><dt>
  Semantics:</dt><dd>
    The expressions before <tt>'<font color=blue>then</font>'</tt> are evaluated in row.
    When such an expression evaluates to 'TRUE' the statements
    behind <tt>'<font color=blue>then</font>'</tt> are executed and the if-statement is finished.
    If all expressions before <tt>'<font color=blue>then</font>'</tt> evaluate to 'FALSE' and an
    else-part is present the statements behind <tt>'<font color=blue>else</font>'</tt> are executed
    and the if-statement is finished.
    If all expressions before <tt>'<font color=blue>then</font>'</tt> evaluate to 'FALSE' and no
    else-part is present the if-statement is finished.
</dd></dl><p>

  Syntax:
</p><pre>
    if_statement ::=
      '<font color=blue>if</font>' expression '<font color=blue>then</font>'
        statement
      { '<font color=blue>elsif</font>' expression '<font color=blue>then</font>'
        statement }
      [ '<font color=blue>else</font>'
        statement ]
      '<font color=blue>end</font>' '<font color=blue>if</font>' .
</pre><p>
  The expression must be of type <tt>'<font color=blue>boolean</font>'</tt>.

</p><p>
  Declaration:
</p><pre>
    $ <font color=blue>syntax</font> <font color=red>expr</font>: .if.().then.().end.if <font color=blue>is</font>           -> 25;
    $ <font color=blue>syntax</font> <font color=red>expr</font>: .if.().then.().().end.if <font color=blue>is</font>        -> 25;

    $ <font color=blue>syntax</font> <font color=red>expr</font>: .elsif.().then.() <font color=blue>is</font>               &lt;- 60;
    $ <font color=blue>syntax</font> <font color=red>expr</font>: .elsif.().then.().() <font color=blue>is</font>            &lt;- 60;
    $ <font color=blue>syntax</font> <font color=red>expr</font>: .else.() <font color=blue>is</font>                        &lt;- 60;

    <font color=blue>const</font> <font color=red>type</font>: ELSIF_RESULT <font color=blue>is</font> newtype;
    <font color=blue>const</font> <font color=red>proc</font>: (ref ELSIF_RESULT <font color=blue>param</font>) ::= enumlit <font color=blue>is  action</font> <font color=maroon>"ENU_GENLIT"</font>;
    <font color=blue>const</font> <font color=red>ELSIF_RESULT</font>: ELSIF_EMPTY <font color=blue>is</font> enumlit;
    <font color=blue>const</font> <font color=red>type</font>: ELSIF_PROC <font color=blue>is</font>                        (func ELSIF_RESULT);
    <font color=blue>const</font> <font color=red>proc</font>: (ref ELSIF_PROC <font color=blue>param</font>) ::= (ref ELSIF_RESULT <font color=blue>param</font>) <font color=blue>is action</font> <font color=maroon>"ENU_CREATE"</font>;

    <font color=blue>const</font> <font color=red>proc</font>:       if (<font color=blue>in</font> <font color=red>boolean</font> <font color=blue>param</font>) then
                        (<font color=blue>in</font> <font color=red>proc</font> <font color=blue>param</font>)
                      end if <font color=blue>is                        action</font> <font color=maroon>"PRC_IF"</font>;

    <font color=blue>const</font> <font color=red>proc</font>:       if (<font color=blue>in</font> <font color=red>boolean</font> <font color=blue>param</font>) then
                        (<font color=blue>in</font> <font color=red>proc</font> <font color=blue>param</font>)
                      (<font color=blue>in</font> <font color=red>ELSIF_PROC</font> <font color=blue>param</font>)
                      end if <font color=blue>is                        action</font> <font color=maroon>"PRC_IF_ELSIF"</font>;

    <font color=blue>const</font> <font color=red>ELSIF_PROC</font>: elsif (<font color=blue>in</font> <font color=red>boolean</font> <font color=blue>param</font>) then
                        (<font color=blue>in</font> <font color=red>proc</font> <font color=blue>param</font>) <font color=blue>is             action</font> <font color=maroon>"PRC_IF"</font>;

    <font color=blue>const</font> <font color=red>ELSIF_PROC</font>: elsif (<font color=blue>in</font> <font color=red>boolean</font> <font color=blue>param</font>) then
                        (<font color=blue>in</font> <font color=red>proc</font> <font color=blue>param</font>)
                      (<font color=blue>in</font> <font color=red>ELSIF_PROC</font> <font color=blue>param</font>) <font color=blue>is         action</font> <font color=maroon>"PRC_IF_ELSIF"</font>;

    <font color=blue>const</font> <font color=red>ELSIF_PROC</font>: else
                        (<font color=blue>in</font> <font color=red>void</font> <font color=blue>param</font>) <font color=blue>is</font>             ELSIF_EMPTY;


    <font color=blue>const</font> <font color=red>proc</font>: if TRUE  then (<font color=blue>in</font> <font color=red>void</font> <font color=blue>param</font>) end if <font color=blue>is</font>                           noop;
    <font color=blue>const</font> <font color=red>proc</font>: if TRUE  then (<font color=blue>in</font> <font color=red>void</font> <font color=blue>param</font>) (<font color=blue>in</font> <font color=red>ELSIF_PROC</font> <font color=blue>param</font>) end if <font color=blue>is</font>     noop;
    <font color=blue>const</font> <font color=red>proc</font>: if FALSE then (<font color=blue>in</font> <font color=red>proc</font> <font color=blue>param</font>) end if <font color=blue>is</font>                           noop;
    <font color=blue>const</font> <font color=red>proc</font>: if FALSE then (<font color=blue>in</font> <font color=red>proc</font> <font color=blue>param</font>) (<font color=blue>in</font> <font color=red>ELSIF_RESULT</font> <font color=blue>param</font>) end if <font color=blue>is</font>   noop;
    <font color=blue>const</font> <font color=red>ELSIF_PROC</font>: elsif TRUE  then (<font color=blue>in</font> <font color=red>void</font> <font color=blue>param</font>) <font color=blue>is</font>                         ELSIF_EMPTY;
    <font color=blue>const</font> <font color=red>ELSIF_PROC</font>: elsif TRUE then (<font color=blue>in</font> <font color=red>void</font> <font color=blue>param</font>) (<font color=blue>in</font> <font color=red>ELSIF_PROC</font> <font color=blue>param</font>)   <font color=blue>is</font>  ELSIF_EMPTY;
    <font color=blue>const</font> <font color=red>ELSIF_PROC</font>: elsif FALSE then (<font color=blue>in</font> <font color=red>proc</font> <font color=blue>param</font>) <font color=blue>is</font>                         ELSIF_EMPTY;
    <font color=blue>const</font> <font color=red>ELSIF_PROC</font>: elsif FALSE then (<font color=blue>in</font> <font color=red>proc</font> <font color=blue>param</font>) (<font color=blue>in</font> <font color=red>ELSIF_RESULT</font> <font color=blue>param</font>) <font color=blue>is</font> ELSIF_EMPTY;
</pre><p></p>

<a name="case-statement"><h3>4.7 case-statement</h3></a>
<p>
  For example:
</p><pre>
    <font color=blue>case</font> currChar <font color=blue>of</font>
      <font color=blue>when</font> {<font color=maroon>'A'</font>, <font color=maroon>'B'</font>, <font color=maroon>'C'</font>, <font color=maroon>'D'</font>, <font color=maroon>'E'</font>, <font color=maroon>'F'</font>, <font color=maroon>'G'</font>, <font color=maroon>'H'</font>, <font color=maroon>'I'</font>, <font color=maroon>'J',
          'K'</font>, <font color=maroon>'L'</font>, <font color=maroon>'M'</font>, <font color=maroon>'N'</font>, <font color=maroon>'O'</font>, <font color=maroon>'P'</font>, <font color=maroon>'Q'</font>, <font color=maroon>'R'</font>, <font color=maroon>'S'</font>, <font color=maroon>'T',
          'U'</font>, <font color=maroon>'V'</font>, <font color=maroon>'W'</font>, <font color=maroon>'X'</font>, <font color=maroon>'Y'</font>, <font color=maroon>'Z'</font>}:
        characterClass := LETTER;
      <font color=blue>when</font> {<font color=maroon>'0'</font>, <font color=maroon>'1'</font>, <font color=maroon>'2'</font>, <font color=maroon>'3'</font>, <font color=maroon>'4'</font>, <font color=maroon>'5'</font>, <font color=maroon>'6'</font>, <font color=maroon>'7'</font>, <font color=maroon>'8'</font>, <font color=maroon>'9'</font>}:
        characterClass := DIGIT;
      <font color=blue>when</font> {<font color=maroon>'!'</font>, <font color=maroon>'$'</font>, <font color=maroon>'%'</font>, <font color=maroon>'&'</font>, <font color=maroon>'*'</font>, <font color=maroon>'+'</font>, <font color=maroon>','</font>, <font color=maroon>'-'</font>, <font color=maroon>'.'</font>, <font color=maroon>'/',
          ':'</font>, <font color=maroon>';'</font>, <font color=maroon>'&lt;'</font>, <font color=maroon>'='</font>, <font color=maroon>'>'</font>, <font color=maroon>'?'</font>, <font color=maroon>'@'</font>, <font color=maroon>'\'</font>, <font color=maroon>'^'</font>, <font color=maroon>'`',
          '|'</font>, <font color=maroon>'~'</font>}:
        characterClass := SPECIAL;
      <font color=blue>when</font> {<font color=maroon>'('</font>, <font color=maroon>')'</font>, <font color=maroon>'['</font>, <font color=maroon>']'</font>, <font color=maroon>'{'</font>, <font color=maroon>'}'</font>}:
        characterClass := PAREN;
      <font color=blue>when</font> {<font color=maroon>'"'</font>}:  <font color=green># Also possible '\"'</font>
        characterClass := APPOSTROPHE;
      <font color=blue>when</font> {<font color=maroon>'''</font>}:  <font color=green># Also possible '\''</font>
        characterClass := QUOTE;
      <font color=blue>otherwise</font>:
        characterClass := ILLEGAL;
    <font color=blue>end case</font>;
</pre><p></p><dl><dt>
  Semantics:</dt><dd>
    The expression between <tt>'<font color=blue>case</font>'</tt> and <tt>'<font color=blue>of</font>'</tt> is evaluated. When the
    resulting value is element of a set behind a <tt>'<font color=blue>when</font>'</tt> the
    statements behind the corresponding colon are executed and
    the case-statement is finished. If the value is not element of
    a set behind a <tt>'<font color=blue>when</font>'</tt> and an <tt>'<font color=blue>otherwise</font>'</tt> part is present the
    statements behind the colon of the <tt>'<font color=blue>otherwise</font>'</tt> are executed
    and the case-statement is finished. If the value is not element
    of a set behind a <tt>'<font color=blue>when</font>'</tt> and no <tt>'<font color=blue>otherwise</font>'</tt> part is present
    the case-statement is finished.
</dd></dl><p>

  Syntax:
</p><pre>
    case_statement ::=
      '<font color=blue>case</font>' expression '<font color=blue>of</font>'
        { '<font color=blue>when</font>' set_expression ':'
          statement }
        [ '<font color=blue>otherwise</font>' ':'
          statement ]
      '<font color=blue>end</font>' '<font color=blue>case</font>' .
</pre><p>

  Declaration:
</p><pre>
    $ <font color=blue>syntax</font> <font color=red>expr</font>: .case.().of.().end.case <font color=blue>is</font>                      -> 25;
    $ <font color=blue>syntax</font> <font color=red>expr</font>: .case.().of.().otherwise. : .().end.case <font color=blue>is</font>     -> 25;
    $ <font color=blue>syntax</font> <font color=red>expr</font>: .case.().of.end.case <font color=blue>is</font>                         -> 25;

    $ <font color=blue>syntax</font> <font color=red>expr</font>: .when.(). : .().() <font color=blue>is</font>              &lt;- 60;
    $ <font color=blue>syntax</font> <font color=red>expr</font>: .when.(). : .() <font color=blue>is</font>                 &lt;- 60;

    <font color=blue>const</font> <font color=red>proc</font>: CASE_DECLS (<font color=blue>in</font> <font color=red>type</font>: aType) <font color=blue>is func</font>
      <font color=blue>local</font>
        <font color=blue>var</font> <font color=red>type</font>: WHEN_RESULT <font color=blue>is</font> <font color=red>void</font>;
        <font color=blue>var</font> <font color=red>type</font>: WHEN_PROC <font color=blue>is</font> <font color=red>void</font>;
        <font color=blue>var</font> <font color=red>type</font>: SELECTOR_TYPE <font color=blue>is</font> <font color=red>void</font>;
      <font color=blue>begin</font>
        <font color=red>WHEN_RESULT</font> := newtype;
        <font color=red>WHEN_PROC</font> := (<font color=red>func WHEN_RESULT</font>);
        <font color=red>SELECTOR_TYPE</font> := <font color=red>set of aType</font>;
        <font color=blue>const</font> <font color=red>proc</font>: case (<font color=blue>ref</font> <font color=red>aType</font> <font color=blue>param</font>) of end case                       <font color=blue>is</font> noop;
        <font color=blue>const</font> <font color=red>proc</font>: case (<font color=blue>ref</font> <font color=red>aType</font> <font color=blue>param</font>) of
                      (<font color=blue>ref</font> <font color=red>WHEN_PROC</font> <font color=blue>param</font>)
                    end case                                                 <font color=blue>is action</font> <font color=maroon>"PRC_CASE"</font>;
        <font color=blue>const</font> <font color=red>proc</font>: case (<font color=blue>ref</font> <font color=red>aType</font> <font color=blue>param</font>) of
                      (<font color=blue>ref</font> <font color=red>WHEN_PROC</font> <font color=blue>param</font>)
                      otherwise : (<font color=blue>ref</font> <font color=red>proc</font> <font color=blue>param</font>)
                    end case                                                 <font color=blue>is action</font> <font color=maroon>"PRC_CASE_DEF"</font>;
        <font color=blue>const</font> <font color=red>proc</font>: (<font color=blue>ref</font> <font color=red>WHEN_RESULT</font> <font color=blue>param</font>) ::= enumlit                      <font color=blue>is action</font> <font color=maroon>"ENU_GENLIT"</font>;
        <font color=blue>const</font> <font color=red>WHEN_RESULT</font>: WHEN_EMPTY (<font color=blue>attr</font> <font color=red>aType</font>) is enumlit;
        <font color=blue>const</font> <font color=red>proc</font>: (<font color=blue>ref</font> <font color=red>WHEN_PROC</font> <font color=blue>param</font>) ::= (<font color=blue>ref</font> <font color=red>WHEN_RESULT</font> <font color=blue>param</font>)        <font color=blue>is action</font> <font color=maroon>"ENU_CREATE"</font>;
        <font color=blue>const</font> <font color=red>WHEN_PROC</font>: when (<font color=blue>ref</font> <font color=red>SELECTOR_TYPE</font> <font color=blue>param</font>) : (<font color=blue>ref</font> <font color=red>proc</font> <font color=blue>param</font>)   <font color=blue>is</font> WHEN_EMPTY(<font color=red>aType</font>);
        <font color=blue>const</font> <font color=red>WHEN_PROC</font>: when (<font color=blue>ref</font> <font color=red>SELECTOR_TYPE</font> <font color=blue>param</font>) : (<font color=blue>ref</font> <font color=red>proc</font> <font color=blue>param</font>)
                           (<font color=blue>ref</font> <font color=red>WHEN_PROC</font> <font color=blue>param</font>)                             <font color=blue>is</font> WHEN_EMPTY(<font color=red>aType</font>);
      <font color=blue>end func</font>;

    CASE_DECLS(<font color=red>integer</font>);
    CASE_DECLS(<font color=red>char</font>);
</pre><p></p>

<p></p>
<a name="PREDEFINED_TYPES"><h2>5. PREDEFINED TYPES</h2></a>
<!-- =================== -->
<p>
    In the following subchapters the predefined types of the
  standard library are introduced. The operators have, when not
  stated otherwise, the type described in the subchapter as
  parameter type and result type. The relations have also the
  type described in the subchapter as parameter type and
  a result of type <tt>'<font color=red>boolean</font>'</tt>. In the descriptions <tt>=></tt> is used
  to show an equivalent expression.
</p>

<a name="boolean"><h3>5.1 boolean</h3></a>
<p>
    The type <tt>'<font color=red>boolean</font>'</tt> consists of the two truth values
  TRUE and FALSE.
</p><pre>
    Prefix operators:
      <font color=blue>not</font>       Negation
                  ( <font color=blue>not</font> TRUE => FALSE,
                    <font color=blue>not</font> FALSE => TRUE )
    Infix operators:
      <font color=blue>and</font>       Logical and
                  ( TRUE <font color=blue>and</font> TRUE => TRUE,
                    A <font color=blue>and</font> B => FALSE else )
      <font color=blue>or</font>        Inclusive logical or
                  ( FALSE <font color=blue>or</font> FALSE => FALSE,
                    A <font color=blue>or</font> B => TRUE else )
      <font color=red>boolean</font> <font color=blue>conv</font> A   Conversion of <font color=red>integer</font> to <font color=red>boolean</font>
                  ( Type of argument A: <font color=red>integer</font>,
                    <font color=red>boolean</font> <font color=blue>conv</font> 0 => FALSE,
                    <font color=red>boolean</font> <font color=blue>conv</font> 1 => TRUE )
      <font color=red>boolean</font> <font color=blue>parse</font> A   Conversion of <font color=red>string</font> to <font color=red>boolean</font>
                  ( Type of argument A: <font color=red>string</font>,
                    <font color=red>boolean</font> <font color=blue>parse</font> <font color=maroon>"FALSE"</font> => FALSE,
                    <font color=red>boolean</font> <font color=blue>parse</font> <font color=maroon>"TRUE"</font> => TRUE,
                    <font color=red>boolean</font> <font color=blue>parse</font> <font color=maroon>"TRUE "</font> => EXCEPTION RANGE_ERROR,
                    <font color=red>boolean</font> <font color=blue>parse</font> <font color=maroon>"ASDF"</font> => EXCEPTION RANGE_ERROR )
    Relations:
      =, &lt;>, >, >=, &lt;, &lt;=
                  ( A relation B =>
                    ord(A) relation ord(B) )
    Functions:
      ord(A)    Ordinal number
                  ( Type of result: <font color=red>integer</font>,
                    ord(FALSE) => 0, ord(TRUE) => 1 )
      succ(A)   Successor
                  ( succ(FALSE) => TRUE,
                    succ(TRUE) => EXCEPTION RANGE_ERROR )
      pred(A)   Predecessor
                  ( pred(FALSE) => EXCEPTION RANGE_ERROR )
                    pred(TRUE) => FALSE )
      str(A)    Conversion to <font color=red>string</font>
                  ( Type of result: <font color=red>string</font>,
                    str(FALSE) => <font color=maroon>"FALSE"</font>,
                    str(TRUE) => <font color=maroon>"TRUE"</font> )
      rand(A, B) Random value in the range [A, B]
                 The random values are uniform distributed.
                  ( rand(A, B) returns a random value such that
                    A &lt;= rand(A, B) <font color=blue>and</font> rand(A, B) &lt;= B holds.
                    rand(A, A) => A,
                    rand(TRUE, FALSE) => EXCEPTION RANGE_ERROR )
      compare(A, B) Compare function
                  ( Type of result: <font color=red>integer</font>,
                    compare(FALSE, TRUE) => -1,
                    compare(TRUE, TRUE) => 0,
                    compare(TRUE, FALSE) => 1 )
      hashCode(A) Hash function
                  ( Type of result: <font color=red>integer</font> )
    Statements:
      incr(A)   Increment
                  ( incr(A) => A:=succ(A) )
      decr(A)   Decrement
                  ( decr(A) => A:=pred(A) )
</pre><p>

    The logical operators <tt>'<font color=blue>and</font>'</tt> and <tt>'<font color=blue>or</font>'</tt> work strictly left
  to right. First they evaluate the left operand and then
  the right operand. When the result of the operation can be
  determined after evaluation of the left operand the right
  operand is not evaluated. This can be used to check for
  a boundary in a boolean expression. Naturally side effects
  of the right operand of the <tt>'<font color=blue>and</font>'</tt> and <tt>'<font color=blue>or</font>'</tt> operator only
  take place when the operand is executed.

</p><p>
  Table for the behaviour of different boolean expressions:
</p><pre>
                               Result when the    Result when the
    Expression                  first operand      first operand
                             evaluates to FALSE  evaluates to TRUE

    <font color=blue>not</font> A                           TRUE               FALSE
    A <font color=blue>and</font> B  respectively
      <font color=blue>not</font>((<font color=blue>not</font> A)<font color=blue>or</font>(<font color=blue>not</font> B))         FALSE                B
    A <font color=blue>or</font>  B  respectively
      <font color=blue>not</font>((<font color=blue>not</font> A)<font color=blue>and</font>(<font color=blue>not</font> B))          B                TRUE
    A >  B  respectively
      A <font color=blue>and</font>(<font color=blue>not</font> B)                  FALSE              <font color=blue>not</font> B
    A >= B  respectively
      A <font color=blue>or</font>(<font color=blue>not</font> B)                   <font color=blue>not</font> B              TRUE
    A &lt;  B  respectively
      (<font color=blue>not</font> A)<font color=blue>and</font> B                    B                FALSE
    A &lt;= B  respectively
      (<font color=blue>not</font> A)<font color=blue>or</font> B                   TRUE                 B
    <font color=blue>not</font> (A <font color=blue>and</font> B)  respectively
      (<font color=blue>not</font> A)<font color=blue>or</font>(<font color=blue>not</font> B)              TRUE               <font color=blue>not</font> B
    <font color=blue>not</font> (A <font color=blue>or</font> B)  respectively
      (<font color=blue>not</font> A)<font color=blue>and</font>(<font color=blue>not</font> B)             <font color=blue>not</font> B              FALSE
</pre><p>

  Optimizing boolean expressions:
</p><p>
    When the result of a boolean expression can be
  determined at compile time, the expression can be
  replaced by a constant. Additionally the following
  equations can be used:
</p><pre>
    (A <font color=blue>or</font>  B) <font color=blue>and</font> (A <font color=blue>or</font>  C)  =  A <font color=blue>or</font>  (B <font color=blue>and</font> C)
    (A <font color=blue>and</font> B) <font color=blue>or</font>  (A <font color=blue>and</font> C)  =  A <font color=blue>and</font> (B <font color=blue>or</font>  C)
</pre><p></p>

<a name="integer"><h3>5.2 integer</h3></a>
<p>
    The type <tt>'<font color=red>integer</font>'</tt> consists of signed integer numbers
  which are at least 32 bits wide. An <tt>'<font color=red>integer</font>'</tt> literal is
  a sequence of digits which is taken to be decimal. The
  sequence of digits may be followed by the letter E or e
  an optional + sign and a decimal exponent. Based numbers
  can be specified when the sequence of digits is followed
  by the # character and a sequence of extended digits.
  The decimal number in front of the # character specifies
  the base of the number which follows the # character.
  As base a number between 2 and 36 is allowed. As
  extended digits the letters A or a can be used for 10,
  B or b can be used for 11 and so on to Z or z which can
  be used as 35. Examples of <tt>'<font color=red>integer</font>'</tt> literals are:
</p><pre>
    0   2147483647   1E6   2e+9   16#c0   16#FFFF   8#177777   2#1010101010
</pre><p>
  The result of an <tt>'<font color=red>integer</font>'</tt> operation is undefined when
  it overflows.
</p><pre>
    Prefix operators:
      +         Identity
      -         Change sign
      !         Factorial
    Infix operators:
      +         Addition
      -         Subtraction
      *         Multiplication
      <font color=blue>div</font>       Integer division truncated towards zero
                  ( A <font color=blue>div</font> B => trunc(flt(A) / flt(B)),
                    A <font color=blue>div</font> 0 => EXCEPTION NUMERIC_ERROR )
      <font color=blue>rem</font>       Reminder of integer division <font color=blue>div</font>
                  ( A <font color=blue>rem</font> B => A - (A <font color=blue>div</font> B) * B,
                    A <font color=blue>rem</font> 0 => EXCEPTION NUMERIC_ERROR )
      <font color=blue>mdiv</font>      Integer division truncated towards negative infinity
                  ( A <font color=blue>mdiv</font> B => round(floor(flt(A) / flt(B))),
                    A <font color=blue>mdiv</font> 0 => EXCEPTION NUMERIC_ERROR )
      <font color=blue>mod</font>       Reminder of integer division <font color=blue>mdiv</font>
                  ( A <font color=blue>mod</font> B => A - (A <font color=blue>mdiv</font> B) * B,
                    A <font color=blue>mod</font> 0 => EXCEPTION NUMERIC_ERROR )
      **        Power
                  ( A ** B is okay for B >= 0,
                    A ** 0 => 1,
                    1 ** B => 1 for B >= 0,
                    A ** B => -(-A) ** B for A <= 0 and B >= 0 and odd(B),
                    A ** B => (-A) ** B for A <= 0 and B >= 0 and not odd(B),
                    A ** -1 => EXCEPTION NUMERIC_ERROR )
      A &lt;&lt; B    Shift left
                  ( A &lt;&lt; B is okay for B >= 0 and B <= 31,
                    A &lt;&lt; B => A * 2_ ** B,
                    A &lt;&lt; 0 => A )
      A >> B    Arithmetic shift right
                  ( A >> B is okay for B >= 0 and B <= 31,
                    A >> B => A <font color=blue>mdiv</font> 2_ ** B  for B <= 30,
                    A >> B => C for A >= 0 holds: C >= 0
                    A >> B => C for A < 0 holds: C < 0
                    A >> B => 0 for A >= 0 and B > ord(log2(A)),
                    A >> B => -1 for A < 0 and B > ord(log2(-A)),
                    A >> 0 => A )
      !         Binomial coefficient
                  ( A ! B => !A <font color=blue>div</font> (!B * !(A - B)) )
      <font color=blue>lpad</font>      Left padding with spaces
                  ( 123 <font color=blue>lpad</font>  8 => <font color=maroon>"     123"</font>,
                    123 <font color=blue>lpad</font>  4 => <font color=maroon>" 123"</font>,
                    123 <font color=blue>lpad</font>  3 => <font color=maroon>"123"</font>,
                    123 <font color=blue>lpad</font>  2 => <font color=maroon>"123"</font>,
                    123 <font color=blue>lpad</font> -8 => <font color=maroon>"123"</font> )
                    -12 <font color=blue>lpad</font>  4 => <font color=maroon>" -12"</font>,
                    -12 <font color=blue>lpad</font>  3 => <font color=maroon>"-12"</font>,
                    -12 <font color=blue>lpad</font>  2 => <font color=maroon>"-12"</font> )
      <font color=blue>lpad0</font>     Left padding with zeros
                  ( 123 <font color=blue>lpad0</font>  8 => <font color=maroon>"00000123"</font>,
                    123 <font color=blue>lpad0</font>  4 => <font color=maroon>"0123"</font>,
                    123 <font color=blue>lpad0</font>  3 => <font color=maroon>"123"</font>,
                    123 <font color=blue>lpad0</font>  2 => <font color=maroon>"123"</font>,
                    123 <font color=blue>lpad0</font> -8 => <font color=maroon>"123"</font>,
                    -12 <font color=blue>lpad0</font>  4 => <font color=maroon>"-012"</font>,
                    -12 <font color=blue>lpad0</font>  3 => <font color=maroon>"-12"</font>,
                    -12 <font color=blue>lpad0</font>  2 => <font color=maroon>"-12"</font> )
      <font color=blue>lpad</font>      Left padding with spaces
                  ( 123 <font color=blue>rpad</font>  8 => <font color=maroon>"123     "</font>,
                    123 <font color=blue>rpad</font>  4 => <font color=maroon>"123 "</font>,
                    123 <font color=blue>rpad</font>  3 => <font color=maroon>"123"</font>,
                    123 <font color=blue>rpad</font>  2 => <font color=maroon>"123"</font>,
                    123 <font color=blue>rpad</font> -8 => <font color=maroon>"123"</font> )
                    -12 <font color=blue>rpad</font>  4 => <font color=maroon>"-12 "</font>,
                    -12 <font color=blue>rpad</font>  3 => <font color=maroon>"-12"</font>,
                    -12 <font color=blue>rpad</font>  2 => <font color=maroon>"-12"</font> )
      <font color=red>integer</font> <font color=blue>conv</font> A   Identity
                  ( <font color=red>integer</font> <font color=blue>conv</font> A => A )
      <font color=red>integer</font> <font color=blue>parse</font> A   Conversion of <font color=red>string</font> to <font color=red>integer</font>
                  ( Type of argument A: <font color=red>string</font>,
                    <font color=red>integer</font> <font color=blue>parse</font> <font color=maroon>"123"</font> => 123,
                    <font color=red>integer</font> <font color=blue>parse</font> <font color=maroon>"-123"</font> => -123,
                    <font color=red>integer</font> <font color=blue>parse</font> <font color=maroon>"+5"</font> => 5,
                    <font color=red>integer</font> <font color=blue>parse</font> <font color=maroon>" 1"</font> => EXCEPTION RANGE_ERROR,
                    <font color=red>integer</font> <font color=blue>parse</font> <font color=maroon>"10 "</font> => EXCEPTION RANGE_ERROR,
                    <font color=red>integer</font> <font color=blue>parse</font> <font color=maroon>"ASDF"</font> => EXCEPTION RANGE_ERROR )
    Relations:
      =, &lt;>, &lt;, &lt;=, >, >=
    Functions:
      ord(A)    Identity
      succ(A)   Successor
                  ( succ(A) => A+1 )
      pred(A)   Predecessor
                  ( pred(A) => A-1 )
      abs(A)    Absolute value
      odd(A)    Odd value
                  ( Type of result: <font color=red>boolean</font> )
      str(A)    Conversion to <font color=red>string</font>
                  ( Type of result: <font color=red>string</font> )
      literal(A) Conversion to a literal
                  ( Type of result: <font color=red>string</font>,
                    literal(A) => str(A) )
      sqrt(A)   Integer square root
                  ( sqrt(A) is okay for A >= 0
                    sqrt(A) => trunc(sqrt(flt(A))),
                    sqrt(-1) => EXCEPTION NUMERIC_ERROR )
      log2(A)   Truncated base 2 logarithm
                  ( log2(A) returns the position of the
                    highest bit set. It is defined for A >= 0
                    log2(2 ** A) = A for A >= 0,
                    log2(0) => -1,
                    log2(1) => 0,
                    log2(2) => 1,
                    log2(-1) => EXCEPTION NUMERIC_ERROR )
      bitLength(A) Number of bits in the minimal two's-complement
                   representation, excluding the sign bit.
                  ( bitLength(A) => succ(log2(A)) for A >= 0,
                    bitLength(A) => succ(log2(pred(-A))) for A < 0 )
      lowestSetBit(A) Index of the lowest-order one bit
                      For A <> 0 this is equal to to number of
                      lowest-order zero bits.
                  ( A >> B &lt;&lt; B = A for A <> 0 and B = lowestSetBit(A),
                    lowestSetBit(0) => -1,
                    lowestSetBit(1) => 0,
                    lowestSetBit(2) => 1 )
      rand(A, B) Random number in the range [A, B]
                 The random values are uniform distributed.
                  ( rand(A, B) returns a random number such that
                    A &lt;= rand(A, B) <font color=blue>and</font> rand(A, B) &lt;= B holds.
                    rand(A, A) => A,
                    rand(1, 0) => EXCEPTION RANGE_ERROR )
      compare(A, B) Compare function
                  ( compare(1, 2) => -1,
                    compare(5, 5) => 0,
                    compare(8, 7) => 1 )
      hashCode(A) Hash function
    Statements:
      A +:= B   Increment A by B
                  ( A +:= B => A := A + B )
      A -:= B   Decrement A by B
                  ( A -:= B => A := A - B )
      A *:= B   Multiplying copy
                  ( A *:= B => A := A * B )
      A &lt;&lt;:= B  Shift left copy
                  ( A &lt;&lt;:= B => A := A &lt;&lt; B )
      A >>:= B  Shift right copy
                  ( A >>:= B => A := A >> B )
      incr(A)   Increment with 1
                  ( incr(A) => A +:= 1 )
      decr(A)   Decrement with 1
                  ( decr(A) => A -:= 1 )
</pre><p>
  For the operations <tt>'<font color=blue>div</font>'</tt> and <tt>'<font color=blue>rem</font>'</tt> holds for all A:</p><pre>
    (A <font color=blue>div</font> B) * B + A <font color=blue>rem</font> B = A           when B &lt;> 0
    -A <font color=blue>div</font> B = -(A <font color=blue>div</font> B)                 when B &lt;> 0
    -A <font color=blue>rem</font> B = -(A <font color=blue>rem</font> B)                 when B &lt;> 0
    A <font color=blue>rem</font> B >= 0 <font color=blue>and</font> A <font color=blue>rem</font> B &lt; abs(B)     when B &lt;> 0 and A >= 0
    A <font color=blue>rem</font> B &lt;= 0 <font color=blue>and</font> A <font color=blue>rem</font> B > -abs(B)    when B &lt;> 0 and A &lt;= 0
</pre><p>
  For the operations <tt>'<font color=blue>mdiv</font>'</tt> and <tt>'<font color=blue>mod</font>'</tt> holds for all A:</p><pre>
    (A <font color=blue>mdiv</font> B) * B + A <font color=blue>mod</font> B = A          when B &lt;> 0
    -A <font color=blue>mdiv</font> B = A <font color=blue>mdiv</font> -B                 when B &lt;> 0
    -A <font color=blue>mod</font> -B = -(A <font color=blue>mod</font> B)                when B &lt;> 0
    A <font color=blue>mod</font> B >= 0 <font color=blue>and</font> A <font color=blue>mod</font> B &lt; B          when B > 0
    A <font color=blue>mod</font> B &lt;= 0 <font color=blue>and</font> A <font color=blue>mod</font> B > B          when B &lt; 0
</pre><p>
  For the operation <tt>'<font color=blue>mdiv</font>'</tt> holds:</p><pre>
    A <font color=blue>mdiv</font> B = A <font color=blue>div</font> B - 1            when A and B have different
                                      signs and A <font color=blue>rem</font> B &lt;> 0 holds.
    A <font color=blue>mdiv</font> B = A <font color=blue>div</font> B                when A and B have the same
                                      sign or A <font color=blue>rem</font> B = 0 holds.
    A <font color=blue>mdiv</font> B = (A - 1) <font color=blue>div</font> B - 1      when A > 0 and B &lt; 0 holds.
    A <font color=blue>mdiv</font> B = (A + 1) <font color=blue>div</font> B - 1      when A &lt; 0 and B > 0 holds.
</pre><p>
  For the operation <tt>'<font color=blue>mod</font>'</tt> holds:</p><pre>
    A <font color=blue>mod</font> B = A <font color=blue>rem</font> B + B      when A and B have different
                               signs and A <font color=blue>rem</font> B &lt;> 0 holds.
    A <font color=blue>mod</font> B = A <font color=blue>rem</font> B          when A and B have the same
                               sign or A <font color=blue>rem</font> B = 0 holds.
</pre><p>

  Table for the behaviour of <tt>'<font color=blue>div</font>'</tt>, <tt>'<font color=blue>rem</font>'</tt>, <tt>'<font color=blue>mdiv</font>'</tt> and <tt>'<font color=blue>mod</font>'</tt>:
</p><pre>
     A    B   A <font color=blue>div</font> B   A <font color=blue>rem</font> B   A <font color=blue>mdiv</font> B  A <font color=blue>mod</font> B

     5    3      1         2         1         2
     4    3      1         1         1         1
     3    3      1         0         1         0
     2    3      0         2         0         2
     1    3      0         1         0         1
     0    3      0         0         0         0
    -1    3      0        -1        -1         2
    -2    3      0        -2        -1         1
    -3    3     -1         0        -1         0
    -4    3     -1        -1        -2         2
    -5    3     -1        -2        -2         1

     A    B   A <font color=blue>div</font> B   A <font color=blue>rem</font> B   A <font color=blue>mdiv</font> B  A <font color=blue>mod</font> B

     5   -3     -1         2        -2        -1
     4   -3     -1         1        -2        -2
     3   -3     -1         0        -1         0
     2   -3      0         2        -1        -1
     1   -3      0         1        -1        -2
     0   -3      0         0         0         0
    -1   -3      0        -1         0        -1
    -2   -3      0        -2         0        -2
    -3   -3      1         0         1         0
    -4   -3      1        -1         1        -1
    -5   -3      1        -2         1        -2
</pre><p>

  For the 'sqrt' function holds (when A >= 0):</p><pre>
    sqrt(A) * sqrt(A) &lt;= A <font color=blue>and</font>
    (sqrt(A) + 1) * (sqrt(A) + 1) > A
</pre><p></p>

<a name="bigInteger"><h3>5.3 bigInteger</h3></a>
<p>
    The type <tt>'<font color=red>bigInteger</font>'</tt> describes signed integer numbers of
  unlimited size. The literals of the type <tt>'<font color=red>bigInteger</font>'</tt> are sequences
  of digits followed by an underscore character (for example 1_ ).
  Although <tt>'<font color=red>bigInteger</font>'</tt> operations cannot overflow, it can happen
  that there is not enough memory to represent a <tt>'<font color=red>bigInteger</font>'</tt> value.
  In this case the exception <tt>'MEMORY_ERROR'</tt> is raised.
</p><pre>
    Prefix operators:
      +         Identity
      -         Change sign
    Infix operators:
      +         Addition
      -         Subtraction
      *         Multiplication
      <font color=blue>div</font>       Integer division truncated towards zero
                  ( A <font color=blue>div</font> B => trunc(A / B),
                    A <font color=blue>div</font> 0_ => EXCEPTION NUMERIC_ERROR )
      <font color=blue>rem</font>       Reminder of integer division <font color=blue>div</font>
                  ( A <font color=blue>rem</font> B => A - (A <font color=blue>div</font> B) * B,
                    A <font color=blue>rem</font> 0_ => EXCEPTION NUMERIC_ERROR )
      <font color=blue>mdiv</font>      Integer division truncated towards negative infinity
                  ( A <font color=blue>mdiv</font> B => floor(A / B),
                    A <font color=blue>mdiv</font> 0_ => EXCEPTION NUMERIC_ERROR )
      <font color=blue>mod</font>       Reminder of integer division <font color=blue>mdiv</font>
                  ( A <font color=blue>mod</font> B => A - (A <font color=blue>mdiv</font> B) * B,
                    A <font color=blue>mod</font> 0_ => EXCEPTION NUMERIC_ERROR )
      A ** B    Power
                  ( Type of argument B: <font color=red>integer</font>,
                    A ** B is okay for B >= 0,
                    A ** 0 => 1_,
                    1_ ** B => 1_ for B >= 0,
                    A ** B => -(-A) ** B for A <= 0 and B >= 0 and odd(B),
                    A ** B => (-A) ** B for A <= 0 and B >= 0 and not odd(B),
                    A ** -1 => EXCEPTION NUMERIC_ERROR )
      A &lt;&lt; B    Shift left
                  ( Type of argument B: <font color=red>integer</font>,
                    A &lt;&lt; B is okay for B >= 0,
                    A &lt;&lt; B => A * 2_ ** B,
                    A &lt;&lt; 0 => A,
                    A &lt;&lt; -1 => EXCEPTION NUMERIC_ERROR )
      A >> B    Arithmetic shift right
                  ( Type of argument B: <font color=red>integer</font>,
                    A >> B is okay for B >= 0,
                    A >> B => A <font color=blue>mdiv</font> 2_ ** B,
                    A >> B => C for A >= 0_ holds: C >= 0_
                    A >> B => C for A < 0_ holds: C < 0_
                    A >> B => 0_ for A >= 0_ and B > ord(log2(A)),
                    A >> B => -1_ for A < 0_ and B > ord(log2(-A)),
                    A >> 0 => A,
                    A >> -1 => EXCEPTION NUMERIC_ERROR )
      <font color=red>bigInteger</font> <font color=blue>conv</font> A   Conversion of <font color=red>integer</font> to <font color=red>bigInteger</font>
                  ( Type of argument A: <font color=red>integer</font>,
                    <font color=red>bigInteger</font> <font color=blue>conv</font> 1 => 1_ )
      <font color=red>bigInteger</font> <font color=blue>parse</font> A   Conversion of <font color=red>string</font> to <font color=red>integer</font>
                  ( Type of argument A: <font color=red>string</font>,
                    <font color=red>bigInteger</font> <font color=blue>parse</font> <font color=maroon>"123"</font> => 123_,
                    <font color=red>bigInteger</font> <font color=blue>parse</font> <font color=maroon>"-123"</font> => -123_,
                    <font color=red>bigInteger</font> <font color=blue>parse</font> <font color=maroon>" 1"</font> => EXCEPTION RANGE_ERROR,
                    <font color=red>bigInteger</font> <font color=blue>parse</font> <font color=maroon>"+5"</font> => EXCEPTION RANGE_ERROR,
                    <font color=red>bigInteger</font> <font color=blue>parse</font> <font color=maroon>"10 "</font> => EXCEPTION RANGE_ERROR,
                    <font color=red>bigInteger</font> <font color=blue>parse</font> <font color=maroon>"ASDF"</font> => EXCEPTION RANGE_ERROR )
    Relations:
      =, &lt;>, &lt;, &lt;=, >, >=
    Functions:
      ord(A)    Ordinal number
                  ( Type of result: <font color=red>integer</font> )
                    ord(99999999999999999999_) => EXCEPTION RANGE_ERROR )
      succ(A)   Successor
                  ( succ(A) => A+1_ )
      pred(A)   Predecessor
                  ( pred(A) => A-1_ )
      abs(A)    Absolute value
      odd(A)    Odd value
                  ( Type of result: <font color=red>boolean</font> )
      str(A)    Conversion to <font color=red>string</font>
                  ( Type of result: <font color=red>string</font> )
      sqrt(A)   Integer square root
                  ( sqrt(A) is okay for A >= 0_
                    sqrt(A) => trunc(sqrt(flt(A))),
                    sqrt(-1_) => EXCEPTION NUMERIC_ERROR )
      log2(A)   Truncated base 2 logarithm
                  ( log2(A) returns the position of the
                    highest bit set. It is defined for A >= 0
                    log2(2_ ** A) = A for A >= 0,
                    log2(0_) => -1_,
                    log2(1_) => 0_,
                    log2(2_) => 1_,
                    log2(-1) => EXCEPTION NUMERIC_ERROR )
      gcd(A, B) Greatest common divisor of A and B.
                  ( gcd(A, B) = gcd(B, A),
                    gcd(A, B) = gcd(-A, B),
                    gcd(A, 0) = abs(A) )
      bitLength(A) Number of bits in the minimal two's-complement
                   representation, excluding the sign bit.
                  ( Type of result: <font color=red>integer</font>,
                    bitLength(A) => ord(succ(log2(A))) for A >= 0_,
                    bitLength(A) => ord(succ(log2(pred(-A)))) for A < 0_ )
      lowestSetBit(A) Index of the lowest-order one bit
                      For A <> 0_ this is equal to to number of
                      lowest-order zero bits.
                  ( Type of result: <font color=red>integer</font>,
                    A >> B &lt;&lt; B = A for A <> 0_ and B = lowestSetBit(A),
                    lowestSetBit(0_) => -1,
                    lowestSetBit(1_) => 0,
                    lowestSetBit(2_) => 1 )
      rand(A, B) Random number in the range [A, B]
                 The random values are uniform distributed.
                  ( rand(A, B) returns a random number such that
                    A &lt;= rand(A, B) <font color=blue>and</font> rand(A, B) &lt;= B holds.
                    rand(A, A) => A,
                    rand(1_, 0_) => EXCEPTION RANGE_ERROR )
      compare(A, B) Compare function
                  ( Type of result: <font color=red>integer</font>,
                    compare(1_, 2_) => -1,
                    compare(5_, 5_) => 0,
                    compare(8_, 7_) => 1 )
      hashCode(A) Hash function
                  ( Type of result: <font color=red>integer</font> )
    Statements:
      A +:= B   Increment A by B
                  ( A +:= B => A := A + B )
      A -:= B   Decrement A by B
                  ( A -:= B => A := A - B )
      A *:= B   Multiplying copy
                  ( A *:= B => A := A * B )
      A &lt;&lt;:= B  Shift left copy
                  ( A &lt;&lt;:= B => A := A &lt;&lt; B )
      A >>:= B  Shift right copy
                  ( A >>:= B => A := A >> B )
      incr(A)   Increment with 1
                  ( incr(A) => A +:= 1_ )
      decr(A)   Decrement with 1
                  ( decr(A) => A -:= 1_ )
</pre><p>
  For the operations <tt>'<font color=blue>div</font>'</tt> and <tt>'<font color=blue>rem</font>'</tt> holds for all A:</p><pre>
    (A <font color=blue>div</font> B) * B + A <font color=blue>rem</font> B = A           when B &lt;> 0_
    -A <font color=blue>div</font> B = -(A <font color=blue>div</font> B)                 when B &lt;> 0_
    -A <font color=blue>rem</font> B = -(A <font color=blue>rem</font> B)                 when B &lt;> 0_
    A <font color=blue>rem</font> B >= 0_ <font color=blue>and</font> A <font color=blue>rem</font> B &lt; abs(B)    when B &lt;> 0_ and A >= 0_
    A <font color=blue>rem</font> B &lt;= 0_ <font color=blue>and</font> A <font color=blue>rem</font> B > -abs(B)   when B &lt;> 0_ and A &lt;= 0_
</pre><p>
  For the operations <tt>'<font color=blue>mdiv</font>'</tt> and <tt>'<font color=blue>mod</font>'</tt> holds for all A:</p><pre>
    (A <font color=blue>mdiv</font> B) * B + A <font color=blue>mod</font> B = A          when B &lt;> 0_
    -A <font color=blue>mdiv</font> B = A <font color=blue>mdiv</font> -B                 when B &lt;> 0_
    -A <font color=blue>mod</font> -B = -(A <font color=blue>mod</font> B)                when B &lt;> 0_
    A <font color=blue>mod</font> B >= 0_ <font color=blue>and</font> A <font color=blue>mod</font> B &lt; B         when B > 0_
    A <font color=blue>mod</font> B &lt;= 0_ <font color=blue>and</font> A <font color=blue>mod</font> B > B         when B &lt; 0_
</pre><p>
  For the operation <tt>'<font color=blue>mdiv</font>'</tt> holds:</p><pre>
    A <font color=blue>mdiv</font> B = A <font color=blue>div</font> B - 1_           when A and B have different
                                      signs and A <font color=blue>rem</font> B &lt;> 0_ holds.
    A <font color=blue>mdiv</font> B = A <font color=blue>div</font> B                when A and B have the same
                                      sign or A <font color=blue>rem</font> B = 0_ holds.
    A <font color=blue>mdiv</font> B = (A - 1_) <font color=blue>div</font> B - 1_    when A > 0_ and B &lt; 0_ holds.
    A <font color=blue>mdiv</font> B = (A + 1_) <font color=blue>div</font> B - 1_    when A &lt; 0_ and B > 0_ holds.
</pre><p>
  For the operation <tt>'<font color=blue>mod</font>'</tt> holds:</p><pre>
    A <font color=blue>mod</font> B = A <font color=blue>rem</font> B + B      when A and B have different
                               signs and A <font color=blue>rem</font> B &lt;> 0_ holds.
    A <font color=blue>mod</font> B = A <font color=blue>rem</font> B          when A and B have the same
                               sign or A <font color=blue>rem</font> B = 0_ holds.
</pre><p>

  Table for the behaviour of <tt>'<font color=blue>div</font>'</tt>, <tt>'<font color=blue>rem</font>'</tt>, <tt>'<font color=blue>mdiv</font>'</tt> and <tt>'<font color=blue>mod</font>'</tt>:
</p><pre>
     A    B   A <font color=blue>div</font> B   A <font color=blue>rem</font> B   A <font color=blue>mdiv</font> B  A <font color=blue>mod</font> B

     5_   3_     1_        2_        1_        2_
     4_   3_     1_        1_        1_        1_
     3_   3_     1_        0_        1_        0_
     2_   3_     0_        2_        0_        2_
     1_   3_     0_        1_        0_        1_
     0_   3_     0_        0_        0_        0_
    -1_   3_     0_       -1_       -1_        2_
    -2_   3_     0_       -2_       -1_        1_
    -3_   3_    -1_        0_       -1_        0_
    -4_   3_    -1_       -1_       -2_        2_
    -5_   3_    -1_       -2_       -2_        1_

     A    B   A <font color=blue>div</font> B   A <font color=blue>rem</font> B   A <font color=blue>mdiv</font> B  A <font color=blue>mod</font> B

     5_  -3_    -1_        2_       -2_       -1_
     4_  -3_    -1_        1_       -2_       -2_
     3_  -3_    -1_        0_       -1_        0_
     2_  -3_     0_        2_       -1_       -1_
     1_  -3_     0_        1_       -1_       -2_
     0_  -3_     0_        0_        0_        0_
    -1_  -3_     0_       -1_        0_       -1_
    -2_  -3_     0_       -2_        0_       -2_
    -3_  -3_     1_        0_        1_        0_
    -4_  -3_     1_       -1_        1_       -1_
    -5_  -3_     1_       -2_        1_       -2_
</pre><p>

  For the 'sqrt' function holds (when A >= 0_):</p><pre>
    sqrt(A) * sqrt(A) &lt;= A <font color=blue>and</font>
    (sqrt(A) + 1_) * (sqrt(A) + 1_) > A
</pre><p></p>

<a name="rational"><h3>5.4 rational</h3></a>
<p>
    The type <tt>'<font color=red>rational</font>'</tt> consists of rational numbers
  represented with an <tt>'<font color=red>integer</font>'</tt> numerator and an <tt>'<font color=red>integer</font>'</tt>
  denominator. The values of the type <tt>'<font color=red>rational</font>'</tt> are
  finite and periodical decimal numbers. Rational literals
  do not exist. The result of a <tt>'<font color=red>rational</font>'</tt> operation
  is undefined when it overflows.
</p><pre>
    Elements:
      <font color=blue>var</font> <font color=red>integer</font>: numerator <font color=blue>is</font> 0;
      <font color=blue>var</font> <font color=red>integer</font>: denominator <font color=blue>is</font> 1;
    Prefix operators:
      +         Identity
      -         Change sign
    Infix operators:
      +         Addition
      -         Subtraction
      *         Multiplication
      /         Division
      /         Create <font color=red>rational</font> from numerator and denominator
                  ( Type of left operand: <font color=red>integer</font>,
                    Type of right operand: <font color=red>integer</font> )
      **        Power
                  ( <font color=red>rational</font> ** <font color=red>integer</font> )
      <font color=red>rational</font> <font color=blue>conv</font> A   Conversion of <font color=red>integer</font> to <font color=red>rational</font>
                  ( Type of argument A: <font color=red>integer</font>,
                    <font color=red>rational</font> <font color=blue>conv</font> 1 => 1 / 1 )
      <font color=red>rational</font> <font color=blue>parse</font> A   Conversion of <font color=red>string</font> to <font color=red>rational</font>
                  ( Type of argument A: <font color=red>string</font> )
    Relations:
      =, &lt;>, &lt;, &lt;=, >, >=
    Functions:
      abs(A)    Absolute value
      rat(A)    Conversion of <font color=red>integer</font> to <font color=red>rational</font>
                  ( Type of argument A: <font color=red>integer</font>,
                    rat(1) => 1 / 1 )
      floor(A)  Truncation towards negative infinity
                  ( Type of result: <font color=red>integer</font>,
                    floor( 1.8)=> 1, floor( 1.0)=> 1,
                    floor(-1.0)=>-1, floor(-1.8)=>-2 )
      ceil(A)   Rounding up towards positive infinity
                  ( Type of result: <font color=red>integer</font>,
                    ceil( 1.2)=> 2, ceil( 1.0)=> 1,
                    ceil(-1.0)=>-1, ceil(-1.2)=>-1 )
      trunc(A)  Truncation towards zero
                  ( Type of result: <font color=red>integer</font>,
                    trunc( 1.8)=> 1, trunc( 1.0)=> 1,
                    trunc(-1.0)=>-1, trunc(-1.8)=>-1 )
      round(A)  Round towards zero
                  ( Type of result: <font color=red>integer</font>,
                    round(0.5)=>1, round(-0.5)=>-1,
                    round(0.4)=>0, round(-0.4)=>0 )
      str(A)    Conversion to <font color=red>string</font>
                  ( Type of result: <font color=red>string</font> )
      compare(A, B) Compare function
                  ( Type of result: <font color=red>integer</font>,
                    compare(1.9, 2.0) => -1,
                    compare(5.2, 5.2) => 0,
                    compare(8.0, 7.9) => 1 )
      hashCode(A) Hash function
                  ( Type of result: <font color=red>integer</font> )
    Statements:
      A +:= B   Increment A by B
                  ( A +:= B => A := A + B )
      A -:= B   Decrement A by B
                  ( A -:= B => A := A - B )
      A *:= B   Multiplying copy
                  ( A *:= B => A := A * B )
</pre><p>
  All calculations with <tt>'<font color=red>rational</font>'</tt> numbers are done exact.
  (Without any rounding)
</p><p></p>

<a name="bigRational"><h3>5.5 bigRational</h3></a>
<p>
    The type <tt>'<font color=red>bigRational</font>'</tt> consists of rational numbers
  represented with an <tt>'<font color=red>bigInteger</font>'</tt> numerator and an
  <tt>'<font color=red>bigInteger</font>'</tt> denominator. The values of the type
  <tt>'<font color=red>bigRational</font>'</tt> are finite and periodical decimal numbers.
  BigRational literals do not exist. Although <tt>'<font color=red>bigRational</font>'</tt>
  operations cannot overflow, it can happen that there
  is not enough memory to represent a <tt>'<font color=red>bigRational</font>'</tt> value.
  In this case the exception <tt>'MEMORY_ERROR'</tt> is raised.
</p><pre>
    Elements:
      <font color=blue>var</font> <font color=red>bigInteger</font>: numerator <font color=blue>is</font> 0_;
      <font color=blue>var</font> <font color=red>bigInteger</font>: denominator <font color=blue>is</font> 1_;
    Prefix operators:
      +         Identity
      -         Change sign
    Infix operators:
      +         Addition
      -         Subtraction
      *         Multiplication
      /         Division
      /         Create <font color=red>bigRational</font> from numerator and denominator
                  ( Type of left argument: <font color=red>bigInteger</font>,
                    Type of right argument: <font color=red>bigInteger</font> )
      **        Power
                  ( <font color=red>bigRational</font> ** <font color=red>integer</font> )
      <font color=red>bigRational</font> <font color=blue>conv</font> A   Conversion of <font color=red>integer</font> to <font color=red>bigRational</font>
                  ( Type of argument A: <font color=red>integer</font>,
                    <font color=red>bigRational</font> <font color=blue>conv</font> 1 => 1_ / 1_ )
      <font color=red>bigRational</font> <font color=blue>conv</font> A   Conversion of <font color=red>bigInteger</font> to <font color=red>bigRational</font>
                  ( Type of argument A: <font color=red>bigInteger</font>,
                    <font color=red>bigRational</font> <font color=blue>conv</font> 1_ => 1_ / 1_ )
      <font color=red>bigRational</font> <font color=blue>parse</font> A   Conversion of <font color=red>string</font> to <font color=red>bigRational</font>
                  ( Type of argument A: <font color=red>string</font> )
    Relations:
      =, &lt;>, &lt;, &lt;=, >, >=
    Functions:
      abs(A)    Absolute value
      rat(A)    Conversion of <font color=red>bigInteger</font> to <font color=red>bigRational</font>
                  ( Type of argument A: <font color=red>bigInteger</font>,
                    rat(1_) => 1_ / 1_ )
      floor(A)  Truncation towards negative infinity
                  ( Type of result: <font color=red>bigInteger</font>,
                    floor( 1.8)=> 1, floor( 1.0)=> 1,
                    floor(-1.0)=>-1, floor(-1.8)=>-2 )
      ceil(A)   Rounding up towards positive infinity
                  ( Type of result: <font color=red>bigInteger</font>,
                    ceil( 1.2)=> 2, ceil( 1.0)=> 1,
                    ceil(-1.0)=>-1, ceil(-1.2)=>-1 )
      trunc(A)  Truncation towards zero
                  ( Type of result: <font color=red>bigInteger</font>,
                    trunc( 1.8)=> 1, trunc( 1.0)=> 1,
                    trunc(-1.0)=>-1, trunc(-1.8)=>-1 )
      round(A)  Round towards zero
                  ( Type of result: <font color=red>bigInteger</font>,
                    round(0.5)=>1, round(-0.5)=>-1,
                    round(0.4)=>0, round(-0.4)=>0 )
      str(A)    Conversion to <font color=red>string</font>
                  ( Type of result: <font color=red>string</font> )
      compare(A, B) Compare function
                  ( Type of result: <font color=red>integer</font>,
                    compare(1.9, 2.0) => -1,
                    compare(5.2, 5.2) => 0,
                    compare(8.0, 7.9) => 1 )
      hashCode(A) Hash function
                  ( Type of result: <font color=red>integer</font> )
    Statements:
      A +:= B   Increment A by B
                  ( A +:= B => A := A + B )
      A -:= B   Decrement A by B
                  ( A -:= B => A := A - B )
      A *:= B   Multiplying copy
                  ( A *:= B => A := A * B )
</pre><p>
  All calculations with <tt>'<font color=red>bigRational</font>'</tt> numbers are done exact.
  (Without any rounding)
</p>

<a name="float"><h3>5.6 float</h3></a>
<p>
    The type <tt>'<font color=red>float</font>'</tt> consists of single precision floating
  point numbers.
</p><pre>
    Constants:
      Infinity  Positive infinity
      NaN       Not-a-Number
    Prefix operators:
      +         Identity
      -         Change sign
    Infix operators:
      +         Addition
      -         Subtraction
      *         Multiplication
      /         Division
                  ( A / 0.0 =>  Infinity for A > 0.0,
                    A / 0.0 => -Infinity for A &lt; 0.0,
                    0.0 / 0.0 => NaN )
      **        Power
                  ( A ** B is okay for A > 0.0,
                    A ** B is okay for A &lt; 0.0 and B is integer,
                    A ** B => NaN for A &lt; 0.0 and B is not integer,
                    A ** 0.0 => 1.0,
                    0.0 ** B => 0.0 for B > 0.0,
                    0.0 ** 0.0 => 1.0,
                    0.0 ** B => Infinity for B &lt; 0.0 )
      **        Power
                  ( Type of right operand: <font color=red>integer</font>
                    A ** B is okay for A > 0.0,
                    A ** B is okay for A &lt; 0.0,
                    A ** 0 => 1.0,
                    0.0 ** B => 0.0 for B > 0,
                    0.0 ** 0 => 1.0,
                    0.0 ** B => Infinity for B &lt; 0 )
      <font color=red>float</font> <font color=blue>conv</font> A   Conversion of <font color=red>integer</font> to <font color=red>float</font>
                  ( Type of argument A: <font color=red>integer</font>,
                    <font color=red>float</font> <font color=blue>conv</font> 1 => 1.0 )
      <font color=blue>digits</font>    Conversion to <font color=red>string</font> with specified precision
                  ( Type of right operand: <font color=red>integer</font>,
                    Type of result: <font color=red>string</font>,
                    3.1415 <font color=blue>digits</font> 2 => <font color=maroon>"3.14"</font>,
                    Infinity <font color=blue>digits</font> A => <font color=maroon>"Infinity"</font>,
                    -Infinity <font color=blue>digits</font> A => <font color=maroon>"-Infinity"</font>,
                    NaN <font color=blue>digits</font> A => <font color=maroon>"NaN"</font> )
      <font color=red>float</font> <font color=blue>parse</font> A   Conversion of <font color=red>string</font> to <font color=red>float</font>
                  ( Type of argument A: <font color=red>string</font> )
    Relations:
      =, &lt;>, &lt;, &lt;=, >, >=
    Functions:
      abs(A)    Absolute value
      flt(A)    Conversion of <font color=red>integer</font> to <font color=red>float</font>
                  ( Type of argument A: <font color=red>integer</font>,
                    flt(1) => 1.0 )
      floor(A)  Truncation towards negative infinity
                  ( floor( 1.8)=> 1.0, floor( 1.0)=> 1.0,
                    floor(-1.0)=>-1.0, floor(-1.2)=>-2.0,
                    floor( 0.9)=> 0.0, floor(-0.1)=>-1.0 )
      ceil(A)   Rounding up towards positive infinity
                  ( ceil( 1.2)=> 2.0, ceil( 1.0)=> 1.0,
                    ceil(-1.8)=>-1.0, ceil(-1.0)=>-1.0,
                    ceil( 0.1)=> 1.0, ceil(-0.9)=> 0.0 )
      trunc(A)  Truncation towards zero
                  ( Type of result: <font color=red>integer</font>,
                    trunc( 1.8)=> 1, trunc( 1.0)=> 1,
                    trunc(-1.8)=>-1, trunc(-1.0)=>-1,
                    trunc( 0.9)=> 0, trunc(-0.9)=> 0 )
      round(A)  Round towards zero
                  ( Type of result: <font color=red>integer</font>,
                    round(1.5)=>2, round(-1.5)=>-2,
                    round(0.5)=>1, round(-0.5)=>-1,
                    round(0.4)=>0, round(-0.4)=>0 )
      str(A)    Conversion to <font color=red>string</font>
                  ( Type of result: <font color=red>string</font>,
                    str(Infinity) => <font color=maroon>"Infinity"</font>,
                    str(-Infinity) => <font color=maroon>"-Infinity"</font>,
                    str(NaN) => <font color=maroon>"NaN"</font> )
      isnan(A)  Check if A is Not-a-Number
      sin(A)    Sine
      cos(A)    Cosine
      tan(A)    Tangent
      exp(A)    Exponential function
      log(A)    Natural logarithm
                  ( log(A) is okay for A > 0.0,
                    log(0.0)  => -Infinity,
                    log(-1.0) =>  NaN )
      log10(A)  Base 10 logarithm
                  ( log10(A) is okay for A > 0.0,
                    log10(0.0)  => -Infinity,
                    log10(-1.0) =>  NaN )
      sqrt(A)   Square root
                  ( sqrt(A) is okay for A >= 0.0,
                    sqrt(-1.0) => NaN )
      asin(A)   Inverse sine
                  ( asin(A) is okay for A >= -1.0 and A &lt;= 1.0,
                    asin(2.0) => NaN )
      acos(A)   Inverse cosine
                  ( acos(A) is okay for A >= -1.0 and A &lt;= 1.0,
                    acos(2.0) => NaN )
      atan(A)   Inverse tangent
      atan2(A, B) Inverse tangent of A / B
      sinh(A)   Hyperbolic sine
      cosh(A)   Hyperbolic cosine
      tanh(A)   Hyperbolic tangent
      rand(A, B) Random number in the range [A, B]
                 The random values are uniform distributed.
                  ( rand(A, B) returns a random number such that
                    A &lt;= rand(A, B) <font color=blue>and</font> rand(A, B) &lt;= B holds.
                    rand(A, A) => A,
                    rand(1.0, 0.0) => EXCEPTION RANGE_ERROR )
      compare(A, B) Compare function
                  ( Type of result: <font color=red>integer</font>,
                    compare(1.9, 2.1) => -1,
                    compare(5.3, 5.3) => 0,
                    compare(7.8, 7.7) => 1 )
      hashCode(A) Hash function
                  ( Type of result: <font color=red>integer</font> )
    Statements:
      A +:= B   Increment A by B
                  ( A +:= B => A := A + B )
      A -:= B   Decrement A by B
                  ( A -:= B => A := A - B )
      A *:= B   Multiplying copy
                  ( A *:= B => A := A * B )
      A /:= B   Dividing copy
                  ( A /:= B => A := A / B )
</pre><p></p>

<a name="complex"><h3>5.7 complex</h3></a>
<p>
    The type <tt>'<font color=red>complex</font>'</tt> consists of complex numbers represented
  with an <tt>'<font color=red>float</font>'</tt> real part and an <tt>'<font color=red>float</font>'</tt> imaginary part.
  Complex literals do not exist. 
</p><pre>
    Elements:
      <font color=blue>var</font> <font color=red>float</font>: re <font color=blue>is</font> 0.0;
      <font color=blue>var</font> <font color=red>float</font>: im <font color=blue>is</font> 0.0;
    Prefix operators:
      +         Identity
      -         Change sign
      <font color=blue>conj</font>      Complex conjugate
    Infix operators:
      +         Addition
      -         Subtraction
      *         Multiplication
      /         Division
                  ( A / complex(0.0) => complex(NaN, NaN) )
      **        Power
                  ( Type of right operand: <font color=red>integer</font>
                    A ** B is okay for A > complex(0.0),
                    A ** B is okay for A &lt; complex(0.0),
                    A ** 0 => complex(1.0),
                    complex(0.0) ** B => complex(0.0) for B > 0,
                    complex(0.0) ** 0 => complex(1.0),
                    complex(0.0) ** B => complex(Infinity, NaN) for B &lt; 0 )
      <font color=red>complex</font> <font color=blue>conv</font> A   Conversion of <font color=red>integer</font> to <font color=red>complex</font>
                  ( Type of argument A: <font color=red>integer</font>,
                    <font color=red>complex</font> <font color=blue>conv</font> A => complex(flt(A)) )
      <font color=red>complex</font> <font color=blue>conv</font> A   Conversion of <font color=red>float</font> to <font color=red>complex</font>
                  ( Type of argument A: <font color=red>float</font>,
                    <font color=red>complex</font> <font color=blue>conv</font> A => complex(A) )
      <font color=blue>digits</font>    Conversion to <font color=red>string</font> with specified precision
                  ( Type of right operand: <font color=red>integer</font>,
                    Type of result: <font color=red>string</font>,
                    complex(3.1415) <font color=blue>digits</font> 2 => <font color=maroon>"3.14+0.00i"</font> )
      <font color=red>complex</font> <font color=blue>parse</font> A   Conversion of <font color=red>string</font> to <font color=red>complex</font>
                  ( Type of argument A: <font color=red>string</font> )
    Relations:
      =, &lt;>
    Functions:
      abs(A)    Absolute value
                  ( Type of result: <font color=red>float</font> )
      sqrAbs(A) Square of absolute value
                  ( Type of result: <font color=red>float</font> )
      arg(A)    Argument (=angle of the polar form of A)
                  ( Type of result: <font color=red>float</font> )
      complex(A, B)  Return a <font color=red>complex</font> number from its real and imaginary part
                  ( Type of argument A: <font color=red>float</font>,
                    Type of argument B: <font color=red>float</font> )
      complex(A)  Return a <font color=red>complex</font> number from its real part
                  ( Type of argument A: <font color=red>float</font> )
      polar(A, B)  Return a <font color=red>complex</font> number from polar coordinates
                  ( Type of argument A: <font color=red>float</font>,
                    Type of argument B: <font color=red>float</font> )
      str(A)    Conversion to <font color=red>string</font>
                  ( Type of result: <font color=red>string</font>,
                    str(complex(1.125)) => <font color=maroon>"1.125+0.0i"</font> )
    Statements:
      A +:= B   Increment A by B
                  ( A +:= B => A := A + B )
      A -:= B   Decrement A by B
                  ( A -:= B => A := A - B )
      A *:= B   Multiplying copy
                  ( A *:= B => A := A * B )
      A /:= B   Dividing copy
                  ( A /:= B => A := A / B )
</pre><p></p>

<a name="char"><h3>5.8 char</h3></a>
<p>
    The type <tt>'<font color=red>char</font>'</tt> describes UNICODE characters encoded
  with UTF-32. In the source file a character literal is
  written as UTF-8 encoded UNICODE character enclosed in
  single quotes. In order to represent nonprintable
  characters and certain printable characters the following
  escape sequences may be used.
</p><pre>
    audible alert    BEL      \a    backslash    (\)   \\
    backspace        BS       \b    apostrophe   (')   \'   
    escape           ESC      \e    double quote (")   \"
    formfeed         FF       \f
    newline          NL (LF)  \n    control-A          \A
    carriage return  CR       \r      ...
    horizontal tab   HT       \t    control-Z          \Z
    vertical tab     VT       \v
</pre><p>
  Additionally the following escape sequence can be used:
</p><ul>
    <li><!-- -  -->Two backslashes with an integer literal between them are
      interpreted as character with the specified ordinal number.
      Note that the integer literal is interpreted decimal unless
      it is written as based integer.</li>
</ul><p>
  Examples of character literals are:
</p><pre>
    <font color=maroon>'a'</font>   <font color=maroon>' '</font>   <font color=maroon>'\n'</font>   <font color=maroon>'!'</font>   <font color=maroon>'\\'</font>   <font color=maroon>'2'</font>   <font color=maroon>'"'</font>   <font color=maroon>'\"'</font>   <font color=maroon>'\''</font>   <font color=maroon>'\8\'</font>
</pre><p>
  To use characters beyond ASCII (which is a subset of UNICODE)
  in the source file make sure that the editor uses UTF-8
  encoded characters.
</p><pre>
    Infix operators:
      <font color=red>char</font> <font color=blue>conv</font> A   Conversion of <font color=red>integer</font> to <font color=red>char</font>
                  ( Type of argument A: <font color=red>integer</font>,
                    <font color=red>char</font> <font color=blue>conv</font> 65 => 'A' )
      <font color=red>char</font> <font color=blue>parse</font> A   Conversion of <font color=red>string</font> to <font color=red>char</font>
                  ( Type of argument A: <font color=red>string</font> )
    Relations:
      =, &lt;>, &lt;, &lt;=, >, >=
    Functions:
      ord(A)    Ordinal number
                  ( Type of result: <font color=red>integer</font> )
      chr(A)    Conversion of <font color=red>integer</font> to <font color=red>char</font>
                  ( Type of argument: <font color=red>integer</font> )
      succ(A)   Successor
                  ( succ(A)=>chr(succ(ord(A))) )
      pred(A)   Predecessor
                  ( pred(A)=>chr(pred(ord(A))) )
      str(A)    Conversion to <font color=red>string</font>
                  ( Type of result: <font color=red>string</font>,
                    str(<font color=maroon>'A'</font>) => <font color=maroon>"A"</font> )
      literal(A) Conversion to a literal
                  ( Type of result: <font color=red>string</font>,
                    literal(<font color=maroon>'A'</font>) => <font color=maroon>"'A'"</font> )
      upper(A)  Conversion to upper case character
                  ( upper(<font color=maroon>'A'</font>) => <font color=maroon>'A'</font> )
                  ( upper(<font color=maroon>'z'</font>) => <font color=maroon>'Z'</font> )
      lower(A)  Conversion to lower case character
                  ( lower(<font color=maroon>'A'</font>) => <font color=maroon>'a'</font> )
                  ( lower(<font color=maroon>'z'</font>) => <font color=maroon>'z'</font> )
      rand(A, B) Random character in the range [A, B]
                 The random values are uniform distributed.
                  ( rand(A, B) returns a random character such that
                    A &lt;= rand(A, B) <font color=blue>and</font> rand(A, B) &lt;= B holds.
                    rand(A, A) => A,
                    rand('B', <font color=maroon>'A'</font>) => EXCEPTION RANGE_ERROR )
      compare(A, B) Compare function
                  ( Type of result: <font color=red>integer</font>,
                    compare(<font color=maroon>'A'</font>, <font color=maroon>'B'</font>) => -1,
                    compare(<font color=maroon>'A'</font>, <font color=maroon>'A'</font>) => 0,
                    compare(<font color=maroon>'B'</font>, <font color=maroon>'A'</font>) => 1 )
      hashCode(A) Hash function
                  ( Type of result: <font color=red>integer</font> )
    Statements:
      incr(A)   Increment
                  ( incr(A) => A := succ(A) )
      decr(A)   Decrement
                  ( decr(A) => A := pred(A) )
</pre><p></p>

<a name="string"><h3>5.9 string</h3></a>
<p>
    The type <tt>'<font color=red>string</font>'</tt> describes sequences of UNICODE characters
  (including the empty string). The characters in the <tt>'<font color=red>string</font>'</tt>
  use the UTF-32 encoding. Strings are not <font color=maroon><tt>'\0\'</tt></font> terminated
  and therefore can also contain binary data. Although <tt>'<font color=red>string</font>'</tt>s
  are allowed to grow very big, it can happen that there is not
  enough memory to represent a <tt>'<font color=red>string</font>'</tt> value. In this case the
  exception <tt>'MEMORY_ERROR'</tt> is raised. In the source file a string
  literal is a sequence of UTF-8 encoded UNICODE characters
  surrounded by double quotes.
</p><p>
  To represent control characters and certain other characters
  in strings the same escape sequences as for character literals
  may be used. E.g.: Quotation characters (") inside strings can
  be represented by preceding them with a backslash ( \" ).
  Additionally there is the following possibility:
</p><ul>
    <li><!-- -  -->Two backslashes with a sequence of blanks, horizontal tabs,
      carriage returns and new lines between them are completely
      ignored. The ignored characters are not part of the string.
      This can be used to continue a string in the following line.
      Note that in this case the leading spaces in the new line
      are not part of the string. Although this possibility exists
      also for character literals it is mentioned here, since it
      makes more sense to use it with string literals</li>
</ul><p>
  Examples of string literals are:
</p><pre>
    <font color=maroon>""</font>   <font color=maroon>" "</font>   <font color=maroon>"\""</font>   <font color=maroon>"'"</font>   <font color=maroon>"String"</font>   <font color=maroon>"CAN\"T !"</font>
</pre><p>
  To use characters beyond ASCII (which is a subset of UNICODE)
  in the source file make sure that the editor uses UTF-8
  encoded characters.
</p><pre>
    Infix operators:
      &         String concatenation
                  ( <font color=maroon>"All "</font> & <font color=maroon>"OK"</font> => <font color=maroon>"All OK"</font> )
      &lt;&        String concatenation with weak priority
                Overloaded for various types with 'enable_io'
                  ( write(<font color=maroon>"i="</font> &lt;& i <font color=blue>digits</font> 2 <font color=blue>len</font> 6 &lt;& <font color=maroon>" $"</font>); )
      <font color=blue>mult</font>      String multiplication
                  ( Type of right operand: <font color=red>integer</font>,
                    <font color=maroon>"LA"</font> <font color=blue>mult</font> 3 => <font color=maroon>"LALALA"</font>,
                    <font color=maroon>"WORD"</font> <font color=blue>mult</font> 0 => <font color=maroon>""</font>,
                    <font color=maroon>"ANY"</font> <font color=blue>mult</font> -1 => EXCEPTION RANGE_ERROR )
      <font color=blue>lpad</font>      Left padding with spaces
                  ( Type of right operand: <font color=red>integer</font>,
                    <font color=maroon>"HELLO"</font> <font color=blue>lpad</font>  8 => <font color=maroon>"   HELLO"</font>,
                    <font color=maroon>"HELLO"</font> <font color=blue>lpad</font>  6 => <font color=maroon>" HELLO"</font>,
                    <font color=maroon>"HELLO"</font> <font color=blue>lpad</font>  5 => <font color=maroon>"HELLO"</font>,
                    <font color=maroon>"HELLO"</font> <font color=blue>lpad</font>  4 => <font color=maroon>"HELLO"</font>,
                    <font color=maroon>"HELLO"</font> <font color=blue>lpad</font>  0 => <font color=maroon>"HELLO"</font>,
                    <font color=maroon>"HELLO"</font> <font color=blue>lpad</font> -8 => <font color=maroon>"HELLO"</font> )
      <font color=blue>lpad0</font>      Left padding with spaces
                  ( Type of right operand: <font color=red>integer</font>,
                    <font color=maroon>"12"</font> <font color=blue>lpad0</font>  5 => <font color=maroon>"00012"</font>,
                    <font color=maroon>"12"</font> <font color=blue>lpad0</font>  3 => <font color=maroon>"012"</font>,
                    <font color=maroon>"12"</font> <font color=blue>lpad0</font>  2 => <font color=maroon>"12"</font>,
                    <font color=maroon>"12"</font> <font color=blue>lpad0</font>  1 => <font color=maroon>"12"</font>,
                    <font color=maroon>"12"</font> <font color=blue>lpad0</font>  0 => <font color=maroon>"12"</font>,
                    <font color=maroon>"12"</font> <font color=blue>lpad0</font> -5 => <font color=maroon>"12"</font> )
      <font color=blue>rpad</font>      Right padding with spaces
                  ( Type of right operand: <font color=red>integer</font>,
                    <font color=maroon>"HELLO"</font> <font color=blue>rpad</font>  8 => <font color=maroon>"HELLO   "</font>,
                    <font color=maroon>"HELLO"</font> <font color=blue>rpad</font>  6 => <font color=maroon>"HELLO "</font>,
                    <font color=maroon>"HELLO"</font> <font color=blue>rpad</font>  5 => <font color=maroon>"HELLO"</font>,
                    <font color=maroon>"HELLO"</font> <font color=blue>rpad</font>  4 => <font color=maroon>"HELLO"</font>,
                    <font color=maroon>"HELLO"</font> <font color=blue>rpad</font>  0 => <font color=maroon>"HELLO"</font>,
                    <font color=maroon>"HELLO"</font> <font color=blue>rpad</font> -8 => <font color=maroon>"HELLO"</font> )
      <font color=red>string</font> <font color=blue>parse</font> A   Identity
    Indices:
      [ A ]     Access one character
                  ( Type of argument A: <font color=red>integer</font>,
                    Type of result: <font color=red>char</font>,
                    A[1] => First character,
                    A[length(A)] => Last character,
                    A[0] => EXCEPTION RANGE_ERROR,
                    A[succ(length(A))] => EXCEPTION RANGE_ERROR )
      [ A .. B ] Access a substring from position A to B
                  ( Type of arguments A and B: <font color=red>integer</font> )
      [ A <font color=blue>len</font> B ] Access a substring from position A with length B
                  ( Type of arguments A and B: <font color=red>integer</font> )
      [ A .. ]  Access a substring beginning at position A
                  ( Type of argument A: <font color=red>integer</font> )
      [ .. A ]  Access a substring ending at position A
                  ( Type of argument A: <font color=red>integer</font> )
    Relations:
      =, &lt;>, &lt;, &lt;=, >, >=
    Functions:
      length(A) Length of <font color=red>string</font>
                  ( Type of result: <font color=red>integer</font>,
                    length(<font color=maroon>""</font>) => 0 )
      pos(A,B)  First position of <font color=red>char</font> B in <font color=red>string</font> A
                  ( Type of argument B: <font color=red>char</font>,
                    Type of result: <font color=red>integer</font>,
                    pos(<font color=maroon>"ABCABC"</font>,<font color=maroon>'B'</font>)=>2,
                    pos(<font color=maroon>"XYZ"</font>,<font color=maroon>'A'</font>)=>0 )
      pos(A,B)  First position of <font color=red>string</font> B in <font color=red>string</font> A
                  ( Type of result: <font color=red>integer</font>,
                    pos(<font color=maroon>"ABCDE ABCDE"</font>,<font color=maroon>"BC"</font>)=>2,
                    pos(<font color=maroon>"XYZXYZ"</font>,<font color=maroon>"ZYX"</font>)=>0,
                    pos(<font color=maroon>"123456789"</font>,<font color=maroon>""</font>)=>0 )
      pos(A,B,C) First position of <font color=red>char</font> B in <font color=red>string</font> A
                 The search starts at position C of <font color=red>string</font> A
                  ( Type of argument B: <font color=red>char</font>,
                    Type of argument C: <font color=red>integer</font>,
                    Type of result: <font color=red>integer</font>,
                    pos(<font color=maroon>"ABCABC"</font>,<font color=maroon>'B'</font>, 3)=>5,
                    pos(<font color=maroon>"XYZYX"</font>,<font color=maroon>'Z'</font>, 4)=>0,
                    pos(<font color=maroon>"12345"</font>,<font color=maroon>'3'</font>, 7)=>0 )
      pos(A,B,C) First position of <font color=red>string</font> B in <font color=red>string</font> A
                 The search starts at position C of <font color=red>string</font> A
                  ( Type of argument C: <font color=red>integer</font>,
                    Type of result: <font color=red>integer</font>,
                    pos(<font color=maroon>"ABCDE ABCDE"</font>,<font color=maroon>"BC"</font>, 3)=>8,
                    pos(<font color=maroon>"XYZXYZ"</font>,<font color=maroon>"ZXY"</font>, 4)=>0,
                    pos(<font color=maroon>"12345"</font>,<font color=maroon>"34"</font>, 7)=>0 )
                    pos(<font color=maroon>"123456789"</font>,<font color=maroon>""</font>, 2)=>0 )
      rpos(A,B) Last position of <font color=red>char</font> B in <font color=red>string</font> A
                  ( Type of argument B: <font color=red>char</font>,
                    Type of result: <font color=red>integer</font>,
                    rpos(<font color=maroon>"ABCABC"</font>,<font color=maroon>'B'</font>)=>5,
                    rpos(<font color=maroon>"XYZ"</font>,<font color=maroon>'A'</font>)=>0 )
      rpos(A,B) Last position of <font color=red>string</font> B in <font color=red>string</font> A
                  ( Type of result: <font color=red>integer</font>,
                    rpos(<font color=maroon>"ABCDE ABCDE"</font>,<font color=maroon>"BC"</font>)=>8,
                    rpos(<font color=maroon>"XYZXYZ"</font>,<font color=maroon>"ZYX"</font>)=>0,
                    rpos(<font color=maroon>"123456789"</font>,<font color=maroon>""</font>)=>0 )
      replace(A,B,C) Replace all occurrences of <font color=red>string</font> B in
                <font color=red>string</font> A by <font color=red>string</font> C
                  ( replace(<font color=maroon>"old gold"</font>, <font color=maroon>"old"</font>, <font color=maroon>"one"</font>)=>
                    <font color=maroon>"one gone"</font> )
      split(A,B) Split A into strings delimited by B
                  ( Type of argument B: <font color=red>char</font>,
                    Type of result: <font color=red>array string</font>,
                    split(<font color=maroon>""</font>, <font color=maroon>':'</font>) => [](<font color=maroon>""</font>),
                    split(<font color=maroon>":"</font>, <font color=maroon>':'</font>) => [](<font color=maroon>""</font>, <font color=maroon>""</font>),
                    split(<font color=maroon>"15:30"</font>, <font color=maroon>':'</font>) => [](<font color=maroon>"15"</font>, <font color=maroon>"30"</font>) )
      split(A,B) Split A into strings delimited by B
                  ( Type of result: <font color=red>array string</font>,
                    split(<font color=maroon>""</font>, <font color=maroon>""</font>) => [](<font color=maroon>""</font>),
                    split(<font color=maroon>"ABC"</font>, <font color=maroon>""</font>) => [](<font color=maroon>"ABC"</font>),
                    split(<font color=maroon>""</font>, <font color=maroon>"; "</font>) => [](<font color=maroon>""</font>),
                    split(<font color=maroon>"writeln; readln;"</font>, <font color=maroon>"; "</font>) => [](<font color=maroon>"writeln"</font>, <font color=maroon>"readln;"</font>) )
      join(A,B) Join the elements of A together with B's between them
                  ( Type of argument A: <font color=red>array string</font>,
                    Type of argument B: <font color=red>char</font>,
                    join([](<font color=maroon>"This"</font>, <font color=maroon>"is"</font>, <font color=maroon>"a"</font>, <font color=maroon>"test"</font>), <font color=maroon>' '</font>) => <font color=maroon>"This is a test"</font> )
      join(A,B) Join the elements of A together with B's between them
                  ( Type of argument A: <font color=red>array string</font>,
                    Type of argument B: <font color=red>string</font>,
                    join([](<font color=maroon>"pro"</font>, <font color=maroon>"gram"</font>), <font color=maroon>""</font>) => <font color=maroon>"program"</font> )
      trim(A)   Removes leading and trailing spaces and control chars
                  ( trim(<font color=maroon>" /n xyz /r"</font>) = <font color=maroon>"xyz"</font> )
      str(A)    Conversion to <font color=red>string</font>
                  ( Type of result: <font color=red>string</font>,
                    str(A) => A )
      literal(A) Conversion to a literal
                  ( Type of result: <font color=red>string</font>,
                    literal(<font color=maroon>"ABC"</font>) => <font color=maroon>"\"ABC\""</font>,
                    literal(<font color=maroon>"O' \"X\""</font>) => <font color=maroon>"\"O\' \\\"X\\\"\""</font> )
      upper(A)  Conversion to upper case characters
                  ( upper(<font color=maroon>"Upper"</font>)=><font color=maroon>"UPPER"</font> )
      lower(A)  Conversion to lower case characters
                  ( lower(<font color=maroon>"Lower"</font>)=><font color=maroon>"lower"</font> )
      compare(A, B) Compare function
                  ( Type of result: <font color=red>integer</font>,
                    compare(<font color=maroon>"ABC"</font>, <font color=maroon>"ABCD"</font>) => -1,
                    compare(<font color=maroon>"ABC"</font>, <font color=maroon>"ABC"</font>) => 0,
                    compare(<font color=maroon>"ABCD"</font>, <font color=maroon>"ABCC"</font>) => 1 )
      hashCode(A) Hash function
                  ( Type of result: <font color=red>integer</font> )
    Statements:
      A &:= B   Append B to A
                  ( A &:= B => A := A & B )
      A @:= [B] C  Assign C to element B of <font color=red>string</font> A
                  ( Type of argument B: <font color=red>integer</font>,
                    Type of argument C: <font color=red>char</font>,
                    A @:= [B] C =>
                        A := A[..pred(B)] & str(C) & A[succ(B)..],
                    A @:= [0] 'x' => EXCEPTION RANGE_ERROR,
                    A @:= [succ(length(A))] 'x' => EXCEPTION RANGE_ERROR )
</pre><p></p>

<a name="array"><h3>5.10 array</h3></a>
<p>
    The type <tt>'<font color=red>array baseType</font>'</tt> describes sequences of <tt>'<font color=red>baseType</font>'</tt>
  elements (including the empty sequence).
</p><dl>
    <dt></dt><dd>For example: <tt>'<font color=red>array integer</font>'</tt> describes arrays of integer elements.</dd>
</dl><p>
  An element of an array can be accessed with an <tt>'<font color=red>integer</font>'</tt> index.
  The minimal and maximal indices of an array are part of the value
  and can be obtained with the functions <tt>'minIdx'</tt> and <tt>'maxIdx'</tt>.
  There are functions which generate arrays with the default minimal
  index of 1 and other functions which generate arrays with the minimal
  index taken from a parameter.
</p><pre>
    Literal:
      [] (elem1, elem2)  Create an array with the given elements
                    The starting index of the array is 1.
      [0] (elem1, elem2)  Create an array with the given elements
                    The starting index of the array is 0.
    Infix operators:
      &         Array concatenation
      <font color=blue>times</font>     Array generation
                  ( Left operand: <font color=red>integer</font>,
                    Right operand: <font color=red>baseType</font>,
                    A <font color=blue>times</font> B Generates an '<font color=red>array baseType</font>'
                    with A elements of B,
                    (1 <font color=blue>times</font> B)[1] => B
                    -1 <font color=blue>times</font> B => EXCEPTION RANGE_ERROR )
      [ A .. B ] <font color=blue>times</font> C    Array generation
                  ( Type of arguments A and B: <font color=red>integer</font> )
                    Type of argument C: <font color=red>baseType</font>,
                    [ A .. B ] <font color=blue>times</font> C Generates an '<font color=red>array baseType</font>'
                    with pred(B - A) elements of C,
                    [ -1 .. -2 ] <font color=blue>times</font> B => empty array,
                    [ -1 .. -3 ] <font color=blue>times</font> B => EXCEPTION RANGE_ERROR )
    Indices:
      [ A ]     Access one array element
                  ( Type of argument A: <font color=red>integer</font>,
                    Type of result: <font color=red>baseType</font>,
                    A[minIdx(A)] => First element,
                    A[maxIdx(A)] => Last element,
                    A[pred(minIdx(A))] => EXCEPTION RANGE_ERROR,
                    A[succ(maxIdx(A))] => EXCEPTION RANGE_ERROR )
      [ A .. B ] Access a sub array
                  ( Type of arguments A and B: <font color=red>integer</font> )
      [ A .. ]  Access a sub array beginning at position A
                  ( Type of argument A: <font color=red>integer</font> )
      [ .. A ]  Access a sub array ending at position A
                  ( Type of argument A: <font color=red>integer</font> )
    Relations:
      =, &lt;>
    Functions:
      length(A) Length of array
                  ( Type of result: <font color=red>integer</font>,
                    length(A) = succ(maxIdx(A) - minIdx(A)),
                    length(0 <font color=blue>times</font> TRUE) => 0,
                    length(5 <font color=blue>times</font> TRUE) => 5 )
      minIdx(A) Minimal index of array
                  ( Type of result: <font color=red>integer</font>,
                    minIdx(3 <font color=blue>times</font> TRUE) => 1,
                    minIdx([-1 .. 4] <font color=blue>times</font> TRUE) => -1 )
      maxIdx(A) Maximal index of array
                  ( Type of result: <font color=red>integer</font>,
                    maxIdx(3 <font color=blue>times</font> TRUE) => 3 )
      rand(A)   Random element from an array
                The random elements are uniform distributed.
                  ( Type of result:  <font color=red>baseType</font> )
      remove(A,B) Remove element with index B from array A and
                  return the removed element
                  ( Type of argument B: <font color=red>integer</font>,
                    Type of result: <font color=red>baseType</font>,
                    remove(0 <font color=blue>times</font> TRUE, 1) => EXCEPTION RANGE_ERROR )
      sort(A)   Sort array using the compare(<font color=red>baseType</font>, <font color=red>baseType</font>) function
    Statements:
      A &:= B   Append B to A
                  ( A &:= B => A := A & B )
      <font color=blue>for</font> A <font color=blue>range</font> B <font color=blue>do</font>
        C
      <font color=blue>end for</font>   Loop over all elements of an array
                  ( Type of argument A: <font color=red>baseType</font>,
                    Type of argument C: <font color=red>proc</font> )
      insert(A, B, C) Insert C to the array A at position B
                  ( Type of argument B: <font color=red>integer</font>,
                    Type of argument C: <font color=red>baseType</font> )
      insert(A, B) Insert B into the sorted array A
                  ( Type of argument C: <font color=red>baseType</font> )
</pre><p></p>

<a name="hash"><h3>5.11 hash</h3></a>
<p>
    The type <tt>'<font color=red>hash [keyType] baseType</font>'</tt> describes hash tables with
  elements of <tt>'<font color=red>baseType</font>'</tt>. The elements can be accessed with an index of
  <tt>'<font color=red>keyType</font>'</tt>.
</p><dl>
    <dt></dt><dd>For example: <tt>'<font color=red>hash [string] integer</font>'</tt> describes hash tables with
    <tt>'<font color=red>integer</font>'</tt> elements and <tt>'<font color=red>string</font>'</tt> keys.</dd>
</dl><p>
  The <tt>'<font color=red>keyType</font>'</tt> of a hash needs to provide the functions
  <tt>'hashCode'</tt> and <tt>'compare'</tt>. Besides this the <tt>'<font color=red>keyType</font>'</tt>
  can be any type.
</p><pre>
    Constants:
      <font color=red>hashType</font>.EMPTY_HASH  Empty hashtable
    Infix operators:
      <font color=blue>in</font>        Element
                  ( Left argument: <font color=red>baseType</font>,
                    Type of result: <font color=red>boolean</font> )
      <font color=blue>not in</font>    Is not Element
                  ( Left argument: <font color=red>baseType</font>,
                    Type of result: <font color=red>boolean</font> )
    Indices:
      [ A ]     Access one hashtable element
                  ( Type of argument A: <font color=red>keyType</font>,
                    Type of result: <font color=red>baseType</font> )
    Functions:
      length(A) Number of elements in hashtable A
                  ( Type of result: <font color=red>integer</font>,
                    length(hashType.EMPTY_HASH) => 0 )
      keys(A)   Unsorted array of keys of the hashtable A
                  ( Type of result: <font color=red>array keyType</font> )
      values(A) Unsorted array of valuess of the hashtable A
                  ( Type of result: <font color=red>array baseType</font> )
      flip(A)   Deliver a hash with keys and values flipped
                  ( Type of result: <font color=red>hash [baseType] array keyType</font> )
    Statements:
      incl(A,B,C) Include element B to hashtable A
                  ( Type of argument B: <font color=red>keyType</font>,
                    Type of argument C: <font color=red>baseType</font> )
      excl(A,B) Exclude element B from hashtable A
                  ( Type of argument B: <font color=red>keyType</font> )
      A @:= [B] C  Assign C to element B of hashtable A
                  ( Type of argument B: <font color=red>keyType</font>,
                    Type of argument C: <font color=red>baseType</font> )
      <font color=blue>for</font> A <font color=blue>range</font> B <font color=blue>do</font>
        C
      <font color=blue>end for</font>   Unsorted loop over all values of a hash
                  ( Type of argument A: <font color=red>baseType</font>,
                    Type of argument C: <font color=red>proc</font> )
      <font color=blue>for key</font> A <font color=blue>range</font> B <font color=blue>do</font>
        C
      <font color=blue>end for</font>   Unsorted loop over all keys of a hash
                  ( Type of argument A: <font color=red>keyType</font>,
                    Type of argument C: <font color=red>proc</font> )
      <font color=blue>for</font> A <font color=blue>key</font> B <font color=blue>range</font> C <font color=blue>do</font>
        D
      <font color=blue>end for</font>   Unsorted loop over all values and keys of a hash
                  ( Type of argument A: <font color=red>baseType</font>,
                    Type of argument B: <font color=red>keyType</font>,
                    Type of argument D: <font color=red>proc</font> )
</pre><p></p>

<a name="set"><h3>5.12 set</h3></a>
<p>
    The type <tt>'<font color=red>set of baseType</font>'</tt> describes a set of elements of a
  <tt>'<font color=red>baseType</font>'</tt>. (including the empty set). The type <tt>'<font color=red>bitset</font>'</tt> is
  defined as <tt>'<font color=red>set of integer</font>'</tt>.
</p><pre>
    Constants:
      <font color=red>setType</font>.EMPTY_SET  Empty set
      EMPTY_SET  Empty set of the type <font color=red>bitset</font>
    Infix operators:
      |         Union 
      &         Intersection
      -         Difference
      >&lt;        Symmetric Difference
      <font color=blue>in</font>        Element
                  ( Left argument: <font color=red>baseType</font>,
                    Type of result: <font color=red>boolean</font> )
      <font color=blue>not in</font>    Is not Element
                  ( Left argument: <font color=red>baseType</font>,
                    Type of result: <font color=red>boolean</font> )
    Relations:
      =, &lt;>     Equal and not equal
                  ( Type of result: <font color=red>boolean</font></font> )
      &lt;=        Subset
                  ( Type of result: <font color=red>boolean</font></font>,
                    A &lt;= B => TRUE when no element X exists for which
                       X <font color=blue>in</font> A <font color=blue>and</font> X <font color=blue>not in</font> B
                    holds.
                    A &lt;= B => FALSE when an element X exists for which
                       X <font color=blue>in</font> A <font color=blue>and</font> X <font color=blue>not in</font> B
                    holds.
                    <font color=red>setType</font>.EMPTY_SET &lt;= A => TRUE,
                    A &lt;= <font color=red>setType</font>.EMPTY_SET => FALSE for A &lt;> EMPTY_SET,
                    A &lt;= B => B >= A )
      &lt;         Proper subset
                  ( Type of result: <font color=red>boolean</font></font>,
                    A &lt; B => A &lt;= B <font color=blue>and</font> <font color=blue>not</font> A = B,
                    <font color=red>setType</font>.EMPTY_SET &lt; A => TRUE for A &lt;> EMPTY_SET,
                    A &lt; <font color=red>setType</font>.EMPTY_SET => FALSE,
                    A &lt; B => B > A )
      >=        Superset
                  ( Type of result: <font color=red>boolean</font></font>,
                    A >= B => TRUE when no element X exists for which
                       X <font color=blue>in</font> B <font color=blue>and</font> X <font color=blue>not in</font> A
                    holds.
                    A >= B => FALSE when an element X exists for which
                       X <font color=blue>in</font> B <font color=blue>and</font> X <font color=blue>not in</font> A
                    holds.
                    A >= <font color=red>setType</font>.EMPTY_SET => TRUE,
                    <font color=red>setType</font>.EMPTY_SET >= A => FALSE for A &lt;> EMPTY_SET,
                    A >= B => B &lt;= A )
      >         Proper superset
                  ( Type of result: <font color=red>boolean</font></font>,
                    A > B => A >= B <font color=blue>and</font> <font color=blue>not</font> A = B,
                    A > <font color=red>setType</font>.EMPTY_SET => TRUE for A &lt;> EMPTY_SET,
                    <font color=red>setType</font>.EMPTY_SET > A => FALSE,
                    A > B => B &lt; A )
    Functions:
      card      Cardinality of a set
                  ( Type of result: <font color=red>integer</font>,
                    card(<font color=red>setType</font>.EMPTY_SET) => 0  )
      min       Minimal element
                  ( Type of result: <font color=red>baseType</font>,
                    Delivers the element from the set for
                    which the following condition holds:
                       Element &lt;= X
                    for all X which are in the set.
                    min(<font color=red>setType</font>.EMPTY_SET) => EXCEPTION RANGE_ERROR )
      max       Maximum element
                  ( Type of result: <font color=red>baseType</font></font>,
                    Delivers the element from the set for
                    which the following condition holds:
                       Element >= X
                    for all X which are in the set.
                    min(<font color=red>setType</font>.EMPTY_SET) => EXCEPTION RANGE_ERROR )
      str(A)    Conversion to <font color=red>string</font>
                  ( Type of result: <font color=red>string</font>,
                    str(<font color=red>setType</font>.EMPTY_SET) => <font color=maroon>"{}"</font>,
                    str({}) => <font color=maroon>"{}"</font> )
                    str({1, 2}) => <font color=maroon>"{1, 2}"</font> )
      rand      Random element from a set
                The random elements are uniform distributed.
                  ( Type of result: <font color=red>baseType</font>,
                    rand(<font color=red>setType</font>.EMPTY_SET) => EXCEPTION RANGE_ERROR )
      compare(A, B) Compare function
                  ( Type of result: <font color=red>integer</font> )
      hashCode(A) Hash function
                  ( Type of result: <font color=red>integer</font> )
    Statements:
      incl(A,B) Include element B to set A
                  ( Type of argument B: <font color=red>baseType</font> )
      excl(A,B) Exclude element B from set A
                  ( Type of argument B: <font color=red>baseType</font> )
      <font color=blue>for</font> A <font color=blue>range</font> B <font color=blue>do</font>
        C
      <font color=blue>end for</font>   Loop over all elements of a set
                  ( Type of argument A: <font color=red>baseType</font>,
                    Type of argument C: <font color=red>proc</font> )
</pre><p></p>

<a name="struct"><h3>5.13 struct</h3></a>
<p>
    The type <tt>'<font color=red>struct</font>'</tt> describes all structured types.
</p><pre>
    Type generators:
      <font color=blue>new struct</font>
        <font color=blue>var</font> <font color=red>aType</font>: name <font color=blue>is</font> value;
        ...
      <font color=blue>end struct</font>
                Create new structure type

      <font color=blue>new</font> <font color=red>metaType</font> <font color=blue>struct</font>
        <font color=blue>var</font> <font color=red>aType</font>: name <font color=blue>is</font> value;
        ...
      <font color=blue>end struct</font>
                Create new structure type as subtype of <tt>'<font color=red>metaType</font>'</tt>,
                which is not a structure

      <font color=blue>sub</font> <font color=red>metaType</font> <font color=blue>struct</font>
        <font color=blue>var</font> <font color=red>aType</font>: name <font color=blue>is</font> value;
        ...
      <font color=blue>end struct</font>
                Create new structure type as subtype of <tt>'<font color=red>metaType</font>'</tt>,
                which is a structure type. The new stucture type inherits all
		elements of the structure type <tt>'<font color=red>metaType</font>'</tt>.

      <font color=blue>var</font> <font color=red>aType</font>: name <font color=blue>is</font> value
                Declare structure element 'name' with 'value'

    Infixoperators:
      .         Access Element of STRUCT
                  ( example.element )
      ->        Access Element of ptr STRUCT
                  ( example->element )
    Relations:
      =, &lt;>
    Functions:
      incl(A, B) Include element in MODULE
                  ( Type of argument B: <font color=red>reference</font> )
      excl(A, B) Exclude element from MODULE
                  ( Type of argument B: <font color=red>reference</font> )
</pre><p></p>

<a name="category"><h3>5.14 category</h3></a>
<p>
    The type <tt>'<font color=red>category</font>'</tt> describes the category of a <tt>'<font color=red>reference</font>'</tt>.
</p><pre>
    Constants:
      SYMBOLOBJECT, DECLAREDOBJECT, FORWARDOBJECT, FWDREFOBJECT, BLOCKOBJECT,
      CALLOBJECT,MATCHOBJECT, TYPEOBJECT, FORMPARAMOBJECT, INTOBJECT,
      BIGINTOBJECT, CHAROBJECT, STRIOBJECT, BSTRIOBJECT, ARRAYOBJECT,
      HASHOBJECT, STRUCTOBJECT, CLASSOBJECT, INTERFACEOBJECT, SETOBJECT,
      FILEOBJECT, SOCKETOBJECT, LISTOBJECT, FLOATOBJECT, WINOBJECT,
      ENUMLITERALOBJECT, CONSTENUMOBJECT, VARENUMOBJECT, REFOBJECT,
      REFLISTOBJECT, EXPROBJECT, ACTOBJECT, VALUEPARAMOBJECT, REFPARAMOBJECT,
      RESULTOBJECT, LOCALVOBJECT, PROGOBJECT
    Infix operators:
      <font color=red>category</font> <font color=blue>conv</font> A   Conversion of <font color=red>integer</font> to <font color=red>category</font>
                  ( Type of argument A: <font color=red>integer</font>,
                    <font color=red>category</font> <font color=blue>conv</font> ord(INTOBJECT) => INTOBJECT )
      <font color=red>category</font> <font color=blue>parse</font> A   Conversion of <font color=red>string</font> to <font color=red>category</font>
                  ( Type of argument A: <font color=red>string</font>,
                    <font color=red>category</font> <font color=blue>parse</font> <font color=maroon>"FLOATOBJECT"</font> => FLOATOBJECT )
    Relations:
      =, &lt;>
    Functions:
      ord(A)    Ordinal number
                  ( Type of result: <font color=red>integer</font> )
      str(A)    Conversion to <font color=red>string</font>
                  ( Type of result: <font color=red>string</font>,
                    str(CHAROBJECT) => <font color=maroon>"CHAROBJECT"</font> )
</pre><p></p>

<a name="reference"><h3>5.15 reference</h3></a>
<p>
    The type <tt>'<font color=red>reference</font>'</tt> describes a reference to any
  object.
</p><pre>
    Constants:
      NIL       Reference to no element.
    Relations:
      =, &lt;>
    Functions:
      category(A) Get the category of the referenced object
                  ( Type of result: <font color=red>category</font>,
                    category(NIL) => EXCEPTION RANGE_ERROR )
      str(A)    Conversion to <font color=red>string</font>
                  ( Type of result: <font color=red>string</font> )
      getType(A) Get the type of the referenced object
                  ( Type of result: <font color=red>type</font>,
                    getType(NIL) => EXCEPTION RANGE_ERROR )
      obj_number(A) Delivers an unique number for each object
                  ( Type of result: <font color=red>integer</font>,
                    obj_number(NIL) => 0 )
      isVar(A)  Reference to a variable object
                  ( Type of result: <font color=red>boolean</font>,
                    isVar(NIL) => EXCEPTION RANGE_ERROR )
      params(A) Gets the formal params of a function
                  ( Type of result: <font color=red>ref_list</font> )
      local_vars(A) Gets the local variables of a function
                  ( Type of result: <font color=red>ref_list</font>,
                    local_vars(NIL) => EXCEPTION RANGE_ERROR,
                    local_vars(A) => EXCEPTION RANGE_ERROR for category(A) <> BLOCKOBJECT )
      local_consts(A) Gets the local constants of a function
                  ( Type of result: <font color=red>ref_list</font>,
                    local_consts(NIL) => EXCEPTION RANGE_ERROR,
                    local_consts(A) => EXCEPTION RANGE_ERROR for category(A) <> BLOCKOBJECT )
      body(A)   Gets the body of a function
                  ( body(NIL) => EXCEPTION RANGE_ERROR,
                    body(A) => EXCEPTION RANGE_ERROR for category(A) <> BLOCKOBJECT )
      func_result(A) Gets the result object of a function
      func_res_init(A) Gets the init value of the result
                       object of a function
      array_to_list(A) Return the array elements as list
                  ( Type of result: <font color=red>ref_list</font>,
                    array_to_list(NIL) => EXCEPTION RANGE_ERROR,
                    array_to_list(A) => EXCEPTION RANGE_ERROR for category(A) <> ARRAYOBJECT )
      array_min_index(A) Return the minimal index of an array
                  ( Type of result: <font color=red>integer</font>,
                    array_min_index(NIL) => EXCEPTION RANGE_ERROR,
                    array_min_index(A) => EXCEPTION RANGE_ERROR for category(A) <> ARRAYOBJECT )
      array_max_index(A) Return the maximal index of an array
                  ( Type of result: <font color=red>integer</font>,
                    array_max_index(NIL) => EXCEPTION RANGE_ERROR,
                    array_max_index(A) => EXCEPTION RANGE_ERROR for category(A) <> ARRAYOBJECT )
      struct_to_list(A) Return the struct elements as list
                  ( Type of result: <font color=red>ref_list</font>,
                    struct_to_list(NIL) => EXCEPTION RANGE_ERROR,
                    struct_to_list(A) => EXCEPTION RANGE_ERROR for category(A) <> STRUCTOBJECT )
      interface_to_struct(A) Return the struct to which the interface object points.
                  ( interface_to_struct(NIL) => EXCEPTION RANGE_ERROR,
                    interface_to_struct(A) => EXCEPTION RANGE_ERROR for category(A) <> INTERFACEOBJECT )
      file(A)   File name of the referenced object
                  ( Type of result: <font color=red>string</font> )
      line(A)   Line number of the referenced object
                  ( Type of result: <font color=red>integer</font> )
      alloc(A)  Create a copy of the object referenced by A
                The object value of the copy is set to NULL
      getValue(A, <font color=red>reference</font>) Dereference as <font color=red>reference</font>
                  ( Type of result: <font color=red>reference</font>,
                    getValue(NIL, <font color=red>reference</font>) => EXCEPTION RANGE_ERROR,
                    getValue(A, <font color=red>reference</font>) => EXCEPTION RANGE_ERROR for
                        category(A) not in {FWDREFOBJECT, REFOBJECT, REFPARAMOBJECT, RESULTOBJECT,
                        LOCALVOBJECT, ENUMLITERALOBJECT, CONSTENUMOBJECT, VARENUMOBJECT} )
      getValue(A, <font color=red>ref_list</font>) Dereference as <font color=red>ref_list</font>
                  ( Type of result: <font color=red>ref_list</font>,
                    getValue(NIL, <font color=red>ref_list</font>) => EXCEPTION RANGE_ERROR,
                    getValue(A, <font color=red>ref_list</font>) => EXCEPTION RANGE_ERROR for
                        category(A) not in {MATCHOBJECT, CALLOBJECT, REFLISTOBJECT} )
      getValue(A, <font color=red>integer</font>) Dereference as <font color=red>integer</font>
                  ( Type of result: <font color=red>integer</font>,
                    getValue(NIL, <font color=red>integer</font>) => EXCEPTION RANGE_ERROR,
                    getValue(A, <font color=red>integer</font>) => EXCEPTION RANGE_ERROR for category(A) <> INTOBJECT )
      getValue(A, <font color=red>bigInteger</font>) Dereference as <font color=red>bigInteger</font>
                  ( Type of result: <font color=red>bigInteger</font>,
                    getValue(NIL, <font color=red>bigInteger</font>) => EXCEPTION RANGE_ERROR,
                    getValue(A, <font color=red>bigInteger</font>) => EXCEPTION RANGE_ERROR for category(A) <> BIGINTOBJECT )
      getValue(A, <font color=red>float</font>) Dereference as <font color=red>float</font>
                  ( Type of result: <font color=red>float</font>,
                    getValue(NIL, <font color=red>float</font>) => EXCEPTION RANGE_ERROR,
                    getValue(A, <font color=red>float</font>) => EXCEPTION RANGE_ERROR for category(A) <> FLOATOBJECT )
      getValue(A, <font color=red>char</font>) Dereference as <font color=red>char</font>
                  ( Type of result: <font color=red>char</font>,
                    getValue(NIL, <font color=red>char</font>) => EXCEPTION RANGE_ERROR,
                    getValue(A, <font color=red>char</font>) => EXCEPTION RANGE_ERROR for category(A) <> CHAROBJECT )
      getValue(A, <font color=red>string</font>) Dereference as <font color=red>string</font>
                  ( Type of result: <font color=red>string</font>,
                    getValue(NIL, <font color=red>string</font>) => EXCEPTION RANGE_ERROR,
                    getValue(A, <font color=red>string</font>) => EXCEPTION RANGE_ERROR for category(A) <> STRIOBJECT )
      getValue(A, <font color=red>bitset</font>) Dereference as <font color=red>bitset</font>
                  ( Type of result: <font color=red>bitset</font>,
                    getValue(NIL, <font color=red>bitset</font>) => EXCEPTION RANGE_ERROR,
                    getValue(A, <font color=red>bitset</font>) => EXCEPTION RANGE_ERROR for category(A) <> SETOBJECT )
      getValue(A, <font color=red>PRIMITIVE_FILE</font>) Dereference as <font color=red>PRIMITIVE_FILE</font>
                  ( Type of result: <font color=red>PRIMITIVE_FILE</font>,
                    getValue(NIL, <font color=red>PRIMITIVE_FILE</font>) => EXCEPTION RANGE_ERROR,
                    getValue(A, <font color=red>PRIMITIVE_FILE</font>) => EXCEPTION RANGE_ERROR for category(A) <> FILEOBJECT )
      getValue(A, <font color=red>program</font>) Dereference as <font color=red>program</font>
                  ( Type of result: <font color=red>program</font>,
                    getValue(NIL, <font color=red>program</font>) => EXCEPTION RANGE_ERROR,
                    getValue(A, <font color=red>program</font>) => EXCEPTION RANGE_ERROR for category(A) <> PROGOBJECT )
      getValue(A, <font color=red>ACTION</font>) Dereference as <font color=red>ACTION</font>
                  ( Type of result: <font color=red>ACTION</font>,
                    getValue(NIL, <font color=red>ACTION</font>) => EXCEPTION RANGE_ERROR,
                    getValue(A, <font color=red>ACTION</font>) => EXCEPTION RANGE_ERROR for category(A) <> ACTOBJECT )
      getValue(A, <font color=red>type</font>) Dereference as <font color=red>type</font>
                  ( Type of result: <font color=red>type</font>,
                    getValue(NIL, <font color=red>type</font>) => EXCEPTION RANGE_ERROR,
                    getValue(A, <font color=red>type</font>) => EXCEPTION RANGE_ERROR for category(A) <> TYPEOBJECT )
      compare(A, B) Compare function
                  ( Type of result: <font color=red>integer</font> )
      hashCode(A) Hash function
                  ( Type of result: <font color=red>integer</font> )
    Statements:
      setVar(A, B) Set var flag of referenced object A to B
                  ( Type of argument B: <font color=red>boolean</font>,
                    setVar(NIL, B) => EXCEPTION RANGE_ERROR )
      setCategory(A, B) Set the category of the referenced object A to B
                  ( Type of argument B: <font color=red>category</font>,
                    setCategory(NIL, B) => EXCEPTION RANGE_ERROR )
      setType(A, B) Set the type of the referenced object A to B
                  ( Type of argument B: <font color=red>type</font>,
                    setType(NIL, B) => EXCEPTION RANGE_ERROR )
      setValue(A, B) Set the value of the referenced object A to B
                  ( Type of argument B: <font color=red>ref_list</font> )
      setParams(A, B) Set the formal params of a function
                  ( Type of argument B: <font color=red>ref_list</font> )
</pre><p></p>

<a name="ref_list"><h3>5.16 ref_list</h3></a>
<p>
    The type <tt>'<font color=red>ref_list</font>'</tt> describes a list of <tt>'<font color=red>reference</font>'</tt> objects.
</p><pre>
    Constants:
      <font color=red>ref_list</font>.EMPTY  Empty reference list.
    Infix operators:
      &         Ref_list list concatenation
      A <font color=blue>in</font> B    Is element in ref_list
                  ( Type of argument A: <font color=red>reference</font>,
                    Type of result: <font color=red>boolean</font> )
      A <font color=blue>not in</font> B  Is element not in ref_list
                  ( Type of argument A: <font color=red>reference</font>,
                    Type of result: <font color=red>boolean</font> )
    Indices:
      [ A ]     Access one ref_list element
                  ( Type of argument A: <font color=red>integer</font>,
                    Type of result: <font color=red>reference</font>,
                    A[1]=>First element,
                    A[length(A)]=>Last element,
                    A[0] => EXCEPTION RANGE_ERROR,
                    A[succ(length(A))] => EXCEPTION RANGE_ERROR )
      [ A .. B ]  Access a sub list
                  ( Type of arguments A and B: <font color=red>integer</font> )
      [ A .. ]  Access a sub list beginning at position A
                  ( Type of argument A: <font color=red>integer</font> )
      [ .. A ]  Access a sub list ending at position A
                  ( Type of argument A: <font color=red>integer</font> )
    Relations:
      =, &lt;>
    Functions:
      length(A) Length of ref_list
                  ( Type of result: <font color=red>integer</font>,
                    length(<font color=red>ref_list</font>.EMPTY) => 0 )
      make_list(A) Create ref_list with element A
                  ( Type of argument A: <font color=red>reference</font> )
      pos(A,B)  First position of <font color=red>reference</font> B in <font color=red>ref_list</font> A
                  ( Type of argument B: <font color=red>reference</font>,
                    Type of result: <font color=red>integer</font> )
      pos(A,B,C) First position of <font color=red>reference</font> B in <font color=red>ref_list</font> A
                 The search starts at position C of <font color=red>ref_list</font> A
                  ( Type of argument B: <font color=red>reference</font>,
                    Type of argument C: <font color=red>integer</font>,
                    Type of result: <font color=red>integer</font> )
      incl(A, B) Include element in list
                  ( Type of argument B: <font color=red>reference</font> )
      excl(A, B) Exclude element from list
                  ( Type of argument B: <font color=red>reference</font> )
    Statements:
      A &:= B   Append B to A
                  ( A &:= B => A := A & B )
      A @:= [B] C  Assign C to element B of ref_list A
                  ( Type of argument B: <font color=red>integer</font>,
                    Type of argument C: <font color=red>reference</font>,
                    A @:= [B] C =>
                        A := A[..pred(B)] & make_list(C) & A[succ(B)..],
                    A @:= [0] C => EXCEPTION RANGE_ERROR,
                    A @:= [succ(length(A))] C => EXCEPTION RANGE_ERROR )
      for A range B do
        C
      end for   Loop over all elements of a ref_list
                  ( Type of argument A: <font color=red>reference</font>,
                    Type of argument C: <font color=red>proc</font> )
</pre><p></p>

<a name="program"><h3>5.17 program</h3></a>
<p>
    The type <tt>'<font color=red>program</font>'</tt> describes a Seed7 program.
</p><pre>
    Constants:
      <font color=red>program</font>.EMPTY  Empty program.
    Relations:
      =, &lt;>
    Functions:
      parseFile(A)  Parse the file with the name A
                  ( Type of argument A: <font color=red>string</font> )
      parseStri(A)  Parse the string A
                  ( Type of argument A: <font color=red>string</font> )
      evaluate(A, B)  Evaluate the expression B which is part of program A
                  ( Type of result: <font color=red>reference</font>,
                    Type of argument B: <font color=red>reference</font> )
      sys_var(A, B)  Return a reference of the system var B of program A
                  ( Type of result: <font color=red>reference</font>,
                    Type of argument B: <font color=red>string</font> )
      error_count(A)  Number of errors in the program A
                  ( Type of result: <font color=red>integer</font> )
      declared_objects(A)  List of objects declared in the program A
                  ( Type of result: <font color=red>ref_list</font> )
      syobject(A, B)  Return object with name B in program A
                  ( Type of result: <font color=red>reference</font>,
                    Type of argument B: <font color=red>string</font> )
      match(A, B)  Return object from program A which matches B
                  ( Type of result: <font color=red>reference</font>,
                    Type of argument B: <font color=red>ref_list</font> )
    Statements:
      execute(A) Execute the program referred by A
</pre><p></p>

<a name="ptr"><h3>5.18 ptr</h3></a>
<p>
    The type <tt>'<font color=red>ptr baseType</font>'</tt> describes a pointer to an object
  of a <tt>'<font color=red>baseType</font>'</tt>. With
</p><pre>
    <font color=blue>const</font> <font color=red>type</font>: ptrType <font color=blue>is</font> <font color=red>ptr baseType</font>;
</pre><p>
  a new pointer type <tt>'<font color=red>ptrType</font>'</tt> is declared.
</p><pre>
    Constants:
      <font color=red>ptrType</font>.NIL   Reference to no element
    Prefix operators:
      &         Address of
                  ( Type of operand: <font color=red>baseType</font> )
    Postfix operators:
      ^         Dereference
                  ( Type of result: <font color=red>baseType</font> )
    Infix operators:
      <font color=red>ptrType</font> <font color=blue>conv</font> A  Conversion from <font color=red>reference</font> A to <font color=red>ptrType</font>
      <font color=red>reference</font> <font color=blue>conv</font> A  Conversion from <font color=red>ptrType</font> A to <font color=red>reference</font>
    Relations:
      =, &lt;>
    Functions:
      base_type(<font color=red>ptrType</font>)  Gets the <font color=red>baseType</font> of a <font color=red>ptrType</font>
                  ( Type of argument <font color=red>ptrType</font>: <font color=red>type</font> )
</pre><p></p>

<a name="ENUMERATION"><h3>5.19 ENUMERATION</h3></a>
<p>
    With
</p><pre>
    <font color=blue>const</font> <font color=red>type</font>: enumType <font color=blue>is new enum</font>
        enum_literal1, enum_literal2
      <font color=blue>end enum</font>;
</pre><p>
  a new enumeration type is declared. The values of this type are:
</p><pre>
    enum_literal1 and enum_literal2
</pre><p>
  For a enumeration type only few operations are predefined.
  Additional operations must be defined separately. So it is
  necessary to define the <tt>'str'</tt> and <tt>'<font color=blue>parse</font>'</tt> functions in order to
  do I/O for a new enumeration type.
</p><pre>
    Infix operators:
      <font color=red>enumType</font> <font color=blue>conv</font> A  Conversion from <font color=red>integer</font> A to <font color=red>enumType</font>
                  ( Type of argument A: <font color=red>integer</font>,
                    <font color=red>enumType</font> <font color=blue>conv</font> 0 => enum_literal1 )
      <font color=red>integer</font> <font color=blue>conv</font> A   Conversion from <font color=red>enumType</font> A to <font color=red>integer</font>
                  ( Type of result: <font color=red>integer</font>,
                    <font color=red>integer</font> <font color=blue>conv</font> enum_literal1 => 0 )
    Relations:
      =, &lt;>, &lt;, &lt;=, >, >=
    Functions:
      ord(A)    Ordinal number
                  ( Type of result: <font color=red>integer</font> )
      succ(A)   Successor
                  ( succ(A)=>enumType <font color=blue>conv</font>(succ(ord(A))) )
      pred(A)   Predecessor
                  ( pred(A)=>enumType <font color=blue>conv</font>(pred(ord(A))) )
    Statements:
      incr(A)   Increment
                  ( incr(A) => A:=succ(A) )
      decr(A)   Decrement
                  ( decr(A) => A:=pred(A) )
</pre><p></p>

<a name="color"><h3>5.20 color</h3></a>
<p>
    The type <tt>'<font color=red>color</font>'</tt> describes colors.
</p><pre>
    Elements:
      <font color=blue>var</font> <font color=red>integer</font>: red_part <font color=blue>is</font> 0;
      <font color=blue>var</font> <font color=red>integer</font>: green_part <font color=blue>is</font> 0;
      <font color=blue>var</font> <font color=red>integer</font>: blue_part <font color=blue>is</font> 0;
    Constants:
      black         is color(0, 0, 0);
      dark_red      is color(32768, 0, 0);
      dark_green    is color(0, 32768, 0);
      brown         is color(32768, 16384, 0);
      dark_blue     is color(0, 0, 32768);
      dark_magenta  is color(32768, 0, 32768);
      dark_cyan     is color(0, 65535, 65535);
      light_gray    is color(49152, 49152, 49152);
      dark_gray     is color(16384, 16384, 16384);
      light_red     is color(65535, 0, 0);
      light_green   is color(0, 65535, 0);
      yellow        is color(65535, 65535, 0);
      light_blue    is color(0, 0, 65535);
      light_magenta is color(65535, 0, 65535);
      light_cyan    is color(32768, 65535, 65535);
      white         is color(65535, 65535, 65535);
      orange        is color(65535, 32768, 0);
      amber         is color(49152, 32768, 16384);
      pink          is color(65535, 32768, 32768);
    Infix operators:
      +         Add two colors in an additive color system
    Relations:
      =, &lt;>
    Functions:
      color(R,G,B) Creates a color from Red, Green and Blue 
                  ( Type of argument R: <font color=red>integer</font>,
                    Type of argument G: <font color=red>integer</font>,
                    Type of argument B: <font color=red>integer</font> )
</pre><p></p>

<a name="time"><h3>5.21 time</h3></a>
<p>
    The type <tt>'<font color=red>time</font>'</tt> describes times and dates.
</p><pre>
    Elements:
      <font color=blue>var</font> <font color=red>integer</font>: year <font color=blue>is</font> 0;
      <font color=blue>var</font> <font color=red>integer</font>: month <font color=blue>is</font> 1;
      <font color=blue>var</font> <font color=red>integer</font>: day <font color=blue>is</font> 1;
      <font color=blue>var</font> <font color=red>integer</font>: hour <font color=blue>is</font> 0;
      <font color=blue>var</font> <font color=red>integer</font>: minute <font color=blue>is</font> 0;
      <font color=blue>var</font> <font color=red>integer</font>: second <font color=blue>is</font> 0;
    Infix operators:
      +         Add a duration to a time
                  ( Type of right operand: <font color=red>duration</font> )
      -         Subtract a duration from a time
                  ( Type of right operand: <font color=red>duration</font> )
      -         Subtract two times
                  ( Type of result: <font color=red>duration</font> )
      <font color=red>time</font> <font color=blue>parse</font> A   Conversion of <font color=red>string</font> to <font color=red>time</font>
                  ( Type of argument A: <font color=red>string</font>,
                    <font color=red>time</font> <font color=blue>parse</font> <font color=maroon>"2005-02-28 12:00:01"</font> => 2005-02-28 12:00:01,
                    <font color=red>time</font> <font color=blue>parse</font> <font color=maroon>"2005-02-29 12:00:01"</font> => EXCEPTION RANGE_ERROR )
    Relations:
      =, &lt;>, &lt;, &lt;=, >, >=
    Functions:
      time(NOW) Gets the current time
      str(A)    Conversion to <font color=red>string</font>
                  ( Type of result: <font color=red>string</font> )
      strDate(A) Conversion of the date to <font color=red>string</font>
                  ( Type of result: <font color=red>string</font> )
      strTime(A) Conversion of the daytime to <font color=red>string</font>
                  ( Type of result: <font color=red>string</font> )
      strTimeZone(A) Conversion of the time zone to <font color=red>string</font>
                  ( Type of result: <font color=red>string</font> )
      truncToSecond(A) Trunc a time to a second
      truncToMinute(A) Trunc a time to a minute
      truncToHour(A) Trunc a time to a hour
      truncToDay(A) Trunc a time to a day
      truncToMonth(A) Trunc a time to a month
      truncToYear(A) Trunc a time to a year
      isLeapYear(A) Determine if a given year is a leap year
                  ( Type of argument A: <font color=red>integer</font> )
                  ( Type of result: <font color=red>boolean</font> )
      daysInMonth(Y, M) Calculate the number of days in a month
                  ( Type of argument Y: <font color=red>integer</font>,
                    Type of argument M: <font color=red>integer</font>,
                    Type of result: <font color=red>integer</font> )
      dayOfWeek(A)  Day of the week with Monday as 1
                  ( Type of result: <font color=red>integer</font> )
      dayOfYear(A)  Day of the year with 1 January as 1
                  ( Type of result: <font color=red>integer</font> )
      weekOfYear(A) Compute the week number of a year (0 to 53).
                    According to ISO 8601: Week number 1 of
                    every year contains the 4. of january.
                  ( Type of result: <font color=red>integer</font> )
      weekDateYear(A) Compute the year of the ISO 8601 week date
                  ( Type of result: <font color=red>integer</font> )
      weekDateWeek(A) Compute the week of the ISO 8601 week date
                  ( Type of result: <font color=red>integer</font> )
      toUTC(A)  Conversion to Coordinated Universal Time (UTC)
      julianDayNumber(A)  Number of days that have elapsed since
                January 1, 4713 BC in the proleptic Julian calendar
                  ( Type of result: <font color=red>integer</font> )
      julianDayNumToTime(A)  Convert julian day number to time
                  ( Type of argument A: <font color=red>integer</font> )
      timestamp1970(A)  Time expressed in seconds since the
                Unix Epoch (1970-01-01 00:00:00 UTC)
                  ( Type of result: <font color=red>integer</font> )
      compare(A, B) Compare function
                  ( Type of result: <font color=red>integer</font> )
      hashCode(A) Hash function
                  ( Type of result: <font color=red>integer</font> )
    Statements:
      A +:= B   Increment A by B
                  ( Type of argument B: <font color=red>duration</font>,
                    A +:= B => A := A + B )
      A -:= B   Decrement A by B
                  ( Type of argument B: <font color=red>duration</font>,
                    A -:= B => A := A - B )
      await(A)  Wait until the given time
</pre><p></p>

<a name="duration"><h3>5.22 duration</h3></a>
<p>
    The type <tt>'<font color=red>duration</font>'</tt> describes time and date durations.
</p><pre>
    Prefix operators:
      +         Identity
      -         Change sign
    Infix operators:
      +         Add two durations
      -         Subtract two durations
      *         Multiply a duration by an <font color=red>integer</font>
                  ( Type of left operand: <font color=red>integer</font> )
      *         Multiply a duration by an <font color=red>integer</font>
                  ( Type of right operand: <font color=red>integer</font> )
      <font color=red>duration</font> <font color=blue>parse</font> A   Conversion of <font color=red>string</font> to <font color=red>duration</font>
                  ( Type of argument A: <font color=red>string</font>,
                    <font color=red>duration</font> <font color=blue>parse</font> <font color=maroon>"0-02-28 12:00:01"</font> => 0-02-28 12:00:01,
                    <font color=red>duration</font> <font color=blue>parse</font> <font color=maroon>"0-13-29 12:00:01"</font> => EXCEPTION RANGE_ERROR )
    Relations:
      =, &lt;>, &lt;, &lt;=, >, >=
    Functions:
      years(A)  Years of the <font color=red>duration</font>
                  ( Type of result: <font color=red>integer</font> )
      months(A) Months of the <font color=red>duration</font>
                  ( Type of result: <font color=red>integer</font> )
      days(A)   Days of the <font color=red>duration</font>
                  ( Type of result: <font color=red>integer</font> )
      hours(A)  Hours of the <font color=red>duration</font>
                  ( Type of result: <font color=red>integer</font> )
      minutes(A) Minutes of the <font color=red>duration</font>
                  ( Type of result: <font color=red>integer</font> )
      seconds(A) Seconds of the <font color=red>duration</font>
                  ( Type of result: <font color=red>integer</font> )
      mycro_seconds(A)  Mycro seconds of the <font color=red>duration</font>
                  ( Type of result: <font color=red>integer</font> )
      str(A)    Conversion to <font color=red>string</font>
                  ( Type of result: <font color=red>string</font> )
      compare(A, B) Compare function
                  ( Type of result: <font color=red>integer</font> )
      hashCode(A) Hash function
                  ( Type of result: <font color=red>integer</font> )
    Statements:
      wait(A)   Wait for given duration
</pre><p></p>

<a name="file"><h3>5.23 file</h3></a>
<p>
    The type <tt>'<font color=red>file</font>'</tt> describes sequential files.
</p><pre>
    Constants:
      STD_NULL  Standard null file
      STD_IN    Standard input of the operating system
      STD_OUT   Standard output of the operating system
      STD_ERR   Standard error output of the operating system
    Variables:
      IN        Standard input file used for file input
                  operations when no file is specified
                  ( IN is initialized with STD_IN )
      OUT       Standard output file used for file output
                  operations when no file is specified
                  ( OUT is initialized with STD_OUT )
    Relations:
      =, &lt;>
    Functions:
      open(A, B) Open external <font color=red>file</font>
                  ( Type of argument A: <font color=red>string</font>,
                    Type of argument B: <font color=red>string</font>,
                    Type of result: <font color=red>file</font>,
                    Returns STD_NULL if open was not
                    possible )
      open_utf8(A, B) Open external UTF-8 <font color=red>file</font>
                  ( Type of argument A: <font color=red>string</font>,
                    Type of argument B: <font color=red>string</font>,
                    Type of result: <font color=red>file</font>,
                    Returns STD_NULL if open was not
                    possible )
      popen(A, B) Open a pipe to a process
                  ( Type of argument A: <font color=red>string</font>,
                    Type of argument B: <font color=red>string</font>,
                    Type of result: <font color=red>file</font>,
                    Returns STD_NULL if popen was not
                    possible )
      openInetSocket(port) Open local internet client socket
                  ( Type of argument port: <font color=red>integer</font>,
                    Type of result: <font color=red>file</font>,
                    Returns STD_NULL if open was not
                    possible )
      openInetSocket(addr, port) Open internet client socket
                  ( Type of argument addr: <font color=red>string</font>,
                    Type of argument port: <font color=red>integer</font>,
                    Type of result: <font color=red>file</font>,
                    Returns STD_NULL if open was not
                    possible )
      length(A) Length of <font color=red>file</font> A
                  ( Type of result: <font color=red>integer</font> )
      tell(A)   Return the actual <font color=red>file</font> position
                  ( Type of argument: <font color=red>file</font>,
                    The first position in the file is 1 )
      getc(A)   Get one character from <font color=red>file</font> A
                  ( Type of result: <font color=red>char</font> )
      gets(A, B) Get <font color=red>string</font> with maximum length B from <font color=red>file</font> A
                  ( Type of argument A: <font color=red>integer</font>,
                    Type of argument B: <font color=red>file</font>,
                    Type of result: <font color=red>string</font>,
                    gets(A, -1) => EXCEPTION RANGE_ERROR )
      getwd(A)  Get one word from <font color=red>file</font> A
                  ( Type of result: <font color=red>string</font> )
      getln(A)  Get one line from <font color=red>file</font> A
                  ( Type of result: <font color=red>string</font> )
      eoln(A)   End of line
                  ( Type of result: <font color=red>boolean</font> )
      hasNext(A) A call of getc does not return the EOF character
                  ( Type of result: <font color=red>boolean</font> )
      eof(A)    End of file
                  ( Type of result: <font color=red>boolean</font> )
    Statements:
      write(A, B) Write <font color=red>string</font> B to <font color=red>file</font> A
                  ( Type of argument B: <font color=red>string</font> )
      writeln(A) Write a new line to <font color=red>file</font> A
      writeln(A, B) Write <font color=red>string</font> B and new line to <font color=red>file</font> A
                  ( Type of argument B: <font color=red>string</font> )
      read(A, B) Read a word from <font color=red>file</font> A into <font color=red>string</font> B
                  ( Type of right operand: <font color=red>string</font> )
      readln(A)  Read a line from <font color=red>file</font> A
      readln(A, B) Read a line from <font color=red>file</font> A into the <font color=red>string</font> B
                  ( Type of right operand: <font color=red>string</font> )
      backSpace(A) Write backspace to <font color=red>file</font> A
      close(A)  Close <font color=red>file</font> A
      flush(A)  Flush <font color=red>file</font> A
      seek(A, B) Set actual file position of <font color=red>file</font> A to B
                  ( Type of argument B: <font color=red>integer</font>,
                    seek(A, 1) => Set to file begin,
                    seek(A, length(A)) => Set to last position,
                    seek(A, length(A) + 1) => Set to end of file,
                    seek(A, -1) => EXCEPTION RANGE_ERROR )
</pre><p></p>

<a name="text"><h3>5.24 text</h3></a>
<p>
    The type <tt>'<font color=red>text</font>'</tt> describes two dimensional files.
</p><pre>
    Relations:
      =, &lt;>
    Functions:
      open_window(F, A, B, C, D) Open a <font color=red>text</font>
                  ( Type of argument A: <font color=red>integer</font>,
                    Type of argument B: <font color=red>integer</font>,
                    Type of argument C: <font color=red>integer</font>,
                    Type of argument D: <font color=red>integer</font> )
      height(A) Height of the <font color=red>text</font>
                  ( Type of result: <font color=red>integer</font> )
      width(A)  Width of the <font color=red>text</font>
                  ( Type of result: <font color=red>integer</font> )
      line(A)   Current line of the <font color=red>text</font>
                  ( Type of result: <font color=red>integer</font> )
      column(A) Current column of the <font color=red>text</font>
                  ( Type of result: <font color=red>integer</font> )
    Statements:
      write(A, B) Write <font color=red>string</font> B to <font color=red>text</font> A
                  ( Type of argument B: <font color=red>string</font> )
      writeln(A) Write a new line to <font color=red>text</font> A
      writeln(A, B) Write <font color=red>string</font> B and new line to <font color=red>text</font> A
                  ( Type of argument B: <font color=red>string</font> )
      read(A, B) Read a word from <font color=red>text</font> A into <font color=red>string</font> B
                  ( Type of right operand: <font color=red>string</font> )
      readln(A)  Read a line from <font color=red>text</font> A
      readln(A, B) Read a line from <font color=red>text</font> A into the <font color=red>string</font> B
                  ( Type of right operand: <font color=red>string</font> )
      backSpace(A) Write backspace to <font color=red>text</font> A
      close(A)  Close <font color=red>text</font> A
      flush(A)  Flush <font color=red>text</font> A
      clear(A)  Clear the window
      v_scroll(A) Scroll the window vertical
      h_scroll(A) Scroll the window horizontal
      color(A, B) Set foreground color of the <font color=red>text</font> A
                  ( Type of argument B: <font color=red>color</font> )
      color(A, B, C) Set foreground and background color of the <font color=red>text</font> A
                  ( Type of argument B: <font color=red>color</font>,
                    Type of argument C: <font color=red>color</font> )
      setPos(A, B, C) Set the current position of the <font color=red>text</font> A
                  ( Type of argument B: <font color=red>integer</font>
                    Type of argument C: <font color=red>integer</font> )
      setLine(A, B) Set the current line of the <font color=red>text</font> A
                  ( Type of argument B: <font color=red>integer</font> )
      setColumn(A, B) Set the current column of the <font color=red>text</font> A
                  ( Type of argument B: <font color=red>integer</font> )
      box(A)    Write a box around the window
      clear_box(A) Clear the box around the window
      cursor_on(A) Make the cursor visible
      cursor_off(A) Make the cursor invisible
</pre><p></p>

<a name="func"><h3>5.25 func</h3></a>
<p>
    The type <tt>'<font color=red>func baseType</font>'</tt> describes functions which return
  a <tt>'<font color=red>baseType</font>'</tt>. For example: <tt>'<font color=red>func integer</font>'</tt> describes an <tt>'<font color=red>integer</font>'</tt>
  function.
</p><pre>
    Values:
      ord, str, abs, sqrt, rand, A + B, A * B, A ** B,
      trunc, round, sin, cos, compare, hashCode, pos,
      replace, trim, length, keys, color, dayOfWeek,
      ...
                Every function declared with <font color=blue>const</font> <font color=red>func</font> ... is a value

    Prefix operators:
      <font color=blue>func</font>
      <font color=blue>result</font>
        <font color=blue>var</font> <font color=red>baseType</font>: result <font color=blue>is</font> <font color=red>baseType</font>.value;
      <font color=blue>begin</font>
        statements
      <font color=blue>end func</font>
                Create a <font color=red>baseType</font> function
                  ( Type of <tt>'statements'</tt>: <font color=red>proc</font>,
                    Type of result: <font color=red>func baseType</font> )

      <font color=blue>func</font>
      <font color=blue>result</font>
        <font color=blue>var</font> <font color=red>baseType</font>: result <font color=blue>is</font> <font color=red>baseType</font>.value;
      <font color=blue>local</font>
        declarations
      <font color=blue>begin</font>
        statements
      <font color=blue>end func</font>
                Create a <font color=red>baseType</font> function with local variables
                  ( Type of <tt>'declarations'</tt>: <font color=red>proc</font>,
                    Type of <tt>'statements'</tt>: <font color=red>proc</font>,
                    Type of result: <font color=red>func baseType</font> )

      <font color=blue>return</font> value
                Create a function with the result type of value
                  ( Type of value: <font color=red>anyType</font> - which means: any type,
                    Type of result: <font color=red>func anyType</font> )
</pre><p>
  Functions are declared as constants with a <tt>'<font color=red>func</font>'</tt> type and
  are initialized with a <tt>'<font color=blue>func result</font> ...'</tt> or <tt>'<font color=blue>return</font> ...'</tt> operator.
  For example:
</p><pre>
    <font color=blue>const</font> <font color=red>func integer</font>: tak (<font color=blue>in</font> <font color=red>integer</font>: x, <font color=blue>in</font> <font color=red>integer</font>: y, <font color=blue>in</font> <font color=red>integer</font>: z) <font color=blue>is func</font>
      <font color=blue>result</font>
        <font color=blue>var</font> <font color=red>integer</font>: result <font color=blue>is</font> 0;
      <font color=blue>begin</font>
        <font color=blue>if</font> y >= x <font color=blue>then</font>
          result := z;
        <font color=blue>else</font>
          result := tak(tak(pred(x), y, z),
                        tak(pred(y), z, x),
                        tak(pred(z), x, y));
        <font color=blue>end if</font>;
      <font color=blue>end func</font>
</pre><p>
  Another example using the <tt>'<font color=blue>return</font>'</tt> function:
</p><pre>
    <font color=blue>const</font> <font color=red>func float</font>: convertRadianToDegree (<font color=blue>in</font> <font color=red>float</font>: x) <font color=blue>is</font>
      <font color=blue>return</font> x * 57.295779513082320876798154814114;
</pre><p>
  This <tt>'<font color=blue>return</font>'</tt> function should not be confused with a <tt>'<font color=blue>return</font>'</tt>
  statement. It is important to note that no <tt>'<font color=blue>return</font>'</tt> statement
  exists. The declaration for the <tt>'<font color=blue>return</font>'</tt> function is as follows:
</p><pre>
    <font color=blue>const</font> <font color=red>func func aType</font>: return (<font color=blue>ref</font> <font color=red>func aType</font> <font color=blue>param</font>)  <font color=blue>is action</font> <font color=maroon>"PRC_RETURN"</font>;
    <font color=blue>const</font> <font color=red>func func aType</font>: return (<font color=blue>ref</font> <font color=red>aType</font> <font color=blue>param</font>)       <font color=blue>is action</font> <font color=maroon>"PRC_RETURN"</font>;
</pre><p>
  The <tt>'<font color=red>func</font>'</tt> types can also be used for parameters.
  Functions which use a <tt>'<font color=red>func</font>'</tt> parameter do not evaluate this
  parameter before the function call. Instead this parameter can
  be evaluated zero or more times inside the function. For example:
</p><pre>
    <font color=blue>const</font> <font color=red>func boolean</font>: (<font color=blue>in</font> <font color=red>boolean</font>: first) and (<font color=blue>in</font> <font color=red>func boolean</font>: second) <font color=blue>is func</font>
      <font color=blue>result</font>
        <font color=blue>var</font> <font color=red>boolean</font>: result <font color=blue>is</font> FALSE;
      <font color=blue>begin</font>
        <font color=blue>if</font> first <font color=blue>then</font>
          result := second;
        <font color=blue>end if</font>;
      <font color=blue>end func</font>;
</pre><p>
  Here the second parameter is only evaluated when the first
  parameter is <tt>'TRUE'</tt>.
</p>

<a name="varfunc"><h3>5.26 varfunc</h3></a>
<p>
    The type <tt>'<font color=red>varfunc baseType</font>'</tt> describes functions which return
  a <tt>'<font color=red>baseType</font>'</tt> variable. For example: A function which returns an
  <tt>'<font color=red>integer</font>'</tt> variable is described with <tt>'<font color=red>varfunc integer</font>'</tt>. A call 
  of a <tt>'<font color=red>varfunc</font>'</tt> can be used at the left side of an assignment.
  Generally a <tt>'<font color=red>varfunc</font>'</tt> can be used at places where an <tt>'<font color=blue>inout</font>'</tt>
  parameter requests a variable.
</p><pre>
    Prefix operators:
      <font color=blue>return var</font> value;
                Create a varfunc which returns the variable <tt>'value'</tt>
                  ( Type of value: <font color=red>anyType</font> - which means: any type,
                    Accessright of value: <font color=blue>var</font> = A variable, an <tt>'<font color=blue>inout</font>'</tt> parameter or a <tt>'<font color=red>varfunc</font>'</tt>
                    Type of result: <font color=red>varfunc anyType</font> )
</pre><p>
    Varfunctions are used to express <tt>'<font color=red>array</font>'</tt>, <tt>'<font color=red>hash</font>'</tt> and <tt>'<font color=red>struct</font>'</tt>
  accesses which can be used at the left and right side of an
  assignment. The access function for a <tt>'<font color=red>hash</font>'</tt> is defined as:
</p><pre>
    <font color=blue>const</font> <font color=red>func baseType</font>: (<font color=blue>in</font> <font color=red>hashType</font>: aHash) [ (<font color=blue>in</font> <font color=red>keyType</font>: aKey) ] <font color=blue>is</font>
      <font color=blue>return</font> INDEX(aHash, aKey, hashCode(aKey), <font color=red>hashType</font>.keyCompare);

    <font color=blue>const</font> <font color=red>varfunc baseType</font>: (<font color=blue>inout</font> <font color=red>hashType</font>: aHash) [ (<font color=blue>in</font> <font color=red>keyType</font>: aKey) ] <font color=blue>is</font>
      <font color=blue>return var</font> INDEX(aHash, aKey, hashCode(aKey), <font color=red>hashType</font>.keyCompare);
</pre><p>
  The example above shows that functions with <tt>'<font color=blue>in</font>'</tt> and <tt>'<font color=blue>inout</font>'</tt>
  parameters can be overloaded. At the right side of an assignment
  the <tt>'<font color=red>func</font>'</tt> is called, while at the left side the <tt>'<font color=red>varfunc</font>'</tt>
  is called. That way the access functions of <font color=red>array</font>s, <font color=red>hash</font>s
  and <font color=red>struct</font>s can be used in the usual way. 
</p>

<a name="void"><h3>5.27 void</h3></a>
<p>
    The type <tt>'<font color=red>void</font>'</tt> describes the empty type.
</p><pre>
    Value:
      empty     This is the only value of the type '<font color=red>void</font>'.
</pre><p></p>

<a name="proc"><h3>5.28 proc</h3></a>
<p>
    The type <tt>'<font color=red>proc</font>'</tt> describes procedures. The type <tt>'<font color=red>proc</font>'</tt>
  is defined as <tt>'<font color=red>func void</font>'</tt>.
</p><pre>
    Values:
      noop;
      <font color=blue>while</font> ... <font color=blue>do</font> ... <font color=blue>end while</font>;
      <font color=blue>repeat</font> ... <font color=blue>until</font> ... ;
      writeln( ... );
      A := B;
      incr(A);
      ...
                Every procedure declared with <font color=blue>const</font> <font color=red>proc</font>: ... is a value
                The procedure <tt>'noop'</tt> does nothing and is used as empty procedure.

    Prefix operators:
      <font color=blue>func</font>
      <font color=blue>begin</font>
        statements
      <font color=blue>end func</font>
                Create a procedure
                  ( Type of <tt>'statements'</tt>: <font color=red>proc</font>,
                    Type of result: <font color=red>proc</font> )

      <font color=blue>func</font>
      <font color=blue>local</font>
        declarations
      <font color=blue>begin</font>
        statements
      <font color=blue>end func</font>
                Create a procedure with local variables
                  ( Type of <tt>'declarations'</tt>: <font color=red>proc</font>,
                    Type of <tt>'statements'</tt>: <font color=red>proc</font>,
                    Type of result: <font color=red>proc</font> )
</pre><p></p>

<a name="type"><h3>5.29 type</h3></a>
<p>
    The type <tt>'<font color=red>type</font>'</tt> describes all types.
</p><pre>
    Values:
      <font color=red>void</font>, <font color=red>boolean</font>, <font color=red>integer</font>, <font color=red>rational</font>, <font color=red>float</font>, <font color=red>char</font>,
      <font color=red>string</font>, <font color=red>reference</font>, <font color=red>ref_list</font>, <font color=red>color</font>, <font color=red>time</font>, <font color=red>duration</font>
      <font color=red>file</font>, <font color=red>proc</font>, <font color=red>type</font>, ...
                Every type declared with <font color=blue>const</font> <font color=red>type</font>: ... is a value
                The type '<font color=red>void</font>' is used as empty type.
    Prefix operators:
      func      Function type
                  ( <font color=red>func char</font> => Function which returns a <font color=red>char</font> )
      varfunc   Varfunc type
                  ( <font color=red>varfunc char</font> => Function which returns a <font color=red>char</font> variable )
      ptr       Pointer type
                  ( <font color=red>ptr bitset</font> => Pointer to <font color=red>bitset</font> )
      array     Array type
                  ( <font color=red>array string</font> => Array of <font color=red>string</font>s )
      set of    Set type
                  ( <font color=red>set of integer</font> => Set of <font color=red>integer</font> )
      subtype   Create subtype of existing type
                  ( <font color=red>subtype char</font> => Subtype of <font color=red>char</font> )
    Relations:
      =, &lt;>
    Functions:
      str(A)    Conversion to <font color=red>string</font>
                  ( Type of result: <font color=red>string</font> )
      newtype   Create a new type
      gentype   Generate a type
      gensub(A) Generate a subtype
      typeof(A) Get the type of an expression
                  ( Type of argument A: Defined for all types,
                    typeof(1) => <font color=red>integer</font>,
                    typeof(<font color=maroon>"asdf"</font>) => <font color=red>string</font> )
      is_func(A)  Is this type a '<font color=red>func</font>' type
                  ( Type of result: <font color=red>boolean</font>,
                    is_func(<font color=red>func char</font>) => TRUE,
                    is_func(<font color=red>varfunc char</font>) => FALSE )
                    is_func(<font color=red>char</font>) => FALSE )
      is_varfunc(A)  Is this type a '<font color=red>varfunc</font>' type
                  ( Type of result: <font color=red>boolean</font>,
                    is_varfunc(<font color=red>func char</font>) => FALSE,
                    is_varfunc(<font color=red>varfunc char</font>) => TRUE,
                    is_varfunc(<font color=red>char</font>) => FALSE )
      result_type(A)  Get the result type of a '<font color=red>func</font>' or '<font color=red>varfunc</font>' type
                  ( result_type(<font color=red>func char</font>) => <font color=red>char</font>,
                    result_type(<font color=red>char</font>) => EXCEPTION RANGE_ERROR )
      base_type(A)  Get the base type of an array, pointer or
                    set type
                  ( base_type(<font color=red>array char</font>) => <font color=red>char</font>,
                    base_type(<font color=red>ptr string</font>) => <font color=red>string</font>,
                    base_type(<font color=red>set of integer</font>) => <font color=red>integer</font> )                    
      type_number(A)  Get an unique number for a type
                  ( Type of result: <font color=red>integer</font> )
      match_obj(A)  Get the match object of a type
                  ( Type of result: <font color=red>reference</font> )
      compare(A, B) Compare function
                  ( Type of result: <font color=red>integer</font> )
      hashCode(A) Hash function
                  ( Type of result: <font color=red>integer</font> )
    Statements:
      <font color=blue>const</font> <font color=red>aType</font>: name <font color=blue>is</font> value
                Declare constant 'name' with 'value'
      <font color=blue>var</font> <font color=red>aType</font>: name <font color=blue>is</font> value
                Declare variable 'name' with 'value'
</pre><p></p>

<a name="object"><h3>5.30 object</h3></a>
<p>
    The type <tt>'<font color=red>object</font>'</tt> is used as meta type for various types.
  This allows defining common operations for all this types.
  The type <tt>'<font color=red>object</font>'</tt> is not used as element type for container
  classes since this can be done much better and type save
  with abstract data types like <tt>'<font color=red>array</font>'</tt>, <tt>'<font color=red>set</font>'</tt>, <tt>'<font color=red>hash</font>'</tt> and
  others.
</p><pre>
    Functions:
      TRACE_OBJ(A)  Write internal information
</pre><p></p>

<a name="expr"><h3>5.31 expr</h3></a>
<p>
    The type <tt>'<font color=red>expr</font>'</tt> is used to describe unmatched expressions.
  These are expressions where the recognizing of the functions
  and the type check is not done yet. This is used for example
  in the definition of function bodies.
</p><pre>
    Functions:
      WRITE_EXPR(A)
                Write expr A to FILE OUT
</pre><p></p>

<p></p>
<a name="PARAMETERS"><h2>6. PARAMETERS</h2></a>
<!-- ============= -->
<p>
    The following subchapters introduce the parameter types of
  Seed7.
</p>

<a name="val_parameter"><h3>6.1 'val' parameter</h3></a>
<p>
  This function appends a comma and a string to the globalStri
  variable:
</p><pre>
    <font color=blue>const</font> <font color=red>proc</font>: appendStri (<font color=blue>val</font> <font color=red>string</font>: stri) <font color=blue>is func</font>
      <font color=blue>begin</font>
        globalStri &:= <font color=maroon>","</font>;
        globalStri &:= stri;
      <font color=blue>end func</font>;
</pre><p>
  After doing
</p><pre>
    globalStri &:= <font color=maroon>"a"</font>;
    appendStri(globalStri);
</pre><p>
  the globalStri variable contains the value <tt><font color=maroon>"a,a"</font></tt>. If the function
  header would be
</p><pre>
    <font color=blue>const</font> <font color=red>proc</font>: appendStri (<font color=blue>in</font> <font color=red>string</font>: stri) <font color=blue>is func</font>
</pre><p>
  the globalStri variable would contain the value <tt><font color=maroon>"a,a,"</font></tt>. This
  difference is because of the following reasons:
</p><p>
  For arrays <tt>'<font color=blue>in</font>'</tt> parameters are equal to <tt>'<font color=blue>ref</font>'</tt> parameters.
  When appendStri called with globalStri as parameter an unwanted
  side effect takes place: Every change of globalStri changes also
  the <tt>'<font color=blue>ref</font>'</tt> parameter stri. Changes to the <tt>'<font color=blue>ref</font>'</tt> parameter would
  also change the global variable. Such unwanted side effects can
  also take place between parameters (when at least one parameter
  is an <tt>'<font color=blue>inout</font>'</tt> parameter).
</pre><p>
  In most cases such unwanted side effects are impossible or can
  be avoided easily. When possible <tt>'<font color=blue>in</font>'</tt> parameters should be
  preferred over <tt>'<font color=blue>val</font>'</tt> parameters.
</p><dl><dt>
  Semantics:</dt><dd>
    When calling a function a formal <tt>'<font color=blue>val</font>'</tt> parameter gets its
    value from the corresponding actual parameter. This is done
    with a create procedure ( ::= ). In the function it is only
    possible to read a formal <tt>'<font color=blue>val</font>'</tt> parameter. Changing a formal
    <tt>'<font color=blue>val</font>'</tt> parameter is not possible. When a function is left a
    <tt>'destr'</tt> procedure is called for every <tt>'<font color=blue>val</font>'</tt> parameter. Formal
    <tt>'<font color=blue>val</font>'</tt> parameters have the access right <tt>'<font color=blue>const</font>'</tt>.
</dd></dl><p>

  Syntax:
</p><pre>
    val_parameter ::=
      '<font color=blue>val</font>' type_expression ':' identifier_declaration |
      '<font color=blue>val</font>' type_expression '<font color=blue>param</font>' .
</pre><p>

  Declaration:
</p><pre>
    $ <font color=blue>syntax</font> <font color=red>expr</font>: .val.().param <font color=blue>is</font>                   -> 40;
    $ <font color=blue>syntax</font> <font color=red>expr</font>: .val.(). : .(<font color=red>expr</font>) <font color=blue>is</font>              -> 40;

    <font color=blue>const</font> <font color=red>func f_param</font>: val (<font color=blue>ref</font> <font color=red>type</font> <font color=blue>param</font>) param <font color=blue>is               action</font> <font color=maroon>"DCL_VAL1"</font>;
    <font color=blue>const</font> <font color=red>func f_param</font>: val (<font color=blue>ref</font> <font color=red>type</font> <font color=blue>param</font>) : (<font color=blue>ref</font> <font color=red>expr</font> <font color=blue>param</font>) <font color=blue>is  action</font> <font color=maroon>"DCL_VAL2"</font>;
</pre><p></p>

<a name="ref_parameter"><h3>6.2 'ref' parameter</h3></a>
<p>
  The following function defines the primitive action for the
  semicolon operator:
</p><pre>
    <font color=blue>const</font> <font color=red>proc</font>: (ref <font color=red>void</font> <font color=blue>param</font>) ; (ref <font color=red>void</font> <font color=blue>param</font>) <font color=blue>is</font> noop;
</pre><p>
  In this definition and other definitions of primitive actions
  <tt>'<font color=blue>ref</font>'</tt> parameters are used. For normal functions usually 
  <tt>'<font color=blue>in</font>'</tt> parameters are used instead of <tt>'<font color=blue>ref</font>'</tt> parameters:
</p><pre>
    <font color=blue>const</font> <font color=red>func integer</font>: total_length (<font color=blue>in</font> <font color=red>array string</font>: arr) <font color=blue>is func</font>
      <font color=blue>result</font>
        <font color=blue>var</font> <font color=red>integer</font>: result <font color=blue>is</font> 0;
      <font color=blue>local</font>
        <font color=blue>var</font> <font color=red>integer</font>: index <font color=blue>is</font> 0;
      <font color=blue>begin</font>
        <font color=blue>for</font> index <font color=blue>range</font> 1 <font color=blue>to</font> length(arr) <font color=blue>do</font>
          result +:= length(arr[index]);
        <font color=blue>end for</font>;
      <font color=blue>end func</font>;
</pre><p>
  Above function could also be defined with the following
  function head:
</p><pre>
    <font color=blue>const</font> <font color=red>func integer</font>: total_length (<font color=blue>ref</font> <font color=red>array string</font>: arr) <font color=blue>is func</font>
</pre><p>
  Since for array types (and also for struct types) <tt>'<font color=blue>in</font>'</tt>
  parameters are defined to act as <tt>'<font color=blue>ref</font>'</tt> parameters both
  definitions are equal. When possible <tt>'<font color=blue>in</font>'</tt> parameters should
  be preferred over <tt>'<font color=blue>ref</font>'</tt> parameters.
</p><dl><dt>
  Semantics:</dt><dd>
    When calling a function a formal <tt>'<font color=blue>ref</font>'</tt> parameter is set to
    refer to the corresponding actual parameter. In the function
    it is only possible to read a formal <tt>'<font color=blue>ref</font>'</tt> parameter.
    Changing a formal <tt>'<font color=blue>ref</font>'</tt> parameter is not possible. Formal
    <tt>'<font color=blue>ref</font>'</tt> parameters have the access right <tt>'<font color=blue>const</font>'</tt>.
</dd></dl><p>

  Syntax:
</p><pre>
    ref_parameter ::=
      '<font color=blue>ref</font>' type_expression ':' identifier_declaration |
      '<font color=blue>ref</font>' type_expression '<font color=blue>param</font>' .
</pre><p>

  Declaration:
</p><pre>
    $ <font color=blue>syntax</font> <font color=red>expr</font>: .ref.().param <font color=blue>is</font>                   -> 40;
    $ <font color=blue>syntax</font> <font color=red>expr</font>: .ref.(). : .(<font color=red>expr</font>) <font color=blue>is</font>              -> 40;

    <font color=blue>const</font> <font color=red>func f_param</font>: ref (<font color=blue>ref</font> <font color=red>type</font> <font color=blue>param</font>) param <font color=blue>is               action</font> <font color=maroon>"DCL_REF1"</font>;
    <font color=blue>const</font> <font color=red>func f_param</font>: ref (<font color=blue>ref</font> <font color=red>type</font> <font color=blue>param</font>) : (<font color=blue>ref</font> <font color=red>expr</font> <font color=blue>param</font>) <font color=blue>is  action</font> <font color=maroon>"DCL_REF2"</font>;
</pre><p></p>

<a name="in_parameter"><h3>6.3 'in' parameter</h3></a>
<p>
  This function checks if a given number is a prime number:
</p><pre>
    <font color=blue>const</font> <font color=red>func boolean</font>: is_prime (<font color=blue>in</font> <font color=red>integer</font>: number) <font color=blue>is func</font>
      <font color=blue>result</font>
        <font color=blue>var</font> <font color=red>boolean</font>: result <font color=blue>is</font> FALSE;
      <font color=blue>local</font>
        <font color=blue>var</font> <font color=red>integer</font>: count <font color=blue>is</font> 2;
      <font color=blue>begin</font>
        <font color=blue>if</font> number = 2 <font color=blue>then</font>
          result := TRUE;
        <font color=blue>elsif</font> number >= 3 <font color=blue>then</font>
          <font color=blue>while</font> number <font color=blue>rem</font> count &lt;> 0 <font color=blue>and</font> count * count &lt;= number <font color=blue>do</font>
            incr(count);
          <font color=blue>end while</font>;
          result := number <font color=blue>rem</font> count &lt;> 0;
        <font color=blue>end if</font>;
      <font color=blue>end func</font>;
</pre><p>
  The following function defines the ex (outer) product:
</p><pre>
    <font color=blue>const</font> <font color=red>func array array integer</font>:
        (<font color=blue>in</font> <font color=red>array integer</font>: a) ex (<font color=blue>in</font> <font color=red>array integer</font>: b) <font color=blue>is func</font>
      <font color=blue>return</font>
        <font color=blue>var</font> <font color=red>array array integer</font>: result <font color=blue>is</font> 0 times 0 times 0;
      <font color=blue>local</font>
        <font color=blue>var</font> <font color=red>integer</font>: index1 <font color=blue>is</font> 1;
      <font color=blue>begin</font>
        result := length(a) <font color=blue>times</font> length(b) <font color=blue>times</font> 0;
        <font color=blue>for</font> index1 <font color=blue>range</font> 1 <font color=blue>to</font> length(a) <font color=blue>do</font>
          <font color=blue>for</font> index2 <font color=blue>range</font> 1 <font color=blue>to</font> length(b) <font color=blue>do</font>
            result[index1][index2] := a[index1] * b[index2];
          <font color=blue>end for</font>;
        <font color=blue>end for</font>;
      <font color=blue>end func</font>;
</pre><p>
  Although both examples use <tt>'<font color=blue>in</font>'</tt> parameters the parameter in the
  first example is actually a <tt>'<font color=blue>val</font>'</tt> parameter while the parameters
  in the second example are actually <tt>'<font color=blue>ref</font>'</tt> parameters. When a new
  type is created with the <tt>'newtype'</tt> function it is necessary to
  specify the meaning of the <tt>'<font color=blue>in</font>'</tt> parameter. This is done with a
  call of the IN_PARAM_IS_VALUE or the IN_PARAM_IS_REFERENCE function
  with the new generated type as parameter. If a new type is created
  with the <tt>'subtype'</tt> function this specification is optional since
  the base type has already a specification of the <tt>'<font color=blue>in</font>'</tt> parameter.
</p><dl><dt>
  Semantics:</dt><dd>
    Depending on the type an <tt>'<font color=blue>in</font>'</tt> parameter is equivalent to an
    <tt>'<font color=blue>val</font>'</tt> (call by value) parameter or to an <tt>'<font color=blue>ref</font>'</tt> (call by reference)
    parameter. Formal <tt>'<font color=blue>in</font>'</tt> parameters have the access right <tt>'<font color=blue>const</font>'</tt>.
</dd></dl><p>

  Syntax:
</p><pre>
    in_parameter ::=
      '<font color=blue>in</font>' type_expression ':' identifier_declaration .
</pre><p>

  Declaration:
</p><pre>
    $ <font color=blue>syntax</font> <font color=red>expr</font>: .in.().param <font color=blue>is</font>                    -> 40;
    $ <font color=blue>syntax</font> <font color=red>expr</font>: .in.(). : .(<font color=red>expr</font>) <font color=blue>is</font>               -> 40;

    <font color=blue>const</font> <font color=red>func f_param</font>: in (<font color=blue>ref</font> <font color=red>type</font> <font color=blue>param</font>) param <font color=blue>is                action</font> <font color=maroon>"DCL_REF1"</font>;

    <font color=blue>const</font> <font color=red>proc</font>: IN_PARAM_IS_VALUE (<font color=blue>ref</font> <font color=red>type</font>: aType) <font color=blue>is func</font>
      <font color=blue>begin</font>
        <font color=blue>const</font> <font color=red>func f_param</font>: in (<font color=blue>attr</font> <font color=red>aType</font>) : (<font color=blue>ref</font> <font color=red>expr</font> <font color=blue>param</font>) <font color=blue>is   action</font> <font color=maroon>"DCL_VAL2"</font>;
      <font color=blue>end func</font>;

    <font color=blue>const</font> <font color=red>proc</font>: IN_PARAM_IS_REFERENCE (<font color=blue>ref</font> <font color=red>type</font>: aType) <font color=blue>is func</font>
      <font color=blue>begin</font>
        <font color=blue>const</font> <font color=red>func f_param</font>: in (<font color=blue>attr</font> <font color=red>aType</font>) : (<font color=blue>ref</font> <font color=red>expr</font> <font color=blue>param</font>) <font color=blue>is   action</font> <font color=maroon>"DCL_REF2"</font>;
      <font color=blue>end func</font>;
</pre><p></p>

<a name="in_var_parameter"><h3>6.4 'in var' parameter</h3></a>
<p>
  This function computes the greatest common divisor:
</p><pre>
    <font color=blue>const</font> <font color=red>func integer</font>: gcd (<font color=blue>in var</font> <font color=red>integer</font>: a, <font color=blue>in var</font> <font color=red>integer</font>: b) <font color=blue>is func</font>
      <font color=blue>result</font>
        <font color=blue>var</font> <font color=red>integer</font>: result <font color=blue>is</font> 0;
      <font color=blue>local</font>
        <font color=blue>var</font> <font color=red>integer</font>: help <font color=blue>is</font> 0;
      <font color=blue>begin</font>
        <font color=blue>while</font> a &lt;> 0 <font color=blue>do</font>
          help := b <font color=blue>rem</font> a;
          b := a;
          a := help;
        <font color=blue>end while</font>;
        result := b;
      <font color=blue>end func</font>;
</pre><p></p><dl><dt>
  Semantics:</dt><dd>
    When calling a function a formal <tt>'<font color=blue>in var</font>'</tt> parameter gets its
    value from the corresponding actual parameter. This is done
    with a create procedure ( ::= ). In the function it is
    possible to read and change a formal <tt>'<font color=blue>in var</font>'</tt> parameter.
    Changing a formal <tt>'<font color=blue>in var</font>'</tt> parameter has no effect on the
    actual parameter. When a function is left a <tt>'destr'</tt> procedure
    is called for every <tt>'<font color=blue>in var</font>'</tt> parameter. Formal <tt>'<font color=blue>in var</font>'</tt>
    parameters have the access right <tt>'<font color=blue>var</font>'</tt>.
</dd></dl><p>

  Syntax:
</p><pre>
    in_var_parameter ::=
      '<font color=blue>in var</font>' type-expression ':' identifier_declaration .
</pre><p>

  Declaration:
</p><pre>
    $ <font color=blue>syntax</font> <font color=red>expr</font>: .in.var.().param <font color=blue>is</font>                -> 40;
    $ <font color=blue>syntax</font> <font color=red>expr</font>: .in.var.(). : .(<font color=red>expr</font>) <font color=blue>is</font>           -> 40;

    <font color=blue>const</font> <font color=red>func f_param</font>: in var (<font color=blue>ref</font> <font color=red>type</font> <font color=blue>param</font>) <font color=blue>param</font> <font color=blue>is               action</font> <font color=maroon>"DCL_IN1VAR"</font>;
    <font color=blue>const</font> <font color=red>func f_param</font>: in var (<font color=blue>ref</font> <font color=red>type</font> <font color=blue>param</font>) : (<font color=blue>ref</font> <font color=red>expr</font> <font color=blue>param</font>) <font color=blue>is  action</font> <font color=maroon>"DCL_IN2VAR"</font>;
</pre><p></p>

<a name="inout_parameter"><h3>6.5 'inout' parameter</h3></a>
<p>
  This procedure doubles the given parameter 'number':
</p><pre>
    <font color=blue>const</font> <font color=red>proc</font>: double (<font color=blue>inout</font> <font color=red>integer</font>: number) <font color=blue>is func</font>
      <font color=blue>begin</font>
        number := 2 * number;
      <font color=blue>end func</font>;
</pre><p></p><dl><dt>
  Semantics:</dt><dd>
    When calling a function a formal <tt>'<font color=blue>inout</font>'</tt> parameter is set to 
    refer to the corresponding actual parameter. In the function
    it is possible to read and change a formal <tt>'<font color=blue>inout</font>'</tt> parameter.
    Changing a formal <tt>'<font color=blue>inout</font>'</tt> parameter changes the actual
    parameter as well. Formal <tt>'<font color=blue>inout</font>'</tt> parameters have the
    access right <tt>'<font color=blue>var</font>'</tt>.
</dd></dl><p>

  Syntax:
</p><pre>
    inout_parameter ::=
      '<font color=blue>inout</font>' type_expression ':' identifier_declaration .
</pre><p>

  Declaration:
</p><pre>
    $ <font color=blue>syntax</font> <font color=red>expr</font>: .inout.().param <font color=blue>is</font>                 -> 40;
    $ <font color=blue>syntax</font> <font color=red>expr</font>: .inout.(). : .(expr) <font color=blue>is</font>            -> 40;

    <font color=blue>const</font> <font color=red>func f_param</font>: inout (<font color=blue>ref</font> <font color=red>type</font> <font color=blue>param</font>) param <font color=blue>is                action</font> <font color=maroon>"DCL_INOUT1"</font>;
    <font color=blue>const</font> <font color=red>func f_param</font>: inout (<font color=blue>ref</font> <font color=red>type</font> <font color=blue>param</font>) : (<font color=blue>ref</font> <font color=red>expr</font> <font color=blue>param</font>) <font color=blue>is   action</font> <font color=maroon>"DCL_INOUT2"</font>;
</pre><p></p>

<a name="Symbol_parameter"><h3>6.6 Symbol parameter</h3></a>
<p>
  Some functions need symbols at fixed places in the parameter
  list. The following IF-statement requests the keywords <tt>'<font color=blue>THEN</font>'</tt>,
  <tt>'<font color=blue>END</font>'</tt> and <tt>'<font color=blue>IF</font>'</tt> at specific places:
</p><pre>
    <font color=blue>IF</font> condition <font color=blue>THEN</font>
      statement
    <font color=blue>END IF</font>;
</pre><p>
  After defining the syntax of this IF-statement with
</p><pre>
    $ <font color=blue>syntax</font> <font color=red>expr</font>: .IF.().THEN.().END.IF <font color=blue>is</font> -> 25;
</pre><p>
  the semantic can be defined with:
</p><pre>
    <font color=blue>const</font> <font color=red>proc</font>: IF (<font color=blue>in</font> <font color=red>boolean</font>: condition) THEN
                  (<font color=blue>in</font> <font color=red>proc</font>: statement)
                END IF <font color=blue>is func</font>

                  <font color=blue>begin</font>
                    <font color=blue>case</font> condition <font color=blue>of</font>
                      <font color=blue>when</font> {TRUE}: statement;
                    <font color=blue>end case</font>;
                  <font color=blue>end func</font>;
</pre><p>
  The symbol parameters are just written outside the parentheses.
  A call of this statement could be:
</p><pre>
    <font color=blue>IF</font> value &lt; maximum <font color=blue>THEN</font>
      write(value)
    <font color=blue>END IF</font>;
</pre><p></p><dl><dt>
  Semantics:</dt><dd>
  Symbol parameters must be defined in a syntax definition and in
  a corresponding semantic definition. In the semantic definition
  symbol parameters are written outside of the parentheses.
  In the actual parameter list the corresponding symbol of the
  formal parameter list must be written.
</dd></dl><p>

  Syntax:
</p><pre>
    symbol_parameter ::=
      name_identifier | special_identifier .
</pre><p></p>

<a name="attr_parameter"><h3>6.7 'attr' parameter</h3></a>
<p>
  This declaration associates a name to the type <tt>'<font color=red>char</font>'</tt>:
</p><pre>
    <font color=blue>const</font> <font color=red>string</font>: name (<font color=blue>attr</font> <font color=red>char</font>) <font color=blue>is</font> <font color=maroon>"char"</font>;
</pre><p>
  This <tt>'name'</tt> can be used as follows:
</p><pre>
    writeln(name(<font color=red>char</font>));
</pre><p>
  It is possible to overload such declarations:
</p><pre>
    <font color=blue>const</font> <font color=red>string</font>: name (<font color=blue>attr</font> <font color=red>boolean</font>) <font color=blue>is</font> <font color=maroon>"boolean"</font>;
    <font color=blue>const</font> <font color=red>string</font>: name (<font color=blue>attr</font> <font color=red>float</font>) <font color=blue>is</font> <font color=maroon>"float"</font>;
</pre><p>
  An <tt>'<font color=blue>attr</font>'</tt> parameter can be used in a function also:
</p><pre>
    <font color=blue>const</font> <font color=red>func char</font>: (<font color=blue>attr</font> <font color=red>char</font>) parse (<font color=blue>in</font> string</font>: <font color=red>stri</font>) <font color=blue>is func</font>
      <font color=blue>result</font>
        <font color=blue>var</font> <font color=red>char</font>: result <font color=blue>is</font> <font color=maroon>' '</font>;
      <font color=blue>begin</font>
        <font color=blue>if</font> length(stri) >= 1 <font color=blue>then</font>
          result := stri[1];
        <font color=blue>else</font>
          <font color=blue>raise</font> RANGE_ERROR;
        <font color=blue>end if</font>;
      <font color=blue>end func</font>;
</pre><p></p><dl><dt>
  Semantics:</dt><dd>
  The actual parameter which corresponds to an <tt>'<font color=blue>attr</font>'</tt> parameter
  must be the type mentioned in the declaration of the <tt>'<font color=blue>attr</font>'</tt> parameter.
  An <tt>'<font color=blue>attr</font>'</tt> parameter does not declare a formal parameter
  variable which could be used inside a function.
</dd></dl><p>

  Syntax:
</p><pre>
    attr_parameter ::=
      '<font color=blue>attr</font>' type_expression .
</pre><p></p>

<p></p>
<a name="OBJECT_ORIENTATION"><h2>7. OBJECT ORIENTATION</h2></a>
<!-- ===================== -->
<p>
    Many people will be familiar with object-orientation from
  languages like C++, Smalltalk, and Java. Seed7 follows the
  route of declaring "interfaces". An interface is a common
  set of operations supported by an object. For instance
  cars, motorcycles, lorries and vans can all accelerate or
  brake, if they are legal to drive on the road they can all
  indicate right and left.
</p><p>
  This view isn't new. C provides a primitive form of
  interfacing. When you write to a <tt>'file'</tt> in C you use the same
  interface (<tt>'fprintf'</tt>) for hard disk files, console output and
  printer output. The implementation does totally different
  things for these files. UNIX has used the "everything is a
  file" philosophy for ages (even network communication uses
  the <tt>file'</tt> interface (see sockets)).
</p><p>
  For short: An interface defines which methods are supported
  while the implementation describes how this is done.
  Several types with different method implementations can
  share the same interface. 
</p>

<a name="interface_and_implementation"><h3>7.1 Interface and implementation</h3></a>
<p>
  Seed7 uses interface types and implementation types.
  Objects declared with an interface type refer to a value
  which has an implementation type. This situation is
  described with the following picture:
</p><pre>
              +----------------+
    declared  |    interface   |<--- interface type
    object:   |     object     |     (known at compile-time)
              +----------------+
                      |
                      | refer to value
                      V
              +----------------+
    value:    | implementation |<--- implementation type
              |     object     |     (unknown at compile-time)
              +----------------+
</pre><p>
  The interface type of an object can always be determined
  at compile-time. Several implementation types can belong
  to one interface type (they implement the interface type).
  E.g.: The types <tt>'<font color=red>null_file</font>'</tt>, <tt>'<font color=red>external_file</font>'</tt> and <tt>'<font color=red>socket</font>'</tt>
  implement the <tt>'<font color=red>file</font>'</tt> interface. On the other hand: An
  implementation type can also implement several interface
  types. An interface object can only refer to a value with
  an implementation type that implements the interface.
  E.g.: A <tt>'<font color=red>shape</font>'</tt> variable cannot refer to a <tt>'<font color=red>socket</font>'</tt>.
</p><p>
  A new interface type is declared with:
</p><pre>
    <font color=blue>const</font> <font color=red>type</font>: shape <font color=blue>is new interface</font>;
</pre><p>
  Interface (DYNAMIC) functions describe what can be done
  with objects of an interface type. An interface function
  for a <tt>'<font color=red>shape</font>'</tt> could be:
</p><pre>
    <font color=blue>const</font> <font color=red>proc</font>: draw (<font color=blue>in</font> <font color=red>shape</font> <font color=blue>param</font>, <font color=blue>inout</font> <font color=red>window</font> <font color=blue>param</font>) <font color=blue>is DYNAMIC</font>;
</pre><p>
  Now we know that it is possible to <tt>'draw'</tt> a <tt>'<font color=red>shape</font>'</tt> to a
  <tt>'<font color=red>window</font>'</tt>. How this drawing is done is described in the
  implementation type. An implementation type for <tt>'<font color=red>shape</font>'</tt> is:
</p><pre>
    <font color=blue>const</font> <font color=red>type</font>: circle <font color=blue>is new struct</font>
        var <font color=red>integer</font>: radius <font color=blue>is</font> 0;
      <font color=blue>end struct</font>;
</pre><p>
  The fact that the type <tt>'<font color=red>circle</font>'</tt> is an implementation type of
  <tt>'<font color=red>shape</font>'</tt> is described with:
</p><pre>
    type_implements_interface(<font color=red>circle</font>, <font color=red>shape</font>);
</pre><p>
  The function which implements <tt>'draw'</tt> for <tt>'<font color=red>circle</font>'s</tt> is:
</p><pre>
    <font color=blue>const</font> <font color=red>proc</font>: draw (<font color=blue>in</font> <font color=red>circle</font>: aCircle, <font color=blue>inout</font> <font color=red>window</font>: aWindow) <font color=blue>is func</font>
      <font color=blue>begin</font>
        circle(aWindow.win, aWindow.currX, aWindow.currY,
            aCircle.radius, aWindow.foreground);
      <font color=blue>end func</font>;
</pre><p>
  In the classic OOP philosophy a message is sent to an object.
  To express this situation classic OO languages use the
  following method call syntax:
</p><pre>
    param1.method(param2, param3)
</pre><p>
  In the method the receiving object is referred with <tt>'self'</tt> or
  <tt>'this'</tt>. The other parameters use the same mechanisms as in
  procedural programming languages (value or reference parameter). 
  Seed7 uses a different approach: Instead of an implicit defined
  <tt>'self'</tt> or <tt>'this'</tt> parameter, all formal parameters get a user
  defined name. To reflect this symmetric approach a Seed7 method
  call looks like a normal function call:
</p><pre>
    method(param1, param2, param3)
</pre><p>
  The definition of the <tt>'draw'</tt> function above uses the formal
  parameter <tt>'aCircle'</tt> in the role of a <tt>'self'</tt> or <tt>'this'</tt> parameter.
  Formal parameters which have an implementation type are
  automatically in the role of a <tt>'self'</tt> or <tt>'this'</tt> parameter.
</p><p>
  A function to create new circle objects can also be helpful:
</p><pre>
    <font color=blue>const</font> <font color=red>func circle</font>: circle (<font color=blue>in</font> <font color=red>integer</font>: radius) <font color=blue>is func</font>
      <font color=blue>result</font>
        <font color=blue>var</font> <font color=red>circle</font>: result <font color=blue>is</font> <font color=red>circle</font>.value;
      <font color=blue>begin</font>
        result.radius := radius;
      <font color=blue>end func</font>;
</pre><p>
  Now we can draw a <tt>'<font color=red>circle</font>'</tt> object with:
</p><pre>
    draw(circle(50), aWindow);
</pre><p>
  Although the statement above does exactly what it should
  do and the separation between interface and implementation
  is obvious, most OO enthusiasts would not be thrilled. All
  decisions which implementation function should be called
  can be made at compile time. To please the OO fans such
  decisions must be made at runtime. This decision process
  is called dynamic dispatch.
</p>

<a name="dynamic_dispatch"><h3>7.2 Dynamic dispatch</h3></a>
<p>
    When the implementation types have different implementations
  of the same function (method) a dynamic dispatch is necessary.
  The type of the value, referred by an interface object, is not
  known at compile-time. In this case the program must decide at
  runtime which implementation of the function should be invoked.
  This decision is based on the implementation type of the value
  (referred by the interface object). A dynamic dispatch only
  takes place when a DYNAMIC (or interface) function is called.
  When the program is analyzed (in the interpreter or compiler)
  the interface functions take precedence over normal functions
  when both are to be considered.
</p><p>
  To demonstrate the dynamic dispatch we define the type <tt>'<font color=red>line</font>'</tt>
  which also implements a <tt>'<font color=red>shape</font>'</tt>:
</p><pre>
    <font color=blue>const</font> <font color=red>type</font>: line <font color=blue>is new struct</font>
        <font color=blue>var</font> <font color=red>integer</font>: xLen <font color=blue>is</font> 0.0;
        <font color=blue>var</font> <font color=red>integer</font>: yLen <font color=blue>is</font> 0.0;
      <font color=blue>end func</font>;

    type_implements_interface(<font color=red>line</font>, <font color=red>shape</font>);

    <font color=blue>const</font> <font color=red>proc</font>: draw (<font color=blue>in</font> <font color=red>line</font>: aLine, <font color=blue>in</font> <font color=red>window</font>: aWindow) <font color=blue>is func</font>
      <font color=blue>begin</font>
        line(aWindow.win, aWindow.currX, aWindow.currY,
            aLine.xLen, aLine.yLen, aWindow.foreground);
      <font color=blue>end func</font>;

    <font color=blue>const</font> <font color=red>func line</font>: line (<font color=blue>in</font> <font color=red>integer</font>: xLen, <font color=blue>in</font> <font color=red>integer</font>: yLen) <font color=blue>is func</font>
      <font color=blue>result</font>
        <font color=blue>var</font> <font color=red>line</font>: result <font color=blue>is</font> <font color=red>line</font>.value;
      <font color=blue>begin</font>
        result.xLen := xLen;
        result.yLen := yLen;
      <font color=blue>end func</font>;
</pre></p>
  In addition we define a normal (not DYNAMIC) function 
  which draws <tt>'<font color=red>shape</font>'s</tt> to the <tt>'currWindow'</tt>:
</p><pre>
    <font color=blue>const</font> <font color=red>proc</font>: draw (<font color=blue>in</font> <font color=red>shape</font>: aShape) <font color=blue>is func</font>
      <font color=blue>begin</font>
        draw(aShape, currWindow);
      <font color=blue>end func</font>;
</pre><p>
  In the example above the call of the (DYNAMIC) interface
  function is <tt>'draw(aShape, currWindow)'</tt>. The
  interface function declared with
</p><pre>
    <font color=blue>const</font> <font color=red>proc</font>: draw (<font color=blue>in</font> <font color=red>shape</font> <font color=blue>param</font>, <font color=blue>inout</font> <font color=red>window</font> <font color=blue>param</font>) <font color=blue>is DYNAMIC</font>;
</pre><p>
  decides which implementation function has to be called.
  The dynamic dispatch works as follows:
</p><ul>
<li><!--   -  -->For all parameters which have an interface type the
    parameter is replaced with its value. In this case the
    parameter <tt>'aShape'</tt> is replaced by a value of type
    <tt>'<font color=red>circle</font>'</tt> or <tt>'<font color=red>line</font>'</tt>.</li>

<li><!--   -  -->The same logic as in the analyze part of the compiler
    is used to find the matching function. In this search
    normal functions take precedence over interface functions.</li>

<li><!--   -  -->When a matching function is found it is called.</li>
</ul><p>
  This process describes the principal logic of the dynamic
  dispatch. In practice it is not necessary to execute the
  analyze part of the compiler during the runtime. It is
  possible to simplify this process with tables and function
  pointers.
</p>

<a name="inheritance"><h3>7.3 Inheritance</h3></a>
<p>
    When a new <tt>'struct'</tt> type is defined it is possible to
  inherit from an existing <tt>'struct'</tt> type. E.g.:
</p><pre>
    <font color=blue>const</font> <font color=red>type</font>: external_file <font color=blue>is sub</font> <font color=red>null_file</font> <font color=blue>struct</font>
        <font color=blue>var</font> <font color=red>PRIMITIVE_FILE</font>: ext_file <font color=blue>is</font> PRIMITIVE_NULL_FILE;
        <font color=blue>var</font> <font color=red>string</font>: name <font color=blue>is</font> <font color=maroon>""</font>;
      <font color=blue>end struct</font>;
</pre><p>
  That way the type <tt>'<font color=red>external_file</font>'</tt> inherits the fields and
  methods of <tt>'<font color=red>null_file</font>'</tt>, which is declared as:
</p><pre>
    <font color=blue>const</font> <font color=red>type</font>: null_file <font color=blue>is new struct</font>
      <font color=blue>var</font> <font color=red>char</font>: bufferChar <font color=blue>is</font> '\n';
      <font color=blue>var</font> <font color=red>boolean</font>: io_empty <font color=blue>is</font> FALSE;
      <font color=blue>var</font> <font color=red>boolean</font>: io_ok <font color=blue>is</font> TRUE;
    <font color=blue>end struct</font>;
</pre><p>
  In most situations it makes sense when the implementation
  types inherit from a basic implementation type such as
  <tt>'<font color=red>null_file</font>'</tt>. That way it is possible to define functions
  which are inherited by all derived implementation types.
  In the standard library the function <tt>'getln'</tt> is such a
  function:
<p><pre>
    <font color=blue>const</font> <font color=red>func string</font>: getln (<font color=blue>inout</font> <font color=red>null_file</font>: aFile) <font color=blue>is func</font>
      <font color=blue>result</font>
        <font color=blue>var</font> <font color=red>string</font>: stri <font color=blue>is</font> "";
      <font color=blue>local</font>
        <font color=blue>var</font> <font color=red>string</font>: buffer <font color=blue>is</font> "";
      <font color=blue>begin</font>
        buffer := gets(aFile, 1);
        <font color=blue>while</font> buffer <> "\n" <font color=blue>and</font> buffer <> "" <font color=blue>do</font>
          stri &:= buffer;
          buffer := gets(aFile, 1);
        <font color=blue>end while</font>;
        aFile.bufferChar := buffer[1];
      <font color=blue>end func</font>;
</pre><p>
  All inherited types of <tt>'<font color=red>null_file</font>'</tt> inherit the function
  <tt>'getln'</tt>, but they are also free to redefine it. In the
  <tt>'getln'</tt> function above the function call <tt>'gets(aFile, 1)'</tt>
  uses the (DYNAMIC) interface function:
</p><pre>
    <font color=blue>const</font> <font color=red>func string</font>: gets (<font color=blue>inout</font> <font color=red>file</font> <font color=blue>param</font>, <font color=blue>in</font> <font color=red>integer</font> <font color=blue>param</font>) <font color=blue>is DYNAMIC</font>;
</pre><p>
  In other OO languages the distinction between interface type
  and basic implementation type is not done. Such languages
  either use a dynamic dispatch for every method call (as Java
  does) or need a keyword to request a dynamic dispatch (as C++
  does with the <tt>'virtual'</tt> keyword).
</p><p>
  When assignments take place between inherited implementation
  types it is important to note that structure assignments are
  done with (deep) copies. Naturally such assignments can only
  copy the elements that are present in both structures.
  In the following example just the <tt>'<font color=red>null_file</font>'</tt> elements
  are copied from <tt>'anExternalFile'</tt> to <tt>'aNullFile'</tt>:
</p><pre>
    <font color=blue>const</font> <font color=red>proc</font>: example <font color=blue>is func</font>
      <font color=blue>local</font>
        <font color=blue>var</font> <font color=red>null_file</font>: aNullFile <font color=blue>is</font> <font color=red>null_file</font>.value;
        <font color=blue>var</font> <font color=red>external_file</font>: anExternalFile <font color=blue>is</font> <font color=red>external_file</font>.value;
      <font color=blue>begin</font>
        aNullFile := anExternalFile;
        write(aNullFile, "hello");
      <font color=blue>end func</font>;
</pre><p>
  Although the variable <tt>'anExternalFile'</tt> is assigned to
  <tt>'aNullFile'</tt>, the statement <tt>'write(aNullFile, "hello")'</tt>
  calls the <tt>'write'</tt> function (method) of the type <tt>'<font color=red>null_file</font>'</tt>.
</p><p>
  A new interface type can also inherit from an existing
  interface type:
</p><pre>
    <font color=blue>const</font> <font color=red>type</font>: shape <font color=blue>is sub</font> <font color=red>object</font> <font color=blue>interface</font>;
</pre><p>
  Although inheritance is a very powerful feature it should
  be used with care. In many situations it makes more sense
  that a new type has an element of another type (so called
  has-a relation) instead of inheriting from that type (so
  called is-a relation).
</p>

<a name="class_methods"><h3>7.4 Class methods</h3></a>
<p>
    Many object-oriented programming languages support methods
  that are associated with a class instead of an instanciated
  object. Such methods are called class methods or static
  methods. Seed7 supports class methods via attribute (<tt>'<font color=blue>attr</font>'</tt>)
  parameters which allow that a function is attached to a type:
</p><pre>
    <font color=blue>const</font> <font color=red>func circle</font>: create (<font color=blue>attr</font> <font color=red>circle</font>, <font color=blue>in</font> <font color=red>integer</font>: radius) <font color=blue>is</font>
      <font color=blue>return</font> circle(radius);
</pre><p>
  This <tt>'create'</tt> function is attached to the type <tt>'<font color=red>circle</font>'</tt> and can be called with
</p><pre>
    create(<font color=red>circle</font>, 10)
</pre><p>
  Many languages require that the class name must precede the
  method name when a class method is called (E.g. <tt>'circle::create(10)'</tt>
  in C++). In contrast to that <tt>'<font color=blue>attr</font>'</tt> parameters are not
  restricted to a specific parameter position. They can be used
  in any parameter position as in the following example:
</p><pre>
    <font color=blue>const</font> <font color=red>func circle</font>: create (<font color=blue>in</font> <font color=red>integer</font>: radius, <font color=blue>attr</font> <font color=red>circle</font>) <font color=blue>is</font>
      <font color=blue>return</font> circle(radius);
</pre><p>
  This function can be called with
</p><pre>
    create(10, <font color=red>circle</font>)
</pre><p>
  Attribute parameters can be used for any type not just for
  interface and implementation types. Objects which do not
  have a function type such as a character constant can also
  be attached to a type:
</p><pre>
    <font color=blue>const</font> <font color=red>char</font>: (<font color=blue>attr</font> <font color=red>char</font>) . value <font color=blue>is</font> <font color=maroon>' '</font>;
</pre><p>
  This way attributes can be used to specify propertys
  of a type such as its default <tt>'value'</tt>.
  Programming languages such as Seed7 which support function
  definitions outside a class can also use normal functions
  instead of class methods. It is a matter of tast if a
  function should be grouped to a type or if it should
  exist stand alone and is called with:
</p><pre>
    circle(10)
</pre><p>
</p>

<a name="multiple_dispatch"><h3>7.5 Multiple dispatch</h3></a>
<p>
    The Seed7 object system allows multiple dispatch (not to
  be confused with multiple inheritance). The methods are
  not assigned to one type (class). The decision which
  function (method) is called at runtime is done based upon
  the types of several arguments. The classic object
  orientation is a special case where a method is connected
  to one class and the dispatch decision is done based on
  the type of the <tt>'self'</tt> or <tt>'this'</tt> parameter.
  The classic object orientation is a single dispatch system.
</p><p>
  In the following example the type <tt>'<font color=red>Number</font>'</tt> is introduced
  which is capable to unify numerical types. The type
  <tt>'<font color=red>Number</font>'</tt> is an interface type which defines
  the interface function for the <tt>'+'</tt> operation:
</p><pre>
    <font color=blue>const</font> <font color=red>type</font>: Number <font color=blue>is sub</font> <font color=red>object</font> <font color=blue>interface</font>;

    <font color=blue>const</font> <font color=red>func Number</font>: (<font color=blue>in</font> <font color=red>Number</font> <font color=blue>param</font>) + (<font color=blue>in</font> <font color=red>Number</font> <font color=blue>param</font>) <font color=blue>is DYNAMIC</font>;
</pre><p>
  The interface type <tt>'<font color=red>Number</font>'</tt> can represent an <tt>'<font color=red>Integer</font>'</tt> or a <tt>'<font color=red>Float</font>'</tt>:
</p><pre>
    <font color=blue>const</font> <font color=red>type</font>: Integer <font color=blue>is new struct</font>
        <font color=blue>var</font> <font color=red>integer</font>: val <font color=blue>is</font> 0;
      <font color=blue>end struct</font>;

    type_implements_interface(<font color=red>Integer</font>, <font color=red>Number</font>);

    <font color=blue>const</font> <font color=red>type</font>: Float <font color=blue>is new struct</font>
        <font color=blue>var</font> <font color=red>float</font>: val <font color=blue>is</font> 0.0;
      <font color=blue>end struct</font>;

    type_implements_interface(<font color=red>Float</font>, <font color=red>Number</font>);
</pre><p>
  The declarations of the converting <tt>'+'</tt> operators are:
</p><pre>
    <font color=blue>const</font> <font color=red>func Float</font>: (<font color=blue>in</font> <font color=red>Integer</font>: a) + (<font color=blue>in</font> <font color=red>Float</font>: b) <font color=blue>is func</font>
      <font color=blue>result</font>
        <font color=blue>var</font> <font color=red>Float</font>: result <font color=blue>is</font> <font color=red>Float</font>.value;
      <font color=blue>begin</font>
        result.val := flt(a.val) + b.val;
      <font color=blue>end func</font>;

    <font color=blue>const</font> <font color=red>func Float</font>: (<font color=blue>in</font> <font color=red>Float</font>: a) + (<font color=blue>in</font> <font color=red>Integer</font>: b) <font color=blue>is func</font>
      <font color=blue>result</font>
        <font color=blue>var</font> <font color=red>Float</font>: result <font color=blue>is</font> <font color=red>Float</font>.value;
      <font color=blue>begin</font>
        result.val := a.val + flt(b.val);
      <font color=blue>end func</font>;
</pre><p>
  The declarations of the normal <tt>'+'</tt> operators (which do not convert) are:
</p><pre>
    <font color=blue>const</font> <font color=red>func Integer</font>: (<font color=blue>in</font> <font color=red>Integer</font>: a) + (<font color=blue>in</font> <font color=red>Integer</font>: b) <font color=blue>is func</font>
      <font color=blue>result</font>
        <font color=blue>var</font> <font color=red>Integer</font>: result <font color=blue>is</font> <font color=red>Integer</font>.value;
      <font color=blue>begin</font>
        result.val := a.val + b.val;
      <font color=blue>end func</font>;

    <font color=blue>const</font> <font color=red>func Float</font>: (<font color=blue>in</font> <font color=red>Float</font>: a) + (<font color=blue>in</font> <font color=red>Float</font>: b) <font color=blue>is func</font>
      <font color=blue>result</font>
        <font color=blue>var</font> <font color=red>Float</font>: result <font color=blue>is</font> <font color=red>Float</font>.value;
      <font color=blue>begin</font>
        result.val := a.val + b.val;
      <font color=blue>end func</font>;
</pre><p>
  The type <tt>'<font color=red>Number</font>'</tt> can be extended to support other
  operators and there can be also implementations using
  <tt>'<font color=red>complex</font>'</tt>, <tt>'<font color=red>bigInteger</font>'</tt>, <tt>'<font color=red>bigRational</font>'</tt>, etc. . That way
  <tt>'<font color=red>Number</font>'</tt> can be used as universal type for math
  calculation. Further extending can lead to an universal
  type. Such an universal type is loved by proponents of
  dynamic typed languages, but there are also good reasons
  to have distinct types for different purposes.
</p>

<a name="replacing_pointers"><h3>7.6 Replacing pointers with interface types</h3></a>
<p>
    Many languages have the concept of a pointer. It is possible
  to implement data structures, such as lists and trees, with
  pointers. Although Seed7 supports the concept of a pointer, they
  are not well suited to describe such data structures. Instead of
  pointers interface types can be used. This way list, trees and
  other advanced data structures can be defined.
</p><p>
  The following example shows how to do this:
  The interface type <tt>'<font color=red>element</font>'</tt> will be used as "pointer":
</p><pre>
    <font color=blue>const</font> <font color=red>type</font>: element <font color=blue>is new interface</font>;
</pre><p>
  An implementation type for the empty <tt>'<font color=red>element</font>'</tt> (emptyElement)
  can be used as basic implementation type from which other
  implementation types can inherit:
</p><pre>
    <font color=blue>const</font> <font color=red>type</font>: emptyElement <font color=blue>is new struct
      end struct</font>;
</pre><p>
  That the implementation type <tt>'<font color=red>emptyElement</font>'</tt> implements the
  interface type <tt>'<font color=red>element</font>'</tt> is described with:
</p><pre>
    type_implements_interface(<font color=red>emptyElement</font>, <font color=red>element</font>);
</pre><p>
  Since every Seed7 expression has exactly one type, it is
  necessary to define a special <tt>'NIL'</tt> value (used with  <tt>'<font color=red>element</font>.NIL'</tt>)
  for the type <tt>'<font color=red>element</font>'</tt>:
</p><pre>
    <font color=blue>const</font> <font color=red>element</font>: (<font color=blue>attr</font> element) . NIL <font color=blue>is</font> <font color=red>emptyElement</font>.value;
</pre><p>
  Now the struct with two "pointers" and an <tt>'<font color=red>integer</font>'</tt> can be
  declared:
</p><pre>
    <font color=blue>const</font> <font color=red>type</font>: treeElement <font color=blue>is sub</font> <font color=red>emptyElement</font> <font color=blue>struct</font>
        <font color=blue>var</font> <font color=red>element</font>: left <font color=blue>is</font> <font color=red>element</font>.NIL;
        <font color=blue>var</font> <font color=red>element</font>: right <font color=blue>is</font> <font color=red>element</font>.NIL;
        <font color=blue>var</font> <font color=red>integer</font>: item <font color=blue>is</font> 0;
      <font color=blue>end struct</font>;
</pre><p>
  Finally the type <tt>'<font color=red>treeElement</font>'</tt> is defined as implementation
  of the type <tt>'<font color=red>element</font>'</tt>:
</p><pre>
    type_implements_interface(<font color=red>treeElement</font>, <font color=red>element</font>);
</pre><p>
  To allow the direct access to the structure elements <tt>'left'</tt>, <tt>'right'</tt>
  and <tt>'item'</tt> for objects of type <tt>'<font color=red>element</font>'</tt> the following declarations
  are necessary:
</p><pre>
    <font color=blue>const</font> <font color=red>func    element</font>: (<font color=blue>ref</font>   <font color=red>element</font> <font color=blue>param</font>).left  <font color=blue>is DYNAMIC</font>;
    <font color=blue>const</font> <font color=red>varfunc element</font>: (<font color=blue>inout</font> <font color=red>element</font> <font color=blue>param</font>).left  <font color=blue>is DYNAMIC</font>;
    <font color=blue>const</font> <font color=red>func    element</font>: (<font color=blue>ref</font>   <font color=red>element</font> <font color=blue>param</font>).right <font color=blue>is DYNAMIC</font>;
    <font color=blue>const</font> <font color=red>varfunc element</font>: (<font color=blue>inout</font> <font color=red>element</font> <font color=blue>param</font>).right <font color=blue>is DYNAMIC</font>;
    <font color=blue>const</font> <font color=red>func    integer</font>: (<font color=blue>ref</font>   <font color=red>element</font> <font color=blue>param</font>).item  <font color=blue>is DYNAMIC</font>;
    <font color=blue>const</font> <font color=red>varfunc integer</font>: (<font color=blue>inout</font> <font color=red>element</font> <font color=blue>param</font>).item  <font color=blue>is DYNAMIC</font>;
</pre><p>
  When all this was declared the following code is possible:
</p><pre>
    <font color=blue>const</font> <font color=red>proc</font>: addItem (<font color=blue>inout</font> <font color=red>element</font>: anElem, <font color=blue>in</font> <font color=red>integer</font>: item) <font color=blue>is func</font>
      <font color=blue>begin</font>
        <font color=blue>if</font> anElem = <font color=red>element</font>.NIL <font color=blue>then</font>
          anElem := xalloc(<font color=red>treeElement</font>.value);
          anElem.item := item;
        <font color=blue>elsif</font> item < anElem.item <font color=blue>then</font>
          addItem(anElem.left, item);
        <font color=blue>elsif</font> item > anElem.item <font color=blue>then</font>
          addItem(anElem.right, item);
        <font color=blue>end if</font>;
      <font color=blue>end func</font>;

    <font color=blue>const</font> <font color=red>proc</font>: listItems (<font color=blue>in</font> <font color=red>element</font>: anElem) <font color=blue>is func</font>
      <font color=blue>begin</font>
        <font color=blue>if</font> anElem <> <font color=red>element</font>.NIL <font color=blue>then</font>
          listItems(anElem.left);
          write(" " <& anElem.item);
          listItems(anElem.right);
        <font color=blue>end if</font>;
      <font color=blue>end func</font>;

    <font color=blue>const</font> <font color=red>func integer</font>: sum (<font color=blue>in</font> <font color=red>element</font>: anElem) <font color=blue>is func</font>
      <font color=blue>result</font>
        <font color=blue>var</font> <font color=red>integer</font>: result <font color=blue>is</font> 0;
      <font color=blue>begin</font>
        <font color=blue>if</font> anElem <> <font color=red>element</font>.NIL <font color=blue>then</font>
          result := anElem.item + sum(anElem.left) + sum(anElem.right);
        <font color=blue>end if</font>;
      <font color=blue>end func</font>;
</pre><p>
  New elements can be created with the function 'xalloc'.
  This way interface and implementation types help to provide the
  pointer functionality.
</p><p>
  Pointers and interface types are not always the best solution.
  Abstract data types like dynamic arrays, hash tables, struct
  types and set types can also be used to declare data structures.
</p>
<p></p>
<a name="THE_FILE_SYSTEM"><h2>8. THE FILE SYSTEM</h2></a>
<!-- ================== -->
<p>
    The file system is used for communication in various ways.
  For example: To write strings on the screen we use the
  following statements:
</p><pre>
    write(<font color=maroon>"hello world"</font>);
    writeln;
</pre><p>
  <tt>'writeln'</tt> means write newline. We can also write data of
  various types with <tt>'write'</tt>:
</p><pre>
    write(<font color=maroon>"result = "</font>);
    write(number <font color=blue>div</font> 5);
    write(<font color=maroon>" "</font>);
    writeln(<font color=blue>not</font> error);
</pre><p>
  The <tt>'writeln'</tt> above writes data and then terminates the line.
  This is equal to a <tt>'write'</tt> followed by a <tt>'writeln'</tt>. Instead of
  multiple write statements the <tt>'<&'</tt> operator can be used to
  concatenate the elements to be written:
</p><pre>
    writeln(<font color=maroon>"result = "</font> <& number <font color=blue>div</font> 5 <& <font color=maroon>" "</font> <& <font color=blue>not</font> error);
</pre><p>
  The <tt>'<&'</tt> operator needs a <tt>'<font color=blue>string</font>'</tt> as left operand and
  is overloaded for various types as right operand. To allow things like
</p><pre>
    write(next_time <& <font color=maroon>" \r"</font>);
</pre><p>
  the <tt>'<&'</tt> operator is also overloaded for various types as
  left operand and a <tt>'<font color=blue>string</font>'</tt> as right operand.
  This allows you to concatenate several objects with <tt>'<&'</tt> when
  at least the first or the second object is a <tt>'<font color=blue>string</font>'</tt>.
  We can also read data from the keyboard:
</p><pre>
    write(<font color=maroon>"Amount? "</font>);
    read(amount);
</pre><p>
  The user is allowed to use backspace and sends the input
  to the program with the RETURN-key. To let the user respond
  with the RETURN-key we can write:
</p><pre>
    writeln(<font color=maroon>"Type RETURN"</font>);
    readln;
</pre><p>
  To read a line of data we can use <tt>'readln'</tt>:
</p><pre>
    write(<font color=maroon>"Your comment? "</font>);
    readln(user_comment_string);
</pre><p>
  In the previous examples all <tt>'read'</tt> statements read from the
  file IN and all <tt>'write'</tt> statements write to the file OUT. The
  files IN and OUT are initialized with <tt>'STD_IN'</tt> and <tt>'STD_OUT'</tt>
  which are the stdin and stdout files of the operating system.
  (Usually the keyboard and the screen). When we want to write
  to other files we use write statements with the file as first
  parameter. To write a line of text to the file <font color=maroon>"info.fil"</font> we
  use the following statements:
</p><pre>
    info_file := open(<font color=maroon>"info.fil"</font>, <font color=maroon>"w"</font>);
    writeln(info_file, <font color=maroon>"This is the first line of the info file."</font>);
    close(info_file);
</pre><p>
  First the external file is opened for writing and then it is
  used. To read the file back in the string <tt>'stri'</tt> we write:
</p><pre>
    info_file := open(<font color=maroon>"info.fil"</font>, <font color=maroon>"r"</font>);
    readln(info_file, stri);
    close(info_file);
</pre><p>
  It is also possible to write values of other types to
  <tt>'info_file'</tt>:
</p><pre>
    writeln(info_file, number);
</pre><p>
  Here the <tt>'number'</tt> is converted to a string which is written
  to the file. A <tt>'number'</tt> is read back with:
</p><pre>
    readln(info_file, number);
</pre><p>
  For doing I/O to a window on the screen we write:
</p><pre>
    window1 := open_window(SCREEN, 10, 10, 5, 60);
    box(window1);
    setPos(window1, 3, 1);
    write(window1, <font color=maroon>"hello there"</font>);
</pre><p>
  This opens the window 'window1' on the SCREEN at the position
  10, 10. This window has 5 lines and 60 columns. A box (of
  characters: - | + ) is written to surround the 'window1' and
  finally the string <tt><font color=maroon>"hello there"</font></tt> is written in the window
  <tt>'window1'</tt> at Position 3, 1. If we want to clear the 'window1'
  we write:
</p><pre>
    clear(window1);
</pre><p>
  Files can be used for much more things. Here is a list of
  goals for a file system:
</p><ul>
    <li><!-- -  -->A concept which provides conversions from arbitrary
      types to strings and back.</li>

    <li><!-- -  -->Basic input and output operations to process a file
      character wise, word wise or line wise.</li>

    <li><!-- -  -->Input and output statements which combine input with
      conversion respectively conversion with output.</li>

    <li><!-- -  -->Simple read and write statements for standard
      input and output for arbitrary types.</li>

    <li><!-- -  -->Standard input and output files and the possibility
      to route the standard I/O to any file.</li>

    <li><!-- -  -->Access to operating system files and devices.</li>

    <li><!-- -  -->An interface which allows the user to define
      his own file types.</li>
</ul><p>
  In the following subchapters we discuss each of these goals.
</p>

<a name="Conversion_to_strings_and_back"><h3>8.1 Conversion to strings and back</h3></a>
<p>
    We archive the goal of doing I/O for arbitrary types with
  two conversion functions. In order to do I/O with a type
  the <tt>'str'</tt> and <tt>'<font color=blue>parse</font>'</tt> functions must be defined for that
  type. As an example we show the conversion functions for the
  type <tt>'<font color=red>boolean</font>'</tt>:
</p><pre>
    <font color=blue>const</font> <font color=red>func string</font>: str (<font color=blue>in</font> <font color=red>boolean</font>: aBool) <font color=blue>is func</font>
      <font color=blue>result</font>
        <font color=blue>var</font> <font color=red>string</font>: result <font color=blue>is</font> <font color=maroon>""</font>;
      <font color=blue>begin</font>
        <font color=blue>if</font> aBool <font color=blue>then</font>
          result := <font color=maroon>"TRUE"</font>;
        <font color=blue>else</font>
          result := <font color=maroon>"FALSE"</font>;
        <font color=blue>end if</font>;
      <font color=blue>end func</font>;

    <font color=blue>const</font> <font color=red>func boolean</font>: (<font color=blue>attr</font> <font color=red>boolean</font>) parse (<font color=blue>in</font> <font color=red>string</font>: stri) <font color=blue>is func</font>
      <font color=blue>result</font>
        <font color=blue>var</font> <font color=red>boolean</font>: result <font color=blue>is</font> FALSE;
      <font color=blue>begin</font>
        <font color=blue>if</font> stri = <font color=maroon>"TRUE"</font> <font color=blue>then</font>
          result := TRUE;
        <font color=blue>elsif</font> stri = <font color=maroon>"FALSE"</font> <font color=blue>then</font>
          result := FALSE;
        <font color=blue>else</font>
          raise RANGE_ERROR;
        <font color=blue>end if</font>;
      <font color=blue>end func</font>;
</pre><p>
  The <tt>'str'</tt> function must deliver a corresponding string for
  every value of the type. The <tt>'<font color=blue>parse</font>'</tt> function parses a string
  and delivers the converted value as result. If the conversion
  is not successful the exception RANGE_ERROR is raised. The
  attribute used with <tt>'<font color=blue>parse</font>'</tt> allows that it is overloaded for
  different types.
</p><p>
  After defining the <tt>'str'</tt> and <tt>'<font color=blue>parse</font>'</tt> functions for a type the
  <tt>'enable_io'</tt> function can be called for this type as in:
</p><pre>
    enable_io(<font color=red>boolean</font>);
</pre><p>
  The <tt>'enable_io'</tt> template declares various io functions like
  <tt>'read'</tt>, <tt>'write'</tt> and others for the provided type (in this
  example <tt>'<font color=red>boolean</font>'</tt>). If only output (or only input) is needed
  for a type it is possible to define just <tt>'str'</tt> (or <tt>'<font color=blue>parse</font>'</tt>)
  and activate just <tt>'enable_output'</tt> (or <tt>'enable_input'</tt>).
</p><p>
  There is also a formatting operator called <tt>'<font color=blue>lpad</font>'</tt> which is based
  on the <tt>'str'</tt> function. The statements
</p><pre>
    write(12 <font color=blue>lpad</font> 6);
    write(3 <font color=blue>lpad</font> 6);
    writeln(45 <font color=blue>lpad</font> 6);
    write(678 <font color=blue>lpad</font> 6);
    write(98765 <font color=blue>lpad</font> 6);
    writeln(4321 <font color=blue>lpad</font> 6);
</pre><p>
  produce the following output:
</p><pre>
        12     3    45
       678 98765  4321
</pre><p>
  As we see the <tt>'<font color=blue>lpad</font>'</tt> operator can be used to produce right
  justified output. There is also a <tt>'<font color=blue>rpad</font>'</tt> operator to produce
  left justified output. The basic definitions of the <tt>'<font color=blue>lpad</font>'</tt>
  and <tt>'<font color=blue>rpad</font>'</tt> operators work on strings and are as follows:
</p><pre>
    <font color=blue>const</font> <font color=red>func string</font>: (<font color=blue>ref</font> <font color=red>string</font>: stri) lpad (<font color=blue>in</font> <font color=red>integer</font>: leng) <font color=blue>is func</font>
      <font color=blue>result</font>
        <font color=blue>var</font> <font color=red>string</font>: result <font color=blue>is</font> <font color=maroon>""</font>;
      <font color=blue>begin</font>
        <font color=blue>if</font> leng > length(stri) <font color=blue>then</font>
          result := <font color=maroon>" "</font> <font color=blue>mult</font> leng - length(stri) & stri;
        <font color=blue>else</font>
          result := stri;
        <font color=blue>end if</font>;
      <font color=blue>end func</font>;

    <font color=blue>const</font> <font color=red>func string</font>: (<font color=blue>ref</font> <font color=red>string</font>: stri) rpad (<font color=blue>in</font> <font color=red>integer</font>: leng) <font color=blue>is func</font>
      <font color=blue>result</font>
        <font color=blue>var</font> <font color=red>string</font>: result <font color=blue>is</font> <font color=maroon>""</font>;
      <font color=blue>begin</font>
        <font color=blue>if</font> leng > length(stri) <font color=blue>then</font>
          result := stri & <font color=maroon>" "</font> <font color=blue>mult</font> leng - length(stri);
        <font color=blue>else</font>
          result := stri;
        <font color=blue>end if</font>;
      <font color=blue>end func</font>;
</pre><p>
  The <tt>'enable_io'</tt> template contains definitions of <tt>'<font color=blue>lpad</font>'</tt> and <tt>'<font color=blue>rpad</font>'</tt>
  to work on the type specified with <tt>'enable_io'</tt>:
</p><pre>
    <font color=blue>const</font> <font color=red>func string</font>: (<font color=blue>in</font> <font color=red>aType</font>: aValue) lpad (<font color=blue>in</font> <font color=red>integer</font>: leng) <font color=blue>is func</font>
      <font color=blue>result</font>
        <font color=blue>var</font> <font color=red>string</font>: stri <font color=blue>is</font> <font color=maroon>""</font>;
      <font color=blue>begin</font>
        stri := str(aValue) <font color=blue>lpad</font> leng;
      <font color=blue>end func</font>;

    <font color=blue>const</font> <font color=red>func string</font>: (<font color=blue>in</font> <font color=red>aType</font>: aValue) rpad (<font color=blue>in</font> <font color=red>integer</font>: leng) <font color=blue>is func</font>
      <font color=blue>result</font>
        <font color=blue>var</font> <font color=red>string</font>: stri <font color=blue>is</font> <font color=maroon>""</font>;
      <font color=blue>begin</font>
        stri := str(aValue) <font color=blue>rpad</font> leng;
      <font color=blue>end func</font>;
</pre><p>
  For <tt>'<font color=red>float</font>'</tt> values exists an additional way to convert them to
  strings. The <tt>'<font color=blue>digits</font>'</tt> operator allows the specification of a
  precision. For example the statements
</p><pre>
    writeln(3.1415 <font color=blue>digits</font> 2);
    writeln(4.0 <font color=blue>digits</font> 2);
</pre><p>
  produce the following output:
</p><pre>
    3.14
    4.00
</pre><p>
  A combination with the <tt>'<font color=blue>lpad</font>'</tt> operator as in
</p><pre>
    writeln(3.1415 <font color=blue>digits</font> 2 <font color=blue>lpad</font> 6);
    writeln(99.9 <font color=blue>digits</font> 2 <font color=blue>lpad</font> 6);
</pre><p>
  is also possible and produces the following output:
</p><pre>
      3.14
     99.90
</pre><p></p>

<a name="Basic_input_and_output_operations"><h3>8.2 Basic input and output operations</h3></a>
<p>
    To allow arbitrary user defined file-types beside the
  operating system files we chose a model in which the
  I/O methods are assigned to the type of the file-value and
  not to the type of the file-variable. This allows a file
  variable to point to any file-value. The file-variables
  have the type <tt>'<font color=red>file</font>'</tt> which has only the assignment method
  defined. For the operating system files and for each user
  defined file a file-type must be declared which has the
  I/O methods defined. These file-types are derived (direct
  or indirect) from the type <tt>'<font color=red>null_file</font>'</tt> for which all I/O
  methods are defined upon a base of basic string I/O
  methods. So for a new user defined file-type only the
  basic string I/O methods must be defined.
</p><p>
  The two basic I/O methods defined for the <tt>'<font color=red>null_file</font>'</tt> are
</p><pre>
    <font color=blue>const</font> <font color=red>proc</font>: write (<font color=blue>ref</font> <font color=red>null_file</font> <font color=blue>param</font>, <font color=blue>in</font> <font color=red>string</font> <font color=blue>param</font>) <font
 color=blue>is</font> noop;
    <font color=blue>const</font> <font color=red>string</font>: gets (<font color=blue>ref</font> <font color=red>null_file</font> <font color=blue>param</font>, <font color=blue>ref</font> <font color=red>integer</font> <font color=blue>param</font>) <f
ont color=blue>is</font> <font color=maroon>""</font>;
</pre><p>
  This means that writing any string to the <tt>'<font color=red>null_file</font>'</tt> has
  no effect and reading any number of characters from the
  <tt>'<font color=red>null_file</font>'</tt> delivers the empty string. When a user defined
  file type is declared these are the two methods that must
  be redefined for the new file-type. Based upon these
  two methods three more methods are defined for the
  <tt>'<font color=red>null_file</font>'</tt> named 'getc', 'getwd' and 'getln'.
  These methods get a character, a word and a line
  respectively. A word is terminated by a space, a tab
  or a linefeed. A line is terminated by a linefeed.
  This methods need not to be redefined for a user defined
  file type but for performance reasons they can also be
  redefined. The definitions for 'getc', 'getwd' and 'getln' for
  the <tt>'<font color=red>null_file</font>'</tt> are
</p><pre>
    <font color=blue>const</font> <font color=red>func char</font>: getc (<font color=blue>inout</font> <font color=red>null_file</font>: aFile) <font color=blue>is func</font>
      <font color=blue>result</font>
        <font color=blue>var</font> <font color=red>char</font>: ch <font color=blue>is</font> <font color=maroon>' '</font>;
      <font color=blue>local</font>
        <font color=blue>var</font> <font color=red>string</font>: buffer <font color=blue>is</font> <font color=maroon>""</font>;
      <font color=blue>begin</font>
        buffer := gets(aFile, 1);
        <font color=blue>if</font> buffer = <font color=maroon>""</font> <font color=blue>then</font>
          ch := EOF;
        <font color=blue>else</font>
          ch := buffer[1];
        <font color=blue>end if</font>;
      <font color=blue>end func</font>;

    <font color=blue>const</font> <font color=red>func string</font>: getwd (<font color=blue>inout</font> <font color=red>null_file</font>: aFile) <font color=blue>is func</font>
      <font color=blue>result</font>
        <font color=blue>var</font> <font color=red>string</font>: stri <font color=blue>is</font> <font color=maroon>""</font>;
      <font color=blue>local</font>
        <font color=blue>var</font> <font color=red>string</font>: buffer <font color=blue>is</font> <font color=maroon>""</font>;
      <font color=blue>begin</font>
        <font color=blue>repeat</font>
          buffer := gets(aFile, 1);
        <font color=blue>until</font> buffer &lt;> <font color=maroon>" "</font> <font color=blue>and</font> buffer &lt;> <font color=maroon>"\t"</font>;
        <font color=blue>while</font> buffer &lt;> <font color=maroon>" "</font> <font color=blue>and</font> buffer &lt;> <font color=maroon>"\t"</font> <font color=blue>and</font>
            buffer &lt;> <font color=maroon>"\n"</font> <font color=blue>and</font> buffer &lt;> <font color=maroon>""</font> <font color=blue>do</font>
          stri &:= buffer;
          buffer := gets(aFile, 1);
        <font color=blue>end while</font>;
        <font color=blue>if</font> buffer = <font color=maroon>""</font> <font color=blue>then</font>
          aFile.bufferChar := EOF;
        <font color=blue>else</font>
          aFile.bufferChar := buffer[1];
        <font color=blue>end if</font>;
      <font color=blue>end func</font>;

    <font color=blue>const</font> <font color=red>func string</font>: getln (<font color=blue>inout</font> <font color=red>null_file</font>: aFile) <font color=blue>is func</font>
      <font color=blue>result</font>
        <font color=blue>var</font> <font color=red>string</font>: stri <font color=blue>is</font> <font color=maroon>""</font>;
      <font color=blue>local</font>
        <font color=blue>var</font> <font color=red>string</font>: buffer <font color=blue>is</font> <font color=maroon>""</font>;
      <font color=blue>begin</font>
        buffer := gets(aFile, 1);
        <font color=blue>while</font> buffer &lt;> <font color=maroon>"\n"</font> <font color=blue>and</font> buffer &lt;> <font color=maroon>""</font> <font color=blue>do</font>
          stri &:= buffer;
          buffer := gets(aFile, 1);
        <font color=blue>end while</font>;
        <font color=blue>if</font> buffer = <font color=maroon>""</font> <font color=blue>then</font>
          aFile.bufferChar := EOF;
        <font color=blue>else</font>
          aFile.bufferChar := buffer[1];
        <font color=blue>end if</font>;
      <font color=blue>end func</font>;
</pre><p>
  Note that <tt>'getwd'</tt> skips leading spaces and tabs while <tt>'getc'</tt> and
  <tt>'getln'</tt> do not.
  When <tt>'getc'</tt>, <tt>'getwd'</tt> or <tt>'getln'</tt> is not defined for a new user defined
  file type the declarations from the <tt>'<font color=red>null_file</font>'</tt> are used instead.
  These declarations are based on the method <tt>'gets'</tt> which must be
  defined for every new user defined file-type.
</p><p>
  Note that there is an assignment to the variable <tt>'bufferChar'</tt>.
  This variable is an element of <tt>'<font color=red>null_file</font>'</tt> and therefore also
  an element of all derived file types. This allows an
  <tt>'eoln'</tt> function to test if the last <tt>'getwd'</tt> or <tt>'getln'</tt> reach the end
  of a line. Here is a definition of the <tt>'eoln'</tt> function:
</p><pre>
    <font color=blue>const</font> <font color=red>func boolean</font>: eoln (<font color=blue>ref</font> <font color=red>null_file</font>: aFile) <font color=blue>is func</font>
      <font color=blue>result</font>
        <font color=blue>var</font> <font color=red>boolean</font>: result <font color=blue>is</font> TRUE;
      <font color=blue>begin</font>
        result := aFile.bufferChar = '\n';
      <font color=blue>end func</font>;
</pre><p>
  Besides assigning a value to <tt>'bufferChar'</tt> in <tt>'getwd'</tt> and <tt>'getln'</tt>
  and using it in <tt>'eoln'</tt> the standard <tt>'<font color=red>file</font>'</tt> functions do nothing
  with <tt>'bufferChar'</tt>. The functions of the <font color=maroon>"scanfile.s7i"</font> library
  use the <tt>'bufferChar'</tt> variable as current character in the scan
  process. As such all functions of the <font color=maroon>"scanfile.s7i"</font> library
  assume that the first character to be processed is always in
  <tt>'bufferChar'</tt>. Since the standard <tt>'<font color=red>file</font>'</tt> functions do not have
  this behaviour, care has to be taken when mixing scanner and
  file functions.
</p><p>
  The next declarations allows various I/O operations for strings:
</p><pre>
    <font color=blue>const</font> <font color=red>proc</font>: writeln (<font color=blue>inout</font> <font color=red>file</font>: aFile, <font color=blue>in</font> <font color=red>string</font>: stri) <font color=blue>is func</font>
      <font color=blue>begin</font>
        write(aFile, stri);
        writeln(aFile);
      <font color=blue>end func</font>;

    <font color=blue>const</font> <font color=red>proc</font>: read (<font color=blue>inout</font> <font color=red>file</font>: aFile, <font color=blue>inout</font> <font color=red>string</font>: stri) <font color=blue>is func</font>
      <font color=blue>begin</font>
        stri := getwd(aFile);
        aFile.io_empty := stri = <font color=maroon>""</font>;
        aFile.io_ok := TRUE;
      <font color=blue>end func</font>;

    <font color=blue>const</font> <font color=red>proc</font>: readln (<font color=blue>inout</font> <font color=red>file</font>: aFile, <font color=blue>inout</font> <font color=red>string</font>: stri) <font color=blue>is func</font>
      <font color=blue>begin</font>
        stri := getln(aFile);
        aFile.io_empty := stri = <font color=maroon>""</font>;
        aFile.io_ok := TRUE;
      <font color=blue>end func</font>;
</pre><p></p>

<a name="Input_and_output_with_conversion"><h3>8.3 Input and output with conversion</h3></a>
<p>
    Normally we need a combination of an I/O operation with
  a conversion operation. There are several functions which are
  based on the <tt>'str'</tt> and <tt>'<font color=blue>parse</font>'</tt> conversions and on the basic
  I/O-functions. The declaration of this functions is done by
  the templates <tt>'enable_io'</tt>, <tt>'enable_input'</tt> and <tt>'enable_output'</tt>.
  The templates <tt>'enable_io'</tt> and <tt>'enable_output'</tt> define the following
  <tt>'write'</tt> function:
</p><pre>
    <font color=blue>const</font> <font color=red>proc</font>: write (<font color=blue>in</font> <font color=red>file</font>: aFile, <font color=blue>in</font> <font color=red>aType</font>: aValue) <font color=blue>is func</font>
      <font color=blue>begin</font>
        write(aFile, str(aValue));
      <font color=blue>end func</font>;
</pre><p>
  The templates <tt>'enable_io'</tt> and <tt>'enable_input'</tt> define the following
  <tt>'read'</tt> and <tt>'readln'</tt> functions:
</p><pre>
    <font color=blue>const</font> <font color=red>proc</font>: read (<font color=blue>inout</font> <font color=red>file</font>: aFile, <font color=blue>inout</font> <font color=red>aType</font>: aValue) <font color=blue>is func</font>
      <font color=blue>local</font>
        <font color=blue>var</font> <font color=red>string</font>: stri <font color=blue>is</font> <font color=maroon>""</font>;
      <font color=blue>begin</font>
        stri := getwd(aFile);
        aFile.io_empty := stri = <font color=maroon>""</font>;
        <font color=blue>block</font>
          aValue := <font color=red>aType</font> <font color=blue>parse</font> stri;
          aFile.io_ok := TRUE;
        <font color=blue>exception</font>
          <font color=blue>catch</font> RANGE_ERROR:
            aFile.io_ok := FALSE;
        <font color=blue>end block</font>;
      <font color=blue>end func</font>;

    <font color=blue>const</font> <font color=red>proc</font>: readln (<font color=blue>inout</font> <font color=red>file</font>: aFile, <font color=blue>inout</font> <font color=red>aType</font>: aValue) <font color=blue>is func</font>
      <font color=blue>local</font>
        <font color=blue>var</font> <font color=red>string</font>: stri <font color=blue>is</font> <font color=maroon>""</font>;
      <font color=blue>begin</font>
        stri := getln(aFile);
        aFile.io_empty := stri = <font color=maroon>""</font>;
        <font color=blue>block</font>
          aValue := <font color=red>aType</font> <font color=blue>parse</font> stri;
          aFile.io_ok := TRUE;
        <font color=blue>exception</font>
          <font color=blue>catch</font> RANGE_ERROR:
            aFile.io_ok := FALSE;
        <font color=blue>end block</font>;
      <font color=blue>end func</font>;
</pre><p>
  The next two declarations define <tt>'writeln'</tt> and <tt>'backSpace'</tt>:
</p><pre>
    <font color=blue>const</font> <font color=red>proc</font>: writeln (<font color=blue>ref</font> <font color=red>external_file</font>: aFile) <font color=blue>is func</font>
      <font color=blue>begin</font>
        write(aFile, <font color=maroon>"\n"</font>);
      <font color=blue>end func</font>;

    <font color=blue>const</font> <font color=red>proc</font>: backSpace (<font color=blue>ref</font> <font color=red>external_file</font>: aFile) <font color=blue>is func</font>
      <font color=blue>begin</font>
        write(aFile, <font color=maroon>"\b \b"</font>);
      <font color=blue>end func</font>;
</pre><p></p>

<a name="Simple_read_and_write_statements"><h3>8.4 Simple read and write statements</h3></a>
<p>
    The simple input/output for the standard I/O-files are
  <tt>'read'</tt> and <tt>'write'</tt> which are defined with <tt>'enable_io'</tt>. Simple
  I/O may look like:
</p><pre>
    write(<font color=maroon>"Amount? "</font>);
    read(amount);
</pre><p>
  <tt>'read'</tt> and <tt>'write'</tt> use the files IN and OUT which are described
  in the next chapter.  Here is the definition of the <tt>'read'</tt> and
  <tt>'write'</tt> procedures done with <tt>'enable_io'</tt>:
</p><pre>
    <font color=blue>const</font> <font color=red>proc</font>: read (<font color=blue>inout</font> <font color=red>aType</font>: aValue) <font color=blue>is func</font>
      <font color=blue>begin</font>
        read(IN, aValue);
      <font color=blue>end func</font>;

    <font color=blue>const</font> <font color=red>proc</font>: readln (<font color=blue>inout</font> <font color=red>aType</font>: aValue) <font color=blue>is func</font>
      <font color=blue>begin</font>
        readln(IN, aValue);
      <font color=blue>end func</font>;

    <font color=blue>const</font> <font color=red>proc</font>: write (<font color=blue>in</font> <font color=red>aType</font>: aValue) <font color=blue>is func</font>
      <font color=blue>begin</font>
        write(OUT, aValue);
      <font color=blue>end func</font>;

    <font color=blue>const</font> <font color=red>proc</font>: writeln (<font color=blue>in</font> <font color=red>aType</font>: aValue) <font color=blue>is func</font>
      <font color=blue>begin</font>
        write(OUT, aValue);
        writeln(OUT);
      <font color=blue>end func</font>;
</pre><p>
  Additional procedures defined outside of <tt>'enable_io'</tt> are:
</p><pre>
    <font color=blue>const</font> <font color=red>proc</font>: readln <font color=blue>is func</font>
      <font color=blue>local</font>
        <font color=blue>var</font> <font color=red>string</font>: stri <font color=blue>is</font> <font color=maroon>""</font>;
      <font color=blue>begin</font>
        stri := getln(IN);
        IN.io_empty := stri = <font color=maroon>""</font>;
        IN.io_ok := TRUE;
      <font color=blue>end func</font>;

    <font color=blue>const</font> <font color=red>proc</font>: read (NL) <font color=blue>is func</font>
      <font color=blue>begin</font>
        readln;
      <font color=blue>end func</font>;

    <font color=blue>const</font> <font color=red>proc</font>: writeln <font color=blue>is func</font>
      <font color=blue>begin</font>
        writeln(OUT);
      <font color=blue>end func</font>;

    <font color=blue>const</font> <font color=red>proc</font>: write (NL) <font color=blue>is func</font>
      <font color=blue>begin</font>
        writeln(OUT);
      <font color=blue>end func</font>;
</pre><p>
  As an example when you call
</p><pre>
    readln(number);
</pre><p>
  the readln(integer) procedure calls
</p><pre>
    readln(IN, number);
</pre><p>
  if the file IN has not redefined readln(IN, integer) this
  procedure calls
</p><pre>
    stri := getln(IN);
</pre><p>
  and <tt>'getln'</tt> may call gets(IN, 1) in a loop or may be defined
  for the file IN. Finally the <tt>'<font color=blue>parse</font>'</tt> function converts the
  string read into an <tt>'<font color=red>integer</font>'</tt> and assigns it to <tt>'number'</tt>
</p><pre>
    number := <font color=red>integer</font> <font color=blue>parse</font> stri;
</pre><p></p>

<a name="Standard_input_and_output_files"><h3>8.5 Standard input and output files</h3></a>
<p>
    The standard I/O files are OUT for output and IN for input.
  This TWO are file-variables which are declared as follows:
</p><pre>
    <font color=blue>var</font> <font color=red>file</font>: IN <font color=blue>is</font> STD_IN;
    <font color=blue>var</font> <font color=red>file</font>: OUT <font color=blue>is</font> STD_OUT;
</pre><p>
  The files <tt>'STD_IN'</tt> and <tt>'STD_OUT'</tt> are the standard input and
  output files of the operating system (Usually the keyboard and
  the screen). Because IN and OUT are variables redirection of
  standard input or standard output can be done easily by
  assigning a new value to them:
</p><pre>
    IN := OTHER_FILE;
</pre><p>
  After that all <tt>'read'</tt> statements refer to OTHER_FILE.
  Most operating systems have also a stderr file which
  can be accessed via the name <tt>'STD_ERR'</tt>. If you want to
  write error messages to the screen even when stdout
  is redirected elsewhere you can write:
</p><pre>
    writeln(STD_ERR, <font color=maroon>"ERROR MESSAGE"</font>);
</pre><p>
  To redirect the standard output to <tt>'STD_ERR'</tt> you can write:
</p><pre>
    OUT := STD_ERR;
</pre><p>
  There is also a file <tt>'STD_NULL'</tt> defined. Anything written to
  it is ignored. Reading from it does deliver empty strings.
  This file can be used to initialize file variables as in:
</p><pre>
    <font color=blue>var</font> <font color=red>file</font>: MY_FILE <font color=blue>is</font> STD_NULL;
</pre><p>
  It is also used to represent an illegal file value when for
  example an <tt>'open'</tt> procedure fails.
</p>

<a name="Access_to_operating_system_files"><h3>8.6 Access to operating system files</h3></a>
<p>
    The interface type <tt>'<font color=red>file</font>'</tt> is also used to access
  operating system files. This is done with the implementation
  type <tt>'<font color=red>external_file</font>'</tt>. The type <tt>'<font color=red>external_file</font>'</tt> is defined as:
</p><pre>
    <font color=blue>const</font> <font color=red>type</font>: external_file <font color=blue>is sub</font> <font color=red>null_file</font> <font color=blue>struct</font>
        <font color=blue>var</font> <font color=red>PRIMITIVE_FILE</font>: ext_file <font color=blue>is</font> PRIMITIVE_null_file;
        <font color=blue>var</font> <font color=red>string</font>: name <font color=blue>is</font> <font color=maroon>""</font>;
      <font color=blue>end struct</font>;
</pre><p>
  This means that every data item of the type <tt>'<font color=red>external_file</font>'</tt>
  has the elements from <tt>'<font color=red>null_file</font>'</tt> and additionally the
  elements <tt>'ext_file'</tt> and <tt>'name'</tt>. The type <tt>'<font color=red>PRIMITIVE_FILE</font>'</tt>
  points directly to an operating system file. Objects
  of type <tt>'<font color=red>PRIMITIVE_FILE</font>'</tt> can only have operating system
  files as values while objects of type <tt>'<font color=red>file</font>'</tt> can also have
  other files as values. To allow the implementation of the
  type <tt>'<font color=red>external_file</font>'</tt> several operations for the type
  <tt>'<font color=red>PRIMITIVE_FILE</font>'</tt> are defined. But outside <tt>'<font color=red>external_file</font>'</tt> the
  type <tt>'<font color=red>PRIMITIVE_FILE</font>'</tt> and its operations should not be used.
</p><p>
  There are three predefined external files <tt>'STD_IN'</tt>, <tt>'STD_OUT'</tt>
  and <tt>'STD_ERR'</tt> which have the following declarations:
</p><pre>
    <font color=blue>const</font> <font color=red>func external_file</font>: INIT_STD_FILE (<font color=blue>ref</font> <font color=red>PRIMITIVE_FILE</font>: primitive_file,
        <font color=blue>in</font> <font color=red>string</font>: file_name) <font color=blue>is func</font>
      <font color=blue>result</font>
        <font color=blue>var</font> <font color=red>external_file</font>: result <font color=blue>is</font> <font color=red>external_file</font>.value;
      <font color=blue>begin</font>
        result.ext_file := primitive_file;
        result.name := file_name;
      <font color=blue>end func</font>;

    <font color=blue>var</font> <font color=red>external_file</font>: STD_IN <font color=blue>is</font>  INIT_STD_FILE(PRIMITIVE_INPUT,  <font color=maroon>"STD_IN"</font>);
    <font color=blue>var</font> <font color=red>external_file</font>: STD_OUT <font color=blue>is</font> INIT_STD_FILE(PRIMITIVE_OUTPUT, <font color=maroon>"STD_OUT"</font>);
    <font color=blue>var</font> <font color=red>external_file</font>: STD_ERR <font color=blue>is</font> INIT_STD_FILE(PRIMITIVE_ERROR,  <font color=maroon>"STD_ERR"</font>);
</pre><p>
  It is possible to do I/O directly with them, but it is more wisely
  to use them only to initialize user defined file variables as in:
</p><pre>
    <font color=blue>var</font> <font color=red>file</font>: err <font color=blue>is</font> STD_ERR;
</pre><p>
  In the rest of the program references to such a variable can be
  used:
</p><pre>
    writeln(err, <font color=maroon>"Some error occurred"</font>);
</pre><p>
  In this case redirection of the file <tt>'err'</tt> can be done very easy.
  The second way to access external files is to use the <tt>'open'</tt>
  function. Usually a file variable is declared
</p><pre>
    <font color=blue>var</font> <font color=red>file</font>: my_out <font color=blue>is</font> STD_NULL;
</pre><p>
  and the result of the <tt>'open'</tt> function is assigned to this file
  variable
</p><pre>
    my_out := open(<font color=maroon>"my_file"</font>, <font color=maroon>"w"</font>);
</pre><p>
  The first parameter of <tt>'open'</tt> is the path of the file to
  be opened. Seed7 always uses the slash (<tt>'/'</tt>) as path
  delimiter. The use of a backslash in a path may raise the
  exception <tt>'RANGE_ERROR'</tt>. The second parameter of <tt>'open'</tt>
  specifies the mode:
</p><pre>
    Binary mode:
      <font color=maroon>"r"</font>   ... Open file for reading.
      <font color=maroon>"w"</font>   ... Truncate to zero length or create file for writing.
      <font color=maroon>"a"</font>   ... Append; open or create file for writing at end-of-file.
      <font color=maroon>"r+"</font>  ... Open file for update (reading and writing).
      <font color=maroon>"w+"</font>  ... Truncate to zero length or create file for update.
      <font color=maroon>"a+"</font>  ... Append; open or create file for update, writing at end-of-file.
    Text mode:
      <font color=maroon>"rt"</font>  ... Open file for reading.
      <font color=maroon>"wt"</font>  ... Truncate to zero length or create file for writing.
      <font color=maroon>"at"</font>  ... Append; open or create file for writing at end-of-file.
      <font color=maroon>"rt+"</font> ... Open file for update (reading and writing).
      <font color=maroon>"wt+"</font> ... Truncate to zero length or create file for update.
      <font color=maroon>"at+"</font> ... Append; open or create file for update, writing at end-of-file.
</pre><p>
  Note that Seed7 defines the modes <font color=maroon>"r"</font>, <font color=maroon>"w"</font>, <font color=maroon>"a"</font>, <font color=maroon>"r+"</font>, <font color=maroon>"w+"</font>
  and <font color=maroon>"a+"</font> as binary modes. This is different from the
  definition used by the <tt>'fopen'</tt> function of the C library.
  The difference between binary and text mode is as follows:
</p><ul>
    <li><!-- -  -->Binary mode provides an implementation independend
      behaviour on all operating systems. In binary mode no
      conversion to and from the line end character (<tt><font color=maroon>'\n'</font></tt>)
      is done. This has the advantage that an <tt>'<font color=red>external_file</font>'</tt>
      written in binary mode is identical on all operating
      systems. Reading files with different line endings
      (<tt><font color=maroon>"\n"</font></tt> and <tt><font color=maroon>"\r\n"</font></tt>) is supported by every <tt>'<font color=red>external_file</font>'</tt>:
      The functions <tt>'getwd'</tt>, <tt>'getln'</tt>, <tt>'read'</tt> and <tt>'readln'</tt>, of
      <tt>'<font color=red>external_file</font>'</tt> skip a carriage return (<tt><font color=maroon>'\r'</font></tt>) when it
      is just before a linefeed (<tt><font color=maroon>'\n'</font></tt>). The rest of the
      <tt>'<font color=red>external_file</font>'</tt> functions like <tt>'getc'</tt> and <tt>'gets'</tt> deliver
      line endings unchanged.
</li>
    <li><!-- -  -->The behaviour of an <tt>'<font color=red>external_file</font>'</tt> in text mode is
      implementation dependend. Under Unix/Linux/Bsd text and
      binary modes are identical. Other operating systems
      prefer to do some line end conversions in text mode:
      When reading a file all occurrences of <tt><font color=maroon>"\r\n"</font></tt> are
      converted to <tt><font color=maroon>'\n'</font></tt>. When writing to a file all
      occurrences of <tt><font color=maroon>'\n'</font></tt> are converted to <tt><font color=maroon>"\r\n"</font></tt>. Note that
      text mode cannot be used to automatically create files
      with <tt><font color=maroon>"\r\n"</font></tt> line endings under Unix/Linux/Bsd.</li>
</ul><p>
  The following table compares the file modes of Seed7 and C:
</p><table border="1">
    <tr><td>Seed7 <tt>'open'</tt> mode</td>   <td>C <tt>'fopen'</tt> mode</td></tr>
    <tr><td><font color=maroon>"r"</font></td>                 <td><font color=maroon>"rb"</font></td></tr>
    <tr><td><font color=maroon>"w"</font></td>                 <td><font color=maroon>"wb"</font></td></tr>
    <tr><td><font color=maroon>"a"</font></td>                 <td><font color=maroon>"ab"</font></td></tr>
    <tr><td><font color=maroon>"r+"</font></td>                <td><font color=maroon>"rb+"</font></td></tr>
    <tr><td><font color=maroon>"w+"</font></td>                <td><font color=maroon>"wb+"</font></td></tr>
    <tr><td><font color=maroon>"a+"</font></td>                <td><font color=maroon>"ab+"</font></td></tr>
    <tr><td><font color=maroon>"rt"</font></td>                <td><font color=maroon>"r"</font></td></tr>
    <tr><td><font color=maroon>"wt"</font></td>                <td><font color=maroon>"w"</font></td></tr>
    <tr><td><font color=maroon>"at"</font></td>                <td><font color=maroon>"a"</font></td></tr>
    <tr><td><font color=maroon>"rt+"</font></td>               <td><font color=maroon>"r+"</font></td></tr>
    <tr><td><font color=maroon>"wt+"</font></td>               <td><font color=maroon>"w+"</font></td></tr>
    <tr><td><font color=maroon>"at+"</font></td>               <td><font color=maroon>"a+"</font></td></tr>
</table><p>
  The function <tt>'open'</tt> returns <tt>'STD_NULL'</tt> when it fails. So it is
  necessary to check the file variable to be on the save side:
</p><pre>
    <font color=blue>if</font> my_out &lt;> STD_NULL <font color=blue>then</font>
</pre><p>
  After that output to <tt>'my_out'</tt> is possible with
</p><pre>
    writeln(my_out, <font color=maroon>"hi there"</font>);
</pre><p>
  Note that <tt>'<font color=red>external_file</font>'</tt> describes BYTE files. Writing
  a character with an ordinal >= 256 such as
</p><pre>
    writeln(my_out, <font color=maroon>"illegal char: \256\"</font>);
</pre><p>
  results in the exception <tt>'RANGE_ERROR'</tt>. To write unicode
  characters other file types must be used. The libraries
  <font color=maroon>"utf8.s7i"</font> and <font color=maroon>"utf16.s7i"</font> provide access to UTF-8 and
  UTF-16 files. The library <font color=maroon>"utf8.s7i"</font> defines the
  implementation type <tt>'<font color=red>utf8_file</font>'</tt> as
</p><pre>
    <font color=blue>const</font> <font color=red>type</font>: utf8_file <font color=blue>is sub</font> <font color=red>external_file</font> <font color=blue>struct</font>
      <font color=blue>end struct</font>;
</pre><p>
  and the function <tt>'open_utf8'</tt> which can be used the same
  way as <tt>'open'</tt>:
</p><pre>
    my_out := open_utf8(<font color=maroon>"utf8_file"</font>, <font color=maroon>"w"</font>);
</pre><p>
  An UTF-8 file accepts all unicode characters. That way
</p><pre>
    writeln(my_out, <font color=maroon>"unicode char: \256\"</font>);
</pre><p>
  works without problems.
</p>

<a name="Keyboard_file"><h3>8.7 Keyboard file</h3></a>
<p>
    As stated earlier <tt>'STD_IN'</tt> provides an interface to the keyboard
  which is line buffered and echoed on <tt>'STD_OUT'</tt>. This means that
  you can see everything you typed. Additionally you can correct
  your input with BACKSPACE until you press RETURN. But sometimes
  an unbuffered and unechoed input is needed. This is provided in
  the library <font color=maroon>"keybd.s7i"</font>, which defines the type <tt>'<font color=red>keyboard_file</font>'</tt>
  and the file <tt>'KEYBOARD'</tt>. Characters typed at the keyboard are
  queued (first in first out) and can be read directly from
  <tt>'KEYBOARD'</tt> without any possibiliy to correct. Additionally
  <tt>'KEYBOARD'</tt> does not echo the characters. Reading from <tt>'KEYBOARD'</tt>
  delivers normal UNICODE characters or special codes (which may be
  or may not be UNICODE characters) for function and cursor keys.
  UNICODE characters and special codes both are <tt>'<font color=red>char</font>'</tt> values. The
  <font color=maroon>"keybd.s7i"</font> library defines <tt>'<font color=red>char</font>'</tt> constants for various keys:
</p><table border="1">
    <tr><td>Key character constant</td>     <td>Description</td></tr>
    <tr><td><tt>KEY_CTL_A</tt> to <tt>KEY_CTL_Z</tt></td>     <td>The control keys ctrl-a to ctrl-z</td></tr>
    <tr><td><tt>KEY_ALT_A</tt> to <tt>KEY_ALT_Z</tt></td>     <td>The alternate keys alt-a to alt-z</td></tr>
    <tr><td><tt>KEY_ALT_0</tt> to <tt>KEY_ALT_9</tt></td>     <td>The alternate keys alt-0 to alt-9</td></tr>
    <tr><td><tt>KEY_F1</tt> to <tt>KEY_F10</tt></td>          <td>Function keys F1 to F10</td></tr>
    <tr><td><tt>KEY_SFT_F1</tt> to <tt>KEY_SFT_F10</tt></td>  <td>Shifted function keys F1 to F10</td></tr>
    <tr><td><tt>KEY_CTL_F1</tt> to <tt>KEY_CTL_F10</tt></td>  <td>Control function keys F1 to F10</td></tr>
    <tr><td><tt>KEY_ALT_F1</tt> to <tt>KEY_ALT_F10</tt></td>  <td>Alternate function keys F1 to F10</td></tr>
    <tr><td><tt>KEY_BS</tt></td>                     <td>Backspace (equal to KEY_CTL_H)</td></tr>
    <tr><td><tt>KEY_TAB</tt></td>                    <td>Horizontal Tab (equal to KEY_CTL_H)</td></tr>
    <tr><td><tt>KEY_NL</tt></td>                     <td>Newline/Enter/Return key (equal to KEY_CTL_J)</td></tr>
    <tr><td><tt>KEY_CR</tt></td>                     <td>Carriage return (equal to KEY_CTL_M)</td></tr>
    <tr><td><tt>KEY_ESC</tt></td>                    <td>Escape key</td></tr>
    <tr><td><tt>KEY_NULCHAR</tt></td>                <td>Nul character key</td></tr>
    <tr><td><tt>KEY_BACKTAB</tt></td>                <td>Horizontal back tab</td></tr>
    <tr><td><tt>KEY_LEFT</tt></td>                   <td>Cursor left</td></tr>
    <tr><td><tt>KEY_RIGHT</tt></td>                  <td>Cursor right</td></tr>
    <tr><td><tt>KEY_UP</tt></td>                     <td>Cursor up</td></tr>
    <tr><td><tt>KEY_DOWN</tt></td>                   <td>Cursor down</td></tr>
    <tr><td><tt>KEY_HOME</tt></td>                   <td>Home key</td></tr>
    <tr><td><tt>KEY_END</tt></td>                    <td>End key</td></tr>
    <tr><td><tt>KEY_PGUP</tt></td>                   <td>Page up</td></tr>
    <tr><td><tt>KEY_PGDN</tt></td>                   <td>Page down</td></tr>
    <tr><td><tt>KEY_INS</tt></td>                    <td>Insert key</td></tr>
    <tr><td><tt>KEY_DEL</tt></td>                    <td>Delete key</td></tr>
    <tr><td><tt>KEY_PAD_CENTER</tt></td>             <td>Numeric keypad center key</td></tr>
    <tr><td><tt>KEY_CTL_LEFT</tt></td>               <td>Control cursor left</td></tr>
    <tr><td><tt>KEY_CTL_RIGHT</tt></td>              <td>Control cursor right</td></tr>
    <tr><td><tt>KEY_CTL_UP</tt></td>                 <td>Control cursor up</td></tr>
    <tr><td><tt>KEY_CTL_DOWN</tt></td>               <td>Control cursor down</td></tr>
    <tr><td><tt>KEY_CTL_HOME</tt></td>               <td>Control home key</td></tr>
    <tr><td><tt>KEY_CTL_END</tt></td>                <td>Control end key</td></tr>
    <tr><td><tt>KEY_CTL_PGUP</tt></td>               <td>Control page up</td></tr>
    <tr><td><tt>KEY_CTL_PGDN</tt></td>               <td>Control page down</td></tr>
    <tr><td><tt>KEY_CTL_INS</tt></td>                <td>Control insert key</td></tr>
    <tr><td><tt>KEY_CTL_DEL</tt></td>                <td>Control delete key</td></tr>
    <tr><td><tt>KEY_SCRLUP</tt></td>                 <td>Scroll up key</td></tr>
    <tr><td><tt>KEY_SCRLDN</tt></td>                 <td>Scroll down key</td></tr>
    <tr><td><tt>KEY_INSLN</tt></td>                  <td>Insert line key</td></tr>
    <tr><td><tt>KEY_DELLN</tt></td>                  <td>Delete line key</td></tr>
    <tr><td><tt>KEY_ERASE</tt></td>                  <td>Erase key</td></tr>
    <tr><td><tt>KEY_CTL_CR</tt></td>                 <td>Control carriage return</td></tr>
    <tr><td><tt>KEY_NULLCMD</tt></td>                <td>Null command of window manager</td></tr>
    <tr><td><tt>KEY_REDRAW</tt></td>                 <td>Redraw command of window manager</td></tr>
    <tr><td><tt>KEY_NEWWINDOW</tt></td>              <td>New window command of window manager</td></tr>
    <tr><td><tt>KEY_MOUSE1</tt></td>                 <td>Mouse key 1 (counted from left)</td></tr>
    <tr><td><tt>KEY_MOUSE2</tt></td>                 <td>Mouse key 2 (counted from left)</td></tr>
    <tr><td><tt>KEY_MOUSE3</tt></td>                 <td>Mouse key 3 (counted from left)</td></tr>
    <tr><td><tt>KEY_MOUSE4</tt></td>                 <td>Mouse key 4 (counted from left)</td></tr>
    <tr><td><tt>KEY_MOUSE5</tt></td>                 <td>Mouse key 5 (counted from left)</td></tr>
    <tr><td><tt>KEY_UNDEF</tt></td>                  <td>Undefined key</td></tr>
    <tr><td><tt>KEY_NONE</tt></td>                   <td>No key pressed (returned by busy_getc)</td></tr>
</table><p>
  The following example uses the <tt>'<font color=red>char</font>'</tt> constant <tt>'KEY_UP'</tt>:
</p><pre>
    $ <font color=blue>include</font> <font color=maroon>"seed7_05.s7i"</font>;
      <font color=blue>include</font> <font color=maroon>"keybd.s7i"</font>;

    <font color=blue>const</font> <font color=red>proc</font>: main <font color=blue>is func</font>
      <font color=blue>begin</font>
        writeln(<font color=maroon>"Please press cursor up"</font>);
        <font color=blue>while</font> getc(KEYBOARD) <> KEY_UP <font color=blue>do</font>
          writeln(<font color=maroon>"This was not cursor up"</font>);
        <font color=blue>end while</font>;
        writeln(<font color=maroon>"Cursor up was pressed"</font>);
      <font color=blue>end func</font>;
</pre><p>
  Progams should use the <tt>'<font color=red>char</font>'</tt> constants defined in <font color=maroon>"keybd.s7i"</font>
  to deal with function and cursor keys, since the special key
  codes may change in future versions of Seed7.
</p><p>
  Additionally to the operations possible with a <tt>'<font color=red>file</font>'</tt> there
  are two functions that are applicable only to files of type
  <tt>'<font color=red>keyboard_file</font>'</tt>:
</p><ul>
    <li><!-- -  --><tt>'busy_getc'</tt>, which delivers the next character
      from the keyboard or <tt>'KEY_NONE'</tt> if no key has been pressed.</li>
    <li><!-- -  --><tt>'keypressed'</tt>, which returns TRUE if a character
      is available from the keyboard and FALSE otherwise.</li>
</ul><p>
  Note that <tt>'keypressed'</tt> does not actually read a character. Reading
  must be done with a different function after <tt>'keypressed'</tt> returns
  TRUE. Both functions (<tt>'busy_getc'</tt> and <tt>'keypressed'</tt>) are useful
  when user input is allowed while some processing takes place.
  The following program uses <tt>'busy_getc(KEYBOARD)'</tt> to display
  the time until a key is pressed:
</p><pre>
    $ <font color=blue>include</font> <font color=maroon>"seed7_05.s7i"</font>;
      <font color=blue>include</font> <font color=maroon>"time.s7i"</font>;
      <font color=blue>include</font> <font color=maroon>"keybd.s7i"</font>;

    <font color=blue>const</font> <font color=red>proc</font>: main <font color=blue>is func</font>
      <font color=blue>begin</font>
        writeln;
        <font color=blue>while</font> busy_getc(KEYBOARD) = KEY_NONE <font color=blue>do</font>
          write(time(NOW) <& <font color=maroon>"\r"</font>);
          flush(OUT);
        <font color=blue>end while</font>;
        writeln;
        writeln;
      <font color=blue>end func</font>;
</pre><p>
  Seed7 programs can run in two modes:
</p><ul>
    <li><!-- -  -->Console mode, where the program runs in a console/terminal window (the default).</li>
    <li><!-- -  -->Graphics mode, where the program has its own graphic window.</li>
</ul><p>
  This two modes are supported with two basic keyboard files:
</p><ul>
    <li><!-- -  --><tt>'CONSOLE_KEYBOARD'</tt>, which uses a terminfo or console driver.</li>
    <li><!-- -  --><tt>'GRAPH_KEYBOARD'</tt>, which uses a X11 or gdi driver.</li>
</ul><p>
  The file <tt>'KEYBOARD'</tt> is actually a variable which refers to one
  of the two basic keyboard files.  The declaration of the type
  <tt>'<font color=red>keyboard_file</font>'</tt> and the file <tt>'KEYBOARD'</tt> in <font color=maroon>"keybd.s7i"</font> is:
</p><pre>
    <font color=blue>const</font> <font color=red>type</font>: keyboard_file <font color=blue>is</font> <font color=red>subtype file</font>;

    <font color=blue>var</font> <font color=red>keyboard_file</font>: KEYBOARD <font color=blue>is</font> CONSOLE_KEYBOARD;
</pre><p>
  Graphic programs switch to to the <tt>'GRAPH_KEYBOARD'</tt> driver with:
</p><pre>
    KEYBOARD := GRAPH_KEYBOARD;
</pre><p>
  Some file types are defined to support the <tt>'KEYBOARD'</tt>. One such
  file type is <tt>'<font color=red>echo_file</font>'</tt>, which is defined in the library <font color=maroon>"echo.s7i"</font>.
  An <tt>'<font color=red>echo_file</font>'</tt> file can be used to write input characters to
  an output file. This is useful since <tt>'KEYBOARD'</tt> does not echo its
  input, but <tt>'<font color=red>echo_file</font>'</tt> is not restricted to support <tt>'KEYBOARD'</tt>.
  The following program writes echos of the keys typed and exits as
  soon as a <tt><font color=maroon>'!'</font></tt> is encountered:
</p><pre>
    $ <font color=blue>include</font> <font color=maroon>"seed7_05.s7i"</font>;
      <font color=blue>include</font> <font color=maroon>"keybd.s7i"</font>;
      <font color=blue>include</font> <font color=maroon>"echo.s7i"</font>;

    <font color=blue>const</font> <font color=red>proc</font>: main <font color=blue>is func</font>
      <font color=blue>local</font>
        <font color=blue>var</font> <font color=red>char</font>: ch <font color=blue>is</font> <font color=maroon>' '</font>;
      <font color=blue>begin</font>
        IN := open_echo(KEYBOARD, OUT);
        <font color=blue>repeat</font>
          ch := getc(IN);
        <font color=blue>until</font> ch = <font color=maroon>'!'</font>;
        writeln;
      <font color=blue>end func</font>;
</pre><p>
  An <tt>'<font color=red>echo_file</font>'</tt> checks also for control-C (KEY_CTL_C). When
  control-C is typed an <tt>'<font color=red>echo_file</font>'</tt> asks if the program should be
  terminated:
</p><pre>
    terminate (y/n)?
</pre><p>
  Aswering <tt>'y'</tt> or <tt>'Y'</tt> is interpreted as <tt>'yes'</tt> and the program
  is terminated with the following message:
</p><pre>
    *** PROGRAM TERMINATED BY USER
</pre><p>
  Any other input removes the question and the program continues
  to read input.
</p><p>  
  Another helpful file type is <tt>'<font color=red>line_file</font>'</tt>, which is defined in the
  library <font color=maroon>"line.s7i"</font>. A <tt>'<font color=red>line_file</font>'</tt> allows to correct the input with
  BACKSPACE until a RETURN (represented with <tt><font color=maroon>'\n'</font></tt>) is encountered.
  In contrast to this editing feature the possibility to edit a line
  of <tt>'STD_IN'</tt> is provided by the operating system. The following
  program uses <tt>'<font color=red>echo_file</font>'</tt> and <tt>'<font color=red>line_file</font>'</tt> to simulate input line
  editing:
</p><pre>
    $ <font color=blue>include</font> <font color=maroon>"seed7_05.s7i"</font>;
      <font color=blue>include</font> <font color=maroon>"keybd.s7i"</font>;
      <font color=blue>include</font> <font color=maroon>"echo.s7i"</font>;
      <font color=blue>include</font> <font color=maroon>"line.s7i"</font>;

    <font color=blue>const</font> <font color=red>proc</font>: main <font color=blue>is func</font>
      <font color=blue>local</font>
        <font color=blue>var</font> <font color=red>char</font>: ch <font color=blue>is</font> <font color=maroon>' '</font>;
      <font color=blue>begin</font>
        IN := open_echo(KEYBOARD, OUT);
        IN := open_line(IN);
        <font color=blue>repeat</font>
          ch := getc(IN);
          write(ch);
        <font color=blue>until</font> ch = <font color=maroon>'!'</font>;
      <font color=blue>end func</font>;
</pre><p>
  This program terminates when a line containing <tt><font color=maroon>'!'</font></tt> is confirmed
  with RETURN.
</p>

<a name="Files_with_line_structure"><h3>8.8 Files with line structure</h3></a>
<p>
  The type <tt>'<font color=red>text</font>'</tt> is a subtype of <tt>'<font color=red>file</font>'</tt> which adds a
  line structure and other features such as scrolling and color.
  The lines and columns of a type <tt>'<font color=red>text</font>'</tt> start with 1
  in the upper left corner and increase downward and rightward.
  The function <tt>'setPos'</tt> sets the current line and column of a
  <tt>'<font color=red>text</font>'</tt>:
</p><pre>
    <font color=blue>const</font> <font color=red>proc</font>: setPos (<font color=blue>inout</font> <font color=red>text</font>: aText, <font color=blue>in</font> <font color=red>integer</font>: line, <font color=blue>in</font> <font color=red>integer</font>: column) <font color=blue>is</font> ...
</pre><p>
  The functions <tt>'setLine'</tt> and <tt>'setColumn'</tt> set just the
  line and column respectively:
</p><pre>
    <font color=blue>const</font> <font color=red>proc</font>: setLine (<font color=blue>inout</font> <font color=red>text</font>: aText, <font color=blue>in</font> <font color=red>integer</font>: line) <font color=blue>is</font> ...

    <font color=blue>const</font> <font color=red>proc</font>: setColumn (<font color=blue>inout</font> <font color=red>text</font>: aText, <font color=blue>in</font> <font color=red>integer</font>: column) <font color=blue>is</font> ...
</pre><p>
  The current line and column of a <tt>'<font color=red>text</font>'</tt> file can be retrieved
  with <tt>'line'</tt> and <tt>'column'</tt>:
</p><pre>
    <font color=blue>const</font> <font color=red>func integer</font>: line (<font color=blue>ref</font> <font color=red>text</font>: aText) <font color=blue>is</font> ...

    <font color=blue>const</font> <font color=red>func integer</font>: column (<font color=blue>ref</font> <font color=red>text</font>: aText) <font color=blue>is</font> ...
</pre><p>
  The current height and width of a <tt>'<font color=red>text</font>'</tt> file can be retrieved
  with <tt>'height'</tt> and <tt>'width'</tt>:
</p><pre>
    <font color=blue>const</font> <font color=red>func integer</font>: height (<font color=blue>ref</font> <font color=red>text</font>: aText) <font color=blue>is</font> ...

    <font color=blue>const</font> <font color=red>func integer</font>: width (<font color=blue>ref</font> <font color=red>text</font>: aText) <font color=blue>is</font> ...
</pre><p>
  To allow random access output to a text screen (or text window)
  the type SCREEN_FILE is defined. The function
</p><pre>
    open(SCREEN_FILE)
</pre><p>
  returns a SCREEN_FILE.
</p>

<a name="Sockets"><h3>8.9 Sockets</h3></a>
<p>
    The library <font color=maroon>"socket.s7i"</font> defines types and functions to
  access sockets. The implementation type for sockets is
  <tt>'<font color=red>socket</font>'</tt>. As interface type <tt>'<font color=red>file</font>'</tt> is used:
</p><pre>
    <font color=blue>var</font> <font color=red>file</font>: clientSocket <font color=blue>is</font> STD_NULL;
</pre><p>
  With <tt>'openInetSocket'</tt> an internet client socket can be opened:
</p><pre>
    clientSocket := openInetSocket(<font color=maroon>"www.google.com"</font>, 80);
</pre><p>
  The function <tt>'openInetSocket'</tt> creates and connects a socket.
  Opening an internet socket at the local host is done with:
</p><pre>
    clientSocket := openInetSocket(1080);
</pre><p>
  Server sockets are supported with the type <tt>'<font color=red>listener</font>'</tt>.
  The type <tt>'<font color=red>listener</font>'</tt> is used directly without interface
  type:
</p><pre>
    <font color=blue>var</font> <font color=red>listener</font>: myListener <font color=blue>is</font> <font color=red>listener</font>.value;
</pre><p>
  The function <tt>'openInetListener'</tt> opens a <tt>'<font color=red>listener</font>'</tt>:
</p><pre>
    myListener := openInetListener(1080);
</pre><p>
  The function <tt>'listen'</tt> is used to listen for incoming socket
  connections of a <tt>'<font color=red>listener</font>'</tt>, and to
  limit the incoming queue:
</p><pre>
    listen(myListener, 10);
</pre><p>
  The function <tt>'accept'</tt> returns the first connected socked
  of the <tt>'<font color=red>listener</font>'</tt>:
</p><pre>
    serverSocket := accept(myListener);
</pre><p></p>

<a name="User_defined_file_types"><h3>8.10 User defined file types</h3></a>
<p>
    In addition to the predefined file types it is often
  necessary to define a new type of file. Such a new file
  has several possibilities:
</p><ul>
    <li><!-- -  -->It could store its contents in a string (not only to be
      faster but also to provide additional file operations)</li>

    <li><!-- -  -->The information can be processed (e.g. to upper case)
      and sent to another file.</li>

    <li><!-- -  -->It could work just like an UNIX utility (Think of
      more, sort, tee, uniq ...)</li>

    <li><!-- -  -->It could provide a file-like interface for something
      with an other interface. (e.g. The contents of a
      directory, or random access I/O to the screen)</li>
</ul><p>
  With the following declaration we define a new file type:
</p><pre>
    <font color=blue>const</font> <font color=red>type</font>: NEW_FILE <font color=blue>is sub</font> <font color=red>null_file</font> <font color=blue>struct</font>
        ...
        <font color=green>(* Local data *)</font>
        ...
      <font color=blue>end struct</font>;
</pre><p>
  It is not necessary to derive the NEW_FILE type directly from
  <tt>'<font color=red>null_file</font>'</tt>. The NEW_FILE type may also be an indirect descendant
  of <tt>'<font color=red>null_file</font>'</tt>. So it is possible to create file type hierarchies.
  The interface implemented by the new file needs also to be specified:
</p><pre>
    type_implements_interface(<font color=red>NEW_FILE</font>, <font color=red>file</font>);
</pre><p>
  The type <tt>'<font color=red>file</font>'</tt> is not the only interface
  type which can be used. There is also the type <tt>'<font color=red>text</font>'</tt> which
  is derived from <tt>'<font color=red>file</font>'</tt>. The type <tt>'<font color=red>text</font>'</tt>
  describes a line oriented file which allows <tt>'setPos'</tt> (which moves the
  current position to the line and column specified) and other functions.
  It is also possible to define new interface types which derive
  from <tt>'<font color=red>file</font>'</tt> or <tt>'<font color=red>text</font>'</tt>.
</p><p>
  As next an open function is needed to generate a new NEW_FILE:
</p><pre>
    <font color=blue>const</font> <font color=red>func file</font>: open_new_file (  <font color=green>(* Parameters *)</font> ) <font color=blue>is func</font>
      <font color=blue>result</font>
        <font color=blue>var</font> <font color=red>file</font>: result <font color=blue>is</font> STD_NULL;
      <font color=blue>begin</font>
        ...
        <font color=green>(* Initialisation of the local data *)</font>
        result := malloc( ... );
        ...
      <font color=blue>end func</font>;
</pre><p>
  Note the usage of the <tt>'malloc'</tt> function to generate a new data
  item. This data item is not freed automatically but if you
  do not open files to often this does not hurt. Now only the
  two basic I/O operations must be defined:
</p><pre>
    <font color=blue>const</font> <font color=red>proc</font>: write (<font color=blue>inout</font> <font color=red>NEW_FILE</font>: new_fil, <font color=blue>in</font> <font color=red>string</font>: stri) <font color=blue>is func</font>
      <font color=blue>begin</font>
        ...
        <font color=green>(* Statements that do the output *)</font>
        ...
      <font color=blue>end func</font>;

    <font color=blue>const</font> <font color=red>proc</font>: gets (<font color=blue>inout</font> <font color=red>NEW_FILE</font>: new_fil, <font color=blue>in</font> <font color=red>integer</font>: leng) <font color=blue>is func</font>
      <font color=blue>result</font>
        <font color=blue>var</font> <font color=red>string</font>: stri <font color=blue>is</font> "";
      <font color=blue>begin</font>
        ...
        <font color=green>(* Statements that do the input *)</font>
        ...
      <font color=blue>end func</font>;
</pre><p>

<a name="Scanning_a_file"><h3>8.11 Scanning a file</h3></a>
<p>
    The I/O concept introduced in the previous chapters separates
  the input of data from its conversion. The <tt>'read'</tt>, <tt>'readln'</tt>,
  <tt>'getwd'</tt> and <tt>'getln'</tt> functions are designed to read whitespace
  separated data elements. When the data elements are not separated
  by whitespace characters this I/O concept is not possible.
  Instead the functions which read from the file need some
  knowledge about the type which they intend to read. Fortunately
  this is a well researched area. The lexical scanners used by
  compilers solve exactly this problem.
</p><p>
  Lexical scanners read symbols from a file and use the concept of
  a current character. A symbol can be a name, a number, a string,
  an operator, a parenthesis or something else. The current
  character is the first character to be processed when scanning a
  symbol. After a scanner has read a symbol the current character
  contains the character just after the symbol. This character
  could be the first character of the next symbol or some
  whitespace character. If the set of symbols is chosen wisely all
  decisions about the type of the symbol and when to stop reading
  characters for a symbol can be done based on the current
  character.
</p><p>
  Every <tt>'<font color=red>file</font>'</tt> contains a <tt>'bufferChar'</tt> variable which is used as
  current character by the scanner functions defined in the
  <font color=maroon>"scanfile.s7i"</font> library. The <font color=maroon>"scanfile.s7i"</font> library contains
  skip... and get... functions. The skip... procedures return void
  and are used to skip input while the get... functions return the
  string of characters they have read. The following basic scanner
  functions are defined in the <font color=maroon>"scanfile.s7i"</font> library:
</p><dl>
    <dt>skipComment</dt>
      <dd>Skips a possibly nested comment from a <tt>'<font color=red>file</font>'</tt>.</dd>
    <dt>getComment</dt>
      <dd>Reads a possibly nested comment from a <tt>'<font color=red>file</font>'</tt>.</dd>
    <dt>skipLineComment</dt>
      <dd>Skips a line comment from a <tt>'<font color=red>file</font>'</tt>.</dd>
    <dt>getLineComment</dt>
      <dd>Reads a line comment from a <tt>'<font color=red>file</font>'</tt>.</dd>
    <dt>getDigits</dt>
      <dd>Reads a sequence of digits from a <tt>'<font color=red>file</font>'</tt>.</dd>
    <dt>getNumber</dt>
      <dd>Reads a numeric literal from a <tt>'<font color=red>file</font>'</tt>.</dd>
    <dt>getNonDigits</dt>
      <dd>Reads a sequence of non digits from a <tt>'<font color=red>file</font>'</tt>.</dd>
    <dt>getQuotedText</dt>
      <dd>Reads a text quoted with " or ' from a <tt>'<font color=red>file</font>'</tt>.</dd>
    <dt>getCharLiteral</dt>
      <dd>Reads a character literal from a <tt>'<font color=red>file</font>'</tt>.</dd>
    <dt>getStringLiteral</dt>
      <dd>Reads a string literal from a <tt>'<font color=red>file</font>'</tt>.</dd>
    <dt>getName</dt>
      <dd>Reads an alphanumeric name from a <tt>'<font color=red>file</font>'</tt>.</dd>
</dl><p>
  Contrary to <tt>'read'</tt> and <tt>'getwd'</tt> basic scanner functions
  do not skip leading whitespace characters. To skip whitespace
  characters one of the following functions can be used:
</p><dl>
    <dt>skipSpace</dt>
      <dd>Skips space characters from a <tt>'<font color=red>file</font>'</tt>.</dd>
    <dt>skipWhiteSpace</dt>
      <dd>Skips whitespace characters from a <tt>'<font color=red>file</font>'</tt>.</dd>
    <dt>getWhiteSpace</dt>
      <dd>Reads whitespace characters from a <tt>'<font color=red>file</font>'</tt>.</dd>
    <dt>getWord</dt>
      <dd>Reads a white space delimited word from a <tt>'<font color=red>file</font>'</tt>.</dd>
    <dt>skipLine</dt>
      <dd>Skips a line from a <tt>'<font color=red>file</font>'</tt>.</dd>
    <dt>getLine</dt>
      <dd>Reads a line from a <tt>'<font color=red>file</font>'</tt>.</dd>
</dl><p>
  The advanced scanner functions do skip whitespace characters
  before reading a symbol:
</p><dl>
    <dt>getSymbolOrComment</dt>
      <dd>Reads a symbol or a comment from a <tt>'<font color=red>file</font>'</tt>.</dd>
    <dt>getSymbol</dt>
      <dd>Reads a symbol from a <tt>'<font color=red>file</font>'</tt>.</dd>
    <dt>getSymbolWithHtmlEntities</dt>
      <dd>Reads a symbol, where html entities are allowed, from a <tt>'<font color=red>file</font>'</tt>.</dd>
    <dt>getHtmlTagSymbolOrComment</dt>
      <dd>Reads a HTML tag, a symbol or a comment from a <tt>'<font color=red>file</font>'</tt>.</dd>
    <dt>skipXmlComment</dt>
      <dd>Skips a XML comment from a <tt>'<font color=red>file</font>'</tt>.</dd>
    <dt>getXmlTagOrContent</dt>
      <dd>Reads a XML/HTML tag or the XML/HTML content text from a <tt>'<font color=red>file</font>'</tt>.</dd>
    <dt>getXmlCharacterReference</dt>
      <dd>Reads a predefined XML entity from a <tt>'<font color=red>file</font>'</tt>.</dd>
    <dt>getXmlTagHeadOrContent</dt>
      <dd>Reads a XML/HTML tag head or a XML/HTML content from a <tt>'<font color=red>file</font>'</tt>.</dd>
    <dt>getSymbolInXmlTag</dt>
      <dd>Reads a symbol which can appear inside a XML/HTML tag from a <tt>'<font color=red>file</font>'</tt>.</dd>
    <dt>getNextXmlAttribute</dt>
      <dd>Reads name and value of an attribute inside a XML tag from <tt>'<font color=red>file</font>'</tt>.</dd>
    <dt>getHtmlAttributeValue</dt>
      <dd>Reads a HTML tag attribute value from a <tt>'<font color=red>file</font>'</tt>.</dd>
    <dt>getNextHtmlAttribute</dt>
      <dd>Reads name and value of an attribute inside a HTML tag from a <tt>'<font color=red>file</font>'</tt>.</dd>
    <dt>getSimpleSymbol</dt>
      <dd>Reads a simple symbol from a <tt>'<font color=red>file</font>'</tt>.</dd>
</dl><p>
  All scanner functions assume that the first character to be
  processed is in <tt>'bufferChar'</tt> and after they are finished the next
  character which should be processed is also in <tt>'bufferChar'</tt>.
  To use scanner functions for a new opened file it is necessary to
  assign the first character to the <tt>'bufferChar'</tt> with:
</p><pre>
    myFile.bufferChar := getc(myFile);
</pre><p>
  In most cases whole files are either processed with normal I/O
  functions or with scanner functions. When normal I/O functions
  need to be combined with scanner functions care has to be taken:
</p><ul>
    <li><!-- -  -->When the last function which read from a file was
      one of <tt>'read'</tt>, <tt>'readln'</tt>, <tt>'getwd'</tt> or <tt>'getln'</tt>
      the <tt>'bufferChar'</tt> already contains the character which
      should be processed next and therefore subsequent scanner
      functions can be used.</li>

    <li><!-- -  -->Other I/O functions like <tt>'getc'</tt> and <tt>'gets'</tt>
      do not assign something to <tt>'bufferChar'</tt>. In this
      case something should be assigned to <tt>'bufferChar'</tt>.</li>

    <li><!-- -  -->Switching back from scanner functions to
      normal I/O functions is best done when the content of
      <tt>'bufferChar'</tt> is known. For example at the end
      of the line.</li>
</ul><p>
  Scanner functions are helpful when it is necessary to read
  numeric input without failing when no digits are present:
</p><pre>
    skipWhiteSpace(IN);
    <font color=blue>if</font> eoln(IN) <font color=blue>then</font>
      writeln("empty input");
    <font color=blue>elsif</font> IN.bufferChar <font color=blue>in</font> {'0' .. '9'} <font color=blue>then</font>
      number := <font color=red>integer</font> <font color=blue>parse</font> getDigits(IN);
      skipLine(IN);
      writeln("number " <& number);
    <font color=blue>else</font>
      stri := getLine(IN);
      writeln("command " <& literal(stri));
    <font color=blue>end if</font>;
</pre><p>
  The function <tt>'getSymbol'</tt> is designed to read Seed7 symbols. When
  the end of the file is reached it returns <tt><font color=maroon>""</font></tt>.
  With <tt>'getSymbol'</tt> name-value pairs can be read:
</p><pre>
    name := getSymbol(inFile);
    <font color=blue>while</font> name <> <font color=maroon>""</font> <font color=blue>do</font>
      <font color=blue>if</font> name <> <font color=maroon>"#"</font> <font color=blue>and</font> getSymbol(inFile) = nt color=maroon>"="/font> <font color=blue>then</font>
        aValue = getSymbol(inFile);
        <font color=blue>if</font> aValue <> <font color=maroon>""</font> <font color=blue>then</font>
          <font color=blue>if</font> aValue[1] = <font color=maroon>'"'</font> <font color=blue>then</font>
            keyValueHash @:= [name] aValue[2 ..];
          <font color=blue>elsif</font> aValue[1] <font color=blue>in</font> {<font color=maroon>'0'</font> .. <font color=maroon>'9'</font>} <font color=blue>then</font>
            keyValueHash @:= [name] aValue;
          <font color=blue>end if</font>;
        <font color=blue>end if</font>;
      <font color=blue>end if</font>;
    <font color=blue>end while</font>;
</pre><p>
  The following loop can be used to process the symbols of a Seed7 program:
</p><pre>
    inFile.bufferChar := getc(inFile);
    currSymbol := getSymbol(inFile);
    <font color=blue>while</font> currSymbol <> <font color=maroon>""</font> <font color=blue>do</font>
      ... process currSymbol ...
      currSymbol := getSymbol(inFile);
    <font color=blue>end while</font>;
</pre><p>
  Whitespace and comments are automatically skipped with the
  function <tt>'getSymbol'</tt>. When comments should also be returned the
  function <tt>'getSymbolOrComment'</tt> can be used. Together with the
  function <tt>'getWhiteSpace'</tt> it is even possible to get the
  whitespace between the symbols:
</p><pre>
    <font color=blue>const</font> <font color=red>func string</font>: processFile (<font color=blue>in</font> <font color=red>string</font>: fileName) <font color=blue>is func</font>
      <font color=blue>result</font>
        <font color=blue>var</font> <font color=red>string</font>: result <font color=blue>is</font> <font color=maroon>""</font>;
      <font color=blue>local</font>
        <font color=blue>var</font> <font color=red>file</font>: inFile <font color=blue>is</font> STD_NULL;
        <font color=blue>var</font> <font color=red>string</font>: currSymbol <font color=blue>is</font> <font color=maroon>""</font>;
      <font color=blue>begin</font>
        inFile := open(fileName, <font color=maroon>"r"</font>);
        <font color=blue>if</font> inFile <> STD_NULL <font color=blue>then</font>
          inFile.bufferChar := getc(inFile);
          result := getWhiteSpace(inFile);
          currSymbol := getSymbolOrComment(inFile);
          <font color=blue>while</font> currSymbol <> <font color=maroon>""</font> <font color=blue>do</font>
            result &:= currSymbol;
            result &:= getWhiteSpace(inFile);
            currSymbol := getSymbolOrComment(inFile);
          <font color=blue>end while</font>;
        <font color=blue>end if</font>;
      <font color=blue>end func</font>;
</pre><p>
  In the example above the function <tt>'processFile'</tt> gathers all
  symbols, whitespace and comments in the string it returns. The
  string returned by <tt>'processFile'</tt> is equivalent to the one
  returned by the function <tt>'getf'</tt>. That way it is easy to test
  the scanner functionality.
</p><p>
  The logic with <tt>'getWhiteSpace'</tt> and <tt>'getSymbolOrComment'</tt> can be used
  to add HTML tags to comments and literals. The following function
  colors comments with green, string and char literals with maroon and
  numeric literals with purple:
</p><pre>
    <font color=blue>const</font> <font color=red>proc</font>: sourceToHtml (<font color=blue>inout</font> <font color=red>file</font>: inFile, <font color=blue>inout</font> <font color=red>file</font>: outFile) <font color=blue>is func</font>
      <font color=blue>local</font>
        <font color=blue>var</font> <font color=red>string</font>: currSymbol <font color=blue>is</font> <font color=maroon>""</font>;
      <font color=blue>begin</font>
        inFile.bufferChar := getc(inFile);
        write(outFile, <font color=maroon>"&lt;pre>\n"</font>);
        write(outFile, getWhiteSpace(inFile));
        currSymbol := getSymbolOrComment(inFile);
        <font color=blue>while</font> currSymbol <> <font color=maroon>""</font> <font color=blue>do</font>
          currSymbol := replace(currSymbol, <font color=maroon>"&amp;"</font>, <font color=maroon>"&amp;amp;"</font>);
          currSymbol := replace(currSymbol, <font color=maroon>"&lt;"</font>, <font color=maroon>"&amp;lt;"</font>);
          <font color=blue>if</font> currSymbol[1] <font color=blue>in</font> {<font color=maroon>'"'</font>, <font color=maroon>'''</font>} <font color=blue>then</font>
            write(outFile, <font color=maroon>"&lt;font color=\"maroon\">"</font>);
            write(outFile, currSymbol);
            write(outFile, <font color=maroon>"&lt;/font>"</font>);
          <font color=blue>elsif</font> currSymbol[1] = <font color=maroon>'#'</font> <font color=blue>or</font> startsWith(currSymbol, <font color=maroon>"(*"</font>) <font color=blue>then</font>
            write(outFile, <font color=maroon>"&lt;font color=\"green\">"</font>);
            write(outFile, currSymbol);
            write(outFile, <font color=maroon>"&lt;/font>"</font>);
          <font color=blue>elsif</font> currSymbol[1] <font color=blue>in</font> digit_char <font color=blue>then</font>
            write(outFile, <font color=maroon>"&lt;font color=\"purple\">"</font>);
            write(outFile, currSymbol);
            write(outFile, <font color=maroon>"&lt;/font>"</font>);
          <font color=blue>else</font>
            write(outFile, currSymbol);
          <font color=blue>end if</font>;
          write(outFile, getWhiteSpace(inFile));
          currSymbol := getSymbolOrComment(inFile);
        <font color=blue>end while</font>;
        write(outFile, <font color=maroon>"&lt;/pre>\n"</font>);
      <font color=blue>end func</font>;
</pre><p>
  The functions <tt>'skipSpace'</tt> and <tt>'skipWhiteSpace'</tt> are defined in
  the <font color=maroon>"scanfile.s7i"</font> library as follows:
</p><pre>
    <font color=blue>const</font> <font color=red>proc</font>: skipSpace (<font color=blue>inout</font> <font color=red>file</font>: inFile) <font color=blue>is func</font>
      <font color=blue>local</font>
        <font color=blue>var</font> <font color=red>char</font>: ch <font color=blue>is</font> <font color=maroon>' '</font>;
      <font color=blue>begin</font>
        ch := inFile.bufferChar;
        <font color=blue>while</font> ch = ' ' <font color=blue>do</font>
          ch := getc(inFile);
        <font color=blue>end while</font>;
        inFile.bufferChar := ch;
      <font color=blue>end func</font>;

    <font color=blue>const</font> <font color=red>proc</font>: skipWhiteSpace (<font color=blue>inout</font> <font color=red>file</font>: inFile) <font color=blue>is func</font>
      <font color=blue>begin</font>
        <font color=blue>while</font> inFile.bufferChar <font color=blue>in</font> white_space_char <font color=blue>do</font>
          inFile.bufferChar := getc(inFile);
        <font color=blue>end while</font>;
      <font color=blue>end func</font>;
</pre><p>
  The functions <tt>'skipComment'</tt> and <tt>'skipLineComment'</tt>, which can be
  used to skip Seed7 comments, are defined as follows:
</p><pre>
    <font color=blue>const</font> <font color=red>proc</font>: skipComment (<font color=blue>inout</font> <font color=red>file</font>: inFile) <font color=blue>is</font> <font color=blue>func</font>
      <font color=blue>local</font>
        <font color=blue>var</font> <font color=red>char</font>: character <font color=blue>is</font> <font color=maroon>' '</font>;
      <font color=blue>begin</font>
        character := getc(inFile);
        <font color=blue>repeat</font>
          <font color=blue>repeat</font>
            <font color=blue>while</font> character <font color=blue>not</font> <font color=blue>in</font> special_comment_char <font color=blue>do</font>
              character := getc(inFile);
            <font color=blue>end</font> <font color=blue>while</font>;
            <font color=blue>if</font> character = <font color=maroon>'('</font> <font color=blue>then</font>
              character := getc(inFile);
              <font color=blue>if</font> character = <font color=maroon>'*'</font> <font color=blue>then</font>
                skipComment(inFile);
                character := getc(inFile);
              <font color=blue>end</font> <font color=blue>if</font>;
            <font color=blue>end</font> <font color=blue>if</font>;
          <font color=blue>until</font> character = <font color=maroon>'*'</font> <font color=blue>or</font> character = EOF;
          <font color=blue>if</font> character <> EOF <font color=blue>then</font>
            character := getc(inFile);
          <font color=blue>end</font> <font color=blue>if</font>;
        <font color=blue>until</font> character = <font color=maroon>')'</font> <font color=blue>or</font> character = EOF;
        <font color=blue>if</font> character = EOF <font color=blue>then</font>
          inFile.bufferChar := EOF;
        <font color=blue>else</font>
          inFile.bufferChar := getc(inFile);
        <font color=blue>end</font> <font color=blue>if</font>;
      <font color=blue>end</font> <font color=blue>func</font>; <font color=green># skipComment</font>

    <font color=blue>const</font> <font color=red>proc</font>: skipLineComment (<font color=blue>inout</font> <font color=red>file</font>: inFile) <font color=blue>is</font> <font color=blue>func</font>
      <font color=blue>local</font>
        <font color=blue>var</font> <font color=red>char</font>: character <font color=blue>is</font> <font color=maroon>' '</font>;
      <font color=blue>begin</font>
        <font color=blue>repeat</font>
          character := getc(inFile);
        <font color=blue>until</font> character = <font color=maroon>'\n'</font> <font color=blue>or</font> character = EOF;
        inFile.bufferChar := character;
      <font color=blue>end</font> <font color=blue>func</font>; <font color=green># skipLineComment</font>
</pre><p>
</p>

<p></p>
<a name="STRUCTURED_SYNTAX_DEFINITION"><h2>9. STRUCTURED SYNTAX DEFINITION</h2></a>
<!-- =============================== -->
<p>
    Most programming languages have only predefined constructs like
  statements and operators. Seed7, on the other hand, additionally
  allows user defined constructs. This chapter introduces the Seed7
  Structured Syntax Description (S7SSD) which is used to define the
  syntax of new constructs. The syntax of predefined constructs is
  also defined with S7SSD.
</p><p>
    The syntax descriptions used in manuals of conventional
  programming languages have no relationship to the approach used by
  the syntax analysis of the corresponding interpreters/compilers.
  S7SSD is a simple syntax description that can be used by humans
  and compilers/interpreters. Although compiler-compilers follow the
  path of machine readable syntax descriptions, they use much more
  complicated syntax and semantic descriptions and do not allow
  users of the language to define new constructs.
</p><p>
    There are different existing notations to specify the syntax of
  programming languages. Backus-Naur Form (BNF) and its variants
  like Extended Backus-Naur Form (EBNF) are examples of such syntax
  specifications. Since it is easier to understand new concepts when
  they are compared to well known concepts, EBNF will be used as a
  base to explain S7SSD.
</p>

<a name="The_Extended_Backus-Naur_Form"><h3>9.1 The Extended Backus-Naur Form</h3></a>
<p>
    As the name says the Extended Backus-Naur Form is an extension
  of BNF. The extension allows the definition of repetitions and
  optional parts without the use of recursion. EBNF has the
  following elements:
</p><ul>
    <li><!-- -  -->Nonterminal symbols consist of lower case letters and
      underline characters.</li>

    <li><!-- -  -->Terminal symbols are quoted strings or names in upper case
      characters which describe unprintable characters (control
      characters).</li>

    <li><!-- -  -->The concatenation of nonterminal and/or terminal symbols is
      described by writing them in sequence.</li>

    <li><!-- -  -->With | two alternatives can be separated.</li>

    <li><!-- -  -->Expressions of the extended Backus-Naur form can be put within
      parentheses ( ... ) .</li>

    <li><!-- -  -->When an expression is optional it is enclosed in square
      brackets [ ... ] .</li>

    <li><!-- -  -->When an expression may be omitted or repeated it is
      enclosed in curly braces { ... } .</li>
</ul></p>
  The syntax of the extended Backus-Naur form can be described in
  extended Backus-Naur form:
</p><pre>
    syntax_description ::=
      { statement } .

    statement ::=
      identifier '::=' expression '.' .

    expression ::=
      term { '|' term } .

    term ::=
      factor { factor } .

    factor ::=
      identifier | string | '(' expression ')' |
      '[' expression ']' | '{' expression '}' .
</pre><p></p>

<a name="The_syntax_of_a_statement"><h3>9.2 The syntax of a statement</h3></a>
<p>
    To explain the Seed7 Structured Syntax Description we design a
  new statement, the <tt>'<font color=blue>loop</font>'</tt> statement. The <tt>'<font color=blue>loop</font>'</tt> statement should
  be similar to <tt>'<font color=blue>while</font>'</tt> and <tt>'<font color=blue>repeat</font>'</tt> loops but instead of having
  the conditional exit at the beginning or at the end, it should
  have a conditional exit in the middle of the loop. This middle
  conditional exit should be part of the <tt>'<font color=blue>loop</font>'</tt> statement. Note that
  the <tt>'<font color=blue>break</font>'</tt> statement, which exists in some programming languages,
  is a statement on its own and is not part of the loop which it
  leaves. Therefore the middle conditional exit should not be
  confused with a <tt>'<font color=blue>break</font>'</tt> statement. An example of the new <tt>'<font color=blue>loop</font>'</tt>
  statement is:
<p><pre>
    <font color=blue>loop</font>
      ch := getc(inFile);
    <font color=blue>until</font> ch = <font color=maroon>'\n'</font> <font color=blue>do</font>
      stri &:= str(ch);
    <font color=blue>end loop</font>;
</pre><p>
  The <tt>'<font color=blue>loop</font>'</tt> example above reads characters from a file and
  concatenates them to a string until the character <tt><font color=maroon>'\n'</font></tt> is read.
  The <tt><font color=maroon>'\n'</font></tt> ends the loop. Hence it is not added to the string.
  An equivalent solution without the usage of the <tt>'<font color=blue>loop</font>'</tt> statement
  would be:
<p><pre>
    <font color=blue>repeat</font>
      ch := getc(inFile);
      <font color=blue>if</font> ch <> <font color=maroon>'\n'</font> <font color=blue>then</font>
        stri &:= str(ch);
      <font color=blue>end if</font>;
    <font color=blue>until</font> ch = <font color=maroon>'\n'</font>;
</pre><p>
  The S7SSD of the <tt>'<font color=blue>loop</font>'</tt> statement is:
</p><pre>
    $ <font color=blue>syntax</font> <font color=red>expr</font>: .loop.().until.().do.().end.loop   <font color=blue>is</font> -> 25;
</pre><p>
  The details of the S7SSD <tt>'<font color=blue>syntax</font>'</tt> definition will be explained
  later. For now we concentrate at the heart of the S7SSD, the
  expression:
</p><pre>
    .loop.().until.().do.().end.loop
</pre><p>
  For the purpose of the syntax description we can just remove the
  dots, which gives:
</p><pre>
     loop () until () do () end loop
</pre><p>
  This are the keywords used in a <tt>'<font color=blue>loop</font>'</tt> statement. The symbol <tt>()</tt>
  acts as placeholder for an expression.
  With EBNF the <tt>'<font color=blue>loop</font>'</tt> statement can be described as:
</p><pre>
    loop_statement ::=
      'loop'
        statement
      'until' expression 'do'
        statement
      'end' 'loop' .
</pre><p>
  An EBNF description may use many nonterminal symbols such as
  <tt>'statement'</tt> or <tt>'expression'</tt>. S7SSD does not distinguish
  between different nonterminal symbols. Instead S7SSD only
  knows one nonterminal symbol: <tt>()</tt>
</p><p>
  Therefore S7SSD cannot distinguish between <tt>'statement'</tt>,
  <tt>'expression'</tt> or something else. At the syntax level any kind of
  expression can by substituted for a S7SSD nonterminal symbol <tt>()</tt>.
  With EBNF it is possible to describe constraints such as the type
  of an expression. S7SSD relies on semantic checks to verify
  such constraints. Given the S7SSD of the <tt>'<font color=blue>loop</font>'</tt> statement an
  expression like
</p><pre>
    <font color=blue>loop</font>
      <font color=maroon>"X"</font>
    <font color=blue>until</font> 1+2 <font color=blue>do</font>
      <font color=red>integer</font>
    <font color=blue>end loop</font>
</pre><p>
  would be legal as it contains the required keywords
</p><pre>
   <font color=blue>loop</font>  <font color=blue>until</font>  <font color=blue>do</font>  <font color=blue>end</font>  <font color=blue>loop</font>
</pre><p>
  and the expressions
</p><pre>
    <font color=maroon>"X"</font>  1+2  <font color=red>integer</font>
</pre><p>
  at the places of the <tt>()</tt> symbols. This is exactly what the syntax
  definition specifies, but it would be not be considered correct
  given the description of the <tt>'<font color=blue>loop</font>'</tt> statement at the beginning of
  the chapter. To determine which types of expressions are allowed
  at the places of the <tt>()</tt> symbol, a semantic definition of the
  <tt>'<font color=blue>loop</font>'</tt> statement is necessary. A semantic definition is just a
  function definition which uses the keywords and parameters from
  the syntax definition. The definition of the <tt>'<font color=blue>loop</font>'</tt> function
  (semantic definition of the <tt>'<font color=blue>loop</font>'</tt> statement) is:
</p><pre>
    <font color=blue>const</font> <font color=red>proc</font>: loop
                  (<font color=blue>in</font> <font color=red>proc</font>: statements1)
                until (<font color=blue>ref</font> <font color=red>func boolean</font>: condition) do
                  (<font color=blue>in</font> <font color=red>proc</font>: statements2)
                end loop <font color=blue>is func</font>
      <font color=blue>local</font>
        <font color=blue>var</font> <font color=red>boolean</font>: exitLoop <font color=blue>is</font> FALSE;
      <font color=blue>begin</font>
        <font color=blue>repeat</font>
          statements1;
          <font color=blue>if not</font> condition <font color=blue>then</font>
            statements2;
          <font color=blue>else</font>
            exitLoop := TRUE;
          <font color=blue>end if</font>;
        <font color=blue>until</font> exitLoop;
      <font color=blue>end func</font>;
</pre><p>
  This definition determines the types of the expressions accepted
  between the keywords. Besides that the semantic definition of the
  <tt>'<font color=blue>loop</font>'</tt> statement is just a normal function definition. Note that
  the sequence of keywords and parameters in the header of this
  function definition is determined by the corresponding syntax
  definition.
</p><p>
  The parameters <tt>'statements1'</tt>, <tt>'condition'</tt> and <tt>'statements2'</tt> are
  closures. A closure is a function without parameters. Function
  types such as <tt>'<font color=red>proc</font>'</tt> or <tt>'<font color=red>func boolean</font>'</tt> are used as type of formal
  closure parameters. An expression with the correct type is allowed
  as actual closure parameter. This actual parameter expression is
  not evaluated when the function is called. Instead the closure
  expression is evaluated every time the formal closure parameter
  is used. This way <tt>'statements1'</tt>, <tt>'condition'</tt> and <tt>'statements2'</tt> are
  not executed when the <tt>'<font color=blue>loop</font>'</tt> function is called. Inside the body
  of the <tt>'<font color=blue>loop</font>'</tt> function the closures are executed at some places.
</p><p>
  The <tt>'<font color=blue>loop</font>'</tt> function uses a <tt>'<font color=blue>repeat</font>'</tt> and an <tt>'<font color=blue>if</font>'</tt> statement to
  implement the desired behaviour. When necessary the closures are
  executed several times.
</p><p>
  For the <tt>'<font color=blue>loop</font>'</tt> example with the semantic errors (see above) we
  would get an error message like:
</p><pre>
    *** chkloop.sd7(35):51: Match for {loop "X" until {1 + 2 } do integer end loop } failed
</pre><p></p>

<a name="Priority_and_associativity"><h3>9.3 Priority and associativity</h3></a>
<p>
    When a syntax construct has parameters before the first symbol
  or after the last symbol the priority and the associativity of the
  construct are significant. Constructs with stronger priority bind
  their parameters earlier than constructs with weaker priority. The
  priority is described by a natural number (inclusive 0). The
  strongest priority is 0. Weaker priorities are described by larger
  numbers. What bind means is can be explained with an example:
</p><pre>
                                       =
    A + B = C * D                    /   \
                                    /     \
    * priority  6                  +       *
    + priority  7                /   \   /   \
    = priority 12               A     B C     D
</pre><p>
  First the * takes its parameters, then the + and at last the =
  follows.
</p><p>
  The associativity describes, in which order constructs with equal
  priority bind their parameters. For example
</p><pre>
    A - B - C
</pre><p>
  can be interpreted in two ways:
</p><pre>
    (A - B) - C    or   A - (B - C)
</pre><p>
  The first interpretation is usually preferred by mathematicians
  and is described with the associativity -> . Generally four
  associativities are possible:</p><pre>
                                                   Symbol

    Binding from left to right                       ->

    Binding from right to left                       &lt;-

    Neither the left nor the right parameter
    are allowed to have the same priority            &lt;->

    At the left side there is a binding from
    left to right and at the right side there
    is a binding from right to left                 ->&lt;-
</pre><p>
  The last two possibilities give no legal interpretation in the
  subtraction example. The third kind of associativity ( &lt;-> ) is
  used by the equal operator ( = ) of Pascal because there a
  expression like
</p><pre>
    A = B = C
</pre><p>
  is not legal.
</p><p>
  There is a second way to describe the associativity. The
  associativity describes if an operand must have a stronger
  priority than the priority of the operator. For example:
</p><pre>
                             -                     7
    A - B - C              /   \                 /   \
                          /     \           &lt;=7 /     \ &lt;7
    - priority 7 ->      /       \             /       \
                        -         C           7         0
                      /   \                 /   \
                     /     \           &lt;=7 /     \ &lt;7
                    /       \             /       \
                   A         B           0         0
</pre><p>
  The numbers in the nodes of the right tree show the priority of
  each sub expression (sub tree). With &lt; and &lt;= the required
  condition for the priority of an operand is described. An
  interpretation is legal if all this conditions are met. If there
  are more than one legal interpretations or no legal
  interpretation the expression is illegal.
</p><p>
  Table for the possibilities of associativity:
</p><pre>
    +---------------+------------------------------+
    | associativity |     The priority of the      |
    +---------------+--------------+---------------+
    |               | left operand | right operand |
    |               |    must be   |    must be    |
    +---------------+--------------+---------------+
    |      ->       |      &lt;=      |      &lt;        |
    |      &lt;-       |      &lt;       |      &lt;=       |
    |      &lt;->      |      &lt;       |      &lt;        |
    |     ->&lt;-      |      &lt;=      |      &lt;=       |
    +---------------+--------------+---------------+
    |               |  than that of the operator   |
    +---------------+------------------------------+
</pre><p>
  The parameter before the operator symbol is called left operand.
  The parameter after the last symbol of a construct is called
  right operand. In case of normal operators the last symbol of a
  construct and the operator symbol are identical. If this is not
  the case there is a third kind of operand. Between the operator
  symbol and the last symbol of a construct are the middle operands.
  Middle operands can have any priority.
</p>

<a name="The_syntax_of_operators"><h3>9.4 The syntax of operators</h3></a>
<p>
    A syntax definition specifies the way a usage of a statement
  or operator must be written. For example a call of the
  <tt>'<font color=blue>not</font>'</tt> operator looks like:
</p><pre>
    <font color=blue>not</font> okay
</pre><p>
  To describe the syntax of the <tt>'<font color=blue>not</font>'</tt> operator we write:
</p><pre>
    $ <font color=blue>syntax</font> <font color=red>expr</font>: .not.() <font color=blue>is</font> &lt;- 13;
</pre><p>
  This means that a <tt>'<font color=blue>not</font>'</tt> expression is constructed with the
  symbol <tt>'<font color=blue>not</font>'</tt> followed by a parameter. The place of the
  parameter is marked with the () sign. The syntax description
  contains no information about the types of the parameters. At
  the syntax level a parameter may be anything. With <tt>'&lt;-'</tt> the
  associativity of the <tt>'<font color=blue>not</font>'</tt> operator is specified as right
  associative. This means that the right operand is allowed to
  have the same priority as the operator symbol. So the
  expression
</p><pre>
    <font color=blue>not not</font> okay
</pre><p>
  is legal and means
</p><pre>
    <font color=blue>not</font> (<font color=blue>not</font> okay)
</pre><p>
  When the associativity of the <tt>'<font color=blue>not</font>'</tt> operator is specified with
  <tt>'->'</tt> instead of <tt>'&lt;-'</tt> the <tt>'<font color=blue>not not</font>'</tt> expression above is not legal.
  With 13 the priority of the whole <tt>'<font color=blue>not</font>'</tt> operator is determined.
  As convention priorities from 1 to 20 are used by operators
  and priority 25 is used by statements. Arithmetic operators
  have priorities from 1 to 11 and comparisons have priority 12.
</p><p>
  To define the <tt>'<font color=blue>not</font>'</tt> operator completely there must be also
  a semantic definition which is as follows:
</p><pre>
    <font color=blue>const</font> <font color=red>func boolean</font>: not (<font color=blue>in</font> <font color=red>boolean</font>: aBool) <font color=blue>is func</font>
      <font color=blue>result</font>
        <font color=blue>var</font> <font color=red>boolean</font>: result <font color=blue>is</font> FALSE;
      <font color=blue>begin</font>
        <font color=blue>if</font> aBool <font color=blue>then</font>
          result := FALSE;
        <font color=blue>else</font>
          result := TRUE;
        <font color=blue>end if</font>;
      <font color=blue>end func</font>;
</pre><p>
  In the declaration the <tt>'<font color=blue>not</font>'</tt> operator is written exactly
  in the same way it is written when it is called. The syntax
  definition is used at both places: declaration and call.
  The syntax and semantic declarations define precisely how
  the <tt>'<font color=blue>not</font>'</tt> operator works.
</p><p>
    As next example we try an infix operator like the <tt>'<font color=blue>and</font>'</tt> operator.
  A call of the <tt>'<font color=blue>and</font>'</tt> operator may look like:
</p><pre>
    okay <font color=blue>and not</font> error
</pre><p>
  To describe the syntax of the <tt>'<font color=blue>and</font>'</tt> operator we write:
</p><pre>
    $ <font color=blue>syntax</font> <font color=red>expr</font>: .().and.() <font color=blue>is</font>    -> 14;
</pre><p>
  This means that an <tt>'<font color=blue>and</font>'</tt> expression is constructed with the
  symbol <tt>'<font color=blue>and</font>'</tt> surrounded by parameters. The <tt>'->'</tt> defines the
  <tt>'<font color=blue>and</font>'</tt> operator as left associative. This means that an expression
  like
</p><pre>
    A <font color=blue>and</font> B <font color=blue>and</font> C
</pre><p>
  is interpreted as
</p><pre>
    (A <font color=blue>and</font> B) <font color=blue>and</font></font> C
</pre><p>
  With 14 the priority of the whole <tt>'<font color=blue>and</font>'</tt> operator is determined.
  Since priority 14 is weaker than the priority of the <tt>'<font color=blue>not</font>'</tt> operator
  which is 13 the example expression is evaluated as:
</p><pre>
    okay <font color=blue>and</font> (<font color=blue>not</font> error)
</pre><p>
  Note that the expression
</p><pre>
    okay <font color=blue>and not</font> error
</pre><p>
  makes no sense when the <tt>'<font color=blue>and</font>'</tt> operator has priority 12 instead of 14.
</p><p>
  S7SSD treats everything as operator description. Operators
  have priority and associativity. The priority and associativity
  determine in which succession S7SSD syntax rules get applied.
  To explain priority and associativity we use the basic arithmetic
  operations (+,-,*,/). To describe them with EBNF we can write:
</p><pre>
    factor :=
      number | name .

    expression_5 ::=
      factor |
      ( '+' expression_5 ) |
      ( '-' expression_5 ) .

    expression_6 ::=
      expression_5 |
      ( expression_6 '*' expression_7 ) |
      ( expression_6 '/' expression_7 ) .

    expression_7 ::=
      expression_6 |
      ( expression_7 '+' expression_6 ) |
      ( expression_7 '-' expression_6 ) .
</pre><p>
  This describes the following things:
</p><ul>
    <li><!-- -  -->The operators have different priorities:<ul>
      <li><!-- -  -->Plus and minus signs are executed first</li>
      <li><!-- -  -->Multiplication and division are executed second.</li>
      <li><!-- -  -->Addition and subtraction are executed last.</li></ul></li>

    <li><!-- -  -->These priorities are exactly what we expect from an
      arithmetic expression.</li>

    <li><!-- -  -->Additionally we see that ++2 is allowed and interpreted as
      +(+(2)) which means that the plus sign is a right-associative
      operator.</li>

    <li><!-- -  -->We can also see that a*b*c is allowed and interpreted as
      (a*b)*c which means that the multiplication is a
      left-associative operator.</li>
</ul></p>
  All this things can also be described with S7SSD:
</p><pre>
    $ <font color=blue>syntax</font> <font color=red>expr</font>: . + .()      is &lt;-  5;
    $ <font color=blue>syntax</font> <font color=red>expr</font>: . - .()      is &lt;-  5;
    $ <font color=blue>syntax</font> <font color=red>expr</font>: .(). * .()   is  -> 6;
    $ <font color=blue>syntax</font> <font color=red>expr</font>: .(). / .()   is  -> 6;
    $ <font color=blue>syntax</font> <font color=red>expr</font>: .(). + .()   is  -> 7;
    $ <font color=blue>syntax</font> <font color=red>expr</font>: .(). - .()   is  -> 7;
</pre><p>
  As we can see S7SSD is shorter as the description with EBNF.
  A syntax statement is explained as follows:
</p><ul>
    <li><!-- -  -->The $ is used to introduce all hard coded statements.</li>

    <li><!-- -  -->The keyword <tt>'<font color=blue>syntax</font>'</tt> introduces a structured syntax
      description.</li>

    <li><!-- -  -->The result of the recognized expression will have
      the type <tt>'<font color=red>expr</font>'</tt>. The type <tt>'<font color=red>expr</font>'</tt> is used between the syntax
      and the semantic analysis. The type <tt>'<font color=red>expr</font>'</tt> describes
      expressions which are syntactically analyzed but not
      semantically analyzed. After the semantic analysis (and
      during the runtime) the type <tt>'<font color=red>expr</font>'</tt> is not used.</li>

    <li><!-- -  -->The colon ':' is used as separator between type and syntax
      description.</li>

    <li><!-- -  -->A dot expression like <tt>'.(). * .()'</tt> is introduced (as can
      probably be guessed by the name) with a dot. For the purpose
      of the syntax description we can just remove the dots in
      our mind: <tt>'() * ()'</tt></li>

    <li><!-- -  -->The symbol <tt>'<font color=blue>is</font>'</tt> is used in all Seed7 declarations as
      separator between the name and the value.</li>

    <li><!-- -  -->The associativity is described with one of the symbols
      <tt>-></tt> (left-associative), <tt>&lt;-</tt> (right-associative),
      <tt>&lt;-></tt> (not associative) and <tt>->&lt;-</tt> (both associativitys).
      When there are no left or right operands, as it is the case
      for the <tt>'<font color=blue>loop</font>'</tt> statement, the associativity is irrelevant.</li>

    <li><!-- -  -->Finally the priority of the syntax construct is defined with
      a integer literal like <tt>'6'</tt>. The priority <tt>'6'</tt> is used for the
      operators <tt>'*'</tt>, <tt>'/'</tt>, <tt>'<font color=blue>div</font>'</tt>, <tt>'<font color=blue>rem</font>'</tt>, <tt>'<font color=blue>mdiv</font>'</tt> and <tt>'<font color=blue>mod</font>'</tt>.</li>
</ul><p></p>

<a name="Syntax_of_predefined_statements"><h3>9.5 Syntax of predefined statements</h3></a>
<p>
    Predefined statements can also be defined with S7SSD.
  E.g.: The <tt>'<font color=blue>while</font>'</tt> statement. A use of the <tt>'<font color=blue>while</font>'</tt> statement is:
</p><pre>
    <font color=blue>while</font> element_index > 0 <font color=blue>and</font> okay <font color=blue>do</font>
      processElement;
      write(<font color=maroon>"."</font>);
    <font color=blue>end while</font>;
</pre><p>
  To describe the syntax of the <tt>'<font color=blue>while</font>'</tt> statement we write:
</p><pre>
    $ <font color=blue>syntax</font> <font color=red>expr</font>: .while.().do.().end.while <font color=blue>is</font> -> 25;
</pre><p>
  This means that the <tt>'<font color=blue>while</font>'</tt> statement is an expression with the
  symbols <tt>'<font color=blue>while</font>'</tt>, <tt>'<font color=blue>do</font>'</tt>, <tt>'<font color=blue>end</font>'</tt> and <tt>'<font color=blue>while</font>'</tt>. With <tt>'->'</tt> the
  associativity of the <tt>'<font color=blue>while</font>'</tt> statement is specified as left
  associative. The associativity has no meaning for the
  <tt>'<font color=blue>while</font>'</tt> statement since there is no parameter before the first
  symbol or after the last symbol. The priority of the whole
  <tt>'<font color=blue>while</font>'</tt> statement is 25.
</p><p>
  The semantic definition of the <tt>'<font color=blue>while</font>'</tt> statement is as follows:
</p><pre>
    <font color=blue>const</font> <font color=red>proc</font>: while (<font color=blue>ref</font> func <font color=red>boolean</font>: condition) do
        (<font color=blue>ref</font> <font color=red>proc</font>: statement) end while <font color=blue>is func</font>
      <font color=blue>begin</font>
        <font color=blue>if</font> condition <font color=blue>then</font>
          statement;
          <font color=blue>while</font> condition <font color=blue>do</font>
            statement;
          <font color=blue>end while</font>;
        <font color=blue>end if</font>;
      <font color=blue>end func</font>;
</pre><p>
  The syntax definition is used for the declaration and for the call.
  This declaration defines precisely how the <tt>'<font color=blue>while</font>'</tt> statement
  works. It is based on the <tt>'<font color=blue>if</font>'</tt> statement and uses recursion
  to emulate the repetition of the loop body.
  Another example for a syntax description is the
  <tt>'<font color=blue>repeat</font>'</tt> statement
</p><pre>
    <font color=blue>repeat</font>
      processElement;
      write(<font color=maroon>"."</font>);
    <font color=blue>until</font> element_index = 0 <font color=blue>or not</font> okay;
</pre><p>
  which has the following syntax description:
</p><pre>
    $ <font color=blue>syntax</font> <font color=red>expr</font>: .repeat.().until.() <font color=blue>is</font> -> 25;
</pre><p>
  This means that the <tt>'<font color=blue>repeat</font>'</tt> statement is an expression with
  the symbols <tt>'<font color=blue>repeat</font>'</tt> and <tt>'<font color=blue>until</font>'</tt> and a parameter between
  <tt>'<font color=blue>repeat</font>'</tt> and <tt>'<font color=blue>until</font>'</tt> and after <tt>'<font color=blue>until</font>'</tt>. With 25 the priority
  of the whole <tt>'<font color=blue>repeat</font>'</tt> statement is determined. With <tt>'->'</tt> the
  associativity of the <tt>'<font color=blue>repeat</font>'</tt> statement is specified as left
  associative. This allows priorities from 0 to 24 for the
  parameter after <tt>'<font color=blue>until</font>'</tt>. Since statements have priority 25
  it is not possible to write a statement direct behind <tt>'<font color=blue>until</font>'</tt>.
</p><p>
  A simple <tt>'<font color=blue>if</font>'</tt> statement, without
  <tt>'<font color=blue>elsif</font>'</tt> part, is the next example.
  A usage of this <tt>'<font color=blue>if</font>'</tt> statement might be:
</p><pre>
    <font color=blue>if</font> okay <font color=blue>then</font>
      writeln(<font color=maroon>"okay"</font>);
    <font color=blue>else</font>
      writeln(<font color=maroon>"not okay"</font>);
    <font color=blue>end if</font>;
</pre><p>
  As syntax description we use
</p><pre>
    $ <font color=blue>syntax</font> <font color=red>expr</font>: .if.().then.().end.if <font color=blue>is</font>            -> 25;
    $ <font color=blue>syntax</font> <font color=red>expr</font>: .if.().then.().else.().end.if <font color=blue>is</font>    -> 25;
</pre><p>
  Note that this description allows <tt>'<font color=blue>if</font>'</tt> statements with and
  without <tt>'<font color=blue>else</font>'</tt> parts. As semantic description we use
</p><pre>
    <font color=blue>const</font> <font color=red>proc</font>: if (<font color=blue>in</font> <font color=red>boolean</font>: condition) then
                  (<font color=blue>in</font> <font color=red>proc</font>: statement)
                end if <font color=blue>is func</font>
      <font color=blue>begin</font>
        <font color=blue>case</font> condition <font color=blue>of</font>
          <font color=blue>when</font> {TRUE}: statement;
        <font color=blue>end case</font>;
      <font color=blue>end func</font>;

    <font color=blue>const</font> proc: if (<font color=blue>in</font> <font color=red>boolean</font>: condition) then
                  (<font color=blue>in</font> <font color=red>proc</font>: statement1)
                else
                  (<font color=blue>in</font> <font color=red>proc</font>: statement2)
                end if <font color=blue>is func</font>
      <font color=blue>begin</font>
        <font color=blue>case</font> condition of
          <font color=blue>when</font> {TRUE}:  statement1;
          <font color=blue>when</font> {FALSE}: statement2;
        <font color=blue>end case</font>;
      <font color=blue>end func</font>;
</pre><p>
  The two forms of the <tt>'<font color=blue>if</font>'</tt> statement are based on the
  <tt>'<font color=blue>case</font>'</tt> statement. A more complex <tt>'<font color=blue>if</font>'</tt> statement with <tt>'<font color=blue>elsif</font>'</tt>
  parts can be:
</p><pre>
    <font color=blue>if</font> number &lt; 0 <font color=blue>then</font>
      write(<font color=maroon>"less"</font>);
    <font color=blue>elsif</font> number = 0 <font color=blue>then</font>
      write(<font color=maroon>"equal"</font>);
    <font color=blue>else</font>
      write(<font color=maroon>"greater"</font>);
    <font color=blue>end if</font>;
</pre><p>
  How to define the syntax and the semantic for this statement
  is described in the next chapter.
</p>

<a name="Advanced_syntax_definitions"><h3>9.6 Advanced syntax definitions</h3></a>
<p>
  When we want to use some special syntax which should be only
  allowed at some place we do the following:
</p><ul>
    <li><!-- -  -->Define the special syntax with S7SSD in a way that does not
      contradict with the rest of the syntax definitions.</li>

    <li><!-- -  -->Use semantic definitions to make sure that this syntax
      construct can only be used at the place desired.</li>
</ul><p>
  The EBNF of the <tt>'<font color=blue>if</font>'</tt> statement with <tt>'<font color=blue>elsif</font>'</tt> parts is:
</p><pre>
    if_statement ::=
      'if' expression 'then'
        statement
      { 'elsif' expression 'then'
        statement }
      [ 'else'
        statement ]
      'end' 'if' .
</pre><p>
  The S7SSD of this <tt>'<font color=blue>if</font>'</tt> statement is:
</p><pre>
    $ <font color=blue>syntax</font> <font color=red>expr</font> : .if.().then.().end.if           <font color=blue>is</font> -> 25;
    $ <font color=blue>syntax</font> <font color=red>expr</font> : .if.().then.().().end.if        <font color=blue>is</font> -> 25;

    $ <font color=blue>syntax</font> <font color=red>expr</font> : .elsif.().then.()               <font color=blue>is</font> <- 60;
    $ <font color=blue>syntax</font> <font color=red>expr</font> : .elsif.().then.().()            <font color=blue>is</font> <- 60;
    $ <font color=blue>syntax</font> <font color=red>expr</font> : .else.()                        <font color=blue>is</font> <- 60;
</pre><p>
  Instead of one rule (as EBNF does) the rule is broken into several
  S7SSD rules. This is necessary because S7SSD does not support the
  [ ] and { } notations. They are not supported for good reasons:
  They complicate the parameter lists and they are also not so easy
  to implement. On the other hand, the BNF like rules of S7SSD
  lead to semantic constructs which are easy to parse and easy to
  compile. The broken down S7SSD rules of the <tt>'<font color=blue>if</font>'</tt> statement
  corresponds to the following EBNF description:
</p><pre>
    if_statement ::=
      'if' expression 'then'
        statement
      'end' 'if' .

    if_statement ::=
      'if' expression 'then'
        statement
        elseif_or_else_part
      'end' 'if' .

    elseif_or_else_part ::=
      'elsif' expression 'then'
        statement .

    elseif_or_else_part ::=
      'elsif' expression 'then'
        statement
        elseif_or_else_part .

    elseif_or_else_part ::=
      'else'
        statement .
</pre><p>
  Since S7SSD uses only one nonterminal symbol <tt>'()'</tt> it is the job
  of the semantic level to make sure that only the right nonterminal
  symbol can be used. This is done by introducing the type
  <tt>'<font color=red>ELSIF_PROC</font>'</tt> (which corresponds to the nonterminal symbol
  <tt>'elseif_or_else_part'</tt> of the EBNF) and the type
  <tt>'<font color=red>ELSIF_RESULT</font>'</tt> (which is the result
  of the <tt>'<font color=red>ELSIF_PROC</font>'</tt>).
</p><p>
  Normally a syntax declaration can be used in many semantic
  declarations. E.g.: The syntax of the <tt>'+'</tt> operator is defined
  once and the semantic of the <tt>'+'</tt> operator is defined for the types
  <tt>'<font color=red>integer</font>'</tt>, <tt>'<font color=red>bigInteger</font>'</tt>, <tt>'<font color=red>float</font>'</tt>, <tt>'<font color=red>complex</font>'</tt>, ... This possibility
  is not needed for the <tt>'<font color=blue>if</font>'</tt> statement. For each of the five
  S7SSD syntax rules of the <tt>'<font color=blue>if</font>'</tt> statement just one
  corresponding semantic declaration is done:
</p><pre>
    <font color=green># Semantic for the syntax: .if.().then.().end.if</font>
    <font color=blue>const</font> <font color=red>proc</font>: if (<font color=blue>in</font> <font color=red>boolean</font>: condition) then
                  (<font color=blue>in</font> <font color=red>proc</font>: statements)
                end if                                    <font color=blue>is func</font>
      <font color=blue>begin</font>
        <font color=blue>case</font> condition <font color=blue>of</font>
          <font color=blue>when</font> {TRUE}: statements;
        <font color=blue>end case</font>;
      <font color=blue>end func</font>;

    <font color=green># Semantic for the syntax: .if.().then.().().end.if</font>
    <font color=blue>const</font> <font color=red>proc</font>: if (<font color=blue>in</font> <font color=red>boolean</font>: condition) then
                  (<font color=blue>in</font> <font color=red>proc</font>: statements)
                (<font color=blue>in</font> <font color=red>ELSIF_PROC</font>: elsifPart)
                end if                                    <font color=blue>is func</font>
      <font color=blue>begin</font>
        <font color=blue>case</font> condition <font color=blue>of</font>
          <font color=blue>when</font> {TRUE}: statements;
          <font color=blue>when</font> {FALSE}: elsifPart;
        <font color=blue>end case</font>;
      <font color=blue>end func</font>;

    <font color=green># Semantic for the syntax: .elsif.().then.()</font>
    <font color=blue>const</font> <font color=red>ELSIF_PROC</font>: elsif (<font color=blue>in</font> <font color=red>boolean</font>: condition) then
                        (<font color=blue>in</font> <font color=red>proc</font>: statements)             <font color=blue>is func</font>
      <font color=blue>begin</font>
        <font color=blue>case</font> condition <font color=blue>of</font>
          <font color=blue>when</font> {TRUE}: statements;
        <font color=blue>end case</font>;
      <font color=blue>end func</font>;

    <font color=green># Semantic for the syntax: .elsif.().then.().()</font>
    <font color=blue>const</font> <font color=red>ELSIF_PROC</font>: elsif (<font color=blue>in</font> <font color=red>boolean</font>: condition) then
                        (<font color=blue>in</font> <font color=red>proc</font>: statements)
                      (<font color=blue>in</font> <font color=red>ELSIF_PROC</font>: elsifPart)          <font color=blue>is func</font>
      <font color=blue>begin</font>
        <font color=blue>case</font> condition <font color=blue>of</font>
          <font color=blue>when</font> {TRUE}: statements;
          <font color=blue>when</font> {FALSE}: elsifPart;
        <font color=blue>end case</font>;
      <font color=blue>end func</font>;

    <font color=green># Semantic for the syntax: .else.()</font>
    <font color=blue>const</font> <font color=red>ELSIF_PROC</font>: else
                        (<font color=blue>ref</font> <font color=red>void</font>: voidValue)        <font color=blue>is</font> ELSIF_EMPTY;
</pre><p>
  Since no other functions of type <tt>'<font color=red>ELSIF_PROC</font>'</tt> are defined only
  legal <tt>'<font color=blue>if</font>'</tt> statements can be written.
</p>

<a name="Comparison_of_EBNF_and_S7SSD"><h3>9.7 Comparison of EBNF and S7SSD</h3></a>
<p>
  In the S7SSD of the <tt>'<font color=blue>loop</font>'</tt> statement
</p><pre>
    $ <font color=blue>syntax</font> <font color=red>expr</font>: .loop.().until.().do.().end.loop <font color=blue>is</font> -> 25;
</pre><p>
  are no nonterminal expressions <tt>'()'</tt> before the first keyword or
  after the last keyword. Therefore the associativity does not play
  any role. The nonterminal expressions <tt>'()'</tt> of the <tt>'<font color=blue>loop</font>'</tt> statement
  are all surrounded by keywords and therefore they can have any
  priority. As priority of the <tt>'<font color=blue>loop</font>'</tt> 25 is chosen just because
  most other statements have also priority 25. The assignments
  (:= +:= *:= ...) have priority 20 and all operators used in
  arithmetic, boolean and string expressions have priorities less
  than 20. BTW: The semicolon operator (;) is defined with the
  priority 50. Operators with a priority of 0 get their parameters
  before operators with priority 1 and so on.
</p><p>
  The corresponding EBNF description of the <tt>'<font color=blue>loop</font>'</tt> statement would
  be:
</p><pre>
    expression_25 ::=
      'loop'
        expression_127
      'until' expression_127 'do'
        expression_127
      'end' 'loop' .
</pre><p>
  We must keep in mind that alternative rules for expression_25 are
  also possible and that for every priority level a rule like
</p><pre>
    expression_127 ::= expression_126 .
</pre><p>
  is defined. Additionally the following rules are defined:
</p><pre>
    expression_0 ::= token | parentheses_expression |
      call_expression | dot_expression .

    token ::=
      identifier | literal .

    parentheses_expression ::=
      '(' expression_127 ')' .

    call_expression ::=
      expression_127 [ '('
      [ expression_127 { ',' expression_127 } ]
      ')' ] .

    dot_expression ::=
      [ '.' ] call_expression { '.' call_expression } .
</pre><p>
  There are some things which are out of the scope of S7SSD.
  The syntax of tokens (whitespace, comments, identifiers and
  literals) and expressions (parentheses, function calls and dot
  expressions) is hard coded. The hard coded constructs are described
  in <a href="tokens.htm">chapter 10 (Tokens)</a> and <a href="expr.htm">chapter 11 (Expressions)</a>.
</p><p>
  For the reasons mentioned above it is not possible to transform
  every EBNF syntax description into S7SSD. Transforming S7SSD
  descriptions to EBNF is always possible.
</p><p>
  The advantage of S7SSD lies in its simplicity and that a fast
  automated syntax recognition algorithm can be easily implemented.
  It is exactly the combination of hard coded syntax recognition and
  flexible syntax rules that make it successful.
</p>

<p></p>
<a name="TOKENS"><h2>10. TOKENS</h2></a>
<!-- ========= -->
<p>
    A program consists of a sequence of tokens which may be delimited
  by white space. There are two types of tokens:
</p><pre>
    identifiers
    literals
</pre><p>
  Syntax:
</p><pre>
    program ::=
      { white_space | token } .

    token ::=
      identifier | literal .
</pre><p></p>

<a name="White_space"><h3>10.1 White space</h3></a>
<p>
    There are three types of white space
</p><pre>
    spaces
    comments
    line comments
</pre><p>
  White space always terminates a preceding token. Some white
  space is required to separate otherwise adjacent tokens.
</p><p>
  Syntax:
</p><pre>
    white_space ::=
      ( space | comment | line_comment )
      { space | comment | line_comment } .
</pre><p></p>

<a name="Spaces"><h4>10.1.1 Spaces</h4></a>
<p>
    There are several types of space characters which are ignored
  except as they separate tokens:
</p><pre>
    blanks, horizontal tabs, carriage returns and new lines.
</pre><p>
  Syntax:
</p><pre>
    space ::=
      ' ' | TAB | CR | NL .
</pre><p></p>

<a name="Comments"><h4>10.1.2 Comments</h4></a>
<p>
    Comments are introduced with the characters <font color=green>(* and are
  terminated with the characters *)</font> . For example:
</p><pre>
    <font color=green>(* This is a comment *)</font>
</pre><p>
  Comment nesting is allowed so it is possible to comment out
  larger sections of the program which can also include comments.
  Comments cannot occur within string or character literals.
</p><p>
  Syntax:
</p><pre>
    comment ::=
      '(*' { any_character } '*)' .
</pre><p></p>

<a name="Line_comments"><h4>10.1.3 Line comments</h4></a>
<p>
    Line comments are introduced with the character <font color=green># and are
  terminated with the end of the line.</font><br>
  For example:
</p><pre>
    <font color=green># This is a comment</font>
</pre><p>
  Comments cannot occur within string, character or numerical
  literals.
</p><p>
  Syntax:
</p><pre>
    line_comment ::=
      '#' { any_character } NL .
</pre><p></p>

<a name="Identifiers"><h3>10.2 Identifiers</h3></a>
<p>
    There are three types of identifiers
</p><pre>
    name identifiers
    special identifiers
    parenthesis
</pre><p>
  Identifiers can be written adjacent except that between two
  name identifiers and between two special identifiers white space
  must be used to separate them.
</p><p>
  Syntax:
</p><pre>
    identifier ::=
      name_identifier | special_identifier | parenthesis .
</pre><p></p>

<a name="Name_identifiers"><h4>10.2.1 Name identifiers</h4></a>
<p>
    A name identifier is a sequence of letters, digits and
  underscores ( _ ). The first character must be a letter or an
  underscore. Examples of name identifiers are:
</p><pre>
    NUMBER  integer  const  if  UPPER_LIMIT  LowerLimit  x5  _end
</pre><p>
  Upper and lower case letters are different. Name identifiers
  may have any length and all characters are significant. The
  name identifier is terminated with a character which is
  neither a letter (or _ ) nor a digit. The terminating
  character is not part of the name identifier.
</p><p>
  Syntax:
</p><pre>
    name_identifier ::=
      ( letter | underscore ) { letter | digit | underscore } .

    letter ::=
      upper_case_letter | lower_case_letter .

    upper_case_letter ::=
      'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' |
      'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' |
      'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' .

    lower_case_letter ::=
      'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' |
      'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' |
      'u' | 'v' | 'w' | 'x' | 'y' | 'z' .

    digit ::=
      '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' .

    underscore ::=
      '_' .
</pre><p></p>

<a name="Special_identifiers"><h4>10.2.2 Special identifiers</h4></a>
<p>
    A special identifier is a sequence of special characters.
  Examples of special identifiers are:
</p><pre>
    +  :=  &lt;=  *  ->  ,  &
</pre><p>
  Here is a list of all special characters:
</p><pre>
    ! $ % & * + , - . / : ; &lt; = > ? @ \ ^ ` | ~
</pre><p>
  Special identifiers may have any length and all characters are
  significant. The special identifier is terminated with a character
  which is not a special character. The terminating character is
  not part of the special identifier.
</p><p>
  Syntax:
</p><pre>
    special_identifier ::=
      special_character { special_character } .

    special_character ::=
      '!' | '$' | '%' | '&' | '*' | '+' | ',' | '-' | '.' | '/' |
      ':' | ';' | '&lt;' | '=' | '>' | '?' | '@' | '\' | '^' | '`' |
      '|' | '~' .
</pre><p></p>

<a name="Parentheses"><h4>10.2.3 Parentheses</h4></a>
<p>
    A parenthesis is one of the following characters:
</p><pre>
    ( ) [ ] { }
</pre><p>
  Note that a parenthesis consists of only one character. Except
  for the character sequence (* (which introduces a comment)
  a parenthesis is terminated with the next character.
</p><p>
  Syntax:
</p><pre>
    parenthesis ::=
      '(' | ')' | '[' | ']' | '{' | '}' .
</pre><p></p>

<a name="Literals"><h3>10.3 Literals</h3></a>
<p>
    There are three types of literals
</p><pre>
    integer literals
    character literals
    string literals
</pre><p>
  Syntax:
</p><pre>
    literal ::=
      integer_literal | character_literal | string_literal .
</pre><p></p>

<a name="Integer_literals"><h4>10.3.1 Integer literals</h4></a>
<p>
    An integer literal is a sequence of digits which is taken to
  be decimal. The sequence of digits may be followed by the letter
  E or e an optional + sign and a decimal exponent. Based numbers
  can be specified when the sequence of digits is followed by
  the # character and a sequence of extended digits. The decimal
  number in front of the # character specifies the base of the
  number which follows the # character. As base a number between
  2 and 36 is allowed. As extended digits the letters A or a can
  be used for 10, B or b can be used for 11 and so on to Z or z
  which can be used as 35.
</p><p>
  Syntax:
</p><pre>
    integer_literal ::=
      decimal_integer [ exponent | based_integer ] .

    decimal_integer ::=
      digit { digit } .

    exponent ::=
      ( 'E' | 'e' ) [ '+' ] decimal_integer .

    based_integer ::=
      '#' extended_digit { extended_digit } .

    extended_digit ::=
      letter | digit .
</pre><p></p>

<a name="String_literals"><h4>10.3.2 String literals</h4></a>
<p>
    A string literal is a sequence of characters surrounded by
  double quotes. For example:
</p><pre>
    <font color=maroon>""</font>   <font color=maroon>" "</font>   <font color=maroon>"\""</font>   <font color=maroon>"'"</font>   <font color=maroon>"\'"</font>   <font color=maroon>"String"</font>   <font color=maroon>"ch=\" "</font>   <font color=maroon>"\n\n"</font>
</pre><p>
  In order to represent nonprintable characters and certain
  printable characters the following escape sequences may be
  used.
</p><pre>
    audible alert    BEL      \a    backslash    (\)   \\
    backspace        BS       \b    apostrophe   (')   \'   
    escape           ESC      \e    double quote (")   \"
    formfeed         FF       \f
    newline          NL (LF)  \n    control-A          \A
    carriage return  CR       \r      ...
    horizontal tab   HT       \t    control-Z          \Z
    vertical tab     VT       \v
</pre><p>
  Additionally there are the following possibilities:
</p><ul>
    <li><!-- -  -->Two backslashes with a sequence of blanks, horizontal tabs,
      carriage returns and new lines between them are completely
      ignored. The ignored characters are not part of the string.
      This can be used to continue a string in the following line.
      Note that in this case the leading spaces in the new line
      are not part of the string.</li>

    <li><!-- -  -->Two backslashes with an integer literal between them is
      interpreted as character with the specified ordinal number.
      Note that the integer literal is interpreted decimal unless
      it is written as based integer.</li>
</ul><p>
  Syntax:
</p><pre>
    string_literal ::=
      '"' { string_character } '"' .

    string_character ::=
      printable_character | escape_sequence .

    escape_sequence ::=
      '\a' | '\b' | '\e' | '\f' | '\n' | '\r' | '\t' | '\v' |
      '\\' | '\''' | '\"' | '\' upper_case_letter |
      '\' { space } '\' | '\' integer_literal '\' .
</pre><p></p>

<a name="Character_literals"><h4>10.3.3 Character literals</h4></a>
<p>
    A character literal is a character enclosed in single
  quotes. For example:
</p><pre>
    <font color=maroon>'a'</font>   <font color=maroon>' '</font>   <font color=maroon>'\n'</font>   <font color=maroon>'!'</font>   <font color=maroon>'\\'</font>   <font color=maroon>'2'</font>   <font color=maroon>'"' </font>  <font color=maroon>'\"'</font>   <font color=maroon>'\''</font>
</pre><p>
  To represent control characters and certain other characters in
  character literals the same escape sequences as for string
  literals may be used.
</p><p>
  Syntax:
</p><pre>
    character_literal ::=
      ''' ( printable_character | escape_sequence ) ''' .

    escape_sequence ::=
      '\a' | '\b' | '\e' | '\f' | '\n' | '\r' | '\t' | '\v' |
      '\\' | '\''' | '\"' | '\' upper_case_letter |
      '\' { space } '\' | '\' integer_literal '\' .
</pre><p></p>

<p></p>
<a name="EXPRESSIONS"><h2>11. EXPRESSIONS</h2></a>
<!-- =============== -->
<p>
    There are two types of expressions. On one side there so
  called simple expressions which are constructed using fixed
  predefined syntax rules. On the other side there are expressions
  which are constructed according to syntax rules defined with
  syntax declarations. Here we describe only simple expressions.
  How syntax declarations work is described in <a href="decls.htm#Syntax_declarations">Chapter 3.2
  (Syntax declarations)</a> and <a href="syntax.htm">chapter 9 (Structured syntax
  definition)</a>. There are only few fixed predefined syntax rules:
</p>

<a name="EXPRESSION_Parentheses"><h3>11.1 Parentheses</h3></a>
<p>
    Parentheses can be used to override any precedence
  rules of predefined and user defined syntax constructs.
  For example
</p><pre>
    2 * (3 + 4)
</pre><p>
  specifies that the + operator gets his parameters first.
</p><p>
  Syntax:
</p><pre>
    parentheses_expression ::=
      '(' expression ')' .
</pre><p></p>

<a name="Call_expressions"><h3>11.2 Call expressions</h3></a>
<p>
    Call expressions can also be used to form a list.
  For example
</p><pre>
    writeln(<font color=maroon>"hello world"</font>)
</pre><p>
  forms a list expression with the elements
</p><pre>
    <font color=maroon>"hello world"</font>
    writeln
</pre><p>
  The meta object of this list is specified with the system
  declaration <font color=maroon>"system expr"</font> which is defined in the include
  file <font color=maroon>"syntax.s7i"</font> included from <font color=maroon>"seed7_05.s7i"</font> as
</p><pre>
    $ <font color=blue>system</font> <font color=maroon>"expr"</font> is expr;
</pre><p>
  A call expression with two parameters as
</p><pre>
    pos(<font color=maroon>"Scotty! Beam me up."</font>, <font color=maroon>"am"</font>)
</pre><p>
  forms a list expression with the elements
</p><pre>
    <font color=maroon>"Scotty! Beam me up."</font>
    <font color=maroon>"am"</font>
    pos
</pre><p>
  Syntax:
</p><pre>
    call_expression ::=
      primary_expression [ '(' comma_expression ')' ] .

    primary_expression ::=
      parentheses_expression | atom .
</pre><p></p>

<a name="Dot_expressions"><h3>11.3 Dot expressions</h3></a>
<p>
    Dot expressions start with a dot and have dots as separator
  between the elements of the list. For example
</p><pre>
    .<font color=blue>not</font>.TRUE
</pre><p>
  and
</p><pre>
    .OKAY.<font color=blue>and</font>.GO_ON
</pre><p>
  form list expressions with the elements
</p><pre>
    <font color=blue>not</font>
    TRUE
</pre><p>
  and
</p><pre>
    OKAY
    <font color=blue>and</font>
    GO_ON
</pre><p>
  The meta object of this list is specified with the system
  declaration <font color=maroon>"system expr"</font> which is defined in the include
  file <font color=maroon>"syntax.s7i"</font> included from <font color=maroon>"seed7_05.s7i"</font> as
</p><pre>
    $ <font color=blue>system</font> <font color=maroon>"expr"</font> <font color=blue>is</font> <font color=red>expr</font>;
</pre><p>
  Dot expressions override the priority of the elements.
  Dot expressions are used in <tt>'<font color=blue>syntax</font>'</tt> declarations.
</p><p>
  Syntax:
</p><pre>
    dot_expression ::=
      [ '.' ] call_expression { '.' call_expression } .
</pre><p></p>

<p></p>
<a name="OPERATING_SYSTEM_ACCESS"><h2>12. OPERATING SYSTEM ACCESS</h2></a>
<!-- =========================== -->
<p>
    Seed7 provides a portable access to the services provided
  by an operating system. This interface is oriented towards
  POSIX and UNIX.
</p>

<a name="Directory_access"><h3>12.1 Directory access</h3></a>
<p>
    A portable access to the contents of directories in the file
  system is provided. For example: After the declaration
</p><pre>
    <font color=blue>var</font> <font color=red>array string</font>: dir_array <font color=blue>is </font>0 <font color=blue>times</font> <font color=maroon>""</font>;
</pre><p>
  the following statement
</p><pre>
    dir_array := read_dir(<font color=maroon>"."</font>);
</pre><p>
  reads the current working directory and stores it into the
  string-array <tt>'dir_array'</tt>. The components of the directory
  can now be accessed via indexing:
</p><pre>
    <font color=blue>for</font> index <font color=blue>range</font> 1 <font color=blue>to</font> length(dir_array) <font color=blue>do</font>
      writeln(dir_array[index]);
    <font color=blue>end for</font>;
</pre><p>
  Note that the strings contain only the name of the file.
  Additional information must be obtained by other calls.
  Other directories can be read by using their name in the
  <tt>'read_dir'</tt> call.
  Basing on this mechanism another mechanism is constructed
  to read the contents of a directory as file. This is shown
  in the following example
</p><pre>
    ...

    <font color=blue>include</font> <font color=maroon>"dir.s7i"</font>;

    <font color=blue>var</font> <font color=red>file</font>: dir_file <font color=blue>is</font> STD_NULL;
    <font color=blue>var</font> <font color=red>string</font>: file_name <font color=blue>is</font> <font color=maroon>""</font>;

    ...

    dir_file := open_dir(<font color=maroon>"."</font>);
    file_name := getln(dir_file);
    <font color=blue>while</font> file_name &lt;> <font color=maroon>""</font> <font color=blue>do</font>
      writeln(file_name);
      file_name := getln(dir_file);
    <font color=blue>end while</font>;
</pre><p>
  This is useful in programs that accept a list of filenames
  as input. Using the <tt>'open_dir'</tt> mechanism it is possible to
  read the filenames directly from a directory without large
  changes in the program.
</p>

<a name="Other_directory_operations"><h3>12.2 Other directory operations</h3></a>
<p>
    In most operating systems each process has a current working
  directory. With the following statement
</p><pre>
    my_dir := getcwd();
</pre><p>
  the full path of the current working directory is assigned to
  the string variable 'my_dir'. To change the current working
  directory the next statement can be used
</p><pre>
    chdir(<font color=maroon>"/usr/bin"</font>);
</pre><p>
  A new directory can be created with
</p><pre>
    mkdir(<font color=maroon>"my_dir"</font>);
</pre><p></p>

<a name="fileType"><h3>12.3 fileType</h3></a>
<p>
    The type of a file can determined with <tt>'fileType'</tt> or
    <tt>'fileTypeSL'</tt>:
</p><pre>
      <font color=blue>const</font> <font color=red>func integer</font>: fileType (<font color=blue>in</font> <font color=red>string</font>: filePath) <font color=blue>is</font> ...
      <font color=blue>const</font> <font color=red>func integer</font>: fileTypeSL (<font color=blue>in</font> <font color=red>string</font>: filePath) <font color=blue>is</font> ...
</pre><p>
    The function <tt>'fileType'</tt> does follow symbolic links.
    Therefore <tt>'fileType'</tt> never returns <tt>'FILE_SYMLINK'</tt>.
    The function <tt>'fileTypeSL'</tt> does not follow symbolic
    links. Therefore <tt>'fileTypeSL'</tt> can also return
    <tt>'FILE_SYMLINK'</tt>. Most functions which use a file path
    except <tt>'fileTypeSL'</tt> and <tt>'readlink'</tt> follow
    symbolic links. 
</p>
    <p><dl><dt><p>Returns:</p></dt><dd>
      <dl>
      <dt>FILE_ABSENT</dt>
          <dd>A component of path does not exist.</dd>
      <dt>FILE_UNKNOWN</dt>
          <dd>The file exists but has an unknown type.</dd>
      <dt>FILE_REGULAR</dt>
          <dd>The file is a regular file.</dd>
      <dt>FILE_DIR</dt>
          <dd>The file is a directory.</dd>
      <dt>FILE_CHAR</dt>
          <dd>The file is a character special file.</dd>
      <dt>FILE_BLOCK</dt>
          <dd>The file is a block special file.</dd>
      <dt>FILE_FIFO</dt>
          <dd>The file is a pipe or FIFO special file.</dd>
      <dt>FILE_SYMLINK</dt>
          <dd>The file is a symbolic link.</dd>
      <dt>FILE_SOCKET</dt>
          <dd>The file is a socket.</dd>
      </dl></dd></dl></p>
    <p><dl><dt><p>Possible exceptions:</p></dt><dd>
      <dl>
      <dt>MEMORY_ERROR</dt>
          <dd>Not enough memory to convert <tt>'filePath'</tt> to the system path type.</dd>
      <dt>RANGE_ERROR</dt>
          <dd><tt>'filePath'</tt> is not representable in the system path type.</dd>
      <dt>FILE_ERROR</dt>
          <dd>The system function returns an error other than ENOENT.</dd>
      </dl></dd></dl></p>

<a name="fileMode"><h3>12.4 fileMode</h3></a>
<p>
    The permissions of a file can determined with <tt>'fileMode'</tt>:
</p><pre>
      <font color=blue>const</font> <font color=red>func fileMode</font>: fileMode (<font color=blue>in</font> <font color=red>string</font>: filePath) <font color=blue>is</font> ...
</pre>
    <p><dl><dt><p>Returns:</p></dt><dd><p>
      The <tt>'<font color=red>fileMode</font>'</tt> which is defined as <tt>'<font color=red>set of filePermission</font>'</tt>.
      </p></dd></dl></p>
    <p><dl><dt><p>The literal values of <tt>'<font color=red>filePermission</font>'</tt> are:</p></dt><dd>
      <dl>
      <dt>EXEC_OTHER</dt>
          <dd>others have execute permission</dd>
      <dt>WRITE_OTHER</dt>
          <dd>others have write permission</dd>
      <dt>READ_OTHER</dt>
          <dd>others have read permission</dd>
      <dt>EXEC_GROUP</dt>
          <dd>group has execute permission</dd>
      <dt>WRITE_GROUP</dt>
          <dd>group has write permission</dd>
      <dt>READ_GROUP</dt>
          <dd>group has read permission</dd>
      <dt>EXEC_USER</dt>
          <dd>owner has execute permission</dd>
      <dt>WRITE_USER</dt>
          <dd>owner has write permission</dd>
      <dt>READ_USER</dt>
          <dd>owner has read permission</dd>
      </dl></dd></dl></p>
    <p><dl><dt><p>Possible exceptions:</p></dt><dd>
      <dl>
      <dt>MEMORY_ERROR</dt>
          <dd>Not enough memory to convert <tt>'filePath'</tt> to the system path type.</dd>
      <dt>RANGE_ERROR</dt>
          <dd><tt>'filePath'</tt> is not representable in the system path type.</dd>
      <dt>FILE_ERROR</dt>
          <dd>A system function returns an error.</dd>
      </dl></dd></dl></p>

<a name="setFileMode"><h3>12.5 setFileMode</h3></a>
<p>
    The permissions of a file can changed with <tt>'setFileMode'</tt>:
</p><pre>
      <font color=blue>const</font> <font color=red>proc</font>: setFileMode (<font color=blue>in</font> <font color=red>string</font>: filePath, <font color=blue>in</font> <font color=red>fileMode</font>: newFileMode) <font color=blue>is</font> ...
</pre><p>
    The type <tt>'<font color=red>fileMode</font>'</tt> is defined as <tt>'<font color=red>set of filePermission</font>'</tt>.
</p>
    <p><dl><dt><p>The literal values of <tt>'<font color=red>filePermission</font>'</tt> are:</p></dt><dd>
      <dl>
      <dt>EXEC_OTHER</dt>
          <dd>others have execute permission</dd>
      <dt>WRITE_OTHER</dt>
          <dd>others have write permission</dd>
      <dt>READ_OTHER</dt>
          <dd>others have read permission</dd>
      <dt>EXEC_GROUP</dt>
          <dd>group has execute permission</dd>
      <dt>WRITE_GROUP</dt>
          <dd>group has write permission</dd>
      <dt>READ_GROUP</dt>
          <dd>group has read permission</dd>
      <dt>EXEC_USER</dt>
          <dd>owner has execute permission</dd>
      <dt>WRITE_USER</dt>
          <dd>owner has write permission</dd>
      <dt>READ_USER</dt>
          <dd>owner has read permission</dd>
      </dl></dd></dl></p>
    <p><dl><dt><p>Possible exceptions:</p></dt><dd>
      <dl>
      <dt>MEMORY_ERROR</dt>
          <dd>Not enough memory to convert <tt>'filePath'</tt> to the system path type.</dd>
      <dt>RANGE_ERROR</dt>
          <dd><tt>'filePath'</tt> is not representable in the system path type.</dd>
      <dt>FILE_ERROR</dt>
          <dd>A system function returns an error.</dd>
      </dl></dd></dl></p>

<a name="fileSize"><h3>12.6 fileSize</h3></a>
<p>
    The size of a file can be determined with <tt>'fileSize'</tt> and <tt>'bigFileSize'</tt>:
</p><pre>
      <font color=blue>const</font> <font color=red>func integer</font>: fileSize (<font color=blue>in</font> <font color=red>string</font>: filePath) <font color=blue>is</font> ...
      <font color=blue>const</font> <font color=red>func bigInteger</font>: bigFileSize (<font color=blue>in</font> <font color=red>string</font>: filePath) <font color=blue>is</font> ...
</pre>
    <p><dl><dt><p>Returns:</p></dt><dd><p>
      For directorys a size of 0 is returned. For other file types
      the operating system functions <tt>'stat()'</tt> and <tt>'seek()'</tt> are
      used to determine the size of a file. The functions <tt>'fileSize'</tt>
      and <tt>'bigFileSize'</tt> succeed when at least one strategy to determine
      the file size succeeds. 
      </p></dd></dl></p>
    <p><dl><dt><p>Possible exceptions:</p></dt><dd>
      <dl>
      <dt>MEMORY_ERROR</dt>
          <dd>Not enough memory to convert <tt>'filePath'</tt> to the system path type.</dd>
      <dt>RANGE_ERROR</dt>
          <dd><tt>'filePath'</tt> is not representable in the system path type.</dd>
      <dt>RANGE_ERROR</dt>
          <dd>The file size is not representable as <font color=red>integer</font>.</dd>
      <dt>FILE_ERROR</dt>
          <dd>It was not possible to determine the file size.</dd>
      </dl></dd></dl></p>

<a name="getATime"><h3>12.7 getATime</h3></a>
<p>
    The access time of a file is returned by the function <tt>'getATime'</tt>:
</p><pre>
      <font color=blue>const</font> <font color=red>func time</font>: getATime (<font color=blue>in</font> <font color=red>string</font>: filePath) <font color=blue>is</font> ...
</pre>
    <p><dl><dt><p>Possible exceptions:</p></dt><dd>
      <dl>
      <dt>MEMORY_ERROR</dt>
          <dd>Not enough memory to convert <tt>'filePath'</tt> to the system path type.</dd>
      <dt>RANGE_ERROR</dt>
          <dd><tt>'filePath'</tt> is not representable in the system path type.</dd>
      <dt>FILE_ERROR</dt>
          <dd>A system function returns an error.</dd>
      </dl></dd></dl></p>

<a name="getCTime"><h3>12.8 getCTime</h3></a>
<p>
    The change time of a file is returned by the function <tt>'getCTime'</tt>:
</p><pre>
      <font color=blue>const</font> <font color=red>func time</font>: getCTime (<font color=blue>in</font> <font color=red>string</font>: filePath) <font color=blue>is</font> ...
</pre>
    <p><dl><dt><p>Possible exceptions:</p></dt><dd>
      <dl>
      <dt>MEMORY_ERROR</dt>
          <dd>Not enough memory to convert <tt>'filePath'</tt> to the system path type.</dd>
      <dt>RANGE_ERROR</dt>
          <dd><tt>'filePath'</tt> is not representable in the system path type.</dd>
      <dt>FILE_ERROR</dt>
          <dd>A system function returns an error.</dd>
      </dl></dd></dl></p>

<a name="getMTime"><h3>12.9 getMTime</h3></a>
<p>
    The modification time of a file is returned by the function <tt>'getMTime'</tt>:
</p><pre>
      <font color=blue>const</font> <font color=red>func time</font>: getMTime (<font color=blue>in</font> <font color=red>string</font>: filePath) <font color=blue>is</font> ...
</pre>
    <p><dl><dt><p>Possible exceptions:</p></dt><dd>
      <dl>
      <dt>MEMORY_ERROR</dt>
          <dd>Not enough memory to convert <tt>'filePath'</tt> to the system path type.</dd>
      <dt>RANGE_ERROR</dt>
          <dd><tt>'filePath'</tt> is not representable in the system path type.</dd>
      <dt>FILE_ERROR</dt>
          <dd>A system function returns an error.</dd>
      </dl></dd></dl></p>

<a name="setATime"><h3>12.10 setATime</h3></a>
<p>
    The function <tt>'setATime'</tt> sets the access time of a file:
</p><pre>
      <font color=blue>const</font> <font color=red>proc</font>: setATime (<font color=blue>in</font> <font color=red>string</font>: filePath, <font color=blue>in</font> <font color=red>time</font>: aTime) <font color=blue>is</font> ...
</pre>
    <p><dl><dt><p>Possible exceptions:</p></dt><dd>
      <dl>
      <dt>MEMORY_ERROR</dt>
          <dd>Not enough memory to convert <tt>'filePath'</tt> to the system path type.</dd>
      <dt>RANGE_ERROR</dt>
          <dd><tt>'filePath'</tt> is not representable in the system path type.</dd>
      <dt>FILE_ERROR</dt>
          <dd>A system function returns an error.</dd>
      </dl></dd></dl></p>

<a name="setMTime"><h3>12.11 setMTime</h3></a>
<p>
    The function <tt>'setMTime'</tt> sets the modification time of a file:
</p><pre>
      <font color=blue>const</font> <font color=red>proc</font>: setMTime (<font color=blue>in</font> <font color=red>string</font>: filePath, <font color=blue>in</font> <font color=red>time</font>: aTime) <font color=blue>is</font> ...
</pre>
    <p><dl><dt><p>Possible exceptions:</p></dt><dd>
      <dl>
      <dt>MEMORY_ERROR</dt>
          <dd>Not enough memory to convert <tt>'filePath'</tt> to the system path type.</dd>
      <dt>RANGE_ERROR</dt>
          <dd><tt>'filePath'</tt> is not representable in the system path type.</dd>
      <dt>FILE_ERROR</dt>
          <dd>A system function returns an error.</dd>
      </dl></dd></dl></p>

<a name="readlink"><h3>12.12 readlink</h3></a>
<p>
    The function <tt>'readlink'</tt> reads the destination of a symbolic link:
</p><pre>
      <font color=blue>const</font> <font color=red>func string</font>: readlink (<font color=blue>in</font> <font color=red>string</font>: filePath) <font color=blue>is</font> ...
</pre>
    <p><dl><dt><p>Returns:</p></dt><dd><p>
      The symbolic link refered by <tt>'filePath'</tt>. 
      </p></dd></dl></p>
    <p><dl><dt><p>Possible exceptions:</p></dt><dd>
      <dl>
      <dt>MEMORY_ERROR</dt>
          <dd>Not enough memory to convert <tt>'filePath'</tt> to the system path type or not
              enough memory to represent the result <tt>'<font color=red>string</font>'</tt>.</dd>
      <dt>RANGE_ERROR</dt>
          <dd><tt>'filePath'</tt> is not representable in the system path type.</dd>
      <dt>FILE_ERROR</dt>
          <dd>The file described with <tt>'filePath'</tt> does not exist or is not a symbolic link.</dd>
      </dl></dd></dl></p>

<a name="symlink"><h3>12.13 symlink</h3></a>
<p>
    The function <tt>'symlink'</tt> creates a symbolic link called
    <tt>'dest'</tt> that contains the string referred by <tt>'source'</tt>:
</p><pre>
      <font color=blue>const</font> <font color=red>proc</font>: symlink (<font color=blue>in</font> <font color=red>string</font>: source, <font color=blue>in</font> <font color=red>string</font>: dest) <font color=blue>is</font> ...
</pre>
    <p><dl><dt><p>Parameters:</p></dt><dd>
      <dl>
      <dt>source</dt>
          <dd>Name of the symbolic link to be created.</dd>
      <dt>dest</dt>
          <dd>String to be contained in the symbolic link.</dd>
      </dl></dd></dl></p>

    <p><dl><dt><p>Possible exceptions:</p></dt><dd>
      <dl>
      <dt>MEMORY_ERROR</dt>
          <dd>Not enough memory to convert <tt>'source'</tt> or <tt>'dest'</tt>
              to the system path type.</dd>
      <dt>RANGE_ERROR</dt>
          <dd><tt>'source'</tt> or <tt>'dest'</tt> is not representable in the
          system path type.</dd>
      <dt>FILE_ERROR</dt>
          <dd>A system function returns an error.</dd>
      </dl></dd></dl></p>

<a name="removeFile"><h3>12.14 removeFile</h3></a>
<p>
    The function <tt>'removeFile'</tt> removes a file or
    empty directory:
</p><pre>
      <font color=blue>const</font> <font color=red>proc</font>: removeFile (<font color=blue>in</font> <font color=red>string</font>: filePath) <font color=blue>is</font> ...
</pre>
    <p><dl><dt><p>Possible exceptions:</p></dt><dd>
      <dl>
      <dt>MEMORY_ERROR</dt>
          <dd>Not enough memory to convert <tt>'filePath'</tt> to the system path type.</dd>
      <dt>RANGE_ERROR</dt>
          <dd><tt>'filePath'</tt> is not representable in the system path type.</dd>
      <dt>FILE_ERROR</dt>
          <dd>The file does not exist or a system function returns an error.</dd>
      </dl></dd></dl></p>

<a name="removeAnyFile"><h3>12.15 removeAnyFile</h3></a>
<p>
    The function <tt>'removeAnyFile'</tt> removes a file independend
    of its file type:
</p><pre>
      <font color=blue>const</font> <font color=red>proc</font>: removeAnyFile (<font color=blue>in</font> <font color=red>string</font>: filePath) <font color=blue>is</font> ...
</pre>
    <p><dl><dt><p>Possible exceptions:</p></dt><dd>
      <dl>
      <dt>MEMORY_ERROR</dt>
          <dd>Not enough memory to convert <tt>'filePath'</tt> to the system path type.</dd>
      <dt>RANGE_ERROR</dt>
          <dd><tt>'filePath'</tt> is not representable in the system path type.</dd>
      <dt>FILE_ERROR</dt>
          <dd>The file does not exist or a system function returns an error.</dd>
      </dl></dd></dl></p>

<a name="copyFile"><h3>12.16 copyFile</h3></a>
<p>
    The function <tt>'copyFile'</tt> copies a file or directory
    tree:
</p><pre>
      <font color=blue>const</font> <font color=red>proc</font>: copyFile (<font color=blue>in</font> <font color=red>string</font>: sourcePath, <font color=blue>in</font> <font color=red>string</font>: destPath) <font color=blue>is</font> ...
</pre><p>
    Permissions/mode, ownership and timestamps of the destination file are
    determined undependend of the corresponding source properties.
    The destination file gets the permissions/mode defined by umask.
    The user executing the program is the owner of the destination file.
    The timestamps of the destination file are set to the current time.
    Symbolic links in sourcePath are always followed.
    Therefore <tt>'copyFile'</tt> will never create a symbolic link.
    Note that the cloneFile does not preserve hard
    links (they are resolved to distinct files).
</p>
    <p><dl><dt><p>Possible exceptions:</p></dt><dd>
      <dl>
      <dt>MEMORY_ERROR</dt>
          <dd>Not enough memory to convert <tt>'sourcePath'</tt> or <tt>'destPath'</tt>
              to the system path type.</dd>
      <dt>RANGE_ERROR</dt>
          <dd><tt>'sourcePath'</tt> or <tt>'destPath'</tt> is not representable in the
              system path type.</dd>
      <dt>FILE_ERROR</dt>
          <dd>Source file does not exist, destination file already exists or
              a system function returns an error.</dd>
      </dl></dd></dl></p>

<a name="cloneFile"><h3>12.17 cloneFile</h3></a>
<p>
    The function <tt>'cloneFile'</tt> clones a file or directory
    tree:
</p><pre>
      <font color=blue>const</font> <font color=red>proc</font>: cloneFile (<font color=blue>in</font> <font color=red>string</font>: sourcePath, <font color=blue>in</font> <font color=red>string</font>: destPath) <font color=blue>is</font> ...
</pre><p>
    Permissions/mode, ownership and timestamps of the original are
    preserved. Symlinks are not followed. Instead the symlink
    is copied. Note that the cloneFile does not preserve hard
    links (they are resolved to distinct files).</p>
    <p><dl><dt><p>Possible exceptions:</p></dt><dd>
      <dl>
      <dt>MEMORY_ERROR</dt>
          <dd>Not enough memory to convert <tt>'sourcePath'</tt> or <tt>'destPath'</tt>
              to the system path type.</dd>
      <dt>RANGE_ERROR</dt>
          <dd><tt>'sourcePath'</tt> or <tt>'destPath'</tt> is not representable in the
              system path type.</dd>
      <dt>FILE_ERROR</dt>
          <dd>Source file does not exist, destination file already exists or
              a system function returns an error.</dd>
      </dl></dd></dl></p>

<a name="moveFile"><h3>12.18 moveFile</h3></a>
<p>
    The function <tt>'moveFile'</tt> moves and/or renames a
    file or directory tree:
</p><pre>
      <font color=blue>const</font> <font color=red>proc</font>: moveFile (<font color=blue>in</font> <font color=red>string</font>: sourcePath, <font color=blue>in</font> <font color=red>string</font>: destPath) <font color=blue>is</font> ...
</pre><p>
    The function uses the C <tt>'rename()'</tt> function.
    When <tt>'rename()'</tt> fails the file (or directory tree)
    is cloned with <tt>'cloneFile'</tt> (which preserves
    permissions/mode, ownership and timestamps) to the new place
    and with the new name. When <tt>'cloneFile'</tt> succeeds
    the original file is deleted. When <tt>'cloneFile'</tt> fails (no space on
    device or other reason) all remains of the failed clone are
    removed. Note that <tt>'cloneFile'</tt> works for
    symbolic links but does not preserve hard links (they are
    resolved to distinct files).</p>
    <p><dl><dt><p>Possible exceptions:</p></dt><dd>
      <dl>
      <dt>MEMORY_ERROR</dt>
          <dd>Not enough memory to convert <tt>'sourcePath'</tt> or <tt>'destPath'</tt>
              to the system path type.</dd>
      <dt>RANGE_ERROR</dt>
          <dd><tt>'sourcePath'</tt> or <tt>'destPath'</tt> is not representable in the
              system path type.</dd>
      <dt>FILE_ERROR</dt>
          <dd>Source file does not exist, destination file already exists or
              a system function returns an error.</dd>
      </dl></dd></dl></p>

<a name="argv"><h3>12.19 argv</h3></a>
<p>
    The function <tt>'argv(PROGRAM)'</tt> returns the argument
    vector of the program as array of strings.
</p><pre>
      <font color=blue>const</font> <font color=red>func array string</font>: argv (PROGRAM) <font color=blue>is</font> ...
</pre>
    <p><dl><dt><p>Returns:</p></dt><dd>
      An array of strings containing the argument vector.
      </dd></dl></p>

<a name="getenv"><h3>12.20 getenv</h3></a>
<p>
    The function <tt>'getenv'</tt> determines the value of an
    environment variable.
</p><pre>
      <font color=blue>const</font> <font color=red>func string</font>: getenv (<font color=blue>in</font> <font color=red>string</font>: name) <font color=blue>is</font> ...
</pre><p>
    The <tt>'getenv'</tt> function searches the environment for an
    environment variable with the given <tt>'name'</tt>. When such
    an environment variable exists the corresponding <font color=red>string</font>
    value is returned.
</p>
    <p><dl><dt><p>Returns:</p></dt><dd>
      The value of an environment variable or <font color=maroon>""</font>
      when the requested environment variable does not exist.
      </dd></dl></p>

<p></p>
<a name="PRIMITIVE_ACTIONS"><h2>13. PRIMITIVE ACTIONS</h2></a>
<!-- ===================== -->
<p>
    Not all functions can be described by calling other
  functions of the same language. For this reason and for
  performance reasons several functions are defined using a
  mechanism called action. For example: It is easy to define
  the <tt>'<font color=blue>while</font>'</tt> statement by using recursion. But this would
  hurt performance and it would also use a huge amount of
  memory for the runtime stack. In practise an implementation
  of the <tt>'<font color=blue>while</font>'</tt> statement can use a conditional jump
  instead of a subroutine call. Since Seed7 has no <tt>'<font color=blue>goto</font>'</tt>
  statement, this is not an option. Instead the primitive
  action PRC_WHILE can be used. The <tt>'<font color=blue>while</font>'</tt> statement is
  defined in the basic Seed7 library <tt>'seed7_05.s7i'</tt> with:
</p><pre>
    <font color=blue>const</font> <font color=red>proc</font>: while (<font color=blue>in</font> <font color=red>func boolean</font> <font color=blue>param</font>) do
        (<font color=blue>in</font> <font color=red>proc</font> <font color=blue>param</font>) end while <font color=blue>is action</font> <font color=maroon>"PRC_WHILE"</font>;
</pre><p>
  This declaration shows the types and the position of
  the parameters of a <tt>'<font color=blue>while</font>'</tt> statement. Such an action
  declaration contains enough information to use the defined
  construct. The semantic of all primitive actions is
  hard coded in the interpreter and in the compiler. The
  parameters of the hard coded actions and the corresponding
  definitions in Seed7 must match. If you are interested in
  the Seed7 definitions of primitive actions just look into
  the file <tt>'seed7_05.s7i'</tt>.
</p><p>
    Currently there are several hundred primitive actions
  predefined in the interpreter. They all have names in upper
  case characters which have the form:
</p><pre>
    TYPE_ACTION
</pre><p>
  Which means that for example all <tt>'<font color=red>integer</font>'</tt> actions start
  with INT_ and all assignment actions end with _CPY .
  The following list shows actions which are used with more
  than one type:
</p><pre>
    _ABS      Absolute value
    _ADD      Addition
    _CAT      Concatenation
    _CMP      Compare
    _CPY      Copy (Assignment)
    _CREATE   Initialize (Construct)
    _DESTR    Destroy (Destruct)
    _DECR     Decrement
    _DIV      Division
    _EQ       Equal
    _GE       Greater equal
    _GETC     Get one character from a <font color=red>file</font>
    _GETS     Get string with maximum length from a <font color=red>file</font>
    _GT       Greater than
    _HASHCODE Compute a hashCode
    _HEAD     Head of <font color=red>ref_list</font>, <font color=red>array</font>, <font color=red>string</font>
    _ICONV    Conversion of <font color=red>integer</font> to another type
    _IDX      Index (Element) of <font color=red>ref_list</font>, <font color=red>array</font>, <font color=red>string</font>
    _INCR     Increment
    _LE       Less equal
    _LNG      Length
    _LOG2     Base 2 logarithm
    _LOWER    Convert to lower case
    _LSHIFT   Shift left
    _LT       Less than
    _MDIV     Modulo division (Integer division truncated towards negative infinity)
    _MINUS    Change sign
    _MOD      Modulo (Reminder of _MDIV integer division)
    _MULT     Multiply
    _NE       Not equal
    _ODD      Odd number
    _ORD      Ordinal number
    _PARSE    Conversion of <font color=red>string</font> to another type
    _PLUS     Positive sign (noop)
    _POW      Power
    _PRED     Predecessor
    _RAND     Random value
    _RANGE    Range of <font color=red>ref_list</font>, <font color=red>array</font>, <font color=red>string</font>
    _REM      Remainder (Reminder of _DIV integer division)
    _RSHIFT   Arithmetic shift right
    _SBTR     Subtract
    _SCAN     Convert from <font color=red>string</font> to another type
    _SEEK     Set actual file position of a <font color=red>file</font>
    _SQRT     Square root
    _STR      Convert to <font color=red>string</font>
    _SUCC     Successor
    _TAIL     Tail of <font color=red>ref_list</font>, <font color=red>array</font>, <font color=red>string</font>
    _TELL     Return the actual <font color=red>file</font> position
    _UPPER    Convert to upper case
    _VALUE    Dereference a <font color=red>reference</font>
    _WRITE    Write <font color=red>string</font> to <font color=red>file</font>
</pre><p>
  Primitive actions are defined for many types. The functions
  which implement the primitive actions are grouped together
  in *lib.c files. The following list contains the action
  prefix, the file containing the functions and a description:
</p><pre>
    ACT_  actlib.c  <font color=red>ACTION</font> operations
    ARR_  arrlib.c  <font color=red>array</font> operations
    BIG_  biglib.c  <font color=red>bigInteger</font> operations
    BLN_  blnlib.c  <font color=red>boolean</font> operations
    BST_  bstlib.c  Operations for byte strings
    CHR_  chrlib.c  <font color=red>char</font> operations
    CMD_  cmdlib.c  Various directory, file and other commands
    DCL_  dcllib.c  Declaration operations
    DRW_  drwlib.c  Drawing operations
    ENU_  enulib.c  Enumeration operations
    FIL_  fillib.c  <font color=red>PRIMITIVE_FILE</font> operations
    FLT_  fltlib.c  <font color=red>float</font> operations
    HSH_  hshlib.c  <font color=red>hash</font> operations
    INT_  intlib.c  <font color=red>integer</font> operations
    ITF_  itflib.c  Operations for interface types
    KBD_  kbdlib.c  Keyboard operations
    LST_  lstlib.c  List operations
    PRC_  prclib.c  <font color=red>proc</font> operations and statements
    PRG_  prglib.c  Program operations
    REF_  reflib.c  <font color=red>reference</font> operations
    RFL_  rfllib.c  <font color=red>ref_list</font> operations
    SCR_  scrlib.c  Screen operations
    SCT_  sctlib.c  <font color=red>struct</font> operations
    SET_  setlib.c  <font color=red>set</font> operations
    SOC_  soclib.c  <font color=red>PRIMITIVE_SOCKET</font> operations
    STR_  strlib.c  <font color=red>string</font> operations
    TIM_  timlib.c  <font color=red>time</font> and <font color=red>duration</font> operations
    TYP_  typlib.c  <font color=red>type</font> operations
    UT8_  ut8lib.c  <font color=red>utf8_file</font> operations
</pre><p>
  The C functions which implement primitive actions have
  lowercase names. E.g.: The action <tt>'PRC_WHILE'</tt> is implemented
  with the C function <tt>'prc_while()'</tt> in the file <tt>'prclib.c'</tt>.
  The parameter list for all C action functions is identical.
  Every *lib.c file has a corresponding *lib.h file which
  contains the prototypes for the action functions.
</p><p>
  The primitive action which describes the addition of two
  integers is <tt>'INT_ADD'</tt>. The Seed7 interface to the action
  <tt>'INT_ADD'</tt> is defined in the file <tt>'seed7_05.s7i'</tt> with:
</p><pre>
    <font color=blue>const</font> <font color=red>func integer</font>: (<font color=blue>in</font> <font color=red>integer</font> <font color=blue>param</font>) + (<font color=blue>in</font> <font color=red>integer</font> <font color=blue>param</font>) <font color=blue>is action</font> <font color=maroon>"INT_ADD"</font>;
</pre><p>
  To execute an action a corresponding C function must
  be present in the hi interpreter. The function for the
  action <tt>'INT_ADD'</tt> is <tt>'int_add()'</tt>. The function <tt>'int_add()'</tt>
  is defined in the file <tt>'intlib.c'</tt> with:
</p><pre>
    #ifdef ANSI_C

    objecttype int_add (listtype arguments)
    #else

    objecttype int_add (arguments)
    listtype arguments;
    #endif

      { /* int_add */
        isit_int(arg_1(arguments));
        isit_int(arg_3(arguments));
        return(bld_int_temp(
            take_int(arg_1(arguments)) +
            take_int(arg_3(arguments))));
      } /* int_add */
</pre><p>
  The action functions use ANSI C prototypes and K&R function headers.
  The function <tt>'int_add()'</tt> adds the first and the third argument (the
  second argument contains the + symbol. The file <tt>'memory.h'</tt>
  contains several macros and functions which help to handle the
  arguments (parameter list) of a C primitive action function.
<ul>
    <li><!-- -  -->The macros <tt>'arg_1'</tt>, <tt>'arg_2'</tt>,
      <tt>'arg_3'</tt>, etc. can be used to get an individual argument
      (E.g.: <tt>'arg_3(arguments)'</tt> ).</li>

    <li><!-- -  -->The macros <tt>'isit_int'</tt>, <tt>'isit_stri'</tt>,
      <tt>'isit_file'</tt>, etc. can be used to check for the correct
      <font color=red>category</font> of an argument
      (E.g.: <tt>'isit_int(arg_1(arguments))'</tt> ).</li>

    <li><!-- -  -->The macros <tt>'take_char'</tt>, <tt>'take_float'</tt>,
      <tt>'take_bigint'</tt>, etc. can be used to get the corresponding
      value of an argument (E.g.: <tt>'take_int(arg_1(arguments))'</tt> ).</li>

    <li><!-- -  -->The functions <tt>'bld_int_temp'</tt>, <tt>'bld_array_temp'</tt>,
      <tt>'bld_win_temp'</tt>, etc. can be used to create the (objecttype)
      result of a primitive action (E.g.: <tt>'return(bld_int_temp(0))'</tt> ).</li>
</ul><p>
  The file <tt>'intlib.h'</tt> contains the prototype for the <tt>'int_add()'</tt>
  function:
</p><pre>
    objecttype int_add (listtype);
</pre><p>
  and also a definition for the K&R C language:
</p><pre>
    objecttype int_add ();
</pre><p>
  Additionally every primitive action is registered in the file
  <tt>'primitive.c'</tt>. The line which incorporates <tt>'INT_ADD'</tt> is:
</p><pre>
    { "INT_ADD",             int_add,             },
</pre><p>
  The entries of the primitive action in the file <tt>'primitive.c'</tt> are
  sorted alphabetically. With this definitions the hi interpreter
  understands a primitive action.
</p><p>
  To allow a primitive function in a compiled Seed7 program the
  Seed7 compiler (comp.sd7) needs to know the action also. The
  compiler function which creates code for the <tt>'INT_ADD'</tt> action is:
</p><pre>
    <font color=blue>const</font> <font color=red>proc</font>: process_int_add (<font color=blue>in</font> <font color=red>ref_list</font>: params, <font color=blue>inout</font> <font color=red>expr_type</font>: c_expr) <font color=blue>is func</font>

      <font color=blue>begin</font>
        c_expr.expr &:= <font color=maroon>"("</font>;
        process_expr(params[1], c_expr);
        c_expr.expr &:= <font color=maroon>") + ("</font>;
        process_expr(params[3], c_expr);
        c_expr.expr &:= <font color=maroon>")"</font>;
      <font color=blue>end func</font>;
</pre><p>
  This function is called from the function <tt>'process_action'</tt> with the
  line:
</p><pre>
    <font color=blue>elsif</font> action_name = <font color=maroon>"INT_ADD"</font> <font color=blue>then</font>
      process_int_add(params, c_expr);
</pre><p>
  Some primitive actions are more complicated and inline code would
  not be the best solution for it. In this case an additional helper
  function is used. The action <tt>'INT_STR'</tt> is such an action. The
  definition of the function <tt>'int_str()'</tt> in the file <tt>'intlib.c'</tt> is:
</p><pre>
    #ifdef ANSI_C

    objecttype int_str (listtype arguments)
    #else

    objecttype int_str (arguments)
    listtype arguments;
    #endif

      { /* int_str */
        isit_int(arg_1(arguments));
        return(bld_stri_temp(intStr(
            take_int(arg_1(arguments)))));
      } /* int_str */
</pre><p>
  The main work for the primitive action <tt>'INT_STR'</tt> is done in
  the helper function <tt>'intStr()'</tt>. The helper function <tt>'intStr()'</tt>
  can be found in the file <tt>'int_rtl.c'</tt>:
</p><pre>
    #ifdef ANSI_C

    stritype intStr (inttype number)
    #else

    stritype intStr (number)
    inttype number;
    #endif

      {
        uinttype unsigned_number;
        booltype sign;
        strelemtype buffer_1[50];
        strelemtype *buffer;
        memsizetype len;
        stritype result;

      /* intStr */
        if ((sign = (number < 0))) {
          unsigned_number = -number;
        } else {
          unsigned_number = number;
        } /* if */
        buffer = &buffer_1[50];
        do {
          *(--buffer) = (strelemtype) (unsigned_number % 10 + '0');
        } while ((unsigned_number /= 10) != 0);
        if (sign) {
          *(--buffer) = (strelemtype) '-';
        } /* if */
        len = &buffer_1[50] - buffer;
        if (!ALLOC_STRI(result, len)) {
          raise_error(MEMORY_ERROR);
          return(NULL);
        } else {
          result->size = len;
          memcpy(result->mem, buffer, (SIZE_TYPE) (len * sizeof(strelemtype)));
          return(result);
        } /* if */
      } /* intStr */
</pre><p>
  The file <tt>'int_rtl.h'</tt> contains a prototype definition for the
  <tt>'intStr()'</tt> helper function:
</p><pre>
    stritype intStr (inttype number);
</pre><p>
  and also a definition for the K&R C language:
</p><pre>
    stritype intStr ();
</pre><p>
  The helper functions are also used in the code generated by
  the Seed7 compiler:
</p><pre>
    <font color=blue>const</font> <font color=red>proc</font>: process_int_str (<font color=blue>in</font> <font color=red>ref_list</font>: params, <font color=blue>inout</font> <font color=red>expr_type</font>: c_expr) <font color=blue>is func</font>

      <font color=blue>begin</font>
        prepare_stri_result(c_expr);
        c_expr.result_expr &:= <font color=maroon>"intStr("</font>;
        getStdParamToResultExpr(params[1], c_expr);
        c_expr.result_expr &:= <font color=maroon>")"</font>;
      <font color=blue>end func</font>;
</pre><p>
  All the *lib.c files containing primitive actions and various
  other files with their functions are grouped together in the
  <tt>'s7_comp.a'</tt> library (Licensed under GPL). Furthermore the C
  primitive action functions (E.g.: int_parse) of the *lib.c
  files may use corresponding functions (E.g.: intParse) which
  can be found in *_rtl.c files (E.g.: <tt>'int_rtl.c'</tt>). The *_rtl.c
  files are grouped together in the <tt>'seed7_05.a'</tt> library
  (Licensed under LGPL). When a Seed7 program is compiled with
  the Seed7 compiler (comp.sd7) inline code is generated for
  many primitive actions. To implement the remaining primitive
  actions the functions of the <tt>'seed7_05.a'</tt> library are used.
</p>
<a name="ACTION"><h3>13.1 Actions for the type ACTION</h3></a>
<p></p><table border="1">
    <tr><td>Action name</td>         <td>actlib.c function</td>   <td>act_comp.c function</td></tr>
    <tr><td>ACT_ILLEGAL</td>         <td>act_illegal</td>         <td></td></tr>
    <tr><td>ACT_CPY</td>             <td>act_cpy</td>             <td>=</td></tr>
    <tr><td>ACT_CREATE</td>          <td>act_create</td>          <td></td></tr>
    <tr><td>ACT_GEN</td>             <td>act_gen</td>             <td></td></tr>
    <tr><td>ACT_STR</td>             <td>act_str</td>             <td>actStr</td></tr>
    <tr><td>ACT_VALUE</td>           <td>act_value</td>           <td>actValue</td></tr>
</table><p></p>
<a name="array"><h3>13.2 Actions for array types</h3></a>
<p></p><table border="1">
    <tr><td>Action name</td>         <td>arrlib.c function</td>   <td>arr_rtl.c function</td></tr>
    <tr><td>ARR_APPEND</td>          <td>arr_append</td>          <td>arrAppend</td></tr>
    <tr><td>ARR_ARRLIT</td>          <td>arr_arrlit</td>          <td>arrArrlit</td></tr>
    <tr><td>ARR_ARRLIT2</td>         <td>arr_arrlit2</td>         <td>arrArrlit2</td></tr>
    <tr><td>ARR_BASELIT</td>         <td>arr_baselit</td>         <td>arrBaselit</td></tr>
    <tr><td>ARR_BASELIT2</td>        <td>arr_baselit2</td>        <td>arrBaselit2</td></tr>
    <tr><td>ARR_CAT</td>             <td>arr_cat</td>             <td>arrCat</td></tr>
    <tr><td>ARR_CONV</td>            <td>arr_conv</td>            <td>(noop)</td></tr>
    <tr><td>ARR_CPY</td>             <td>arr_cpy</td>             <td>cpy_ ...</td></tr>
    <tr><td>ARR_CREATE</td>          <td>arr_create</td>          <td>create_ ...</td></tr>
    <tr><td>ARR_DESTR</td>           <td>arr_destr</td>           <td>destr_ ...</td></tr>
    <tr><td>ARR_EMPTY</td>           <td>arr_empty</td>           <td></td></tr>
    <tr><td>ARR_EXTEND</td>          <td>arr_extend</td>          <td>arrExtend</td></tr>
    <tr><td>ARR_GEN</td>             <td>arr_gen</td>             <td>arrGen</td></tr>
    <tr><td>ARR_HEAD</td>            <td>arr_head</td>            <td>arrHead</td></tr>
    <tr><td>ARR_IDX</td>             <td>arr_idx</td>             <td>a-&gt;arr[b-a-&gt;min_position]</td></tr>
    <tr><td>ARR_LNG</td>             <td>arr_lng</td>             <td>a->max_position-a->min_position + 1</td></tr>
    <tr><td>ARR_MAXIDX</td>          <td>arr_maxidx</td>          <td>a->max_position</td></tr>
    <tr><td>ARR_MINIDX</td>          <td>arr_minidx</td>          <td>a->min_position</td></tr>
    <tr><td>ARR_RANGE</td>           <td>arr_range</td>           <td>arrRange</td></tr>
    <tr><td>ARR_REMOVE</td>          <td>arr_remove</td>          <td>arrRemove</td></tr>
    <tr><td>ARR_SORT</td>            <td>arr_sort</td>            <td>arrSort</td></tr>
    <tr><td>ARR_TAIL</td>            <td>arr_tail</td>            <td>arrTail</td></tr>
    <tr><td>ARR_TIMES</td>           <td>arr_times</td>           <td>times_ ...</td></tr>
</table><p></p>
<a name="bigInteger"><h3>13.3 Actions for the type bigInteger</h3></a>
<p></p><table border="1">
    <tr><td>Action name</td>         <td>biglib.c function</td>   <td>big_rtl.c function</td></tr>
    <tr><td>BIG_ABS</td>             <td>big_abs</td>             <td>bigAbs</td></tr>
    <tr><td>BIG_ADD</td>             <td>big_add</td>             <td>bigAdd, bigAddTemp</td></tr>
    <tr><td>BIG_BIT_LENGTH</td>      <td>big_bit_length</td>      <td>bigBitLength</td></tr>
    <tr><td>BIG_CLIT</td>            <td>big_clit</td>            <td>bigCLit</td></tr>
    <tr><td>BIG_CMP</td>             <td>big_cmp</td>             <td>bigCmp</td></tr>
    <tr><td>BIG_CPY</td>             <td>big_cpy</td>             <td>bigCpy</td></tr>
    <tr><td>BIG_CREATE</td>          <td>big_create</td>          <td>bigCreate</td></tr>
    <tr><td>BIG_DECR</td>            <td>big_decr</td>            <td>bigDecr</td></tr>
    <tr><td>BIG_DESTR</td>           <td>big_destr</td>           <td>bigDestr</td></tr>
    <tr><td>BIG_DIV</td>             <td>big_div</td>             <td>bigDiv</td></tr>
    <tr><td>BIG_EQ</td>              <td>big_eq</td>              <td>bigEq</td></tr>
    <tr><td>BIG_GCD</td>             <td>big_gcd</td>             <td>bigGcd</td></tr>
    <tr><td>BIG_GE</td>              <td>big_ge</td>              <td>bigCmp >= 0</td></tr>
    <tr><td>BIG_GROW</td>            <td>big_grow</td>            <td>bigGrow</td></tr>
    <tr><td>BIG_GT</td>              <td>big_gt</td>              <td>bigCmp > 0</td></tr>
    <tr><td>BIG_HASHCODE</td>        <td>big_hashcode</td>        <td>bigHashCode</td></tr>
    <tr><td>BIG_ICONV</td>           <td>big_iconv</td>           <td>bigIConv</td></tr>
    <tr><td>BIG_INCR</td>            <td>big_incr</td>            <td>bigIncr</td></tr>
    <tr><td>BIG_IPOW</td>            <td>big_ipow</td>            <td>bigIPow</td></tr>
    <tr><td>BIG_LE</td>              <td>big_le</td>              <td>bigCmp <= 0</td></tr>
    <tr><td>BIG_LOG2</td>            <td>big_log2</td>            <td>bigLog2</td></tr>
    <tr><td>BIG_LOWEST_SET_BIT</td>  <td>big_lowest_set_bit</td>  <td>bigLowestSetBit</td></tr>
    <tr><td>BIG_LSHIFT</td>          <td>big_lshift</td>          <td>bigLShift</td></tr>
    <tr><td>BIG_LSHIFT_ASSIGN</td>   <td>big_lshift_assign</td>   <td>bigLShiftAssign</td></tr>
    <tr><td>BIG_LT</td>              <td>big_lt</td>              <td>bigCmp < 0</td></tr>
    <tr><td>BIG_MDIV</td>            <td>big_mdiv</td>            <td>bigMDiv</td></tr>
    <tr><td>BIG_MINUS</td>           <td>big_minus</td>           <td>bigMinus</td></tr>
    <tr><td>BIG_MOD</td>             <td>big_mod</td>             <td>bigMod</td></tr>
    <tr><td>BIG_MULT</td>            <td>big_mult</td>            <td>bigMult</td></tr>
    <tr><td>BIG_MULT_ASSIGN</td>     <td>big_mult_assign</td>     <td>bigMultAssign</td></tr>
    <tr><td>BIG_NE</td>              <td>big_ne</td>              <td>bigNe</td></tr>
    <tr><td>BIG_ODD</td>             <td>big_odd</td>             <td>bigOdd</td></tr>
    <tr><td>BIG_ORD</td>             <td>big_ord</td>             <td>bigOrd</td></tr>
    <tr><td>BIG_PARSE</td>           <td>big_parse</td>           <td>bigParse</td></tr>
    <tr><td>BIG_PLUS</td>            <td>big_plus</td>            <td>(noop)</td></tr>
    <tr><td>BIG_PRED</td>            <td>big_pred</td>            <td>bigPred</td></tr>
    <tr><td>BIG_RAND</td>            <td>big_rand</td>            <td>bigRand</td></tr>
    <tr><td>BIG_REM</td>             <td>big_rem</td>             <td>bigRem</td></tr>
    <tr><td>BIG_RSHIFT</td>          <td>big_rshift</td>          <td>bigRShift</td></tr>
    <tr><td>BIG_RSHIFT_ASSIGN</td>   <td>big_rshift_assign</td>   <td>bigRShiftAssign</td></tr>
    <tr><td>BIG_SBTR</td>            <td>big_sbtr</td>            <td>bigSbtr, bigSbtrTemp</td></tr>
    <tr><td>BIG_SHRINK</td>          <td>big_shrink</td>          <td>bigShrink</td></tr>
    <tr><td>BIG_STR</td>             <td>big_str</td>             <td>bigStr</td></tr>
    <tr><td>BIG_SUCC</td>            <td>big_succ</td>            <td>bigSucc</td></tr>
    <tr><td>BIG_VALUE</td>           <td>big_value</td>           <td>bigValue</td></tr>
</table><p></p>
<a name="boolean"><h3>13.4 Actions for the type boolean</h3></a>
<p></p><table border="1">
    <tr><td>Action name</td>         <td>blnlib.c function</td>   <td>bln_rtl.c function</td></tr>
    <tr><td>BLN_AND</td>             <td>bln_and</td>             <td>&amp;&amp;</td></tr>
    <tr><td>BLN_CPY</td>             <td>bln_cpy</td>             <td>blnCpy</td></tr>
    <tr><td>BLN_CREATE</td>          <td>bln_create</td>          <td>blnCreate</td></tr>
    <tr><td>BLN_GE</td>              <td>bln_ge</td>              <td>&gt;=</td></tr>
    <tr><td>BLN_GT</td>              <td>bln_gt</td>              <td>&gt;</td></tr>
    <tr><td>BLN_ICONV</td>           <td>bln_iconv</td>           <td>&amp; 1</td></tr>
    <tr><td>BLN_LE</td>              <td>bln_le</td>              <td>&lt;=</td></tr>
    <tr><td>BLN_LT</td>              <td>bln_lt</td>              <td>&lt;</td></tr>
    <tr><td>BLN_NOT</td>             <td>bln_not</td>             <td>!</td></tr>
    <tr><td>BLN_OR</td>              <td>bln_or</td>              <td>||</td></tr>
    <tr><td>BLN_ORD</td>             <td>bln_ord</td>             <td>(inttype)</td></tr>
</table><p></p>
<a name="bstring"><h3>13.5 Actions for byte strings</h3></a>
<p></p><table border="1">
    <tr><td>Action name</td>         <td>bstlib.c function</td>   <td>bst_rtl.c function</td></tr>
    <tr><td>BST_APPEND</td>          <td>bst_append</td>          <td>bstAppend</td></tr>
    <tr><td>BST_CAT</td>             <td>bst_cat</td>             <td>bstCat</td></tr>
    <tr><td>BST_CPY</td>             <td>bst_cpy</td>             <td>bstCpy</td></tr>
    <tr><td>BST_CREATE</td>          <td>bst_create</td>          <td>bstCreate</td></tr>
    <tr><td>BST_DESTR</td>           <td>bst_destr</td>           <td>bstDestr</td></tr>
    <tr><td>BST_EMPTY</td>           <td>bst_empty</td>           <td></td></tr>
</table><p></p>
<a name="char"><h3>13.6 Actions for the type char</h3></a>
<p></p><table border="1">
    <tr><td>Action name</td>         <td>chrlib.c function</td>   <td>chr_rtl.c function</td></tr>
    <tr><td>CHR_CHR</td>             <td>chr_chr</td>             <td>(chartype)</td></tr>
    <tr><td>CHR_CMP</td>             <td>chr_cmp</td>             <td>chrCmp</td></tr>
    <tr><td>CHR_CONV</td>            <td>chr_conv</td>            <td>(noop)</td></tr>
    <tr><td>CHR_CPY</td>             <td>chr_cpy</td>             <td>chrCpy</td></tr>
    <tr><td>CHR_CREATE</td>          <td>chr_create</td>          <td>chrCreate</td></tr>
    <tr><td>CHR_DECR</td>            <td>chr_decr</td>            <td>--</td></tr>
    <tr><td>CHR_EQ</td>              <td>chr_eq</td>              <td>==</td></tr>
    <tr><td>CHR_GE</td>              <td>chr_ge</td>              <td>&gt;=</td></tr>
    <tr><td>CHR_GT</td>              <td>chr_gt</td>              <td>&gt;</td></tr>
    <tr><td>CHR_HASHCODE</td>        <td>chr_hashcode</td>        <td>(inttype)</td></tr>
    <tr><td>CHR_ICONV</td>           <td>chr_iconv</td>           <td>(chartype)</td></tr>
    <tr><td>CHR_INCR</td>            <td>chr_incr</td>            <td>++</td></tr>
    <tr><td>CHR_LE</td>              <td>chr_le</td>              <td>&lt;=</td></tr>
    <tr><td>CHR_LOW</td>             <td>chr_low</td>             <td>chrLow</td></tr>
    <tr><td>CHR_LT</td>              <td>chr_lt</td>              <td>&lt;</td></tr>
    <tr><td>CHR_NE</td>              <td>chr_ne</td>              <td>!=</td></tr>
    <tr><td>CHR_ORD</td>             <td>chr_ord</td>             <td>(inttype)</td></tr>
    <tr><td>CHR_PRED</td>            <td>chr_pred</td>            <td>-1</td></tr>
    <tr><td>CHR_STR</td>             <td>chr_str</td>             <td>chrStr</td></tr>
    <tr><td>CHR_SUCC</td>            <td>chr_succ</td>            <td>+1</td></tr>
    <tr><td>CHR_UP</td>              <td>chr_up</td>              <td>chrUp</td></tr>
    <tr><td>CHR_VALUE</td>           <td>chr_value</td>           <td>chrValue</td></tr>
</table><p></p>
<a name="commands"><h3>13.7 Actions for various directory, file and other commands</h3></a>
<p></p><table border="1">
    <tr><td>Action name</td>         <td>cmdlib.c function</td>   <td>cmd_rtl.c function</td></tr>
    <tr><td>CMD_BIG_FILESIZE</td>    <td>cmd_big_filesize</td>    <td>cmdBigFileSize</td></tr>
    <tr><td>CMD_CHDIR</td>           <td>cmd_chdir</td>           <td>cmdChdir</td></tr>
    <tr><td>CMD_CLONE_FILE</td>      <td>cmd_clone_file</td>      <td>cmdCloneFile</td></tr>
    <tr><td>CMD_CONFIG_VALUE</td>    <td>cmd_config_value</td>    <td>cmdConfigValue</td></tr>
    <tr><td>CMD_COPY_FILE</td>       <td>cmd_copy_file</td>       <td>cmdCopyFile</td></tr>
    <tr><td>CMD_FILEMODE</td>        <td>cmd_filemode</td>        <td>cmdFileMode</td></tr>
    <tr><td>CMD_FILESIZE</td>        <td>cmd_filesize</td>        <td>cmdFileSize</td></tr>
    <tr><td>CMD_FILETYPE</td>        <td>cmd_filetype</td>        <td>cmdFileType</td></tr>
    <tr><td>CMD_FILETYPE_SL</td>     <td>cmd_filetype_sl</td>     <td>cmdFileTypeSL</td></tr>
    <tr><td>CMD_GETCWD</td>          <td>cmd_getcwd</td>          <td>cmdGetcwd</td></tr>
    <tr><td>CMD_GET_ATIME</td>       <td>cmd_get_atime</td>       <td>cmdGetATime</td></tr>
    <tr><td>CMD_GET_CTIME</td>       <td>cmd_get_ctime</td>       <td>cmdGetCTime</td></tr>
    <tr><td>CMD_GET_MTIME</td>       <td>cmd_get_mtime</td>       <td>cmdGetMTime</td></tr>
    <tr><td>CMD_LS</td>              <td>cmd_ls</td>              <td>cmdLs</td></tr>
    <tr><td>CMD_MKDIR</td>           <td>cmd_mkdir</td>           <td>cmdMkdir</td></tr>
    <tr><td>CMD_MOVE</td>            <td>cmd_move</td>            <td>cmdMove</td></tr>
    <tr><td>CMD_READLINK</td>        <td>cmd_readlink</td>        <td>cmdReadlink</td></tr>
    <tr><td>CMD_REMOVE</td>          <td>cmd_remove</td>          <td>cmdRemove</td></tr>
    <tr><td>CMD_REMOVE_ANY_FILE</td> <td>cmd_remove_any_file</td> <td>cmdRemoveAnyFile</td></tr>
    <tr><td>CMD_SET_ATIME</td>       <td>cmd_set_atime</td>       <td>cmdSetATime</td></tr>
    <tr><td>CMD_SET_FILEMODE</td>    <td>cmd_set_filemode</td>    <td>cmdSetFileMode</td></tr>
    <tr><td>CMD_SET_MTIME</td>       <td>cmd_set_mtime</td>       <td>cmdSetMTime</td></tr>
    <tr><td>CMD_SHELL</td>           <td>cmd_shell</td>           <td>cmdShell</td></tr>
    <tr><td>CMD_SYMLINK</td>         <td>cmd_symlink</td>         <td>cmdSymlink</td></tr>
</table><p></p>
<a name="declarations"><h3>13.8 Actions for declarations</h3></a>
<p></p><table border="1">
    <tr><td>Action name</td>         <td>dcllib.c function</td>   <td></td></tr>
    <tr><td>DCL_ATTR</td>            <td>dcl_attr</td>            <td></td></tr>
    <tr><td>DCL_CONST</td>           <td>dcl_const</td>           <td></td></tr>
    <tr><td>DCL_ELEMENTS</td>        <td>dcl_elements</td>        <td></td></tr>
    <tr><td>DCL_FWD</td>             <td>dcl_fwd</td>             <td></td></tr>
    <tr><td>DCL_GETFUNC</td>         <td>dcl_getfunc</td>         <td></td></tr>
    <tr><td>DCL_GETOBJ</td>          <td>dcl_getobj</td>          <td></td></tr>
    <tr><td>DCL_GLOBAL</td>          <td>dcl_global</td>          <td></td></tr>
    <tr><td>DCL_IN1VAR</td>          <td>dcl_in1var</td>          <td></td></tr>
    <tr><td>DCL_IN2VAR</td>          <td>dcl_in2var</td>          <td></td></tr>
    <tr><td>DCL_INOUT1</td>          <td>dcl_inout1</td>          <td></td></tr>
    <tr><td>DCL_INOUT2</td>          <td>dcl_inout2</td>          <td></td></tr>
    <tr><td>DCL_REF1</td>            <td>dcl_ref1</td>            <td></td></tr>
    <tr><td>DCL_REF2</td>            <td>dcl_ref2</td>            <td></td></tr>
    <tr><td>DCL_SYMB</td>            <td>dcl_symb</td>            <td></td></tr>
    <tr><td>DCL_VAL1</td>            <td>dcl_val1</td>            <td></td></tr>
    <tr><td>DCL_VAL2</td>            <td>dcl_val2</td>            <td></td></tr>
    <tr><td>DCL_VAR</td>             <td>dcl_var</td>             <td></td></tr>
</table><p></p>
<a name="graphic_output"><h3>13.9 Actions to do graphic output</h3></a>
<p></p><table border="1">
    <tr><td>Action name</td>         <td>drwlib.c function</td>   <td>drw_rtl.c/drw_x11.c/drw_win.c function</td></tr>
    <tr><td>DRW_ARC</td>             <td>drw_arc</td>             <td>drwArc</td></tr>
    <tr><td>DRW_ARC2</td>            <td>drw_arc2</td>            <td>drwArc2</td></tr>
    <tr><td>DRW_BACKGROUND</td>      <td>drw_background</td>      <td>drwBackground</td></tr>
    <tr><td>DRW_CIRCLE</td>          <td>drw_circle</td>          <td>drwCircle</td></tr>
    <tr><td>DRW_CLEAR</td>           <td>drw_clear</td>           <td>drwClear</td></tr>
    <tr><td>DRW_COLOR</td>           <td>drw_color</td>           <td>drwColor</td></tr>
    <tr><td>DRW_COPYAREA</td>        <td>drw_copyarea</td>        <td>drwCopyArea</td></tr>
    <tr><td>DRW_CPY</td>             <td>drw_cpy</td>             <td>drwCpy</td></tr>
    <tr><td>DRW_CREATE</td>          <td>drw_create</td>          <td>drwCreate</td></tr>
    <tr><td>DRW_DESTR</td>           <td>drw_destr</td>           <td>drwDestr</td></tr>
    <tr><td>DRW_EMPTY</td>           <td>drw_empty</td>           <td></td></tr>
    <tr><td>DRW_EQ</td>              <td>drw_eq</td>              <td>==</td></tr>
    <tr><td>DRW_FARCCHORD</td>       <td>drw_farcchord</td>       <td>drwFArcChord</td></tr>
    <tr><td>DRW_FARCPIESLICE</td>    <td>drw_farcpieslice</td>    <td>drwFArcPieSlice</td></tr>
    <tr><td>DRW_FCIRCLE</td>         <td>drw_fcircle</td>         <td>drwFCircle</td></tr>
    <tr><td>DRW_FELLIPSE</td>        <td>drw_fellipse</td>        <td>drwFEllipse</td></tr>
    <tr><td>DRW_FLUSH</td>           <td>drw_flush</td>           <td>drwFlush</td></tr>
    <tr><td>DRW_FPOLYLINE</td>       <td>drw_fpolyLine</td>       <td>drwFPolyLine</td></tr>
    <tr><td>DRW_GENPOINTLIST</td>    <td>drw_genPointList</td>    <td>drwGenPointList</td></tr>
    <tr><td>DRW_GET</td>             <td>drw_get</td>             <td>drwGet</td></tr>
    <tr><td>DRW_HEIGHT</td>          <td>drw_height</td>          <td>drwHeight</td></tr>
    <tr><td>DRW_IMAGE</td>           <td>drw_image</td>           <td>drwImage</td></tr>
    <tr><td>DRW_LINE</td>            <td>drw_line</td>            <td>drwLine</td></tr>
    <tr><td>DRW_NE</td>              <td>drw_ne</td>              <td>!=</td></tr>
    <tr><td>DRW_NEW_PIXMAP</td>      <td>drw_new_pixmap</td>      <td>drwNewPixmap</td></tr>
    <tr><td>DRW_OPEN</td>            <td>drw_open</td>            <td>drwOpen</td></tr>
    <tr><td>DRW_OPEN_SUB_WINDOW</td> <td>drw_open_sub_window</td> <td>drwOpenSubWindow</td></tr>
    <tr><td>DRW_PARC</td>            <td>drw_parc</td>            <td>drwPArc</td></tr>
    <tr><td>DRW_PCIRCLE</td>         <td>drw_pcircle</td>         <td>drwPCircle</td></tr>
    <tr><td>DRW_PFARCCHORD</td>      <td>drw_pfarcchord</td>      <td>drwPFArcChord</td></tr>
    <tr><td>DRW_PFARCPIESLICE</td>   <td>drw_pfarcpieslice</td>   <td>drwFArcPieSlice</td></tr>
    <tr><td>DRW_PFCIRCLE</td>        <td>drw_pfcircle</td>        <td>drwPFCircle</td></tr>
    <tr><td>DRW_PFELLIPSE</td>       <td>drw_pfellipse</td>       <td>drwPFEllipse</td></tr>
    <tr><td>DRW_PLINE</td>           <td>drw_pline</td>           <td>drwPLine</td></tr>
    <tr><td>DRW_POINT</td>           <td>drw_point</td>           <td>drwPoint</td></tr>
    <tr><td>DRW_POINTER_XPOS</td>    <td>drw_pointer_xpos</td>    <td>drwPointerXpos</td></tr>
    <tr><td>DRW_POINTER_YPOS</td>    <td>drw_pointer_ypos</td>    <td>drwPointerYpos</td></tr>
    <tr><td>DRW_POLYLINE</td>        <td>drw_polyLine</td>        <td>drwPolyLine</td></tr>
    <tr><td>DRW_PPOINT</td>          <td>drw_ppoint</td>          <td>drwPPoint</td></tr>
    <tr><td>DRW_PRECT</td>           <td>drw_prect</td>           <td>drwPRect</td></tr>
    <tr><td>DRW_PUT</td>             <td>drw_put</td>             <td>drwPut</td></tr>
    <tr><td>DRW_RECT</td>            <td>drw_rect</td>            <td>drwRect</td></tr>
    <tr><td>DRW_RGBCOL</td>          <td>drw_rgbcol</td>          <td>drwRgbColor</td></tr>
    <tr><td>DRW_SETPOS</td>          <td>drw_setPos</td>          <td>drwSetPos</td></tr>
    <tr><td>DRW_SETTRANSPARENTCOLOR</td> <td>drw_setTransparentColor</td> <td>drwSetTransparentColor</td></tr>
    <tr><td>DRW_TEXT</td>            <td>drw_text</td>            <td>drwText</td></tr>
    <tr><td>DRW_WIDTH</td>           <td>drw_width</td>           <td>drwWidth</td></tr>
    <tr><td>DRW_XPOS</td>            <td>drw_xpos</td>            <td>drwXPos</td></tr>
    <tr><td>DRW_YPOS</td>            <td>drw_ypos</td>            <td>drwYPos</td></tr>
</table><p></p>
<a name="enumeration"><h3>13.10 Actions for enumeration types</h3></a>
<p></p><table border="1">
    <tr><td>Action name</td>         <td>enulib.c function</td>   <td></td></tr>
    <tr><td>ENU_CONV</td>            <td>enu_conv</td>            <td>(noop)</td></tr>
    <tr><td>ENU_CPY</td>             <td>enu_cpy</td>             <td>=</td></tr>
    <tr><td>ENU_CREATE</td>          <td>enu_create</td>          <td></td></tr>
    <tr><td>ENU_EQ</td>              <td>enu_eq</td>              <td>==</td></tr>
    <tr><td>ENU_GENLIT</td>          <td>enu_genlit</td>          <td></td></tr>
    <tr><td>ENU_ICONV2</td>          <td>enu_iconv2</td>          <td>(noop)</td></tr>
    <tr><td>ENU_NE</td>              <td>enu_ne</td>              <td>!=</td></tr>
    <tr><td>ENU_ORD2</td>            <td>enu_ord2</td>            <td>(noop)</td></tr>
    <tr><td>ENU_SIZE</td>            <td>enu_size</td>            <td></td></tr>
    <tr><td>ENU_VALUE</td>           <td>enu_value</td>           <td>enuValue</td></tr>
</table><p></p>
<a name="PRIMITIVE_FILE"><h3>13.11 Actions for the type PRIMITIVE_FILE</h3></a>
<p></p><table border="1">
    <tr><td>Action name</td>         <td>fillib.c function</td>   <td>fil_rtl.c function</td></tr>
    <tr><td>FIL_BIG_LNG</td>         <td>fil_big_lng</td>         <td>filBigLng</td></tr>
    <tr><td>FIL_BIG_SEEK</td>        <td>fil_big_seek</td>        <td>filBigSeek</td></tr>
    <tr><td>FIL_BIG_TELL</td>        <td>fil_big_tell</td>        <td>filBigTell</td></tr>
    <tr><td>FIL_CLOSE</td>           <td>fil_close</td>           <td>fclose</td></tr>
    <tr><td>FIL_CPY</td>             <td>fil_cpy</td>             <td>fltCpy</td></tr>
    <tr><td>FIL_CREATE</td>          <td>fil_create</td>          <td>fltCreate</td></tr>
    <tr><td>FIL_EMPTY</td>           <td>fil_empty</td>           <td></td></tr>
    <tr><td>FIL_EOF</td>             <td>fil_eof</td>             <td>feof</td></tr>
    <tr><td>FIL_EQ</td>              <td>fil_eq</td>              <td>==</td></tr>
    <tr><td>FIL_ERR</td>             <td>fil_err</td>             <td>stderr</td></tr>
    <tr><td>FIL_FLUSH</td>           <td>fil_flush</td>           <td>fflush</td></tr>
    <tr><td>FIL_GETC</td>            <td>fil_getc</td>            <td>fgetc</td></tr>
    <tr><td>FIL_GETS</td>            <td>fil_gets</td>            <td>filGets</td></tr>
    <tr><td>FIL_HAS_NEXT</td>        <td>fil_has_next</td>        <td>filHasNext</td></tr>
    <tr><td>FIL_IN</td>              <td>fil_in</td>              <td>stdin</td></tr>
    <tr><td>FIL_LINE_READ</td>       <td>fil_line_read</td>       <td>filLineRead</td></tr>
    <tr><td>FIL_LIT</td>             <td>fil_lit</td>             <td>filLit</td></tr>
    <tr><td>FIL_LNG</td>             <td>fil_lng</td>             <td>filLng</td></tr>
    <tr><td>FIL_NE</td>              <td>fil_ne</td>              <td>!=</td></tr>
    <tr><td>FIL_OPEN</td>            <td>fil_open</td>            <td>filOpen</td></tr>
    <tr><td>FIL_OUT</td>             <td>fil_out</td>             <td>stdout</td></tr>
    <tr><td>FIL_POPEN</td>           <td>fil_popen</td>           <td>filPopen</td></tr>
    <tr><td>FIL_PRINT</td>           <td>fil_print</td>           <td>filPrint</td></tr>
    <tr><td>FIL_SEEK</td>            <td>fil_seek</td>            <td>filSeek</td></tr>
    <tr><td>FIL_TELL</td>            <td>fil_tell</td>            <td>filTell</td></tr>
    <tr><td>FIL_VALUE</td>           <td>fil_value</td>           <td>filValue</td></tr>
    <tr><td>FIL_WORD_READ</td>       <td>fil_word_read</td>       <td>filWordRead</td></tr>
    <tr><td>FIL_WRITE</td>           <td>fil_write</td>           <td>filWrite</td></tr>
</table><p></p>
<a name="float"><h3>13.12 Actions for the type float</h3></a>
<p></p><table border="1">
    <tr><td>Action name</td>         <td>fltlib.c function</td>   <td>flt_rtl.c function</td></tr>
    <tr><td>FLT_A2TAN</td>           <td>flt_a2tan</td>           <td>atan2</td></tr>
    <tr><td>FLT_ABS</td>             <td>flt_abs</td>             <td>fabs</td></tr>
    <tr><td>FLT_ACOS</td>            <td>flt_acos</td>            <td>acos</td></tr>
    <tr><td>FLT_ADD</td>             <td>flt_add</td>             <td>+</td></tr>
    <tr><td>FLT_ASIN</td>            <td>flt_asin</td>            <td>asin</td></tr>
    <tr><td>FLT_ATAN</td>            <td>flt_atan</td>            <td>atan</td></tr>
    <tr><td>FLT_CAST</td>            <td>flt_cast</td>            <td>(x.floatvalue=a, x.intvalue)</td></tr>
    <tr><td>FLT_CEIL</td>            <td>flt_ceil</td>            <td>ceil</td></tr>
    <tr><td>FLT_CMP</td>             <td>flt_cmp</td>             <td>fltCmp</td></tr>
    <tr><td>FLT_COS</td>             <td>flt_cos</td>             <td>cos</td></tr>
    <tr><td>FLT_COSH</td>            <td>flt_cosh</td>            <td>cosh</td></tr>
    <tr><td>FLT_CPY</td>             <td>flt_cpy</td>             <td>fltCpy</td></tr>
    <tr><td>FLT_CREATE</td>          <td>flt_create</td>          <td>fltCreate</td></tr>
    <tr><td>FLT_DGTS</td>            <td>flt_dgts</td>            <td>fltDgts</td></tr>
    <tr><td>FLT_DIV</td>             <td>flt_div</td>             <td>/</td></tr>
    <tr><td>FLT_DIV_ASSIGN</td>      <td>flt_div_assign</td>      <td>/=</td></tr>
    <tr><td>FLT_EQ</td>              <td>flt_eq</td>              <td>==</td></tr>
    <tr><td>FLT_EXP</td>             <td>flt_exp</td>             <td>exp</td></tr>
    <tr><td>FLT_FLOOR</td>           <td>flt_floor</td>           <td>floor</td></tr>
    <tr><td>FLT_GE</td>              <td>flt_ge</td>              <td>&gt;=</td></tr>
    <tr><td>FLT_GROW</td>            <td>flt_grow</td>            <td>+=</td></tr>
    <tr><td>FLT_GT</td>              <td>flt_gt</td>              <td>&gt;</td></tr>
    <tr><td>FLT_HASHCODE</td>        <td>flt_hashcode</td>        <td>(x.floatvalue=a, x.intvalue)</td></tr>
    <tr><td>FLT_ICAST</td>           <td>flt_icast</td>           <td>(x.intvalue=a, x.floatvalue)</td></tr>
    <tr><td>FLT_ICONV</td>           <td>flt_iconv</td>           <td>(float)</td></tr>
    <tr><td>FLT_IFLT</td>            <td>flt_iflt</td>            <td>(float)</td></tr>
    <tr><td>FLT_IPOW</td>            <td>flt_ipow</td>            <td>fltIPow</td></tr>
    <tr><td>FLT_ISNAN</td>           <td>flt_isnan</td>           <td>isnan</td></tr>
    <tr><td>FLT_LE</td>              <td>flt_le</td>              <td>&lt;=</td></tr>
    <tr><td>FLT_LOG</td>             <td>flt_log</td>             <td>log</td></tr>
    <tr><td>FLT_LOG10</td>           <td>flt_log10</td>           <td>log10</td></tr>
    <tr><td>FLT_LT</td>              <td>flt_lt</td>              <td>&lt;</td></tr>
    <tr><td>FLT_MINUS</td>           <td>flt_minus</td>           <td>-</td></tr>
    <tr><td>FLT_MULT</td>            <td>flt_mult</td>            <td>*</td></tr>
    <tr><td>FLT_MULT_ASSIGN</td>     <td>flt_mult_assign</td>     <td>*=</td></tr>
    <tr><td>FLT_NE</td>              <td>flt_ne</td>              <td>!=</td></tr>
    <tr><td>FLT_PARSE</td>           <td>flt_parse</td>           <td>fltParse</td></tr>
    <tr><td>FLT_PLUS</td>            <td>flt_plus</td>            <td>(noop)</td></tr>
    <tr><td>FLT_POW</td>             <td>flt_pow</td>             <td>pow</td></tr>
    <tr><td>FLT_RAND</td>            <td>flt_rand</td>            <td>fltRand</td></tr>
    <tr><td>FLT_ROUND</td>           <td>flt_round</td>           <td>a&lt;0.0?-((inttype)(0.5-a)):(inttype)(0.5+a)</td></tr>
    <tr><td>FLT_SBTR</td>            <td>flt_sbtr</td>            <td>-</td></tr>
    <tr><td>FLT_SHRINK</td>          <td>flt_shrink</td>          <td>-=</td></tr>
    <tr><td>FLT_SIN</td>             <td>flt_sin</td>             <td>sin</td></tr>
    <tr><td>FLT_SINH</td>            <td>flt_sinh</td>            <td>sinh</td></tr>
    <tr><td>FLT_SQRT</td>            <td>flt_sqrt</td>            <td>sqrt</td></tr>
    <tr><td>FLT_STR</td>             <td>flt_str</td>             <td>fltStr</td></tr>
    <tr><td>FLT_TAN</td>             <td>flt_tan</td>             <td>tan</td></tr>
    <tr><td>FLT_TANH</td>            <td>flt_tanh</td>            <td>tanh</td></tr>
    <tr><td>FLT_TRUNC</td>           <td>flt_trunc</td>           <td>(inttype)</td></tr>
    <tr><td>FLT_VALUE</td>           <td>flt_value</td>           <td>fltValue</td></tr>
</table><p></p>
<a name="graphic_keyboard"><h3>13.13 Actions to support the graphic keyboard</h3></a>
<p></p><table border="1">
    <tr><td>Action name</td>         <td>drwlib.c function</td>   <td>kbd_rtl.c/drw_x11.c/drw_win.c function</td></tr>
    <tr><td>GKB_BUSY_GETC</td>       <td>gkb_busy_getc</td>       <td>gkbKeyPressed() ? gkbGetc() : 512</td></tr>
    <tr><td>GKB_GETC</td>            <td>gkb_getc</td>            <td>gkbGetc</td></tr>
    <tr><td>GKB_GETS</td>            <td>gkb_gets</td>            <td>gkbGets</td></tr>
    <tr><td>GKB_KEYPRESSED</td>      <td>gkb_keypressed</td>      <td>gkbKeyPressed</td></tr>
    <tr><td>GKB_LINE_READ</td>       <td>gkb_line_read</td>       <td>gkbLineRead</td></tr>
    <tr><td>GKB_RAW_GETC</td>        <td>gkb_raw_getc</td>        <td>gkbRawGetc</td></tr>
    <tr><td>GKB_WINDOW</td>          <td>gkb_window</td>          <td>gkbWindow</td></tr>
    <tr><td>GKB_WORD_READ</td>       <td>gkb_word_read</td>       <td>gkbWordRead</td></tr>
    <tr><td>GKB_XPOS</td>            <td>gkb_xpos</td>            <td>gkbXpos</td></tr>
    <tr><td>GKB_YPOS</td>            <td>gkb_ypos</td>            <td>gkbYpos</td></tr>
</table><p></p>
<a name="hash"><h3>13.14 Actions for hash types</h3></a>
<p></p><table border="1">
    <tr><td>Action name</td>         <td>hshlib.c function</td>   <td>hsh_rtl.c function</td></tr>
    <tr><td>HSH_CONTAINS</td>        <td>hsh_contains</td>        <td>hshContains</td></tr>
    <tr><td>HSH_CPY</td>             <td>hsh_cpy</td>             <td>hshCpy</td></tr>
    <tr><td>HSH_CREATE</td>          <td>hsh_create</td>          <td>hshCreate</td></tr>
    <tr><td>HSH_DESTR</td>           <td>hsh_destr</td>           <td>hshDestr</td></tr>
    <tr><td>HSH_EMPTY</td>           <td>hsh_empty</td>           <td>hshEmpty</td></tr>
    <tr><td>HSH_EXCL</td>            <td>hsh_excl</td>            <td>hshExcl</td></tr>
    <tr><td>HSH_FOR</td>             <td>hsh_for</td>             <td>for</td></tr>
    <tr><td>HSH_FOR_DATA_KEY</td>    <td>hsh_for_data_key</td>    <td>for</td></tr>
    <tr><td>HSH_FOR_KEY</td>         <td>hsh_for_key</td>         <td>for</td></tr>
    <tr><td>HSH_IDX</td>             <td>hsh_idx</td>             <td>hshIdx, hshIdxAddr</td></tr>
    <tr><td>HSH_IDX2</td>            <td>hsh_idx2</td>            <td></td></tr>
    <tr><td>HSH_INCL</td>            <td>hsh_incl</td>            <td>hshIncl</td></tr>
    <tr><td>HSH_KEYS</td>            <td>hsh_keys</td>            <td>hshKeys</td></tr>
    <tr><td>HSH_LNG</td>             <td>hsh_lng</td>             <td>a->size</td></tr>
    <tr><td>HSH_REFIDX</td>          <td>hsh_refidx</td>          <td></td></tr>
    <tr><td>HSH_VALUES</td>          <td>hsh_values</td>          <td>hshValues</td></tr>
</table><p></p>
<a name="integer"><h3>13.15 Actions for the type integer</h3></a>
<p></p><table border="1">
    <tr><td>Action name</td>         <td>intlib.c function</td>   <td>int_rtl.c function</td></tr>
    <tr><td>INT_ABS</td>             <td>int_abs</td>             <td>labs</td></tr>
    <tr><td>INT_ADD</td>             <td>int_add</td>             <td>+</td></tr>
    <tr><td>INT_BINOM</td>           <td>int_binom</td>           <td>intBinom</td></tr>
    <tr><td>INT_BIT_LENGTH</td>      <td>int_bit_length</td>      <td>intBitLength</td></tr>
    <tr><td>INT_CMP</td>             <td>int_cmp</td>             <td>intCmp</td></tr>
    <tr><td>INT_CONV</td>            <td>int_conv</td>            <td>(noop)</td></tr>
    <tr><td>INT_CPY</td>             <td>int_cpy</td>             <td>intCpy</td></tr>
    <tr><td>INT_CREATE</td>          <td>int_create</td>          <td>intCreate</td></tr>
    <tr><td>INT_DECR</td>            <td>int_decr</td>            <td>--</td></tr>
    <tr><td>INT_DIV</td>             <td>int_div</td>             <td>/</td></tr>
    <tr><td>INT_EQ</td>              <td>int_eq</td>              <td>==</td></tr>
    <tr><td>INT_FACT</td>            <td>int_fact</td>            <td>fact[a]</td></tr>
    <tr><td>INT_GE</td>              <td>int_ge</td>              <td>&gt;=</td></tr>
    <tr><td>INT_GROW</td>            <td>int_grow</td>            <td>+=</td></tr>
    <tr><td>INT_GT</td>              <td>int_gt</td>              <td>&gt;</td></tr>
    <tr><td>INT_HASHCODE</td>        <td>int_hashcode</td>        <td>(noop)</td></tr>
    <tr><td>INT_INCR</td>            <td>int_incr</td>            <td>++</td></tr>
    <tr><td>INT_LE</td>              <td>int_le</td>              <td>&lt;=</td></tr>
    <tr><td>INT_LOG2</td>            <td>int_log2</td>            <td>intLog2</td></tr>
    <tr><td>INT_LOWEST_SET_BIT</td>  <td>int_lowest_set_bit</td>  <td>intLowestSetBit</td></tr>
    <tr><td>INT_LPAD0</td>           <td>int_lpad0</td>           <td>intLpad0</td></tr>
    <tr><td>INT_LSHIFT</td>          <td>int_lshift</td>          <td>&lt;&lt;</td></tr>
    <tr><td>INT_LSHIFT_ASSIGN</td>   <td>int_lshift_assign</td>   <td>&lt;&lt;=</td></tr>
    <tr><td>INT_LT</td>              <td>int_lt</td>              <td>&lt;</td></tr>
    <tr><td>INT_MDIV</td>            <td>int_mdiv</td>            <td>a&gt;0&amp;&amp;b&lt;0?(a-1)/b-1:a&lt;0&amp;&amp;b&gt;0?(a+1)/b-1:a/b</td></tr>
    <tr><td>INT_MINUS</td>           <td>int_minus</td>           <td>-</td></tr>
    <tr><td>INT_MOD</td>             <td>int_mod</td>             <td>c=a%b,((a&gt;0&amp;&amp;b&lt;0)||(a&lt;0&amp;&amp;b&gt;0))&amp;&amp;c!=0?c+b:c</td></tr>
    <tr><td>INT_MULT</td>            <td>int_mult</td>            <td>*</td></tr>
    <tr><td>INT_MULT_ASSIGN</td>     <td>int_mult_assign</td>     <td>*=</td></tr>
    <tr><td>INT_NE</td>              <td>int_ne</td>              <td>!=</td></tr>
    <tr><td>INT_ODD</td>             <td>int_odd</td>             <td>&amp;1</td></tr>
    <tr><td>INT_ORD</td>             <td>int_ord</td>             <td>(noop)</td></tr>
    <tr><td>INT_PARSE</td>           <td>int_parse</td>           <td>intParse</td></tr>
    <tr><td>INT_PLUS</td>            <td>int_plus</td>            <td>(noop)</td></tr>
    <tr><td>INT_POW</td>             <td>int_pow</td>             <td>intPow</td></tr>
    <tr><td>INT_PRED</td>            <td>int_pred</td>            <td>--</td></tr>
    <tr><td>INT_RAND</td>            <td>int_rand</td>            <td>intRand</td></tr>
    <tr><td>INT_REM</td>             <td>int_rem</td>             <td>%</td></tr>
    <tr><td>INT_RSHIFT</td>          <td>int_rshift</td>          <td>a&gt;&gt;b<br />a&lt;0?~(~a&gt;&gt;b):a&gt;&gt;b</td></tr>
    <tr><td>INT_RSHIFT_ASSIGN</td>   <td>int_rshift_assign</td>   <td>a&gt;&gt;=b<br />if (a<0) a= ~(~a&gt;&gt;b); else a&gt;&gt;=b;</td></tr>
    <tr><td>INT_SBTR</td>            <td>int_sbtr</td>            <td>-</td></tr>
    <tr><td>INT_SHRINK</td>          <td>int_shrink</td>          <td>-=</td></tr>
    <tr><td>INT_SQRT</td>            <td>int_sqrt</td>            <td>intSqrt</td></tr>
    <tr><td>INT_STR</td>             <td>int_str</td>             <td>intStr</td></tr>
    <tr><td>INT_STR_BASED</td>       <td>int_str_based</td>       <td>intStrBased</td></tr>
    <tr><td>INT_SUCC</td>            <td>int_succ</td>            <td>+1</td></tr>
    <tr><td>INT_VALUE</td>           <td>int_value</td>           <td>intValue</td></tr>
</table><p></p>
<a name="interface"><h3>13.16 Actions for interface types</h3></a>
<p></p><table border="1">
    <tr><td>Action name</td>         <td>itflib.c function</td>   <td></td></tr>
    <tr><td>ITF_CONV2</td>           <td>itf_conv2</td>           <td>(noop)</td></tr>
    <tr><td>ITF_CPY</td>             <td>itf_cpy</td>             <td>=</td></tr>
    <tr><td>ITF_CPY2</td>            <td>itf_cpy2</td>            <td>=</td></tr>
    <tr><td>ITF_CREATE</td>          <td>itf_create</td>          <td></td></tr>
    <tr><td>ITF_CREATE2</td>         <td>itf_create2</td>         <td></td></tr>
    <tr><td>ITF_EQ</td>              <td>itf_eq</td>              <td>==</td></tr>
    <tr><td>ITF_NE</td>              <td>itf_ne</td>              <td>!=</td></tr>
    <tr><td>ITF_SELECT</td>          <td>itf_select</td>          <td></td></tr>
</table><p></p>
<a name="console_keyboard"><h3>13.17 Actions to support the text (console) screen keyboard</h3></a>
<p></p><table border="1">
    <tr><td>Action name</td>         <td>kbdlib.c function</td>   <td>kbd_rtl.c/kbd_inf.c function</td></tr>
    <tr><td>KBD_BUSY_GETC</td>       <td>kbd_busy_getc</td>       <td>kbdKeyPressed() ? kbdGetc() : 512</td></tr>
    <tr><td>KBD_GETC</td>            <td>kbd_getc</td>            <td>kbdGetc</td></tr>
    <tr><td>KBD_GETS</td>            <td>kbd_gets</td>            <td>kbdGets</td></tr>
    <tr><td>KBD_KEYPRESSED</td>      <td>kbd_keypressed</td>      <td>kbdKeyPressed</td></tr>
    <tr><td>KBD_LINE_READ</td>       <td>kbd_line_read</td>       <td>kbdLineRead</td></tr>
    <tr><td>KBD_RAW_GETC</td>        <td>kbd_raw_getc</td>        <td>kbdRawGetc</td></tr>
    <tr><td>KBD_WORD_READ</td>       <td>kbd_word_read</td>       <td>kbdWordRead</td></tr>
</table><p></p>
<a name="list"><h3>13.18 Actions for the list type</h3></a>
<p></p><table border="1">
    <tr><td>Action name</td>         <td>lstlib.c function</td>   <td></td></tr>
    <tr><td>LST_CAT</td>             <td>lst_cat</td>             <td></td></tr>
    <tr><td>LST_CPY</td>             <td>lst_cpy</td>             <td></td></tr>
    <tr><td>LST_CREATE</td>          <td>lst_create</td>          <td></td></tr>
    <tr><td>LST_DESTR</td>           <td>lst_destr</td>           <td></td></tr>
    <tr><td>LST_ELEM</td>            <td>lst_elem</td>            <td></td></tr>
    <tr><td>LST_EMPTY</td>           <td>lst_empty</td>           <td></td></tr>
    <tr><td>LST_EXCL</td>            <td>lst_excl</td>            <td></td></tr>
    <tr><td>LST_HEAD</td>            <td>lst_head</td>            <td></td></tr>
    <tr><td>LST_IDX</td>             <td>lst_idx</td>             <td></td></tr>
    <tr><td>LST_INCL</td>            <td>lst_incl</td>            <td></td></tr>
    <tr><td>LST_LNG</td>             <td>lst_lng</td>             <td></td></tr>
    <tr><td>LST_RANGE</td>           <td>lst_range</td>           <td></td></tr>
    <tr><td>LST_TAIL</td>            <td>lst_tail</td>            <td></td></tr>
</table><p></p>
<a name="proc"><h3>13.19 Actions for proc operations and statements</h3></a>
<p></p><table border="1">
    <tr><td>Action name</td>         <td>prclib.c function</td>   <td></td></tr>
    <tr><td>PRC_ARGS</td>            <td>prc_args</td>            <td></td></tr>
    <tr><td>PRC_BEGIN</td>           <td>prc_begin</td>           <td></td></tr>
    <tr><td>PRC_BLOCK</td>           <td>prc_block</td>           <td></td></tr>
    <tr><td>PRC_BLOCK_DEF</td>       <td>prc_block_def</td>       <td></td></tr>
    <tr><td>PRC_CASE</td>            <td>prc_case</td>            <td>switch</td></tr>
    <tr><td>PRC_CASE_DEF</td>        <td>prc_case_def</td>        <td>switch</td></tr>
    <tr><td>PRC_CPY</td>             <td>prc_cpy</td>             <td></td></tr>
    <tr><td>PRC_CREATE</td>          <td>prc_create</td>          <td></td></tr>
    <tr><td>PRC_DECLS</td>           <td>prc_decls</td>           <td></td></tr>
    <tr><td>PRC_DYNAMIC</td>         <td>prc_dynamic</td>         <td></td></tr>
    <tr><td>PRC_EXIT</td>            <td>prc_exit</td>            <td>exit</td></tr>
    <tr><td>PRC_FOR_DOWNTO</td>      <td>prc_for_downto</td>      <td>for</td></tr>
    <tr><td>PRC_FOR_TO</td>          <td>prc_for_to</td>          <td>for</td></tr>
    <tr><td>PRC_HEAPSTAT</td>        <td>prc_heapstat</td>        <td></td></tr>
    <tr><td>PRC_HSIZE</td>           <td>prc_hsize</td>           <td>heapsize</td></tr>
    <tr><td>PRC_IF</td>              <td>prc_if</td>              <td>if</td></tr>
    <tr><td>PRC_IF_ELSIF</td>        <td>prc_if_elsif</td>        <td>if</td></tr>
    <tr><td>PRC_INCLUDE</td>         <td>prc_include</td>         <td></td></tr>
    <tr><td>PRC_LOCAL</td>           <td>prc_local</td>           <td></td></tr>
    <tr><td>PRC_NOOP</td>            <td>prc_noop</td>            <td>prcNoop</td></tr>
    <tr><td>PRC_RAISE</td>           <td>prc_raise</td>           <td>raise_error</td></tr>
    <tr><td>PRC_REPEAT</td>          <td>prc_repeat</td>          <td>do</td></tr>
    <tr><td>PRC_RES_BEGIN</td>       <td>prc_res_begin</td>       <td></td></tr>
    <tr><td>PRC_RES_LOCAL</td>       <td>prc_res_local</td>       <td></td></tr>
    <tr><td>PRC_RETURN</td>          <td>prc_return</td>          <td></td></tr>
    <tr><td>PRC_RETURN2</td>         <td>prc_return2</td>         <td></td></tr>
    <tr><td>PRC_SETTRACE</td>        <td>prc_settrace</td>        <td></td></tr>
    <tr><td>PRC_TRACE</td>           <td>prc_trace</td>           <td></td></tr>
    <tr><td>PRC_VARFUNC</td>         <td>prc_varfunc</td>         <td></td></tr>
    <tr><td>PRC_VARFUNC2</td>        <td>prc_varfunc2</td>        <td></td></tr>
    <tr><td>PRC_WHILE</td>           <td>prc_while</td>           <td>while</td></tr>
</table><p></p>
<a name="program"><h3>13.20 Actions for the type program</h3></a>
<p></p><table border="1">
    <tr><td>Action name</td>         <td>prglib.c function</td>   <td>prg_comp.c function</td></tr>
    <tr><td>PRG_CPY</td>             <td>prg_cpy</td>             <td>prgCpy</td></tr>
    <tr><td>PRG_CREATE</td>          <td>prg_create</td>          <td></td></tr>
    <tr><td>PRG_DECL_OBJECTS</td>    <td>prg_decl_objects</td>    <td>prgDeclObjects</td></tr>
    <tr><td>PRG_DESTR</td>           <td>prg_destr</td>           <td></td></tr>
    <tr><td>PRG_EMPTY</td>           <td>prg_empty</td>           <td></td></tr>
    <tr><td>PRG_EQ</td>              <td>prg_eq</td>              <td>==</td></tr>
    <tr><td>PRG_ERROR_COUNT</td>     <td>prg_error_count</td>     <td>prgErrorCount</td></tr>
    <tr><td>PRG_EVAL</td>            <td>prg_eval</td>            <td>prgEval</td></tr>
    <tr><td>PRG_EXEC</td>            <td>prg_exec</td>            <td>prgExec</td></tr>
    <tr><td>PRG_FIL_PARSE</td>       <td>prg_fil_parse</td>       <td>prgFilParse</td></tr>
    <tr><td>PRG_FIND</td>            <td>prg_find</td>            <td></td></tr>
    <tr><td>PRG_MATCH</td>           <td>prg_match</td>           <td>prgMatch</td></tr>
    <tr><td>PRG_NAME</td>            <td>prg_name</td>            <td>arg_0</td></tr>
    <tr><td>PRG_NE</td>              <td>prg_ne</td>              <td>!=</td></tr>
    <tr><td>PRG_PROG</td>            <td>prg_prog</td>            <td></td></tr>
    <tr><td>PRG_STR_PARSE</td>       <td>prg_str_parse</td>       <td>prgStrParse</td></tr>
    <tr><td>PRG_SYOBJECT</td>        <td>prg_syobject</td>        <td>prgSyobject</td></tr>
    <tr><td>PRG_SYSVAR</td>          <td>prg_sysvar</td>          <td>prgSysvar</td></tr>
    <tr><td>PRG_VALUE</td>           <td>prg_value</td>           <td>prgValue</td></tr>
</table><p></p>
<a name="reference"><h3>13.21 Actions for the type reference</h3></a>
<p></p><table border="1">
    <tr><td>Action name</td>         <td>reflib.c function</td>   <td>ref_data.c function</td></tr>
    <tr><td>REF_ADDR</td>            <td>ref_addr</td>            <td>&</td></tr>
    <tr><td>REF_ALLOC</td>           <td>ref_alloc</td>           <td>refAlloc</td></tr>
    <tr><td>REF_ARRMAXIDX</td>       <td>ref_arrmaxidx</td>       <td>refArrmaxidx</td></tr>
    <tr><td>REF_ARRMINIDX</td>       <td>ref_arrminidx</td>       <td>refArrminidx</td></tr>
    <tr><td>REF_ARRTOLIST</td>       <td>ref_arrtolist</td>       <td>refArrtolist</td></tr>
    <tr><td>REF_BODY</td>            <td>ref_body</td>            <td>refBody</td></tr>
    <tr><td>REF_BUILD</td>           <td>ref_build</td>           <td></td></tr>
    <tr><td>REF_CATEGORY</td>        <td>ref_category</td>        <td>refCategory</td></tr>
    <tr><td>REF_CAT_PARSE</td>       <td>ref_cat_parse</td>       <td>refCatParse</td></tr>
    <tr><td>REF_CAT_STR</td>         <td>ref_cat_str</td>         <td>refCatStr</td></tr>
    <tr><td>REF_CMP</td>             <td>ref_cmp</td>             <td>refCmp</td></tr>
    <tr><td>REF_CONTENT</td>         <td>ref_content</td>         <td></td></tr>
    <tr><td>REF_CONV</td>            <td>ref_conv</td>            <td>(noop)</td></tr>
    <tr><td>REF_CPY</td>             <td>ref_cpy</td>             <td>refCpy</td></tr>
    <tr><td>REF_CREATE</td>          <td>ref_create</td>          <td>refCreate</td></tr>
    <tr><td>REF_DEREF</td>           <td>ref_deref</td>           <td></td></tr>
    <tr><td>REF_EQ</td>              <td>ref_eq</td>              <td>==</td></tr>
    <tr><td>REF_FILE</td>            <td>ref_file</td>            <td>refFile</td></tr>
    <tr><td>REF_FIND</td>            <td>ref_find</td>            <td></td></tr>
    <tr><td>REF_HASHCODE</td>        <td>ref_hashcode</td>        <td>(inttype)(((uinttype)a)&gt;&gt;6)</td></tr>
    <tr><td>REF_ISSYMB</td>          <td>ref_issymb</td>          <td></td></tr>
    <tr><td>REF_ISVAR</td>           <td>ref_isvar</td>           <td>refIsvar</td></tr>
    <tr><td>REF_ITFTOSCT</td>        <td>ref_itftosct</td>        <td>refItftosct</td></tr>
    <tr><td>REF_LINE</td>            <td>ref_line</td>            <td>refLine</td></tr>
    <tr><td>REF_LOCAL_CONSTS</td>    <td>ref_local_consts</td>    <td>refLocalConsts</td></tr>
    <tr><td>REF_LOCAL_VARS</td>      <td>ref_local_vars</td>      <td>refLocalVars</td></tr>
    <tr><td>REF_MKREF</td>           <td>ref_mkref</td>           <td></td></tr>
    <tr><td>REF_NAME</td>            <td>ref_name</td>            <td></td></tr>
    <tr><td>REF_NE</td>              <td>ref_ne</td>              <td>!=</td></tr>
    <tr><td>REF_NIL</td>             <td>ref_nil</td>             <td></td></tr>
    <tr><td>REF_NUM</td>             <td>ref_num</td>             <td>refNum</td></tr>
    <tr><td>REF_PARAMS</td>          <td>ref_params</td>          <td>refParams</td></tr>
    <tr><td>REF_PROG</td>            <td>ref_prog</td>            <td></td></tr>
    <tr><td>REF_RESINI</td>          <td>ref_resini</td>          <td>refResini</td></tr>
    <tr><td>REF_RESULT</td>          <td>ref_result</td>          <td>refResult</td></tr>
    <tr><td>REF_SCAN</td>            <td>ref_scan</td>            <td></td></tr>
    <tr><td>REF_SCTTOLIST</td>       <td>ref_scttolist</td>       <td>refScttolist</td></tr>
    <tr><td>REF_SELECT</td>          <td>ref_select</td>          <td>a->stru[b]</td></tr>
    <tr><td>REF_SETCATEGORY</td>     <td>ref_setcategory</td>     <td>refSetCategory</td></tr>
    <tr><td>REF_SETPARAMS</td>       <td>ref_setparams</td>       <td>refSetParams</td></tr>
    <tr><td>REF_SETTYPE</td>         <td>ref_settype</td>         <td>refSetType</td></tr>
    <tr><td>REF_STR</td>             <td>ref_str</td>             <td>refStr</td></tr>
    <tr><td>REF_SYMB</td>            <td>ref_symb</td>            <td></td></tr>
    <tr><td>REF_TRACE</td>           <td>ref_trace</td>           <td>printf</td></tr>
    <tr><td>REF_TYPE</td>            <td>ref_type</td>            <td>refType</td></tr>
    <tr><td>REF_VALUE</td>           <td>ref_value</td>           <td>refValue</td></tr>
</table><p></p>
<a name="ref_list"><h3>13.22 Actions for the type ref_list</h3></a>
<p></p><table border="1">
    <tr><td>Action name</td>         <td>rfllib.c function</td>   <td>rfl_data.c function</td></tr>
    <tr><td>RFL_APPEND</td>          <td>rfl_append</td>          <td>rflAppend</td></tr>
    <tr><td>RFL_CAT</td>             <td>rfl_cat</td>             <td>rflCat</td></tr>
    <tr><td>RFL_CPY</td>             <td>rfl_cpy</td>             <td>rflCpy</td></tr>
    <tr><td>RFL_CREATE</td>          <td>rfl_create</td>          <td>rflCreate</td></tr>
    <tr><td>RFL_DESTR</td>           <td>rfl_destr</td>           <td>rflDestr</td></tr>
    <tr><td>RFL_ELEM</td>            <td>rfl_elem</td>            <td>rflElem</td></tr>
    <tr><td>RFL_ELEMCPY</td>         <td>rfl_elemcpy</td>         <td>rflElemcpy</td></tr>
    <tr><td>RFL_EMPTY</td>           <td>rfl_empty</td>           <td></td></tr>
    <tr><td>RFL_EQ</td>              <td>rfl_eq</td>              <td>rflEq</td></tr>
    <tr><td>RFL_EXCL</td>            <td>rfl_excl</td>            <td></td></tr>
    <tr><td>RFL_EXPR</td>            <td>rfl_expr</td>            <td></td></tr>
    <tr><td>RFL_FOR</td>             <td>rfl_for</td>             <td>for</td></tr>
    <tr><td>RFL_HEAD</td>            <td>rfl_head</td>            <td>rflHead</td></tr>
    <tr><td>RFL_IDX</td>             <td>rfl_idx</td>             <td>rflIdx</td></tr>
    <tr><td>RFL_INCL</td>            <td>rfl_incl</td>            <td>rflIncl</td></tr>
    <tr><td>RFL_IPOS</td>            <td>rfl_ipos</td>            <td>rflIpos</td></tr>
    <tr><td>RFL_LNG</td>             <td>rfl_lng</td>             <td>rflLng</td></tr>
    <tr><td>RFL_MKLIST</td>          <td>rfl_mklist</td>          <td>rflMklist</td></tr>
    <tr><td>RFL_NE</td>              <td>rfl_ne</td>              <td>rflNe</td></tr>
    <tr><td>RFL_NOT_ELEM</td>        <td>rfl_not_elem</td>        <td>!rflElem</td></tr>
    <tr><td>RFL_POS</td>             <td>rfl_pos</td>             <td>rflPos</td></tr>
    <tr><td>RFL_RANGE</td>           <td>rfl_range</td>           <td>rflRange</td></tr>
    <tr><td>RFL_SETVALUE</td>        <td>rfl_setvalue</td>        <td>rflSetvalue</td></tr>
    <tr><td>RFL_TAIL</td>            <td>rfl_tail</td>            <td>rflTail</td></tr>
    <tr><td>RFL_TRACE</td>           <td>rfl_trace</td>           <td></td></tr>
    <tr><td>RFL_VALUE</td>           <td>rfl_value</td>           <td>rflValue</td></tr>
</table><p></p>
<a name="console_output"><h3>13.23 Actions for text (console) screen output</h3></a>
<p></p><table border="1">
    <tr><td>Action name</td>         <td>scrlib.c function</td>   <td>scr_inf.c/scr_rtl.c/scr_win.c function</td></tr>
    <tr><td>SCR_CLEAR</td>           <td>scr_clear</td>           <td>scrClear</td></tr>
    <tr><td>SCR_CURSOR</td>          <td>scr_cursor</td>          <td>scrCursor</td></tr>
    <tr><td>SCR_FLUSH</td>           <td>scr_flush</td>           <td>scrFlush</td></tr>
    <tr><td>SCR_HEIGHT</td>          <td>scr_height</td>          <td>scrHeight</td></tr>
    <tr><td>SCR_H_SCL</td>           <td>scr_h_scl</td>           <td>scrHScroll</td></tr>
    <tr><td>SCR_OPEN</td>            <td>scr_open</td>            <td>scrOpen</td></tr>
    <tr><td>SCR_SETPOS</td>          <td>scr_setpos</td>          <td>scrSetpos</td></tr>
    <tr><td>SCR_V_SCL</td>           <td>scr_v_scl</td>           <td>scrVScroll</td></tr>
    <tr><td>SCR_WIDTH</td>           <td>scr_width</td>           <td>scrWidth</td></tr>
    <tr><td>SCR_WRITE</td>           <td>scr_write</td>           <td>scrWrite</td></tr>
</table><p></p>
<a name="struct"><h3>13.24 Actions for struct types</h3></a>
<p></p><table border="1">
    <tr><td>Action name</td>         <td>sctlib.c function</td>   <td></td></tr>
    <tr><td>SCT_ALLOC</td>           <td>sct_alloc</td>           <td></td></tr>
    <tr><td>SCT_CAT</td>             <td>sct_cat</td>             <td></td></tr>
    <tr><td>SCT_CONV</td>            <td>sct_conv</td>            <td></td></tr>
    <tr><td>SCT_CPY</td>             <td>sct_cpy</td>             <td>cpy_ ...</td></tr>
    <tr><td>SCT_CREATE</td>          <td>sct_create</td>          <td>create_ ...</td></tr>
    <tr><td>SCT_DESTR</td>           <td>sct_destr</td>           <td>destr_ ...</td></tr>
    <tr><td>SCT_ELEM</td>            <td>sct_elem</td>            <td></td></tr>
    <tr><td>SCT_EMPTY</td>           <td>sct_empty</td>           <td></td></tr>
    <tr><td>SCT_INCL</td>            <td>sct_incl</td>            <td></td></tr>
    <tr><td>SCT_LNG</td>             <td>sct_lng</td>             <td></td></tr>
    <tr><td>SCT_REFIDX</td>          <td>sct_refidx</td>          <td></td></tr>
    <tr><td>SCT_SELECT</td>          <td>sct_select</td>          <td>a->stru[b]</td></tr>
</table><p></p>
<a name="set"><h3>13.25 Actions for set types</h3></a>
<p></p><table border="1">
    <tr><td>Action name</td>         <td>setlib.c function</td>   <td>set_rtl.c function</td></tr>
    <tr><td>SET_ARRLIT</td>          <td>set_arrlit</td>          <td>setArrlit</td></tr>
    <tr><td>SET_BASELIT</td>         <td>set_baselit</td>         <td>setBaselit</td></tr>
    <tr><td>SET_CARD</td>            <td>set_card</td>            <td>setCard</td></tr>
    <tr><td>SET_CMP</td>             <td>set_cmp</td>             <td>setCmp</td></tr>
    <tr><td>SET_CONV</td>            <td>set_conv</td>            <td>(noop)</td></tr>
    <tr><td>SET_CPY</td>             <td>set_cpy</td>             <td>setCpy</td></tr>
    <tr><td>SET_CREATE</td>          <td>set_create</td>          <td>setCreate</td></tr>
    <tr><td>SET_DESTR</td>           <td>set_destr</td>           <td>setDestr</td></tr>
    <tr><td>SET_DIFF</td>            <td>set_diff</td>            <td>setDiff</td></tr>
    <tr><td>SET_ELEM</td>            <td>set_elem</td>            <td>setElem</td></tr>
    <tr><td>SET_EMPTY</td>           <td>set_empty</td>           <td></td></tr>
    <tr><td>SET_EQ</td>              <td>set_eq</td>              <td>setEq</td></tr>
    <tr><td>SET_EXCL</td>            <td>set_excl</td>            <td>setExcl</td></tr>
    <tr><td>SET_GE</td>              <td>set_ge</td>              <td>setIsSubset(b, a)</td></tr>
    <tr><td>SET_GT</td>              <td>set_gt</td>              <td>setIsProperSubset(b, a)</td></tr>
    <tr><td>SET_HASHCODE</td>        <td>set_hashcode</td>        <td>setHashCode</td></tr>
    <tr><td>SET_ICONV</td>           <td>set_iconv</td>           <td>setIConv</td></tr>
    <tr><td>SET_INCL</td>            <td>set_incl</td>            <td>setIncl</td></tr>
    <tr><td>SET_INTERSECT</td>       <td>set_intersect</td>       <td>setIntersect</td></tr>
    <tr><td>SET_LE</td>              <td>set_le</td>              <td>setIsSubset</td></tr>
    <tr><td>SET_LT</td>              <td>set_lt</td>              <td>setIsProperSubset</td></tr>
    <tr><td>SET_MAX</td>             <td>set_max</td>             <td>setMax</td></tr>
    <tr><td>SET_MIN</td>             <td>set_min</td>             <td>setMin</td></tr>
    <tr><td>SET_NE</td>              <td>set_ne</td>              <td>setNe</td></tr>
    <tr><td>SET_NOT_ELEM</td>        <td>set_not_elem</td>        <td>setNotElem</td></tr>
    <tr><td>SET_RAND</td>            <td>set_rand</td>            <td>setRand</td></tr>
    <tr><td>SET_SCONV</td>           <td>set_sconv</td>           <td>setSConv</td></tr>
    <tr><td>SET_SYMDIFF</td>         <td>set_symdiff</td>         <td>setSymdiff</td></tr>
    <tr><td>SET_UNION</td>           <td>set_union</td>           <td>setUnion</td></tr>
    <tr><td>SET_VALUE</td>           <td>set_value</td>           <td>setValue</td></tr>
</table><p></p>
<a name="PRIMITIVE_SOCKET"><h3>13.26 Actions for the type PRIMITIVE_SOCKET</h3></a>
<p></p><table border="1">
    <tr><td>Action name</td>         <td>strlib.c function</td>   <td>str_rtl.c function</td></tr>
    <tr><td>SOC_ACCEPT</td>          <td>soc_accept</td>          <td>socAccept</td></tr>
    <tr><td>SOC_BIND</td>            <td>soc_bind</td>            <td>socBind</td></tr>
    <tr><td>SOC_CLOSE</td>           <td>soc_close</td>           <td>socClose</td></tr>
    <tr><td>SOC_CONNECT</td>         <td>soc_connect</td>         <td>socConnect</td></tr>
    <tr><td>SOC_CPY</td>             <td>soc_cpy</td>             <td>=</td></tr>
    <tr><td>SOC_CREATE</td>          <td>soc_create</td>          <td></td></tr>
    <tr><td>SOC_EMPTY</td>           <td>soc_empty</td>           <td></td></tr>
    <tr><td>SOC_EQ</td>              <td>soc_eq</td>              <td>==</td></tr>
    <tr><td>SOC_GETC</td>            <td>soc_getc</td>            <td>socGetc</td></tr>
    <tr><td>SOC_GETS</td>            <td>soc_gets</td>            <td>socGets</td></tr>
    <tr><td>SOC_INET_ADDR</td>       <td>soc_inet_addr</td>       <td>socInetAddr</td></tr>
    <tr><td>SOC_INET_LOCAL_ADDR</td> <td>soc_inet_local_addr</td> <td>socInetLocalAddr</td></tr>
    <tr><td>SOC_INET_SERV_ADDR</td>  <td>soc_inet_serv_addr</td>  <td>socInetServAddr</td></tr>
    <tr><td>SOC_LINE_READ</td>       <td>soc_line_read</td>       <td>socLineRead</td></tr>
    <tr><td>SOC_LISTEN</td>          <td>soc_listen</td>          <td>socListen</td></tr>
    <tr><td>SOC_NE</td>              <td>soc_ne</td>              <td>!=</td></tr>
    <tr><td>SOC_RECV</td>            <td>soc_recv</td>            <td>socRecv</td></tr>
    <tr><td>SOC_RECVFROM</td>        <td>soc_recvfrom</td>        <td>socRecvfrom</td></tr>
    <tr><td>SOC_SEND</td>            <td>soc_send</td>            <td>socSend</td></tr>
    <tr><td>SOC_SENDTO</td>          <td>soc_sendto</td>          <td>socSendto</td></tr>
    <tr><td>SOC_SOCKET</td>          <td>soc_socket</td>          <td>socSocket</td></tr>
    <tr><td>SOC_WORD_READ</td>       <td>soc_word_read</td>       <td>socWordRead</td></tr>
    <tr><td>SOC_WRITE</td>           <td>soc_write</td>           <td>socWrite</td></tr>
</table><p></p>
<a name="string"><h3>13.27 Actions for the type string</h3></a>
<p></p><table border="1">
    <tr><td>Action name</td>         <td>strlib.c function</td>   <td>str_rtl.c function</td></tr>
    <tr><td>STR_APPEND</td>          <td>str_append</td>          <td>strAppend</td></tr>
    <tr><td>STR_CAT</td>             <td>str_cat</td>             <td>strConcat, strConcatTemp</td></tr>
    <tr><td>STR_CHIPOS</td>          <td>str_chipos</td>          <td>strChIpos</td></tr>
    <tr><td>STR_CHPOS</td>           <td>str_chpos</td>           <td>strChPos</td></tr>
    <tr><td>STR_CHSPLIT</td>         <td>str_chsplit</td>         <td>strChSplit</td></tr>
    <tr><td>STR_CLIT</td>            <td>str_clit</td>            <td>strCLit</td></tr>
    <tr><td>STR_CMP</td>             <td>str_cmp</td>             <td>strCompare</td></tr>
    <tr><td>STR_CPY</td>             <td>str_cpy</td>             <td>strCopy</td></tr>
    <tr><td>STR_CREATE</td>          <td>str_create</td>          <td>strCreate</td></tr>
    <tr><td>STR_DESTR</td>           <td>str_destr</td>           <td>strDestr</td></tr>
    <tr><td>STR_ELEMCPY</td>         <td>str_elemcpy</td>         <td>a-&gt;mem[b-1]=c</td></tr>
    <tr><td>STR_EQ</td>              <td>str_eq</td>              <td>a->size==b->size&amp;&amp;memcmp(a,b,a->size*sizeof(strelemtype))==0</td></tr>
    <tr><td>STR_GE</td>              <td>str_ge</td>              <td>strGe</td></tr>
    <tr><td>STR_GETENV</td>          <td>str_getenv</td>          <td>strGetenv</td></tr>
    <tr><td>STR_GT</td>              <td>str_gt</td>              <td>strGt</td></tr>
    <tr><td>STR_HASHCODE</td>        <td>str_hashcode</td>        <td>strHashCode</td></tr>
    <tr><td>STR_HEAD</td>            <td>str_head</td>            <td>strHead</td></tr>
    <tr><td>STR_IDX</td>             <td>str_idx</td>             <td>a-&gt;mem[b-1]</td></tr>
    <tr><td>STR_IPOS</td>            <td>str_ipos</td>            <td>strIpos</td></tr>
    <tr><td>STR_LE</td>              <td>str_le</td>              <td>strLe</td></tr>
    <tr><td>STR_LIT</td>             <td>str_lit</td>             <td>strLit</td></tr>
    <tr><td>STR_LNG</td>             <td>str_lng</td>             <td>a->size</td></tr>
    <tr><td>STR_LOW</td>             <td>str_low</td>             <td>strLow, strLowTemp</td></tr>
    <tr><td>STR_LPAD</td>            <td>str_lpad</td>            <td>strLpad</td></tr>
    <tr><td>STR_LPAD0</td>           <td>str_lpad0</td>           <td>strLpad0, strLpad0Temp</td></tr>
    <tr><td>STR_LT</td>              <td>str_lt</td>              <td>strLt</td></tr>
    <tr><td>STR_MULT</td>            <td>str_mult</td>            <td>strMult</td></tr>
    <tr><td>STR_NE</td>              <td>str_ne</td>              <td>a->size==b->size&amp;&amp;memcmp(a,b,a->size*sizeof(strelemtype))==0</td></tr>
    <tr><td>STR_POS</td>             <td>str_pos</td>             <td>strPos</td></tr>
    <tr><td>STR_PUSH</td>            <td>str_push</td>            <td>strPush</td></tr>
    <tr><td>STR_RANGE</td>           <td>str_range</td>           <td>strRange</td></tr>
    <tr><td>STR_RCHPOS</td>          <td>str_rchpos</td>          <td>strRChPos</td></tr>
    <tr><td>STR_REPL</td>            <td>str_repl</td>            <td>strRepl</td></tr>
    <tr><td>STR_RPAD</td>            <td>str_rpad</td>            <td>strRpad</td></tr>
    <tr><td>STR_RPOS</td>            <td>str_rpos</td>            <td>strRpos</td></tr>
    <tr><td>STR_SPLIT</td>           <td>str_split</td>           <td>strSplit</td></tr>
    <tr><td>STR_STR</td>             <td>str_str</td>             <td>(noop)</td></tr>
    <tr><td>STR_SUBSTR</td>          <td>str_substr</td>          <td>strSubstr</td></tr>
    <tr><td>STR_TAIL</td>            <td>str_tail</td>            <td>strTail</td></tr>
    <tr><td>STR_TOUTF8</td>          <td>str_toutf8</td>          <td>strToUtf8</td></tr>
    <tr><td>STR_TRIM</td>            <td>str_trim</td>            <td>strTrim</td></tr>
    <tr><td>STR_UP</td>              <td>str_up</td>              <td>strUp, strUpTemp</td></tr>
    <tr><td>STR_UTF8TOSTRI</td>      <td>str_utf8tostri</td>      <td>strUtf8ToStri</td></tr>
    <tr><td>STR_VALUE</td>           <td>str_value</td>           <td>strValue</td></tr>
</table><p></p>
<a name="time"><h3>13.28 Actions for the type time</h3></a>
<p></p><table border="1">
    <tr><td>Action name</td>         <td>timlib.c function</td>   <td>tim_unx.c/tim_win.c function</td></tr>
    <tr><td>TIM_AWAIT</td>           <td>tim_await</td>           <td>timAwait</td></tr>
    <tr><td>TIM_FROM_TIMESTAMP</td>  <td>tim_from_timestamp</td>  <td>timFromTimestamp</td></tr>
    <tr><td>TIM_NOW</td>             <td>tim_now</td>             <td>timNow</td></tr>
    <tr><td>TIM_SET_LOCAL_TZ</td>    <td>tim_set_local_tz</td>    <td>timSetLocalTZ</td></tr>
</table><p></p>
<a name="type"><h3>13.29 Actions for the type type</h3></a>
<p></p><table border="1">
    <tr><td>Action name</td>         <td>typlib.c function</td>   <td>typ_data.c function</td></tr>
    <tr><td>TYP_ADDINTERFACE</td>    <td>typ_addinterface</td>    <td></td></tr>
    <tr><td>TYP_CMP</td>             <td>typ_cmp</td>             <td>typCmp</td></tr>
    <tr><td>TYP_CPY</td>             <td>typ_cpy</td>             <td>typCpy</td></tr>
    <tr><td>TYP_CREATE</td>          <td>typ_create</td>          <td>typCreate</td></tr>
    <tr><td>TYP_DESTR</td>           <td>typ_destr</td>           <td>typDestr</td></tr>
    <tr><td>TYP_EQ</td>              <td>typ_eq</td>              <td>==</td></tr>
    <tr><td>TYP_FUNC</td>            <td>typ_func</td>            <td>typFunc</td></tr>
    <tr><td>TYP_GENSUB</td>          <td>typ_gensub</td>          <td></td></tr>
    <tr><td>TYP_GENTYPE</td>         <td>typ_gentype</td>         <td></td></tr>
    <tr><td>TYP_HASHCODE</td>        <td>typ_hashcode</td>        <td>(inttype)(((uinttype)a)&gt;&gt;6)</td></tr>
    <tr><td>TYP_ISDECLARED</td>      <td>typ_isdeclared</td>      <td></td></tr>
    <tr><td>TYP_ISDERIVED</td>       <td>typ_isderived</td>       <td>typIsDerived</td></tr>
    <tr><td>TYP_ISFORWARD</td>       <td>typ_isforward</td>       <td></td></tr>
    <tr><td>TYP_ISFUNC</td>          <td>typ_isfunc</td>          <td>typIsFunc</td></tr>
    <tr><td>TYP_ISVARFUNC</td>       <td>typ_isvarfunc</td>       <td>typIsVarfunc</td></tr>
    <tr><td>TYP_MATCHOBJ</td>        <td>typ_matchobj</td>        <td>typMatchobj</td></tr>
    <tr><td>TYP_META</td>            <td>typ_meta</td>            <td>typMeta</td></tr>
    <tr><td>TYP_NE</td>              <td>typ_ne</td>              <td>!=</td></tr>
    <tr><td>TYP_NUM</td>             <td>typ_num</td>             <td>typNum</td></tr>
    <tr><td>TYP_RESULT</td>          <td>typ_result</td>          <td>typResult</td></tr>
    <tr><td>TYP_STR</td>             <td>typ_str</td>             <td>typStr</td></tr>
    <tr><td>TYP_VALUE</td>           <td>typ_value</td>           <td>typValue</td></tr>
    <tr><td>TYP_VARCONV</td>         <td>typ_varconv</td>         <td></td></tr>
    <tr><td>TYP_VARFUNC</td>         <td>typ_varfunc</td>         <td>typVarfunc</td></tr>
</table><p></p>
<a name="utf8_file"><h3>13.30 Actions for the type utf8_file</h3></a>
<p></p><table border="1">
    <tr><td>Action name</td>         <td>ut8lib.c function</td>   <td>ut8_rtl.c function</td></tr>
    <tr><td>UT8_GETC</td>            <td>ut8_getc</td>            <td>ut8Getc</td></tr>
    <tr><td>UT8_GETS</td>            <td>ut8_gets</td>            <td>ut8Gets</td></tr>
    <tr><td>UT8_LINE_READ</td>       <td>ut8_line_read</td>       <td>ut8LineRead</td></tr>
    <tr><td>UT8_SEEK</td>            <td>ut8_seek</td>            <td>ut8Seek</td></tr>
    <tr><td>UT8_WORD_READ</td>       <td>ut8_word_read</td>       <td>ut8WordRead</td></tr>
    <tr><td>UT8_WRITE</td>           <td>ut8_write</td>           <td>ut8Write</td></tr>
</table><p></p>

<p></p>
<a name="ERRORS"><h2>14. ERRORS</h2></a>
<!-- ========== -->
<p></p>
<a name="Compile_time_errors"><h3>14.1 Compile time errors</h3></a>
<p>
  The compile time errors are not fatal (the program can
  execute) except for the error 1 (Out of heap space) which
  terminates the compilation process and no execution occurs.
</p><pre>
   1: Fatal Error: Out of heap space
   2: File "%s" not found
   3: Include file "%s" not found
   4: "END OF FILE" encountered
   5: Illegal character in text "%s"
   6: Unclosed comment
   7: Illegal pragma "%s"
   8: Illegal action "%s"
   9: Illegal system declaration "%s"
  10: Integer "%s" too big
  11: Negative exponent in integer literal
  12: Digit expected found "%s"
  13: Integer "%dE%s" too big
  14: Integer base "%ld" not between 2 and 36
  15: Extended digit expected found "%s"
  16: Illegal digit "%c" in based integer "%d#%s"
  17: Based integer "%d#%s" too big
  18: "'" expected found "%s"
  19: Character literal exceeds source line
  20: Use \" instead of "" to represent " in a string
  21: Use / instead of \\ as path delimiter
  22: Illegal string escape "\%s"
  23: Numerical escape sequences should end with "\" not "%s");
  24: String continuations should end with "\" not "%s");
  25: String literal exceeds source line
  26: Name expected found "%s"
  27: Integer literal expected found "%s"
  28: String literal expected found "%s"
  29: Identifier expected found "%s"
  30: Expression expected found "%s"
  31: Expression expected after "begin"
  32: Declaration expected found "%s"
  33: Initialisation of "%s" failed
  34: "%s" declared twice
  35: "%s" not declared
  36: Associativity expected found "%s"
  37: Statement priority "%s" too big
  38: Syntax with two parameters before operator is illegal
  39: Empty syntax declaration
  40: "%s" redeclared with infix priority %d not %d
  41: "%s" redeclared with prefix priority %d not %d
  42: Priority %d required for parameter after "%s" not %d
  43: Priority &lt;= %d expected found "%s" with priority %d
  44: Priority <= %d expected found "%s" with priority %d
  45: "%s" must have priority %d not %d for dot expression
  46: "%s" expected found "%s"
  47: "%s" expected found "%s"
  48: Undefined type for literal "%s"
  49: "newtype", "subtype", "func", "enumlit" or "action" expected found "%s"
  50: "func" or "type" expected found "%s"
  51: Match for %s failed
  52: Variable expected in %s found %s
  53: Type expected found %s
  54: Procedure expected found %s expression
  55: Parameter specifier expected found "%s"
  56: Evaluate type expression %s failed
      Undefined error
</pre><p></p>

<a name="Exceptions"><h3>14.2 Exceptions</h3></a>
<p>
  There are various exceptions which can be raised during
  program execution:
</p><dl><dt>
    MEMORY_ERROR:</dt><dd><dl><dt>
      May be raised by various operations of the following types:</dt><dd>
          <font color=red>array</font>, <font color=red>struct</font>, <font color=red>hash</font>, <font color=red>file</font>, <font color=red>func</font>, <font color=red>proc</font>, <font color=red>reference</font>, <font color=red>string</font>.</dd><dt>
      Additionally the interpreter kernel may raise this exception also.</dd><dt></dl></dd><dt>
    NUMERIC_ERROR:</dt><dd><dl><dt>
      May be raised from the following <tt>'<font color=red>integer</font>'</tt> operations:</dt><dd>
          !, **, <font color=blue>div</font>, <font color=blue>rem</font>, <font color=blue>mdiv</font>, <font color=blue>mod</font>, ld.</dd><dt>
      May be raised from the following <tt>'<font color=red>bigInteger</font>'</tt> operations:</dt><dd>
          **, <font color=blue>div</font>, <font color=blue>rem</font>, <font color=blue>mdiv</font>, <font color=blue>mod</font>.</dd><dt></dl></dd><dt>
    RANGE_ERROR:</dt><dd><dl><dt>
      May be raised from the following <tt>'<font color=red>integer</font>'</tt> operation:</dt><dd>
          <font color=blue>parse</font>, rand.</dd><dt>
      May be raised from the following <tt>'<font color=red>bigInteger</font>'</tt> operation:</dt><dd>
          <font color=blue>parse</font>, rand.</dd><dt>
      May be raised from the following <tt>'<font color=red>float</font>'</tt> operation:</dt><dd>
          <font color=blue>parse</font>, rand.</dd><dt>
      May be raised from the following <tt>'<font color=red>char</font>'</tt> operation:</dt><dd>
          str.</dd><dt>
      May be raised from the following <tt>'<font color=red>string</font>'</tt> operation:</dt><dd>
          @:=, <font color=blue>mult</font>, pos.</dd><dt>
      May be raised from the following <tt>'<font color=red>bitset</font>'</tt> operation:</dt><dd>
          min, max, rand.</dd><dt>
      May be raised from the following <tt>'<font color=red>array</font>'</tt> operation:</dt><dd>
          [ ].</dd><dt>
      May be raised from the following <tt>'<font color=red>hash</font>'</tt> operation:</dt><dd>
          [ ].</dd><dt>
      May be raised from the following <tt>'<font color=red>file</font>'</tt> operation:</dt><dd>
          open, gets, write, seek.</dd><dt></dl></dd><dt>
    FILE_ERROR:</dt><dd><dl><dt>
      May be raised by the following functions:</dt><dd>
          fileSize, bigFileSize, fileType, fileTypeSL, fileMode, setFileMode,
          read_dir, remove, removeAnyFile, rename, cloneFile, copyFile,
          readlink, symlink, hasNext, seek, tell, bigTell, setbuf, write,
          inetSocketAddress, openInetSocket, openInetListener</dd><dt></dl></dd><dt>
    ILLEGAL_ACTION:</dt><dd>
      May be raised by the interpreter kernel when a primitive action
      does not point to any legal action. This check is only done when
      the hi interpreter is compiled with <tt>'#define WITH_ACTION_CHECK'</tt>.
      The ILLEGAL_ACTION exception is also raised when the primitive
      action ACT_ILLEGAL is executed.</dd><dt>
</dl><p></p>

<a name="Handlers"><h3>14.3 Handlers</h3></a>
<p>
  To catch an EXCEPTION the following handler construct can be used:
</p><pre>
    <font color=blue>block</font>
      number := 1 <font color=blue>div</font> 0;
    <font color=blue>exception</font>
      <font color=blue>catch</font> NUMERIC_ERROR:
        number := 1;
    <font color=blue>end block</font>;
</pre><p></p>

<a name="Stack_trace"><h3>14.4 Stack trace</h3></a>
<p>
  When an EXCEPTION is not catched at any level the program is
  terminated and the hi interpreter generates a stack trace.
  For example:
</p><pre>
    *** Uncaught EXCEPTION NUMERIC_ERROR raised with
    {integer <80b2e64>: <SYMBOLOBJECT> 0 div integer <80b2e64>: <SYMBOLOBJECT> 0 }

    {(in integer <80b2e64> param) div (in integer <80b2e64> param) } at lander.sd7(1028)
    drawLogo {} at lander.sd7(1080)
    advanced_lander {} at lander.sd7(873)
    setup {} at lander.sd7(1441)
    main {} no POSINFO
</pre><p></p>

<a name="Other_errors_and_warnings"><h3>14.5 Other errors and warnings</h3></a>
<p><dl><dt>
  No more memory. Program terminated.</dt><dd>
    This error message is displayed after the compile time error 1
    (Out of heap space) . The file name and line number of the
    analyzer source code where this happens is displayed together
    with internal heap information. If this happens the -m option
    can be used to make more memory available. Perhaps this slows
    the compilation phase down.</dd><dt>

  System declaration for main missing</dt><dd>
    Each program must contain a system declaration that describes
    which procedure to start as first one.</dd><dt>

  EXCEPTION %s raised with</dt><dd>
    If your trace level specifies exception tracing exceptions
    and handlers are displayed with this messages and the user
    must type the ENTER-key to accept.</dd><dt>

  ACTION $%s REQUIRES %s NOT %s</dt><dd>
    This error can happen when an action tries to do something
    with the wrong primitive value. For example adding an
    integer to a string with INT_ADD. Since the analyze phase
    checks for the right types this error can only happen when the
    basic libraries are defined wrong.</dd><dt>

  ACTION $%s REQUIRES VARIABLE %s NOT %s</dt><dd>
    This error can happen with actions which assign a value to
    a constant. Since the analyze phase checks for variable objects
    this error can only happen when the basic libraries are defined
    wrong. Principally this error is possible with the following
    operations: :=, incr, decr, wrd_rd, lin_rd</dd><dt>
</dl></p>
