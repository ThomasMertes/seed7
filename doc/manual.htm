<html>
<head>
<title>
Seed7 Manual</title>
<style type="text/css">
<!--
a.link:visited { color: mediumblue; text-decoration: none }
a.link:link    { color: blue; text-decoration: none }
a.link:hover   { color: blue; text-decoration: underline }
a.link:active  { color: orange; text-decoration: underline }

a.menu:visited { color: purple; background-color: silver }
a.menu:link    { color: purple; background-color: silver }
a.menu:hover   { color: red;    background-color: silver }
a.menu:active  { color: green;  background-color: silver }

a.head:visited { color: cyan;  background-color: blue }
a.head:link    { color: cyan;  background-color: blue }
a.head:hover   { color: white; background-color: blue }
a.head:active  { color: green; background-color: blue }

a.type:visited { color: red; text-decoration: underline  }
a.type:link    { color: red; text-decoration: underline  }
a.type:hover   { color: navy }
a.type:active  { color: gold }

a.keywd:visited { color: blue; text-decoration: underline  }
a.keywd:link    { color: blue; text-decoration: underline  }
a.keywd:hover   { color: orange }
a.keywd:active  { color: green }

a.op:visited { color: blue; text-decoration: underline  }
a.op:link    { color: blue; text-decoration: underline  }
a.op:hover   { color: orange }
a.op:active  { color: green }

a.lib:visited { color: maroon; text-decoration: underline  }
a.lib:link    { color: maroon; text-decoration: underline  }
a.lib:hover   { color: blue }
a.lib:active  { color: orange }

a.prog:visited { color: darkgreen; text-decoration: underline  }
a.prog:link    { color: darkgreen; text-decoration: underline  }
a.prog:hover   { color: darkorange }
a.prog:active  { color: orange }

a.func:visited { color: purple; text-decoration: underline  }
a.func:link    { color: purple; text-decoration: underline  }
a.func:hover   { color: magenta }
a.func:active  { color: olive }

a.var:visited { color: darkcyan; text-decoration: underline  }
a.var:link    { color: darkcyan; text-decoration: underline  }
a.var:hover   { color: darkred }
a.var:active  { color: gold }

a.exception:visited { color: black; text-decoration: none }
a.exception:link    { color: black; text-decoration: none }
a.exception:hover   { color: blue; text-decoration: underline }
a.exception:active  { color: orange; text-decoration: underline }

a.ebnf:visited { color: black; text-decoration: none }
a.ebnf:link    { color: black; text-decoration: none }
a.ebnf:hover   { color: blue; text-decoration: underline }
a.ebnf:active  { color: orange; text-decoration: underline }

span.type    { color: red }
span.keywd   { color: blue }
span.op      { color: blue }
span.comment { color: green }
span.stri    { color: maroon }
span.lib     { color: maroon }
span.prog    { color: darkgreen }
span.func    { color: purple }
span.var     { color: darkcyan }

.tt { font-family: monospace; font-size: 10pt; }

body  { font-size: 12pt; }
table { font-size: 12pt; }
tt    { font-size: 10pt; }

pre.tt {
    white-space: pre;
    table-display: fixed;
    white-space: pre-wrap;
    font-size: 10pt;
    overflow: auto;
    color: black;
    margin: 0;
    padding: 0;
}

pre.box {
    border: 1pt dashed black;
    white-space: pre;
    table-display: fixed;
    white-space: pre-wrap;
    font-size: 10pt;
    overflow: auto;
    padding: 1em 0;
    background: #F8F8F8;
    color: black;
}

pre.indent {
    border: 1pt dashed black;
    white-space: pre;
    table-display: fixed;
    white-space: pre-wrap;
    font-size: 10pt;
    overflow: auto;
    padding: 1em 0;
    background: #F8F8F8;
    color: black;
    padding-left: 16px;
}

//-->
</style>
</head>
<body>

<!--[(********************************************************************)
(*                                                                  *)
(*  manual.txt                                                      *)
(*                                                                  *)
(*  Copyright (C) 1989 - 2012  Thomas Mertes                        *)
(*  All rights reserved.                                            *)
(*                                                                  *)
(*  Documentation: Manual for the Seed7 programming language        *)
(*                                                                  *)
(*  This file is distributed "AS IS" in the hope that it will be    *)
(*  useful, but WITHOUT ANY WARRANTY; without even the implied      *)
(*  warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.*)
(*                                                                  *)
(********************************************************************)]-->
<!--(*--><p></p><hr /><h1 align="center">Manual for the Seed7 programming language</h1><hr /><!--*)-->

<div>
<h2>CONTENTS</h2>

<ol>
<li><a class="link" href="#intro_file_start"><big><b>INTRODUCTION</b></big></a><ol>
<li><a class="link" href="#intro_What_is_Seed7"><b>What is Seed7?</b></a></li>
<li><a class="link" href="#intro_Why_a_new_programming_language"><b>Why a new programming language?</b></a></li>
<li><a class="link" href="#intro_Features_of_Seed7"><b>Features of Seed7</b></a></li>
<li><a class="link" href="#intro_How_to_read_the_manual"><b>How to read the manual</b></a></li></ol></li>
<li><a class="link" href="#tutorial_file_start"><big><b>TUTORIAL</b></big></a><ol>
<li><a class="link" href="#tutorial_Hello_world"><b>Hello world</b></a></li>
<li><a class="link" href="#tutorial_Local_declarations_and_expressions"><b>Local declarations and expressions</b></a></li>
<li><a class="link" href="#tutorial_For_loop_and_float_expressions"><b>For loop and float expressions</b></a></li>
<li><a class="link" href="#tutorial_Parameters"><b>Parameters</b></a></li>
<li><a class="link" href="#tutorial_Declare_a_statement"><b>Declare a statement</b></a></li>
<li><a class="link" href="#tutorial_Template_declaring_a_statement"><b>Template declaring a statement</b></a></li></ol></li>
<li><a class="link" href="#decls_file_start"><big><b>DECLARATIONS</b></big></a><ol>
<li><a class="link" href="#decls_Normal_declarations"><b>Normal declarations</b></a></li>
<li><a class="link" href="#decls_Syntax_declarations"><b>Syntax declarations</b></a></li>
<li><a class="link" href="#decls_System_declarations"><b>System declarations</b></a></li></ol></li>
<li><a class="link" href="#stats_file_start"><big><b>PREDEFINED STATEMENTS</b></big></a><ol>
<li><a class="link" href="#stats_Assignment"><b>Assignment</b></a></li>
<li><a class="link" href="#stats_while-statement"><b>while-statement</b></a></li>
<li><a class="link" href="#stats_repeat-statement"><b>repeat-statement</b></a></li>
<li><a class="link" href="#stats_for-statement"><b>for-statement</b></a></li>
<li><a class="link" href="#stats_for-step-statement"><b>for-step-statement</b></a></li>
<li><a class="link" href="#stats_for-each-statement"><b>for-each-statement</b></a></li>
<li><a class="link" href="#stats_if-statement"><b>if-statement</b></a></li>
<li><a class="link" href="#stats_case-statement"><b>case-statement</b></a></li></ol></li>
<li><a class="link" href="#types_file_start"><big><b>PREDEFINED TYPES</b></big></a><ol>
<li><a class="link" href="#types_boolean"><b>boolean</b></a></li>
<li><a class="link" href="#types_integer"><b>integer</b></a></li>
<li><a class="link" href="#types_bigInteger"><b>bigInteger</b></a></li>
<li><a class="link" href="#types_rational"><b>rational</b></a></li>
<li><a class="link" href="#types_bigRational"><b>bigRational</b></a></li>
<li><a class="link" href="#types_float"><b>float</b></a></li>
<li><a class="link" href="#types_complex"><b>complex</b></a></li>
<li><a class="link" href="#types_char"><b>char</b></a></li>
<li><a class="link" href="#types_string"><b>string</b></a></li>
<li><a class="link" href="#types_array"><b>array</b></a></li>
<li><a class="link" href="#types_hash"><b>hash</b></a></li>
<li><a class="link" href="#types_set"><b>set</b></a></li>
<li><a class="link" href="#types_struct"><b>struct</b></a></li>
<li><a class="link" href="#types_category"><b>category</b></a></li>
<li><a class="link" href="#types_reference"><b>reference</b></a></li>
<li><a class="link" href="#types_ref_list"><b>ref_list</b></a></li>
<li><a class="link" href="#types_program"><b>program</b></a></li>
<li><a class="link" href="#types_ptr"><b>ptr</b></a></li>
<li><a class="link" href="#types_ENUMERATION"><b>ENUMERATION</b></a></li>
<li><a class="link" href="#types_color"><b>color</b></a></li>
<li><a class="link" href="#types_time"><b>time</b></a></li>
<li><a class="link" href="#types_duration"><b>duration</b></a></li>
<li><a class="link" href="#types_file"><b>file</b></a></li>
<li><a class="link" href="#types_text"><b>text</b></a></li>
<li><a class="link" href="#types_func"><b>func</b></a></li>
<li><a class="link" href="#types_varfunc"><b>varfunc</b></a></li>
<li><a class="link" href="#types_void"><b>void</b></a></li>
<li><a class="link" href="#types_proc"><b>proc</b></a></li>
<li><a class="link" href="#types_type"><b>type</b></a></li>
<li><a class="link" href="#types_object"><b>object</b></a></li>
<li><a class="link" href="#types_expr"><b>expr</b></a></li></ol></li>
<li><a class="link" href="#params_file_start"><big><b>PARAMETERS</b></big></a><ol>
<li><a class="link" href="#params_val_parameter"><b>'val' parameter</b></a></li>
<li><a class="link" href="#params_ref_parameter"><b>'ref' parameter</b></a></li>
<li><a class="link" href="#params_in_parameter"><b>'in' parameter</b></a></li>
<li><a class="link" href="#params_in_var_parameter"><b>'in var' parameter</b></a></li>
<li><a class="link" href="#params_inout_parameter"><b>'inout' parameter</b></a></li>
<li><a class="link" href="#params_Symbol_parameter"><b>Symbol parameter</b></a></li>
<li><a class="link" href="#params_attr_parameter"><b>'attr' parameter</b></a></li></ol></li>
<li><a class="link" href="#objects_OBJECT_ORIENTATION"><big><b>OBJECT ORIENTATION</b></big></a><ol>
<li><a class="link" href="#objects_interface_and_implementation"><b>Interface and implementation</b></a></li>
<li><a class="link" href="#objects_dynamic_dispatch"><b>Dynamic dispatch</b></a></li>
<li><a class="link" href="#objects_inheritance"><b>Inheritance</b></a></li>
<li><a class="link" href="#objects_class_methods"><b>Class methods</b></a></li>
<li><a class="link" href="#objects_multiple_dispatch"><b>Multiple dispatch</b></a></li>
<li><a class="link" href="#objects_replacing_pointers"><b>Replacing pointers with interface types</b></a></li></ol></li>
<li><a class="link" href="#file_file_start"><big><b>THE FILE SYSTEM</b></big></a><ol>
<li><a class="link" href="#file_Conversion_to_strings_and_back"><b>Conversion to strings and back</b></a></li>
<li><a class="link" href="#file_Basic_input_and_output_operations"><b>Basic input and output operations</b></a></li>
<li><a class="link" href="#file_Input_and_output_with_conversion"><b>Input and output with conversion</b></a></li>
<li><a class="link" href="#file_Simple_read_and_write_statements"><b>Simple read and write statements</b></a></li>
<li><a class="link" href="#file_Standard_input_and_output_files"><b>Standard input and output files</b></a></li>
<li><a class="link" href="#file_Access_to_operating_system_files"><b>Access to operating system files</b></a></li>
<li><a class="link" href="#file_Keyboard_file"><b>Keyboard file</b></a></li>
<li><a class="link" href="#file_Files_with_line_structure"><b>Files with line structure</b></a></li>
<li><a class="link" href="#file_Sockets"><b>Sockets</b></a></li>
<li><a class="link" href="#file_User_defined_file_types"><b>User defined file types</b></a></li>
<li><a class="link" href="#file_Scanning_a_file"><b>Scanning a file</b></a></li></ol></li>
<li><a class="link" href="#syntax_file_start"><big><b>STRUCTURED SYNTAX DEFINITION</b></big></a><ol>
<li><a class="link" href="#syntax_The_Extended_Backus-Naur_Form"><b>The Extended Backus-Naur Form</b></a></li>
<li><a class="link" href="#syntax_The_syntax_of_a_statement"><b>The syntax of a statement</b></a></li>
<li><a class="link" href="#syntax_Priority_and_associativity"><b>Priority and associativity</b></a></li>
<li><a class="link" href="#syntax_The_syntax_of_operators"><b>The syntax of operators</b></a></li>
<li><a class="link" href="#syntax_Syntax_of_predefined_statements"><b>Syntax of predefined statements</b></a></li>
<li><a class="link" href="#syntax_Advanced_syntax_definitions"><b>Advanced syntax definitions</b></a></li>
<li><a class="link" href="#syntax_Comparison_of_EBNF_and_S7SSD"><b>Comparison of EBNF and S7SSD</b></a></li></ol></li>
<li><a class="link" href="#tokens_file_start"><big><b>TOKENS</b></big></a><ol>
<li><a class="link" href="#tokens_White_space"><b>White space</b></a><ol>
<li><a class="link" href="#tokens_Spaces"><b><i>Spaces</i></b></a></li>
<li><a class="link" href="#tokens_Comments"><b><i>Comments</i></b></a></li>
<li><a class="link" href="#tokens_Line_comments"><b><i>Line comments</i></b></a></li></ol></li>
<li><a class="link" href="#tokens_Identifiers"><b>Identifiers</b></a><ol>
<li><a class="link" href="#tokens_Name_identifiers"><b><i>Name identifiers</i></b></a></li>
<li><a class="link" href="#tokens_Special_identifiers"><b><i>Special identifiers</i></b></a></li>
<li><a class="link" href="#tokens_Parentheses"><b><i>Parentheses</i></b></a></li></ol></li>
<li><a class="link" href="#tokens_Literals"><b>Literals</b></a><ol>
<li><a class="link" href="#tokens_Integer_literals"><b><i>Integer literals</i></b></a></li>
<li><a class="link" href="#tokens_BigInteger_literals"><b><i>BigInteger literals</i></b></a></li>
<li><a class="link" href="#tokens_Float_literals"><b><i>Float literals</i></b></a></li>
<li><a class="link" href="#tokens_String_literals"><b><i>String literals</i></b></a></li>
<li><a class="link" href="#tokens_Character_literals"><b><i>Character literals</i></b></a></li></ol></li></ol></li>
<li><a class="link" href="#expr_file_start"><big><b>EXPRESSIONS</b></big></a><ol>
<li><a class="link" href="#expr_EXPRESSION_Parentheses"><b>Parentheses</b></a></li>
<li><a class="link" href="#expr_Call_expressions"><b>Call expressions</b></a></li>
<li><a class="link" href="#expr_Dot_expressions"><b>Dot expressions</b></a></li></ol></li>
<li><a class="link" href="#os_file_start"><big><b>OPERATING SYSTEM ACCESS</b></big></a><ol>
<li><a class="link" href="#os_Standard_path_representation"><b>Standard path representation</b></a></li>
<li><a class="link" href="#os_readDir"><b>readDir</b></a></li>
<li><a class="link" href="#os_openDir"><b>openDir</b></a></li>
<li><a class="link" href="#os_getcwd"><b>getcwd</b></a></li>
<li><a class="link" href="#os_chdir"><b>chdir</b></a></li>
<li><a class="link" href="#os_mkdir"><b>mkdir</b></a></li>
<li><a class="link" href="#os_homeDir"><b>homeDir</b></a></li>
<li><a class="link" href="#os_fileType"><b>fileType</b></a></li>
<li><a class="link" href="#os_fileMode"><b>fileMode</b></a></li>
<li><a class="link" href="#os_setFileMode"><b>setFileMode</b></a></li>
<li><a class="link" href="#os_fileSize"><b>fileSize</b></a></li>
<li><a class="link" href="#os_getATime"><b>getATime</b></a></li>
<li><a class="link" href="#os_getCTime"><b>getCTime</b></a></li>
<li><a class="link" href="#os_getMTime"><b>getMTime</b></a></li>
<li><a class="link" href="#os_setATime"><b>setATime</b></a></li>
<li><a class="link" href="#os_setMTime"><b>setMTime</b></a></li>
<li><a class="link" href="#os_readlink"><b>readlink</b></a></li>
<li><a class="link" href="#os_symlink"><b>symlink</b></a></li>
<li><a class="link" href="#os_removeFile"><b>removeFile</b></a></li>
<li><a class="link" href="#os_removeAnyFile"><b>removeAnyFile</b></a></li>
<li><a class="link" href="#os_copyFile"><b>copyFile</b></a></li>
<li><a class="link" href="#os_cloneFile"><b>cloneFile</b></a></li>
<li><a class="link" href="#os_moveFile"><b>moveFile</b></a></li>
<li><a class="link" href="#os_argv_PROGRAM"><b>argv(PROGRAM)</b></a></li>
<li><a class="link" href="#os_name_PROGRAM"><b>name(PROGRAM)</b></a></li>
<li><a class="link" href="#os_path_PROGRAM"><b>path(PROGRAM)</b></a></li>
<li><a class="link" href="#os_dir_PROGRAM"><b>dir(PROGRAM)</b></a></li>
<li><a class="link" href="#os_file_PROGRAM"><b>file(PROGRAM)</b></a></li>
<li><a class="link" href="#os_getenv"><b>getenv</b></a></li>
<li><a class="link" href="#os_setenv"><b>setenv</b></a></li>
<li><a class="link" href="#os_environment"><b>environment</b></a></li></ol></li>
<li><a class="link" href="#actions_file_start"><big><b>PRIMITIVE ACTIONS</b></big></a><ol>
<li><a class="link" href="#actions_ACTION"><b>Actions for the type ACTION</b></a></li>
<li><a class="link" href="#actions_array"><b>Actions for array types</b></a></li>
<li><a class="link" href="#actions_bigInteger"><b>Actions for the type bigInteger</b></a></li>
<li><a class="link" href="#actions_boolean"><b>Actions for the type boolean</b></a></li>
<li><a class="link" href="#actions_bstring"><b>Actions for byte strings</b></a></li>
<li><a class="link" href="#actions_char"><b>Actions for the type char</b></a></li>
<li><a class="link" href="#actions_commands"><b>Actions for various directory, file and other commands</b></a></li>
<li><a class="link" href="#actions_console_output"><b>Actions for text (console) screen output</b></a></li>
<li><a class="link" href="#actions_declarations"><b>Actions for declarations</b></a></li>
<li><a class="link" href="#actions_graphic_output"><b>Actions to do graphic output</b></a></li>
<li><a class="link" href="#actions_enumeration"><b>Actions for enumeration types</b></a></li>
<li><a class="link" href="#actions_clib_file"><b>Actions for the type clib_file</b></a></li>
<li><a class="link" href="#actions_float"><b>Actions for the type float</b></a></li>
<li><a class="link" href="#actions_graphic_keyboard"><b>Actions to support the graphic keyboard</b></a></li>
<li><a class="link" href="#actions_hash"><b>Actions for hash types</b></a></li>
<li><a class="link" href="#actions_integer"><b>Actions for the type integer</b></a></li>
<li><a class="link" href="#actions_interface"><b>Actions for interface types</b></a></li>
<li><a class="link" href="#actions_console_keyboard"><b>Actions to support the text (console) screen keyboard</b></a></li>
<li><a class="link" href="#actions_list"><b>Actions for the list type</b></a></li>
<li><a class="link" href="#actions_pollData"><b>Actions for the type pollData</b></a></li>
<li><a class="link" href="#actions_proc"><b>Actions for proc operations and statements</b></a></li>
<li><a class="link" href="#actions_program"><b>Actions for the type program</b></a></li>
<li><a class="link" href="#actions_reference"><b>Actions for the type reference</b></a></li>
<li><a class="link" href="#actions_ref_list"><b>Actions for the type ref_list</b></a></li>
<li><a class="link" href="#actions_struct"><b>Actions for struct types</b></a></li>
<li><a class="link" href="#actions_set"><b>Actions for set types</b></a></li>
<li><a class="link" href="#actions_PRIMITIVE_SOCKET"><b>Actions for the type PRIMITIVE_SOCKET</b></a></li>
<li><a class="link" href="#actions_string"><b>Actions for the type string</b></a></li>
<li><a class="link" href="#actions_time"><b>Actions for the type time</b></a></li>
<li><a class="link" href="#actions_type"><b>Actions for the type type</b></a></li>
<li><a class="link" href="#actions_utf8_file"><b>Actions for the type utf8_file</b></a></li></ol></li>
<li><a class="link" href="#ffi_file_start"><big><b>FOREIGN FUNCTION INTERFACE</b></big></a><ol>
<li><a class="link" href="#ffi_C_types_used_by_the_implementation"><b>C types used by the implementation</b></a></li>
<li><a class="link" href="#ffi_String_and_path_conversions"><b>String and path conversions</b></a></li>
<li><a class="link" href="#ffi_Macros_to_access_the_action_parameters"><b>Macros to access the action parameters</b></a></li>
<li><a class="link" href="#ffi_Functions_to_create_action_results"><b>Functions to create action results</b></a></li></ol></li>
<li><a class="link" href="#errors_file_start"><big><b>ERRORS</b></big></a><ol>
<li><a class="link" href="#errors_Compile_time_errors"><b>Compile time errors</b></a></li>
<li><a class="link" href="#errors_Exceptions"><b>Exceptions</b></a></li>
<li><a class="link" href="#errors_Handlers"><b>Handlers</b></a></li>
<li><a class="link" href="#errors_Stack_trace"><b>Stack trace</b></a></li>
<li><a class="link" href="#errors_Other_errors_and_warnings"><b>Other errors and warnings</b></a></li></ol></li>
</ol></div>

<a name="intro_file_start"></a><p></p>
<a name="intro_INTRODUCTION"><h2>1. INTRODUCTION</h2></a>

<p></p>

<a name="intro_What_is_Seed7"><h3>1.1 What is Seed7?</h3></a>
<p>
    Seed7 is a general-purpose programming language. It is a
  higher level language compared to Ada, C++ and Java. In Seed7
  new statements and operators can be defined easily. Functions
  with type results and type parameters are more elegant than
  the usual template or generics concept. Object orientation is
  used when it brings advantages and not in places when other
  solutions are more obvious. Although Seed7 contains several
  concepts of other programming languages it is generally not
  considered as a direct descendant of any other programming
  language.
</p><p>
  The programmer should concentrate on problem solving instead
  of administration or the fulfillment of some paradigm.
  Therefore Seed7 allows programming in the "problem space"
  instead of bending everything into a small syntactic or
  semantic concept. The predefined constructs of Seed7 are
  defined in a way to be easy readable and understandable. This
  practical approach can be summarized as:
</p><dl><dd><table border="1" cellspacing="0" cellpadding="5"><tr><td>
    <big><b><font color="orange">&nbsp;Programming should be fun&nbsp;</font></b></big>
</td></tr></table></dd></dl><p>
  Seed7 programs can be interpreted or compiled. Therefore Seed7
  can be used for scripting and for "real" programs.
</p>

<a name="intro_Why_a_new_programming_language"><h3>1.2 Why a new programming language?</h3></a>
<p>
    Conventional programming languages have a firmly given
  syntactic structure. The form of the statements, operators,
  declarations, procedures and functions is fixed in the
  language definition and cannot be changed by the user. It is
  only possible to declare new procedures, functions and in
  some languages also new operators. However the syntax of
  procedure-, function and operator calls cannot be changed.
  Although this rigid pattern is favorable for the portability
  of programs, the improvement of a programming language is
  almost impossible. Extensions are however desirable, in order
  to repair existing weaknesses, to introduce new more obvious
  constructs and to adapt the programming language to different
  application areas. E.g.: In the area of mathematics the
  readability of a program can be substantially increased by
  the introduction of matrix and vector operators. After
  declaring an inner product and an outer (or cross) product for
  vectors it is possible to write e.g.
</p><pre class="indent">
v1: = v2 <span class="op">cross</span> v3;   write(v1 * v2);
</pre><p>
  Programs which search for some data in a database can become
  more understandable by using a for statement to loop over the
  tables. A usage of such a for statement could be:
</p><pre class="indent">
<span class="keywd">for</span> person1, person2
<span class="keywd">where</span> person1.age = person2.age <span class="op">and</span>
     person1.mother = person2.mother <span class="op">and</span>
     person1 &lt;> person2 <span class="keywd">do</span>
   writeln(<span class="stri">"Twins: "</span> &lt;&amp; person1.name &lt;&amp; <span class="stri">" and "</span> &lt;&amp; person2.name);
<span class="keywd">end for</span>;
</pre><p>
  Such extensions make understanding, changing and debugging of
  a program easier.
</p>

<a name="intro_Features_of_Seed7"><h3>1.3 Features of Seed7</h3></a>
<p>
  Seed7 has the following features
</p><ul>
    <li>User defined statements and operators.</li>

    <li>Types are first class objects and therefore templates and
      generics can be defined easily without special syntax.</li>

    <li>Predefined constructs like arrays or for-loops are
      defined in the language itself.</li>

    <li><a class="link" href="#objects_file_start">Object orientation</a> is based on interfaces, supports
      multiple dispatch and allows to connect methods to objects.</li>

    <li><span class="link">Static type checking</span> and no <span class="link">automatic casts</span>.</li>

    <li><a class="link" href="#errors_Exceptions">exception handling</a></li>

    <li>overloading of procedures/functions/operators/statements</li>

    <li>Various predefined types like resizable <a class="type" href="#types_array">arrays</a>, <a class="type" href="#types_hash">hashes</a>,
      <a class="type" href="#types_set">bitsets</a>, <a class="type" href="#types_struct">structs</a>, etc.</li>
</ul><p>
  But a new programming language differs not only from existing
  ones by new features. The real advantage comes from omitting
  features which are outdated.
</p><p>
  Several concepts in use by other languages are not present
</p><ul>
    <li>There is no goto statement.
      Hidden goto's like break- and continue-statements are
      also omitted.</li>

    <li>There is no return statement. Instead a result variable
      can be defined to which the result of a function can
      be assigned.</li>

    <li>There are no <span class="link">automatic type conversions</span>.
      When a subprogram should be used for different types
      it must be overloaded.</li>

    <li>There are no <span class="link">variable length parameter lists</span>.
      Instead it is possible to use arrays as parameters.</li>

    <li>There are no default parameters.
      But it is easy to define two subprograms: One with and
      one without an additional parameter.</li>

    <li>There is no special "parameter" called "self" or "this".
      In a procedure the receiving object is defined as
      formal parameter with a user-defined name.</li>

    <li>There is no macro feature since this mechanism is too
      similar to the subprogram feature. Instead subprograms
      can be used in a more flexible way than in other languages.</li>

    <li>There are no <span class="link">reserved words</span>.</li>

    <li>There is no conceptual distinction between functions,
      operators, procedures and statements.</li>

    <li>The procedure calling mechanism is not based on a concept
      with an object-message pair (An object receives a message).
      Instead a match is done over a list of objects. This more
      general (and powerful) mechanism is called multiple dispatch
      and it includes the simple object-message mechanism as
      special case.</li>
</ul><p>
  There are several concepts which are also used by other languages:
</p><ul>
    <li>Block comments start with <span class="comment">(* and end with *)</span> and may be nested.</li>

    <li>Line comments start with <span class="comment"># and are terminated with the end of the line.</span></li>
</ul><p>
  There are several concepts which are new
</p><ul>
    <li>Variables and constants must be initialized when they are
      defined.</li>

    <li>Every expression has exactly one type.
      That means that overloaded functions are resolved with
      their actual parameters and not with the context of their
      call. (This is different to the overloading mechanism
      used by ADA)</li>

    <li>With a syntax declaration new operators and statements
      can be defined.</li>

    <li>Not only predefined operator symbols can be
      overloaded. Additionally it is possible to invent
      completely new operator symbols.</li>
</ul><p>
  Several restrictions of other languages are released
</p><ul>
    <li>There is no limitation in the length of an identifier and
      all characters of an identifier are significant.</li>

    <li>Statements and parentheses can be nested without limitation
      in depth.</li>

    <li>The number of parameters and local variables is not
      limited.</li>

    <li>Strings can contain any characters (also the NUL character)
      This allows holding binary information in strings.</li>

    <li>Although strings are not NUL terminated they have
      no size limitation. (Except there is no more memory)</li>

    <li>String literals can have any length.</li>

    <li>There is no limitation in the length of a source line.</li>

    <li>There is no level limitation for nesting includes.</li>
</ul>

<a name="intro_How_to_read_the_manual"><h3>1.4 How to read the manual</h3></a>
<p>
    You can have several views of the Seed7 programming language.
  Dependent on the view you can concentrate on specific
  chapters.
</p><p>
  For example Seed7 can be used as conventional programming language.
  In this case you are interested in how the statements look like,
  which types are available, which operators are predefined, how
  to declare variables and procedures and other things like these.
  The statements and the predefined types are described in <a class="link" href="#stats_file_start">chapter
  4 (Predefined statements)</a> and <a class="link" href="#types_file_start">chapter 5 (Predefined types)</a> and the
  declaration mechanism is described in <a class="link" href="#decls_file_start">chapter 3 (Declarations)</a>.
</p><p>
  But Seed7 is also an object oriented programming language.
  In this case you are interested in how to define new classes,
  how instances are generated, the method calling mechanism,
  the predefined class hierarchy and other things like these.
  The object orientation of Seed7 is described in <a class="link" href="#objects_file_start">chapter 7
  (Object orientation)</a>. A good example for classes and instances
  is the file system which is described in <a class="link" href="#file_file_start">chapter 8 (The file
  system)</a>.
</p><p>
  And Seed7 is also an extensible programming language.
  In this case you are interested in how to declare new
  statements, how to define new operators, assigning a priority
  and an associativity to operators and other things like these.
  An overview about syntax declarations can be found in
  <a class="link" href="#decls_Syntax_declarations">Chapter 3.2 (Syntax declarations)</a>. A detailed description
  of the Seed7 syntax definitions can be found in <a class="link" href="#syntax_file_start">chapter 9
  (Structured syntax definition)</a>. <a class="link" href="#stats_file_start">Chapter 4 (Predefined
  statements)</a> contains various examples of syntax and semantic
  declarations. The basic parts of the syntax are described in
  <a class="link" href="#tokens_file_start">chapter 10 (Tokens)</a> and <a class="link" href="#expr_file_start">chapter 11 (Expressions)</a>.
</p>

<a name="tutorial_file_start"></a><p></p>
<a name="tutorial_TUTORIAL"><h2>2. TUTORIAL</h2></a>

<p>
    We begin with a tutorial introduction to Seed7. In
  this chapter we want to show the principal ideas that
  make Seed7 work. At this point, we are not trying to be
  complete or precise. We just want to give a clear view
  to the primary philosophic ideas of Seed7. When the
  primary ideas are understood a complete and precise
  reference can be learned easier.
</p>

<a name="tutorial_Hello_world"><h3>2.1 Hello world</h3></a>
<p>
    A Seed7 program consists of a sequence of declarations.
  With each declaration a <tt><a class="type" href="#types_type">type</a></tt> and a name is attached to the
  new object. In addition every new declared object gets an
  initial value.
</p><p>
  Here is an example of an object declaration:
</p><pre class="indent">
<span class="keywd">const</span> <span class="type">proc</span>: main <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    writeln(<span class="stri">"hello world"</span>);
  <span class="keywd">end func</span>;
</pre><p>
  The object <tt>'main'</tt> is declared as constant and <tt><a class="type" href="#types_proc">proc</a></tt>
  is the type of <tt>'main'</tt>. Declaring <tt>'main'</tt> with the type
  <tt><a class="type" href="#types_proc">proc</a></tt> makes a procedure out of it. The object <tt>'main'</tt> gets a
</p><pre class="indent">
<span class="keywd">func</span> ... <span class="keywd">end func</span>
</pre><p>
  construct as value. The <tt>'<span class="keywd">func</span>'</tt> construct is similar to
  <tt><span class="keywd">begin</span> ... <span class="keywd">end</span></tt> in PASCAL and <tt>{ ... }</tt> in C. Inside the <tt>'<span class="keywd">func</span>'</tt> is a
  <tt><span class="func">writeln</span></tt> statement with the <tt><span class="stri">"hello world"</span></tt> string. The
  <tt><span class="func">writeln</span></tt> statement is used to write a <tt><a class="type" href="#types_string">string</a></tt> followed by a
  newline character. To use this declaration as the standard
  hello world example program, we have to add a few things:
</p><pre class="indent">
$ <span class="keywd">include</span> <span class="lib">"seed7_05.s7i"</span>;

<span class="keywd">const</span> <span class="type">proc</span>: main <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    writeln(<span class="stri">"hello world"</span>);
  <span class="keywd">end func</span>;
</pre><p>
  The first line includes all definitions of the standard
  library. In contrast to other standard libraries the seed7_05.s7i
  library contains not only function declarations but also
  declarations of statements and operators.
  Additionally the seed7_05.s7i library defines the '<tt>main</tt>' function
  as entry point for a Seed7 program.
</p><p>
  If you write this program in a file called hello.sd7
  and execute the command
</p><pre class="indent">
s7 hello
</pre><p>
  The Seed7 interpreter writes something like
</p><pre class="indent">
SEED7 INTERPRETER Version 5.0.4  Copyright (c) 1990-2013 Thomas Mertes
hello world
</pre><p>
  You get information about the Seed7 interpreter and
  the output of the world.sd7 program:
</p><pre class="indent">
hello world
</pre><p>
  The the option <b>-q</b> can be used to suppress the line
  with information about the Seed7 interpreter:
</p><pre class="indent">
s7 -q hello
</pre><p></p>

<a name="tutorial_Local_declarations_and_expressions"><h3>2.2 Local declarations and expressions</h3></a>
<p>
    To write a Fahrenheit to Celsius conversion table we use
  the following program:
</p><pre class="indent">
<span class="comment">(* Print a Fahrenheit-Celsius table
   for Fahrenheit values between 0 and 300 *)</span>

$ <span class="keywd">include</span> <span class="lib">"seed7_05.s7i"</span>;

<span class="keywd">const</span> <span class="type">proc</span>: main <span class="keywd">is func</span>
  <span class="keywd">local</span>
    <span class="keywd">const</span> <span class="type">integer</span>: lower <span class="keywd">is</span> 0;
    <span class="keywd">const</span> <span class="type">integer</span>: upper <span class="keywd">is</span> 300;
    <span class="keywd">const</span> <span class="type">integer</span>: increment <span class="keywd">is</span> 20;
    <span class="keywd">var</span> <span class="type">integer</span>: fahr <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: celsius <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    fahr := lower;
    <span class="keywd">while</span> fahr &lt;= upper <span class="keywd">do</span>
      celsius := 5 * (fahr - 32) <span class="op">div</span> 9;
      write(fahr);
      write(<span class="stri">" "</span>);
      writeln(celsius);
      fahr := fahr + increment;
    <span class="keywd">end while</span>;
  <span class="keywd">end func</span>;
</pre><p>
  Everything between <span class="comment">(* and *)</span> is a <a class="link" href="#tokens_Comments">comment</a>, which is ignored.
  This program contains local constants and variables of the
  type <tt><a class="type" href="#types_integer">integer</a></tt>. The constants and variables must be
  initialized when they are declared. This program contains
  also an <a class="link" href="#stats_Assignment">assignment</a>, a <a class="link" href="#stats_while-statement">while-statement</a> and the expression to
  compute the <tt>'celsius'</tt> value. Note that the statements inside
  the <a class="link" href="#stats_while-statement">while-loop</a> are between <tt>'<span class="keywd">do</span>'</tt> and <tt>'<span class="keywd">end while</span>'</tt>. The
  expression to compute the <tt>'celsius'</tt> value uses an integer
  division (<tt><span class="op">div</span></tt>). The <tt>'write'</tt> statement can be used to write
  strings and integers without a newline character. The output
  produced by this program is
</p><pre class="indent">
0 -17
20 -6
40 4
60 15
80 26
100 37
120 48
140 60
160 71
180 82
200 93
220 104
240 115
260 126
280 137
300 148
</pre><p></p>

<a name="tutorial_For_loop_and_float_expressions"><h3>2.3 For loop and float expressions</h3></a>
<p>
    An improved version of the program to write the Fahrenheit
  to Celsius conversion table is:
</p><pre class="indent">
$ <span class="keywd">include</span> <span class="lib">"seed7_05.s7i"</span>;
  <span class="keywd">include</span> <span class="lib">"<span class="lib">float.s7i</span>"</span>;

<span class="keywd">const</span> <span class="type">proc</span>: main <span class="keywd">is func</span>
  <span class="keywd">local</span>
    <span class="keywd">const</span> <span class="type">integer</span>: lower <span class="keywd">is</span> 0;
    <span class="keywd">const</span> <span class="type">integer</span>: upper <span class="keywd">is</span> 300;
    <span class="keywd">const</span> <span class="type">integer</span>: increment <span class="keywd">is</span> 20;
    <span class="keywd">var</span> <span class="type">integer</span>: fahr <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">float</span>: celsius <span class="keywd">is</span> 0.0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> fahr <span class="keywd">range</span> lower <span class="keywd">to</span> upper <span class="keywd">step</span> increment <span class="keywd">do</span>
      celsius := flt(5 * (fahr - 32)) / 9.0;
      writeln(fahr <span class="op">lpad</span> 3 &lt;&amp; <span class="stri">" "</span> &lt;&amp; celsius <span class="op">digits</span> 2 <span class="op">lpad</span> 6);
    <span class="keywd">end for</span>;
  <span class="keywd">end func</span>;
</pre><p>
  To use the type <tt><a class="type" href="#types_float">float</a></tt> it is necessary to include
  <tt><span class="lib">float.s7i</span></tt>. The <tt><a class="type" href="#types_float">float</a></tt> variable <tt>'celsius'</tt> must be
  initialized with 0.0 (instead of 0). The <tt><a class="link" href="#stats_for-statement">for-loop</a></tt> is
  written as:
</p><pre class="indent">
<span class="keywd">for</span> ... <span class="keywd">range</span> ... <span class="keywd">to </span>... <span class="keywd">step</span> ... <span class="keywd">do</span>
  ...
<span class="keywd">end for</span>
</pre><p>
  To specify a lower and an upper limit together with a step
  value. For a step value of 1 the <tt><a class="link" href="#stats_for-statement">for-loop</a></tt> it is written as:
</p><pre class="indent">
<span class="keywd">for</span> ... <span class="keywd">range</span> ... <span class="keywd">to</span> ... <span class="keywd">do</span>
  ...
<span class="keywd">end for</span>
</pre><p>
  And for a step value of -1 it can be written as:
</p><pre class="indent">
<span class="keywd">for</span> ... <span class="keywd">range</span> ... <span class="keywd">downto</span> ... <span class="keywd">do</span>
  ...
<span class="keywd">end for</span>
</pre><p>
  Since Seed7 is strong typed <tt><a class="type" href="#types_integer">integer</a></tt> and <tt><a class="type" href="#types_float">float</a></tt> values
  cannot be mixed in expressions. Therefore the <tt><a class="type" href="#types_integer">integer</a></tt>
  expression <tt>'5 * (fahr - 32)'</tt> is converted to <tt><a class="type" href="#types_float">float</a></tt> with
  the function <tt><span class="func">flt</span></tt>. For the same reason a <tt>'<span class="func">/</span>'</tt> division and
  the value <tt>'9.0'</tt> must be used. The <tt><span class="op">&lt;&amp;</span></tt> operator is used to
  concatenate elements before writing. If the right operand of
  the <tt><span class="op">&lt;&amp;</span></tt> operator has not the type <tt><a class="type" href="#types_string">string</a></tt> it is converted to
  a <tt><a class="type" href="#types_string">string</a></tt> using the <tt>'str'</tt> function. The <tt><span class="op">lpad</span></tt> operator
  converts the value of <tt>'fahr'</tt> to a string and pads spaces to
  the left until the string has length 3. The <tt><span class="keywd">digits</span></tt> operator
  converts the value of <tt>'celsius'</tt> to a string with 2 decimal
  digits. The resulting string is padded left up to a length
  of 6.
</p>

<a name="tutorial_Parameters"><h3>2.4 Parameters</h3></a>
<p>
    Most parameters are not changed inside a function. Seed7
  uses <tt>'<span class="keywd">in</span>'</tt> parameters to describe this situation:
</p><pre class="indent">
<span class="keywd">const</span> <span class="type">func integer</span>: negate (<span class="keywd">in</span> <span class="type">integer</span>: num1) <span class="keywd">is</span>
  <span class="keywd">return</span> -num1;

<span class="keywd">const</span> <span class="type">func integer</span>: fib (<span class="keywd">in</span> <span class="type">integer</span>: num1) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: fib <span class="keywd">is</span> 1;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> num1 &lt;> 1 <span class="op">and</span> num1 &lt;> 2 <span class="keywd">then</span>
      fib := fib(pred(num1)) + fib(num1 - 2);
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre><p>
  The functions above use <tt>'<span class="keywd">in</span>'</tt> parameters named <tt>'num1'</tt>.
  An assignment to <tt>'num1'</tt> is not allowed. A formal <tt>'<span class="keywd">in</span>'</tt>
  parameter like <tt>'num1'</tt> behaves like a constant.
  Trying to change a formal <tt>'<span class="keywd">in</span>'</tt> parameter:
</p><pre class="indent">
<span class="keywd">const</span> <span class="type">proc</span>: wrong (<span class="keywd">in</span> <span class="type">integer</span>: num2) <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    num2 := 0;
  <span class="keywd">end func</span>;
</pre><p>
  results in a compile time error:
</p><pre class="indent">
*** tst77.sd7(5):52: Variable expected in {num2 := 0 } found parameter (in integer: num2)
    num2 := 0;
</pre><p>
  When a function wants to change the value of the actual
  parameter it can use an <tt>'<span class="keywd">inout</span>'</tt> parameter:
</p><pre class="indent">
<span class="keywd">const</span> <span class="type">proc</span>: reset (<span class="keywd">inout</span> <span class="type">integer</span>: num2) <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    num2 := 0;
  <span class="keywd">end func</span>;
</pre><p>
  If you call this function with
</p><pre class="indent">
reset(number);
</pre><p>
  the variable <tt>'number'</tt> has the value 0 afterwards. Calling
  <tt>'reset'</tt> with a constant instead of a variable:
</p><pre class="indent">
reset(8);
</pre><p>
  results in a compile time error
</p><pre class="indent">
*** tst77.sd7(12):52: Variable expected in {8 reset } found constant integer: 8
    reset(8);
</pre><p>
  Sometimes an <tt>'<span class="keywd">in</span>'</tt> parameter is needed, but you need to change
  the formal parameter in the function without affecting the
  actual parameter. In this case we use the <tt>'<span class="keywd">in var</span>'</tt> parameter:
</p><pre class="indent">
<span class="keywd">const</span> <span class="type">func string</span>: oct_str (<span class="keywd">in var</span> <span class="type">integer</span>: number) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> number >= 0 <span class="keywd">then</span>
      <span class="keywd">repeat</span>;
        stri := str(number <span class="op">mod</span> 8) & stri;
        number := number <span class="op">mdiv</span> 8;
      <span class="keywd">until</span> number = 0;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre><p>
  As you can see this works like a combination of an <tt>'<span class="keywd">in</span>'</tt>
  parameter with a local <tt>'<span class="keywd">var</span>'</tt>.
</p><p>
  Conventionally there are two kinds of parameters:
  <tt>'call by value'</tt> and <tt>'call by reference'</tt>. When taking the
  access right (constant or variable) into account we get
  the following table:
</p><dl><dd><table border="1" cellspacing="0" cellpadding="5">
    
    <tr><th> parameter </th><th>  call by  </th><th> access right </th></tr>
    
    <tr><td> val       </td><td align="center">   value   </td><td> const        </td></tr>
    <tr><td> ref       </td><td align="center"> reference </td><td> const        </td></tr>
    <tr><td> in        </td><td align="center"> val / ref </td><td> const        </td></tr>
    <tr><td> in var    </td><td align="center">   value   </td><td> var          </td></tr>
    <tr><td> inout     </td><td align="center"> reference </td><td> var          </td></tr>
    
</table></dd></dl><p>
  Additionally to the parameters we already know this table
  describes also <tt>'<span class="keywd">val</span>'</tt> and <tt>'<span class="keywd">ref</span>'</tt> parameters which use
  'call by value' and 'call by reference' and have a constant
  formal parameter. The <tt>'<span class="keywd">in</span>'</tt> parameter is called by
  <tt>'val / ref'</tt> in this table which is easily explained:
</p><dl><dd>
    An <tt>'<span class="keywd">in</span>'</tt> parameter is either a <tt>'<span class="keywd">val</span>'</tt> or a <tt>'<span class="keywd">ref</span>'</tt> parameter
    depending on the type of the parameter.
</dd></dl><p>
  The parameter
</p><pre class="indent">
<span class="keywd">in</span> <span class="type">integer</span>: number
</pre><p>
  is a 'val' parameter which could also be declared as
</p><pre class="indent">
<span class="keywd">val</span> <span class="type">integer</span>: number
</pre><p>
  while the parameter
</p><pre class="indent">
<span class="keywd">in</span> <span class="type">string</span>: stri
</pre><p>
  is a 'ref' parameter which could also be declared as
</p><pre class="indent">
<span class="keywd">ref</span> <span class="type">string</span>: stri
</pre><p>
  The meaning of the <tt>'<span class="keywd">in</span>'</tt> parameter is predefined for most
  types. Usually types with small amounts of data use <tt>'<span class="keywd">val</span>'</tt>
  as <tt>'<span class="keywd">in</span>'</tt> parameter while types with bigger data amounts use
  <tt>'<span class="keywd">ref</span>'</tt>. Most of the time it is not necessary to care if an
  <tt>'<span class="keywd">in</span>'</tt> parameter is really a <tt>'<span class="keywd">val</span>'</tt> or <tt>'<span class="keywd">ref</span>'</tt> parameter.
</p><p>
  In rare cases a <tt>'<span class="keywd">ref</span>'</tt> parameter would have undesired side
  effects with global variables or other <tt>'<span class="keywd">ref</span>'</tt> parameters.
  In these cases an explicit <tt>'<span class="keywd">val</span>'</tt> parameter instead of an
  <tt>'<span class="keywd">in</span>'</tt> parameter makes sense.
</p><p>
  In all normal cases an <tt>'<span class="keywd">in</span>'</tt> parameter should be preferred
  over an explicit <tt>'<span class="keywd">val</span>'</tt> and <tt>'<span class="keywd">ref</span>'</tt> parameter.
</p>

<a name="tutorial_Declare_a_statement"><h3>2.5 Declare a statement</h3></a>
<p>
    This example program writes its arguments
</p><pre class="indent">
$ <span class="keywd">include</span> <span class="lib">"seed7_05.s7i"</span>;       <span class="comment"># Standard Seed7 library</span>

<span class="keywd">const</span> <span class="type">proc</span>: main <span class="keywd">is func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> stri <span class="keywd">range</span> argv(PROGRAM) <span class="keywd">do</span>
      write(stri &lt;& <span class="stri">" "</span>);
    <span class="keywd">end for</span>;
    writeln;
  <span class="keywd">end func</span>;
</pre><p>
  The <tt><a class="link" href="#stats_for-statement">for-statement</a></tt> iterates over <tt><span class="func">argv</span>(PROGRAM)</tt>.
  The function <tt><span class="func">argv</span>(PROGRAM)</tt> returns an <tt><a class="type" href="#types_array">array string</a></tt>
  (=<tt><a class="type" href="#types_array">array</a></tt> of <tt><a class="type" href="#types_string">string</a></tt> elements). The <tt><a class="link" href="#stats_for-statement">for-statement</a></tt> is overloaded
  for various collection types. In the standard Seed7 library
  <tt><span class="lib">seed7_05.s7i</span></tt> the <tt><a class="link" href="#stats_for-statement">for-statement</a></tt> for <a class="type" href="#types_array">array</a>s is declared as
  follows:
</p><pre class="indent">
<span class="keywd">const</span> <span class="type">proc</span>: for (<span class="keywd">inout</span> <span class="type">baseType</span>: variable) range (<span class="keywd">in</span> <span class="type">arrayType</span>: arr_obj) do
              (<span class="keywd">in</span> <span class="type">proc</span>: statements)
            end for <span class="keywd">is func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> number <span class="keywd">range</span> 1 <span class="keywd">to</span> length(arr_obj) <span class="keywd">do</span>
      variable := arr_obj[number];
      statements;
    <span class="keywd">end for</span>;
  <span class="keywd">end func</span>;
</pre><p>
  The syntax of this <tt><a class="link" href="#stats_for-statement">for-statement</a></tt> is declared as:
</p><pre class="indent">
$ <span class="keywd">syntax</span> <span class="type">expr</span>: .for.().range.().to.().do.().end.for <span class="keywd">is</span>              -> 25;
</pre><p>
  Additionally everybody can overload the <tt><a class="link" href="#stats_for-statement">for-statement</a></tt> also.
  Because of these powerful features Seed7 does not need iterators.
</p>

<a name="tutorial_Template_declaring_a_statement"><h3>2.6 Template declaring a statement</h3></a>
<p>
  Templates are just normal functions with <a class="type" href="#types_type">type</a>s as parameters.
  The following template function declares <tt><a class="link" href="#stats_for-statement">for-statements</a></tt>:
</p><pre class="indent">
<span class="keywd">const</span> <span class="type">proc</span>: FOR_DECLS (<span class="keywd">in</span> <span class="type">type</span>: aType) <span class="keywd">is func</span>
  <span class="keywd">begin</span>

    <span class="keywd">const</span> <span class="type">proc</span>: for (<span class="keywd">inout</span> <span class="type">aType</span>: variable) range (<span class="keywd">in</span> <span class="type">aType</span>: low) to (<span class="keywd">in</span> <span class="type">aType</span>: high) do
        (<span class="keywd">in</span> <span class="type">proc</span>: statements) end for <span class="keywd">is func</span>
      <span class="keywd">begin</span>
        variable := low;
        <span class="keywd">if</span> variable &lt;= high <span class="keywd">then</span>
          statements;
          <span class="keywd">while</span> variable &lt; high <span class="keywd">do</span>
            incr(variable);
            statements;
          <span class="keywd">end while</span>;
        <span class="keywd">end if</span>;
      <span class="keywd">end func</span>;

  <span class="keywd">end func</span>;

FOR_DECLS(<span class="type">char</span>);
FOR_DECLS(<span class="type">boolean</span>);
</pre><p>
  The body of the 'FOR_DECLS' function contains a declaration of
  the <tt><a class="link" href="#stats_for-statement">for-statement</a></tt> for the type <tt><span class="type">aType</span></tt>. Calling 'FOR_DECLS' with
  <tt><a class="type" href="#types_char">char</a></tt> and <tt><a class="type" href="#types_boolean">boolean</a></tt> as parameter creates corresponding declarations
  of <tt><a class="link" href="#stats_for-statement">for-statements</a></tt>. The example above is a simplified part of
  the library <tt><span class="lib">forloop.s7i</span></tt>.
</p>

<a name="decls_file_start"></a><p></p>
<a name="decls_DECLARATIONS"><h2>3. DECLARATIONS</h2></a>

<p>
    A declaration specifies the identifier, type, and other
  aspects of language elements such as variables, constants
  and functions. In Seed7 everything must be declared before
  it is used. Seed7 uses three kinds of declarations:
</p><ul>
    <li>Normal declarations</li>
    <li>Syntax declarations</li>
    <li>System declarations</li>
</ul><p>
  which are described in detail in the following subchapters.
</p>

<a name="decls_Normal_declarations"><h3>3.1 Normal declarations</h3></a>
<p>
    Normal declarations are the most commonly used form of
  declarations. To contrast them to the syntax declarations normal
  declarations are sometimes called semantic declarations. Seed7
  uses uniform looking declaration constructs to declare variables,
  constants, types, functions and parameters. For example:
</p><pre class="indent">
<span class="keywd">const</span> <span class="type">integer</span>: ONE <span class="keywd">is</span> 1;
</pre><p>
  declares the <tt><a class="type" href="#types_integer">integer</a></tt> constant <tt>'ONE'</tt> which is initialized with the
  value 1. Variable declarations are also possible. For example:
</p><pre class="indent">
<span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
</pre><p>
  declares the <tt><a class="type" href="#types_integer">integer</a></tt> variable <tt>'number'</tt> which is initialized with
  the value 0. Type declarations are done as constant declarations
  where the type of the declared constant is <tt><a class="type" href="#types_type">type</a></tt>:
</p><pre class="indent">
<span class="keywd">const</span> <span class="type">type</span>: myChar <span class="keywd">is</span> <span class="type">char</span>;
</pre><p>
  Function declarations are also a form of constant declaration:
</p><pre class="indent">
<span class="keywd">const</span> <span class="type">func boolean</span>: flipCoin <span class="keywd">is</span>
  <span class="keywd">return</span> rand(FALSE, TRUE);
</pre><p>
  Each object declared with a <tt>'<span class="keywd">const</span>'</tt> or <tt>'<span class="keywd">var</span>'</tt> declaration obtains
  an initial value. It is not possible to use <tt>'<span class="keywd">const</span>'</tt> or <tt>'<span class="keywd">var</span>'</tt>
  declarations without initial value. Declarations with
  initialization expressions are also possible. For example
</p><pre class="indent">
<span class="keywd">var</span> <span class="type">string</span>: fileName <span class="keywd">is</span> NAME & <span class="stri">".txt"</span>;
</pre><p>
  The expression is evaluated and the result is assigned to
  the new object. This is done in the analyze phase of the
  interpreter or compiler, before the execution of the program
  starts. The initialization expressions may contain any
  function (or operator) call. That way user defined functions
  can also be used to initialize a constant or variable:
</p><pre class="indent">
<span class="keywd">const</span> <span class="type">boolean</span>: maybe <span class="keywd">is</span> flipCoin;
</pre><p>
  Constant and variable declarations can be global or local.
  The mechanism to define a parameter like <tt>'x'</tt> is similar to the
  <tt>'<span class="keywd">const</span>'</tt> or <tt>'<span class="keywd">var</span>'</tt> declarations:
</p><pre class="indent">
<span class="keywd">const</span> <span class="type">func float</span>: inverse (<span class="keywd">in</span> <span class="type">float</span>: x) <span class="keywd">is</span>
  <span class="keywd">return</span> 1/x;
</pre><p>
  Function parameters, such as the parameter <tt>'statement'</tt> in
  the example below, act as call-by-name parameters:
</p><pre class="indent">
<span class="keywd">const</span> <span class="type">proc</span>: possiblyDo (<span class="keywd">in</span> <span class="type">proc</span>: statement) <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> flipCoin <span class="keywd">then</span>
      statement;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre><p>
  Abstract data types such as <tt><span class="type">subtype</span></tt>, <tt><a class="type" href="#types_struct">struct</a></tt>, <tt><span class="type">subrange</span></tt>, <tt><a class="type" href="#types_array">array</a></tt>, <tt><a class="type" href="#types_hash">hash</a></tt>, <tt><a class="type" href="#types_set">set</a></tt>,
  <tt><span class="type">interface</span></tt> and <tt><span class="type">enum</span></tt> are realized as
  functions which return a type. E.g.: The type <tt><a class="type" href="#types_array">array</a></tt> is defined in the
  <tt><span class="lib">seed7_05.s7i</span></tt> library with the following header:
</p><pre class="indent">
<span class="keywd">const</span> <span class="type">func type</span>: array (<span class="keywd">in</span> <span class="type">type</span>: baseType) <span class="keywd">is func</span>
</pre><p>
  User defined abstract data types are also possible.
</p><p>
  The initialization uses the creation operation ( ::= ).
  Explicit calls of the create operation are not needed.
</p><p>
  The lifetime of an object goes like this:
</p><ol><li>
  Memory is reserved for the new object (stack or heap memory
     make no difference here).
</li><li>
  The content of the new memory is undefined (It may contain
     garbage), therefore a create statement is necessary instead of
     an assignment.
</li><li>
  The create statements copies the right expression to the left
     expression taking into account that the left expression is
     undefined.
</li><li>
  If the object is variable other values can be assigned using
     the assign statement ( := ). The assignment can assume that the
     left expression contains a legal value. This allows that for
     strings (and some other types which are just references to a
     memory area) the memory containing the old string value (and
     not the memory of the object itself) can be freed when
     necessary.
</li><li>
  At the end of the lifetime of an object the destroy statement
     is executed. For strings (and some other types which are just
     references to a memory area) the memory containing the string
     value (and not the memory of the object itself) is freed.
</li><li>
  The memory of the object is freed.
</li></ol><p>
  The first three steps are usually hidden in the declaration
  statement. The expression
</p><pre class="indent">
ONE . ::= . 1
</pre><p>
  is executed to assign 1 to the object ONE. There are two
  reasons to use ::= instead of := to assign the initialization
  value.
</p><ol><li>
  The assignment ( := ) can only be used to assign a value
    to a variable and initialization is also needed for
    constants.
</li><li>
  Sometimes some initializations are needed for the new
    object in addition to the pure assignment.
</li></ol><p>
  For all predefined types the creation operator ( ::= )
  is already defined. To allow the declaration of objects of a
  new user defined type the constructor operation for this type
  must be defined.
</p>

<a name="decls_Syntax_declarations"><h3>3.2 Syntax declarations</h3></a>
<p>
    Syntax declarations are used to specify the syntax, priority
  and associativity of operators, statements, declarations and
  other constructs. A syntax declaration which defines the
  <tt>'+'</tt> operator is:
</p><pre class="indent">
$ <span class="keywd">syntax</span> <a class="type" href="#types_expr">expr</a>: .(). + .()   <span class="keywd">is</span> ->  7;
</pre><p>
  Most syntax definitions can be found in the file <tt><span class="lib">syntax.s7i</span></tt>.
  A detailed description of the syntax declarations can be
  found in <a class="link" href="#syntax_file_start">chapter 9 (Structured syntax definition)</a>
  There is also a hard coded syntax for function calls with
  a parenthesis enclosed parameter list where the parameters
  are separated by commas. The hard coded syntax is described
  in <a class="link" href="#expr_file_start">chapter 11 (Expressions)</a>.
  Here we use a more complex syntax description:
</p>

<a name="decls_System_declarations"><h3>3.3 System declarations</h3></a>
<p>
    With system declarations the analyzer and the interpreter
  are informed about which objects should be used for various system
  internal purposes. An example of a system declaration is
</p><pre class="indent">
$ <span class="keywd">system</span> <span class="stri">"integer"</span> <span class="keywd">is</span> <span class="type">integer</span>;
</pre><p>
  This defines that the type of all integer literals is <tt><a class="type" href="#types_integer">integer</a></tt>.
  Additionally <tt><a class="type" href="#types_integer">integer</a></tt> is used as type for all integers generated
  by primitive actions.
  There are different objects which are defined by a
  system declaration
</p><ul>
    <li>The types of literals and simple expressions for example:
        <tt><a class="type" href="#types_string">string</a></tt> for strings and <tt><a class="type" href="#types_integer">integer</a></tt> for integers</li>

    <li>Which objects should be used as result values for
      primitive actions for example:<dl><dd>
        <tt>TRUE</tt>, <tt>FALSE</tt> and <tt>empty</tt></dd></dl></li>

    <li>The EXCEPTIONS which are to be raised by
      primitive actions for example:<dl><dd>
        <tt><a class="exception" href="#errors_NUMERIC_ERROR">NUMERIC_ERROR</a></tt> and <tt><a class="exception" href="#errors_MEMORY_ERROR">MEMORY_ERROR</a></tt></dd></dl></li>

    <li>Which objects should be used for several implicit
      actions for example:<dl><dd>
        <tt>:=</tt> <tt>::=</tt> <tt><span class="func">destroy</span></tt> <tt><span class="func">write</span></tt> and <tt><span class="func">flush</span></tt></dd></dl></li>
</ul><p>
  The following system declarations exist
</p><pre class="indent">
$ <span class="keywd">system</span> <span class="stri">"type"</span> <span class="keywd">is</span> <a class="type" href="#types_type">type</a>;
$ <span class="keywd">system</span> <span class="stri">"expr"</span> <span class="keywd">is</span> <a class="type" href="#types_expr">expr</a>;
$ <span class="keywd">system</span> <span class="stri">"integer"</span> <span class="keywd">is</span> <a class="type" href="#types_integer">integer</a>;
$ <span class="keywd">system</span> <span class="stri">"bigInteger"</span> <span class="keywd">is</span> <a class="type" href="#types_bigInteger">bigInteger</a>;
$ <span class="keywd">system</span> <span class="stri">"char"</span> <span class="keywd">is</span> <a class="type" href="#types_char">char</a>;
$ <span class="keywd">system</span> <span class="stri">"string"</span> <span class="keywd">is</span> <a class="type" href="#types_string">string</a>;
$ <span class="keywd">system</span> <span class="stri">"proc"</span> <span class="keywd">is</span> <a class="type" href="#types_proc">proc</a>;
$ <span class="keywd">system</span> <span class="stri">"float"</span> <span class="keywd">is</span> <a class="type" href="#types_float">float</a>;

$ <span class="keywd">system</span> <span class="stri">"true"</span> <span class="keywd">is</span> TRUE;
$ <span class="keywd">system</span> <span class="stri">"false"</span> <span class="keywd">is</span> FALSE;
$ <span class="keywd">system</span> <span class="stri">"empty"</span> <span class="keywd">is</span> empty;

$ <span class="keywd">system</span> <span class="stri">"memory_error"</span> <span class="keywd">is</span> <a class="exception" href="#errors_MEMORY_ERROR">MEMORY_ERROR</a>;
$ <span class="keywd">system</span> <span class="stri">"numeric_error"</span> <span class="keywd">is</span> <a class="exception" href="#errors_NUMERIC_ERROR">NUMERIC_ERROR</a>;
$ <span class="keywd">system</span> <span class="stri">"range_error"</span> <span class="keywd">is</span> <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a>;
$ <span class="keywd">system</span> <span class="stri">"file_error"</span> <span class="keywd">is</span> <a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a>;
$ <span class="keywd">system</span> <span class="stri">"illegal_action"</span> <span class="keywd">is</span> <a class="exception" href="#errors_ILLEGAL_ACTION">ILLEGAL_ACTION</a>;

$ <span class="keywd">system</span> <span class="stri">"assign"</span> <span class="keywd">is</span> := ;
$ <span class="keywd">system</span> <span class="stri">"create"</span> <span class="keywd">is</span> ::= ;
$ <span class="keywd">system</span> <span class="stri">"destroy"</span> <span class="keywd">is</span> destroy;
$ <span class="keywd">system</span> <span class="stri">"ord"</span> <span class="keywd">is</span> ord;
$ <span class="keywd">system</span> <span class="stri">"in"</span> <span class="keywd">is</span> <span class="keywd">in</span>;
$ <span class="keywd">system</span> <span class="stri">"prot_outfile"</span> <span class="keywd">is</span> PROT_OUTFILE;
$ <span class="keywd">system</span> <span class="stri">"flush"</span> <span class="keywd">is</span> flush;
$ <span class="keywd">system</span> <span class="stri">"write"</span> <span class="keywd">is</span> write;
$ <span class="keywd">system</span> <span class="stri">"writeln"</span> <span class="keywd">is</span> writeln;
$ <span class="keywd">system</span> <span class="stri">"main"</span> <span class="keywd">is</span> main;
</pre><p></p>

<a name="stats_file_start"></a><p></p>
<a name="stats_PREDEFINED_STATEMENTS"><h2>4. PREDEFINED STATEMENTS</h2></a>

<p>
    The library contains several predefined statements:
  <a class="link" href="#stats_Assignment">assignment</a>, <a class="link" href="#stats_while-statement">while-statement</a>, <a class="link" href="#stats_repeat-statement">repeat-statement</a>, <a class="link" href="#stats_for-statement">for-statement</a>,
  <a class="link" href="#stats_if-statement">if-statement</a>, <a class="link" href="#stats_case-statement">case-statement</a> and procedure call.
</p>
<dl><dt>
  Syntax:
</dt><dd><tt><dl>
    <dt><a name="stats_ebnf_statement">statement</a> ::=</dt><dd>
      <a class="ebnf" href="#stats_ebnf_single_statement">single_statement</a> [ ';' [ <a class="ebnf" href="#stats_ebnf_statement">statement</a> ] ] .</dd>
<dt><br /></dt>
    <dt><a name="stats_ebnf_single_statement">single_statement</a> ::=</dt><dd>
      <a class="ebnf" href="#stats_ebnf_assignment_statement">assignment_statement</a> | <a class="ebnf" href="#stats_ebnf_while_statement">while_statement</a> | <a class="ebnf" href="#stats_ebnf_repeat_statement">repeat_statement</a> |<br />
      <a class="ebnf" href="#stats_ebnf_for_statement">for_statement</a> | <a class="ebnf" href="#stats_ebnf_for_step_statement">for_step_statement</a> | <a class="ebnf" href="#stats_ebnf_for_each_statement">for_each_statement</a> |<br />
      <a class="ebnf" href="#stats_ebnf_if_statement">if_statement</a> | <a class="ebnf" href="#stats_ebnf_case_statement">case_statement</a> |<br />
      procedure_call | <a class="ebnf" href="#stats_ebnf_empty_statement">empty_statement</a> .</dd>
<dt><br /></dt>
    <dt><a name="stats_ebnf_empty_statement">empty_statement</a> ::=</dt><dd>
      'noop' .</dd>
</dl></tt></dd></dl><p>
  Everywhere where one statement can be written a sequence of
  statements can also be used. The semicolon-operator concatenates
  two statements giving a new statement. The semicolon operator
  can also be used behind the last statement of a statement
  sequence. In this case the semicolon is just ignored.

</p><p>
  Declaration:
</p><pre class="indent">
$ <span class="keywd">syntax</span> <a class="type" href="#types_expr">expr</a>: .(). ; .() <span class="keywd">is</span>            &lt;- 50;
$ <span class="keywd">syntax</span> <a class="type" href="#types_expr">expr</a>: .(). ; <span class="keywd">is</span>                &lt;- 50 [1];

<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: (<span class="keywd">ref</span> <a class="type" href="#types_void">void</a> <span class="keywd">param</span>) ; (<span class="keywd">ref</span> <a class="type" href="#types_void">void</a> <span class="keywd">param</span>) <span class="keywd">is</span> noop;
</pre><p></p>

<a name="stats_Assignment"><h3>4.1 Assignment</h3></a>
<p>
  For example:
</p><pre class="indent">
minimum := maximum <span class="op">div</span> 2;
</pre><p></p><dl><dt>
  Semantics:</dt><dd>
    The expression at the right side of the assignment symbol is
    evaluated and assigned to the variable at the left side.
</dd></dl>
<dl><dt>
  Syntax:
</dt><dd><tt><dl>
    <dt><a name="stats_ebnf_assignment_statement">assignment_statement</a> ::=</dt><dd>
      designator ':=' <a class="ebnf" href="#expr_ebnf_expression">expression</a> .</dd>
</dl></tt></dd></dl><p>
  The assignment statement is defined for every standard type.
</p><p>
  If an assignment for a new user defined type is needed it
  must be defined additionally.

</p><p>
  Declaration:
</p><pre class="indent">
$ <span class="keywd">syntax</span> <a class="type" href="#types_expr">expr</a>: .(). := .() <span class="keywd">is</span>                     &lt;-> 20;

<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: (<span class="keywd">inout</span> <a class="type" href="#types_type">type</a>: dest) := (<span class="keywd">ref</span> <a class="type" href="#types_type">type</a>: source)             <span class="keywd">is</span> action <span class="stri">"TYP_CPY"</span>;
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: (<span class="keywd">inout</span> <a class="type" href="#types_proc">proc</a>: dest) := (<span class="keywd">ref</span> <a class="type" href="#types_proc">proc</a>: source)             <span class="keywd">is</span> action <span class="stri">"PRC_CPY"</span>;
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: (<span class="keywd">inout</span> <a class="type" href="#types_func">func</a> <span class="type">aType</span>: dest) := (<span class="keywd">ref</span> <a class="type" href="#types_func">func</a> <span class="type">aType</span>: source) <span class="keywd">is</span> action <span class="stri">"PRC_CPY"</span>;
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: (<span class="keywd">inout</span> <a class="type" href="#types_varfunc">varfunc</a> <span class="type">aType</span>: dest) := (<span class="keywd">ref</span> <a class="type" href="#types_varfunc">varfunc</a> <span class="type">aType</span>: source) <span class="keywd">is</span> action <span class="stri">"PRC_CPY"</span>;
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: (<span class="keywd">inout</span> <span class="type">ACTION</span>: dest) := (<span class="keywd">in</span> <span class="type">ACTION</span>: source)          <span class="keywd">is</span> action <span class="stri">"ACT_CPY"</span>;
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: (<span class="keywd">inout</span> <a class="type" href="#types_boolean">boolean</a>: dest) := (<span class="keywd">in</span> <a class="type" href="#types_boolean">boolean</a>: source)        <span class="keywd">is</span> action <span class="stri">"BLN_CPY"</span>;
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: (<span class="keywd">inout</span> <a class="type" href="#types_integer">integer</a>: dest) := (<span class="keywd">in</span> <a class="type" href="#types_integer">integer</a>: source)        <span class="keywd">is</span> action <span class="stri">"INT_CPY"</span>;
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: (<span class="keywd">inout</span> <a class="type" href="#types_char">char</a>: dest) := (<span class="keywd">ref</span> <a class="type" href="#types_char">char</a>: source)             <span class="keywd">is</span> action <span class="stri">"CHR_CPY"</span>;
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: (<span class="keywd">inout</span> <a class="type" href="#types_string">string</a>: dest) := (<span class="keywd">ref</span> <a class="type" href="#types_string">string</a>: source)         <span class="keywd">is</span> action <span class="stri">"STR_CPY"</span>;
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: (<span class="keywd">inout</span> <a class="type" href="#types_reference">reference</a>: dest) := (<span class="keywd">ref</span> <a class="type" href="#types_reference">reference</a>: source)   <span class="keywd">is</span> action <span class="stri">"REF_CPY"</span>;
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: (<span class="keywd">inout</span> <a class="type" href="#types_ref_list">ref_list</a>: dest) := (<span class="keywd">in</span> <a class="type" href="#types_ref_list">ref_list</a>: source)      <span class="keywd">is</span> action <span class="stri">"RFL_CPY"</span>;
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: (<span class="keywd">inout</span> <span class="type">ptrType</span>: dest) := (<span class="keywd">in</span> <span class="type">ptrType</span>: source)        <span class="keywd">is</span> action <span class="stri">"REF_CPY"</span>;
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: (<span class="keywd">inout</span> <span class="type">varptrType</span>: dest) := (<span class="keywd">in</span> <span class="type">varptrType</span>: source)  <span class="keywd">is</span> action <span class="stri">"REF_CPY"</span>;
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: (<span class="keywd">inout</span> <span class="type">arrayType</span>: dest) := (<span class="keywd">in</span> <span class="type">arrayType</span>: source)    <span class="keywd">is</span> action <span class="stri">"ARR_CPY"</span>;
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: (<span class="keywd">inout</span> <a class="type" href="#types_set">bitset</a>: dest) := (<span class="keywd">in</span> <a class="type" href="#types_set">bitset</a>: source)          <span class="keywd">is</span> action <span class="stri">"SET_CPY"</span>;
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: (<span class="keywd">inout</span> <span class="type">structType</span>: dest) := (<span class="keywd">in</span> <span class="type">structType</span>: source)  <span class="keywd">is</span> action <span class="stri">"SCT_CPY"</span>;
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: (<span class="keywd">inout</span> <span class="type">enumType</span>: dest) := (<span class="keywd">in</span> <span class="type">enumType</span>: source)      <span class="keywd">is</span> action <span class="stri">"ENU_CPY"</span>;
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: (<span class="keywd">inout</span> <span class="type">clib_file</span>: dest) := (<span class="keywd">ref</span> <span class="type">clib_file</span>: source)   <span class="keywd">is</span> action <span class="stri">"FIL_CPY"</span>;
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: (<span class="keywd">inout</span> <span class="type">interfaceType</span>: dest) := (<span class="keywd">ref</span> <span class="type">interfaceType</span>: source) <span class="keywd">is</span> action <span class="stri">"ITF_CPY"</span>;
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: (<span class="keywd">inout</span> <span class="type">interfaceType</span>: dest) := (<span class="keywd">ref</span> <span class="type">aType</span>: source)   <span class="keywd">is</span> action <span class="stri">"ITF_CPY2"</span>;
</pre><p></p>

<a name="stats_while-statement"><h3>4.2 while-statement</h3></a>
<p>
  For example:
</p><pre class="indent">
<span class="keywd">while</span> maximum > minimum <span class="keywd">do</span>
  minimum := 2 * minimum + stepValue;
  decr(stepValue);
<span class="keywd">end while</span>;
</pre><p></p><dl><dt>
  Semantics:</dt><dd>
    First the condition between <tt><span class="keywd">while</span></tt> and <tt><span class="keywd">do</span></tt> is evaluated.
    When this evaluation yields <tt><span class="var">FALSE</span></tt>, the while-statement is
    finished. When the evaluation yields <tt><span class="var">TRUE</span></tt>, the statement
    between <tt><span class="keywd">do</span></tt> and <tt><span class="keywd">end</span></tt> is executed and the whole while-statement
    is executed again.
</dd></dl>
<dl><dt>
  Syntax:
</dt><dd><tt><dl>
    <dt><a name="stats_ebnf_while_statement">while_statement</a> ::=</dt><dd>
      '<span class="keywd">while</span>' <a class="ebnf" href="#expr_ebnf_expression">expression</a> '<span class="keywd">do</span>'<br />
      &nbsp;&nbsp;<a class="ebnf" href="#stats_ebnf_statement">statement</a><br />
      '<span class="keywd">end</span>' '<span class="keywd">while</span>' .</dd>
</dl></tt></dd></dl><p>
  The expression must be of type <tt><a class="type" href="#types_boolean">boolean</a></tt>.

</p><p>
  Declaration:
</p><pre class="indent">
$ <span class="keywd">syntax</span> <a class="type" href="#types_expr">expr</a>: .while.().do.().end.while <span class="keywd">is</span>       -> 25;

<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: while (<span class="keywd">ref</span> <a class="type" href="#types_func">func</a> <a class="type" href="#types_boolean">boolean</a>: condition) do (<span class="keywd">in</span> <a class="type" href="#types_proc">proc</a>: statement) end while <span class="keywd">is action</span> <span class="stri">"PRC_WHILE"</span>;
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: while (<span class="keywd">in</span> <a class="type" href="#types_boolean">boolean</a>: condition)  do (<span class="keywd">in</span> <a class="type" href="#types_proc">proc</a>: statement) end while      <span class="keywd">is action</span> <span class="stri">"PRC_WHILE"</span>;
</pre><p>
  Alternate declaration:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: while (<span class="keywd">ref</span> <a class="type" href="#types_func">func</a> <a class="type" href="#types_boolean">boolean</a>: condition) do (<span class="keywd">in</span> <a class="type" href="#types_proc">proc</a>: statement) end while <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> condition <span class="keywd">then</span>
      statement;
      <span class="keywd">while</span> condition <span class="keywd">do</span>
        statement;
      <span class="keywd">end while</span>;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre><p></p>

<a name="stats_repeat-statement"><h3>4.3 repeat-statement</h3></a>
<p>
  For example:
</p><pre class="indent">
<span class="keywd">repeat</span>
  incr(minimum);
  maximum := maximum - stepValue;
<span class="keywd">until</span> 2 * minimum > maximum;
</pre><p></p><dl><dt>
  Semantics:</dt><dd>
    The statement between <tt><span class="keywd">repeat</span></tt> and <tt><span class="keywd">until</span></tt> is executed.
    Then the condition after <tt><span class="keywd">until</span></tt> is evaluated. When this
    evaluation yields <tt><span class="var">TRUE</span></tt>, the repeat-statement is finished.
    When the evaluation yields <tt><span class="var">FALSE</span></tt> the repeat-statement is
    executed again.
</dd></dl>
<dl><dt>
  Syntax:
</dt><dd><tt><dl>
    <dt><a name="stats_ebnf_repeat_statement">repeat_statement</a> ::=</dt><dd>
      '<span class="keywd">repeat</span>'<br />
      &nbsp;&nbsp;<a class="ebnf" href="#stats_ebnf_statement">statement</a><br />
      '<span class="keywd">until</span>' <a class="ebnf" href="#expr_ebnf_expression">expression</a> .</dd>
</dl></tt></dd></dl><p>
  The expression must be of type <tt><a class="type" href="#types_boolean">boolean</a></tt>.

</p><p>
  Declaration:
</p><pre class="indent">
$ <span class="keywd">syntax</span> <a class="type" href="#types_expr">expr</a>: .repeat.().until.() <span class="keywd">is</span>             -> 25;

<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: repeat (<span class="keywd">in</span> <a class="type" href="#types_proc">proc</a>: statement) until (<span class="keywd">ref</span> <a class="type" href="#types_func">func</a> <a class="type" href="#types_boolean">boolean</a>: condition) <span class="keywd">is action</span> <span class="stri">"PRC_REPEAT"</span>;
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: repeat (<span class="keywd">in</span> <a class="type" href="#types_proc">proc</a>: statement) until (<span class="keywd">in</span> <a class="type" href="#types_boolean">boolean</a>: condition)       <span class="keywd">is action</span> <span class="stri">"PRC_REPEAT"</span>;
</pre><p>
  Alternate declaration:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: repeat (<span class="keywd">in</span> <a class="type" href="#types_proc">proc</a>: statement) until (<span class="keywd">ref</span> <a class="type" href="#types_func">func</a> <a class="type" href="#types_boolean">boolean</a>: condition) <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    statement;
    <span class="keywd">if</span> <span class="keywd">not</span> condition <span class="keywd">then</span>
      <span class="keywd">repeat</span>
        statement;
      <span class="keywd">until</span> condition;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre><p></p>

<a name="stats_for-statement"><h3>4.4 for-statement</h3></a>
<p>
  For example:
</p><pre class="indent">
<span class="keywd">for</span> index <span class="keywd">range</span> min_index <span class="keywd">to</span> max_index <span class="keywd">do</span>
  sumValue +:= field[index];
<span class="keywd">end for</span>;
</pre><p></p><dl><dt>
  Semantics:</dt><dd><dl><dt>
    When the <tt><span class="keywd">to</span></tt> symbol is used the for-statement is defined as
    follows:</dt><dd>
      First the lower limit and the upper limit which stand behind
      <tt><span class="keywd">range</span></tt> and <tt><span class="keywd">to</span></tt> are evaluated. Then the lower limit is assigned
      to the control variable which stands behind <tt><span class="keywd">for</span></tt>. If the value
      of the control variable is less than or equal the upper limit
      the statements behind <tt><span class="keywd">do</span></tt> are executed. After that the control
      variable is incremented and compared with the upper limit
      again. This compare - execute - increment cycle is repeated
      until the control variable is greater than the upper limit.</dd><dt>
    When the <tt><span class="keywd">downto</span></tt> symbol is used the for-statement is defined as
    follows:</dt><dd>
      First the upper limit and the lower limit which stand behind
      <tt><span class="keywd">range</span></tt> and <tt><span class="keywd">downto</span></tt> are evaluated. Then the upper limit is
      assigned to the control variable which stands behind <tt><span class="keywd">for</span></tt>. If
      the value of the control variable is greater than or equal the
      lower limit the statements behind <tt><span class="keywd">do</span></tt> are executed. After that
      the control variable is decremented and compared with the lower
      limit again. This compare - execute - increment cycle is
      repeated until the control variable is less than the lower limit.</dd></dl>
</dd></dl>
<dl><dt>
  Syntax:
</dt><dd><tt><dl>
    <dt><a name="stats_ebnf_for_statement">for_statement</a> ::=</dt><dd>
      '<span class="keywd">for</span>' <a class="ebnf" href="#tokens_ebnf_identifier">identifier</a> '<span class="keywd">range</span>' <a class="ebnf" href="#expr_ebnf_expression">expression</a> [ '<span class="keywd">to</span>' | '<span class="keywd">downto</span>' ] <a class="ebnf" href="#expr_ebnf_expression">expression</a> '<span class="keywd">do</span>'<br />
      &nbsp;&nbsp;<a class="ebnf" href="#stats_ebnf_statement">statement</a><br />
      '<span class="keywd">end</span>' '<span class="keywd">for</span>' .</dd>
</dl></tt></dd></dl><p>

  Declaration:
</p><pre class="indent">
$ <span class="keywd">syntax</span> <a class="type" href="#types_expr">expr</a>: .for.().range.().to.().do.().end.for <span class="keywd">is</span>     -> 25;
$ <span class="keywd">syntax</span> <a class="type" href="#types_expr">expr</a>: .for.().range.().downto.().do.().end.for <span class="keywd">is</span> -> 25;

<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: FOR_DECLS (<span class="keywd">in</span> <a class="type" href="#types_type">type</a>: aType) <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    <span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: for (<span class="keywd">inout</span> <span class="type">aType</span>: variable) range
        (<span class="keywd">in</span> <span class="type">aType</span>: lowerLimit) to (<span class="keywd">in</span> <span class="type">aType</span>: upperLimit) do
        (<span class="keywd">in</span> <a class="type" href="#types_proc">proc</a>: statements) end for <span class="keywd">is func</span>
      <span class="keywd">begin</span>
        variable := lowerLimit;
        <span class="keywd">if</span> variable &lt;= upperLimit <span class="keywd">then</span>
          statements;
          <span class="keywd">while</span> variable &lt; upperLimit <span class="keywd">do</span>
            incr(variable);
            statements;
          <span class="keywd">end while</span>;
        <span class="keywd">end if</span>;
      <span class="keywd">end func</span>;

    <span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: for (<span class="keywd">inout</span> <span class="type">aType</span>: variable) range
        (<span class="keywd">in</span> <span class="type">aType</span>: upperLimit) downto (<span class="keywd">in</span> <span class="type">aType</span>: lowerLimit) do
        (<span class="keywd">in</span> <a class="type" href="#types_proc">proc</a>: statements) end for <span class="keywd">is func</span>
      <span class="keywd">begin</span>
        variable := upperLimit;
        <span class="keywd">if</span> variable >= lowerLimit <span class="keywd">then</span>
          statements;
          <span class="keywd">while</span> variable > lowerLimit <span class="keywd">do</span>
            decr(variable);
            statements;
          <span class="keywd">end while</span>;
        end if;
      <span class="keywd">end func</span>;
  <span class="keywd">end func</span>;

FOR_DECLS(<a class="type" href="#types_integer">integer</a>);
FOR_DECLS(<a class="type" href="#types_char">char</a>);
FOR_DECLS(<a class="type" href="#types_boolean">boolean</a>);
</pre><p></p>

<a name="stats_for-step-statement"><h3>4.5 for-step-statement</h3></a>
<p>
  For example:
</p><pre class="indent">
<span class="keywd">for</span> evenNumber <span class="keywd">range</span> 0 <span class="keywd">to</span> 10 <span class="keywd">step</span> 2 <span class="keywd">do</span>
  write(evenNumber);
<span class="keywd">end for</span>;
</pre><p></p><dl><dt>
  Semantics:</dt><dd><dl><dt>
    When the <tt><span class="keywd">to</span></tt> symbol is used the for-statement is defined as
    follows:</dt><dd>
      First the lower limit and the upper limit which stand behind
      <tt><span class="keywd">range</span></tt> and <tt><span class="keywd">to</span></tt> are evaluated. Then the lower limit is assigned
      to the control variable which stands behind <tt><span class="keywd">for</span></tt>. If the value
      of the control variable is less than or equal the upper limit
      the statements behind <tt><span class="keywd">do</span></tt> are executed. After that the control
      variable is incremented by the value behind <tt><span class="keywd">step</span></tt>. Then
      the control variable is compared with the upper limit again.
      This compare - execute - increment cycle is repeated until
      the control variable is greater than the upper limit.</dd><dt>
    When the <tt><span class="keywd">downto</span></tt> symbol is used the for-statement is defined as
    follows:</dt><dd>
      First the upper limit and the lower limit which stand behind
      <tt><span class="keywd">range</span></tt> and <tt><span class="keywd">downto</span></tt> are evaluated. Then the upper limit is
      assigned to the control variable which stands behind <tt><span class="keywd">for</span></tt>. If
      the value of the control variable is greater than or equal the
      lower limit the statements behind <tt><span class="keywd">do</span></tt> are executed. After that
      the control variable is decremented by the value behind <tt><span class="keywd">step</span></tt>.
      Then the control variable is compared with the lower limit
      again. This compare - execute - increment cycle is repeated
      until the control variable is less than the lower limit.</dd></dl>
</dd></dl>
<dl><dt>
  Syntax:
</dt><dd><tt><dl>
    <dt><a name="stats_ebnf_for_step_statement">for_step_statement</a> ::=</dt><dd>
      '<span class="keywd">for</span>' <a class="ebnf" href="#tokens_ebnf_identifier">identifier</a> '<span class="keywd">range</span>' <a class="ebnf" href="#expr_ebnf_expression">expression</a> [ '<span class="keywd">to</span>' | '<span class="keywd">downto</span>' ] <a class="ebnf" href="#expr_ebnf_expression">expression</a> '<span class="keywd">step</span>' <a class="ebnf" href="#expr_ebnf_expression">expression</a> '<span class="keywd">do</span>'<br />
      &nbsp;&nbsp;<a class="ebnf" href="#stats_ebnf_statement">statement</a><br />
      '<span class="keywd">end</span>' '<span class="keywd">for</span>' .</dd>
</dl></tt></dd></dl><p>

  Declaration:
</p><pre class="indent">
$ <span class="keywd">syntax</span> <a class="type" href="#types_expr">expr</a>: .for.().range.().to.().step.().do.().end.for <span class="keywd">is</span>     -> 25;
$ <span class="keywd">syntax</span> <a class="type" href="#types_expr">expr</a>: .for.().range.().downto.().step.().do.().end.for <span class="keywd">is</span> -> 25;

<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: FOR_STEP_DECLS (<span class="keywd">in</span> <a class="type" href="#types_type">type</a>: aType) <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getobj((<span class="keywd">inout</span> <span class="type">aType</span> param) +:= (<span class="keywd">in</span> <a class="type" href="#types_integer">integer</a> param)) <> NIL <span class="keywd">then</span>

      <span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: for (<span class="keywd">inout</span> <span class="type">aType</span>: variable) range (<span class="keywd">in</span> <span class="type">aType</span>: lowerLimit) to (<span class="keywd">in</span> <span class="type">aType</span>: upperLimit)
          step (<span class="keywd">in</span> <a class="type" href="#types_integer">integer</a>: incr_step) do
          (<span class="keywd">in</span> <a class="type" href="#types_proc">proc</a>: statements) end for <span class="keywd">is func</span>
        <span class="keywd">begin</span>
          variable := lowerLimit;
          <span class="keywd">while</span> variable <= upperLimit <span class="keywd">do</span>
            statements;
            variable +:= incr_step;
          <span class="keywd">end while</span>;
        <span class="keywd">end func</span>;

    <span class="keywd">end if</span>;
    <span class="keywd">if</span> getobj((<span class="keywd">inout</span> <span class="type">aType</span> param) -:= (<span class="keywd">in</span> <a class="type" href="#types_integer">integer</a> param)) <> NIL <span class="keywd">then</span>

      <span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: for (<span class="keywd">inout</span> <span class="type">aType</span>: variable) range (<span class="keywd">in</span> <span class="type">aType</span>: upperLimit) downto (<span class="keywd">in</span> <span class="type">aType</span>: lowerLimit)
          step (<span class="keywd">in</span> <a class="type" href="#types_integer">integer</a>: decr_step) do
          (<span class="keywd">in</span> <a class="type" href="#types_proc">proc</a>: statements) end for <span class="keywd">is func</span>
        <span class="keywd">begin</span>
          variable := upperLimit;
          <span class="keywd">while</span> variable >= lowerLimit <span class="keywd">do</span>
            statements;
            variable -:= decr_step;
          <span class="keywd">end while</span>;
        <span class="keywd">end func</span>;

    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;

FOR_STEP_DECLS(<a class="type" href="#types_integer">integer</a>);
</pre><p></p>

<a name="stats_for-each-statement"><h3>4.6 for-each-statement</h3></a>
<p>
  For example:
</p><pre class="indent">
<span class="keywd">for</span> currObject <span class="keywd">range</span> element_list <span class="keywd">do</span>
  result &amp;:= " " & str(currObject);
<span class="keywd">end for</span>;
</pre><p></p><dl><dt>
  Semantics:</dt><dd>
    First the element list which stands behind <tt><span class="keywd">range</span></tt> is evaluated.
    If the element list is empty the for-each-statement is finished.
    Otherwise the first element of the element list is assigned
    to the control variable which stands behind <tt><span class="keywd">for</span></tt>. Then the
    statements behind <tt><span class="keywd">do</span></tt> are executed. If there is no next element
    in the element the for-each-statement is finished. Otherwise
    the next element of the element list is assigned to the control
    variable. This check for next element - execute cycle is repeated
    until there is no next element in the element list.
</dd></dl>
<dl><dt>
  Syntax:
</dt><dd><tt><dl>
    <dt><a name="stats_ebnf_for_each_statement">for_each_statement</a> ::=</dt><dd>
      '<span class="keywd">for</span>' <a class="ebnf" href="#tokens_ebnf_identifier">identifier</a> '<span class="keywd">range</span>' <a class="ebnf" href="#expr_ebnf_expression">expression</a> '<span class="keywd">do</span>'<br />
      &nbsp;&nbsp;<a class="ebnf" href="#stats_ebnf_statement">statement</a><br />
      '<span class="keywd">end</span>' '<span class="keywd">for</span>' .</dd>
</dl></tt></dd></dl><p>

  Declaration:
</p><pre class="indent">
$ <span class="keywd">syntax</span> <a class="type" href="#types_expr">expr</a>: .for.().range.().do.().end.for <span class="keywd">is</span>          -> 25;

<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: for (<span class="keywd">inout</span> <a class="type" href="#types_reference">reference</a>: variable) range (<span class="keywd">in</span> <a class="type" href="#types_ref_list">ref_list</a>: aRefList) do
              (<span class="keywd">in</span> <a class="type" href="#types_proc">proc</a>: statement)
            end for <span class="keywd">is action</span> <span class="stri">"RFL_FOR"</span>;

<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: for (<span class="keywd">inout</span> <span class="type">baseType</span>: variable) range (<span class="keywd">in</span> <span class="type">arrayType</span>: arr_obj) do
              (<span class="keywd">in</span> <a class="type" href="#types_proc">proc</a>: statements)
            end for <span class="keywd">is func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="#types_integer">integer</a>: number <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> number <span class="keywd">range</span> minIdx(arr_obj) <span class="keywd">to</span> maxIdx(arr_obj) <span class="keywd">do</span>
      variable := arr_obj[number];
      statements;
    <span class="keywd">end for</span>;
  <span class="keywd">end func</span>;

<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: for (<span class="keywd">inout</span> <span class="type">baseType</span>: variable) range (<span class="keywd">in</span> <span class="type">setType</span>: a_set) do
              (<span class="keywd">in</span> <a class="type" href="#types_proc">proc</a>: statements)
            end for <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    <span class="keywd">for</span> variable <span class="keywd">range</span> min(a_set) <span class="keywd">to</span> max(a_set) <span class="keywd">do</span>
      <span class="keywd">if</span> variable <span class="keywd">in</span> a_set <span class="keywd">then</span>
        statements;
      <span class="keywd">end if</span>;
    <span class="keywd">end for</span>;
  <span class="keywd">end func</span>;
</pre><p></p>

<a name="stats_if-statement"><h3>4.7 if-statement</h3></a>
<p>
  For example:
</p><pre class="indent">
<span class="keywd">if</span> sumValue &lt; minimum <span class="keywd">then</span>
  factor := sumValue;
  sumValue := minimum;
<span class="keywd">elsif</span> sumValue > maximum <span class="keywd">then</span>
  factor := -sumValue;
  sumValue := maximum;
<span class="keywd">else</span>
  factor := 0;
<span class="keywd">end if</span>;
</pre><p></p><dl><dt>
  Semantics:</dt><dd>
    The expressions before <tt><span class="keywd">then</span></tt> are evaluated in row.
    When such an expression evaluates to <tt><span class="var">TRUE</span></tt> the statements
    behind <tt><span class="keywd">then</span></tt> are executed and the if-statement is finished.
    If all expressions before <tt><span class="keywd">then</span></tt> evaluate to <tt><span class="var">FALSE</span></tt> and an
    else-part is present the statements behind <tt><span class="keywd">else</span></tt> are executed
    and the if-statement is finished.
    If all expressions before <tt><span class="keywd">then</span></tt> evaluate to <tt><span class="var">FALSE</span></tt> and no
    else-part is present the if-statement is finished.
</dd></dl>
<dl><dt>
  Syntax:
</dt><dd><tt><dl>
    <dt><a name="stats_ebnf_if_statement">if_statement</a> ::=</dt><dd>
      '<span class="keywd">if</span>' <a class="ebnf" href="#expr_ebnf_expression">expression</a> '<span class="keywd">then</span>'<br />
      &nbsp;&nbsp;<a class="ebnf" href="#stats_ebnf_statement">statement</a><br />
      { '<span class="keywd">elsif</span>' <a class="ebnf" href="#expr_ebnf_expression">expression</a> '<span class="keywd">then</span>'<br />
      &nbsp;&nbsp;<a class="ebnf" href="#stats_ebnf_statement">statement</a> }<br />
      [ '<span class="keywd">else</span>'<br />
      &nbsp;&nbsp;<a class="ebnf" href="#stats_ebnf_statement">statement</a> ]<br />
      '<span class="keywd">end</span>' '<span class="keywd">if</span>' .</dd>
</dl></tt></dd></dl><p>
  The expression must be of type <tt><a class="type" href="#types_boolean">boolean</a></tt>.

</p><p>
  Declaration:
</p><pre class="indent">
$ <span class="keywd">syntax</span> <a class="type" href="#types_expr">expr</a>: .if.().then.().end.if <span class="keywd">is</span>           -> 25;
$ <span class="keywd">syntax</span> <a class="type" href="#types_expr">expr</a>: .if.().then.().().end.if <span class="keywd">is</span>        -> 25;

$ <span class="keywd">syntax</span> <a class="type" href="#types_expr">expr</a>: .elsif.().then.() <span class="keywd">is</span>               &lt;- 60;
$ <span class="keywd">syntax</span> <a class="type" href="#types_expr">expr</a>: .elsif.().then.().() <span class="keywd">is</span>            &lt;- 60;
$ <span class="keywd">syntax</span> <a class="type" href="#types_expr">expr</a>: .else.() <span class="keywd">is</span>                        &lt;- 60;

<span class="keywd">const</span> <a class="type" href="#types_type">type</a>: ELSIF_RESULT <span class="keywd">is</span> newtype;
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: (ref ELSIF_RESULT <span class="keywd">param</span>) ::= enumlit <span class="keywd">is  action</span> <span class="stri">"ENU_GENLIT"</span>;
<span class="keywd">const</span> <span class="type">ELSIF_RESULT</span>: ELSIF_EMPTY <span class="keywd">is</span> enumlit;
<span class="keywd">const</span> <a class="type" href="#types_type">type</a>: ELSIF_PROC <span class="keywd">is</span>                        (func ELSIF_RESULT);
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: (ref ELSIF_PROC <span class="keywd">param</span>) ::= (ref ELSIF_RESULT <span class="keywd">param</span>) <span class="keywd">is action</span> <span class="stri">"ENU_CREATE"</span>;

<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>:       if (<span class="keywd">in</span> <a class="type" href="#types_boolean">boolean</a> <span class="keywd">param</span>) then
                    (<span class="keywd">in</span> <a class="type" href="#types_proc">proc</a> <span class="keywd">param</span>)
                  end if <span class="keywd">is                        action</span> <span class="stri">"PRC_IF"</span>;

<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>:       if (<span class="keywd">in</span> <a class="type" href="#types_boolean">boolean</a> <span class="keywd">param</span>) then
                    (<span class="keywd">in</span> <a class="type" href="#types_proc">proc</a> <span class="keywd">param</span>)
                  (<span class="keywd">in</span> <span class="type">ELSIF_PROC</span> <span class="keywd">param</span>)
                  end if <span class="keywd">is                        action</span> <span class="stri">"PRC_IF_ELSIF"</span>;

<span class="keywd">const</span> <span class="type">ELSIF_PROC</span>: elsif (<span class="keywd">in</span> <a class="type" href="#types_boolean">boolean</a> <span class="keywd">param</span>) then
                    (<span class="keywd">in</span> <a class="type" href="#types_proc">proc</a> <span class="keywd">param</span>) <span class="keywd">is             action</span> <span class="stri">"PRC_IF"</span>;

<span class="keywd">const</span> <span class="type">ELSIF_PROC</span>: elsif (<span class="keywd">in</span> <a class="type" href="#types_boolean">boolean</a> <span class="keywd">param</span>) then
                    (<span class="keywd">in</span> <a class="type" href="#types_proc">proc</a> <span class="keywd">param</span>)
                  (<span class="keywd">in</span> <span class="type">ELSIF_PROC</span> <span class="keywd">param</span>) <span class="keywd">is         action</span> <span class="stri">"PRC_IF_ELSIF"</span>;

<span class="keywd">const</span> <span class="type">ELSIF_PROC</span>: else
                    (<span class="keywd">in</span> <a class="type" href="#types_void">void</a> <span class="keywd">param</span>) <span class="keywd">is</span>             ELSIF_EMPTY;


<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: if TRUE  then (<span class="keywd">in</span> <a class="type" href="#types_void">void</a> <span class="keywd">param</span>) end if <span class="keywd">is</span>                           noop;
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: if TRUE  then (<span class="keywd">in</span> <a class="type" href="#types_void">void</a> <span class="keywd">param</span>) (<span class="keywd">in</span> <span class="type">ELSIF_PROC</span> <span class="keywd">param</span>) end if <span class="keywd">is</span>     noop;
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: if FALSE then (<span class="keywd">in</span> <a class="type" href="#types_proc">proc</a> <span class="keywd">param</span>) end if <span class="keywd">is</span>                           noop;
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: if FALSE then (<span class="keywd">in</span> <a class="type" href="#types_proc">proc</a> <span class="keywd">param</span>) (<span class="keywd">in</span> <span class="type">ELSIF_RESULT</span> <span class="keywd">param</span>) end if <span class="keywd">is</span>   noop;
<span class="keywd">const</span> <span class="type">ELSIF_PROC</span>: elsif TRUE  then (<span class="keywd">in</span> <a class="type" href="#types_void">void</a> <span class="keywd">param</span>) <span class="keywd">is</span>                         ELSIF_EMPTY;
<span class="keywd">const</span> <span class="type">ELSIF_PROC</span>: elsif TRUE then (<span class="keywd">in</span> <a class="type" href="#types_void">void</a> <span class="keywd">param</span>) (<span class="keywd">in</span> <span class="type">ELSIF_PROC</span> <span class="keywd">param</span>)   <span class="keywd">is</span>  ELSIF_EMPTY;
<span class="keywd">const</span> <span class="type">ELSIF_PROC</span>: elsif FALSE then (<span class="keywd">in</span> <a class="type" href="#types_proc">proc</a> <span class="keywd">param</span>) <span class="keywd">is</span>                         ELSIF_EMPTY;
<span class="keywd">const</span> <span class="type">ELSIF_PROC</span>: elsif FALSE then (<span class="keywd">in</span> <a class="type" href="#types_proc">proc</a> <span class="keywd">param</span>) (<span class="keywd">in</span> <span class="type">ELSIF_RESULT</span> <span class="keywd">param</span>) <span class="keywd">is</span> ELSIF_EMPTY;
</pre><p></p>

<a name="stats_case-statement"><h3>4.8 case-statement</h3></a>
<p>
  For example:
</p><pre class="indent">
<span class="keywd">case</span> currChar <span class="keywd">of</span>
  <span class="keywd">when</span> {<span class="stri">'A'</span> .. <span class="stri">'Z'</span>} | {<span class="stri">'a'</span> .. <span class="stri">'z'</span>}:
    characterClass := LETTER;
  <span class="keywd">when</span> {<span class="stri">'0'</span> .. <span class="stri">'9'</span>}:
    characterClass := DIGIT;
  <span class="keywd">when</span> {<span class="stri">'!'</span>, <span class="stri">'$'</span>, <span class="stri">'%'</span>, <span class="stri">'&'</span>, <span class="stri">'*'</span>, <span class="stri">'+'</span>, <span class="stri">','</span>, <span class="stri">'-'</span>, <span class="stri">'.'</span>, <span class="stri">'/',
      ':'</span>, <span class="stri">';'</span>, <span class="stri">'&lt;'</span>, <span class="stri">'='</span>, <span class="stri">'>'</span>, <span class="stri">'?'</span>, <span class="stri">'@'</span>, <span class="stri">'\'</span>, <span class="stri">'^'</span>, <span class="stri">'`',
      '|'</span>, <span class="stri">'~'</span>}:
    characterClass := SPECIAL;
  <span class="keywd">when</span> {<span class="stri">'('</span>, <span class="stri">')'</span>, <span class="stri">'['</span>, <span class="stri">']'</span>, <span class="stri">'{'</span>, <span class="stri">'}'</span>}:
    characterClass := PAREN;
  <span class="keywd">when</span> {<span class="stri">'"'</span>}:  <span class="comment"># Also possible '\"'</span>
    characterClass := APPOSTROPHE;
  <span class="keywd">when</span> {<span class="stri">'''</span>}:  <span class="comment"># Also possible '\''</span>
    characterClass := QUOTE;
  <span class="keywd">otherwise</span>:
    characterClass := ILLEGAL;
<span class="keywd">end case</span>;
</pre><p></p><dl><dt>
  Semantics:</dt><dd>
    The expression between <tt><span class="keywd">case</span></tt> and <tt><span class="keywd">of</span></tt> is evaluated. When the
    resulting value is element of a set behind a <tt><span class="keywd">when</span></tt> the
    statements behind the corresponding colon are executed and
    the case-statement is finished. If the value is not element of
    a set behind a <tt><span class="keywd">when</span></tt> and an <tt><span class="keywd">otherwise</span></tt> part is present the
    statements behind the colon of the <tt><span class="keywd">otherwise</span></tt> are executed
    and the case-statement is finished. If the value is not element
    of a set behind a <tt><span class="keywd">when</span></tt> and no <tt><span class="keywd">otherwise</span></tt> part is present
    the case-statement is finished.
</dd></dl>
<dl><dt>
  Syntax:
</dt><dd><tt><dl>
    <dt><a name="stats_ebnf_case_statement">case_statement</a> ::=</dt><dd>
      '<span class="keywd">case</span>' <a class="ebnf" href="#expr_ebnf_expression">expression</a> '<span class="keywd">of</span>'<br />
      &nbsp;&nbsp;{ '<span class="keywd">when</span>' <a class="ebnf" href="#stats_ebnf_set_expression">set_expression</a> ':'<br />
      &nbsp;&nbsp;&nbsp;&nbsp;<a class="ebnf" href="#stats_ebnf_statement">statement</a> }<br />
      &nbsp;&nbsp;[ '<span class="keywd">otherwise</span>' ':'<br />
      &nbsp;&nbsp;&nbsp;&nbsp;<a class="ebnf" href="#stats_ebnf_statement">statement</a> ]<br />
      '<span class="keywd">end</span>' '<span class="keywd">case</span>' .</dd>
<dt><br /></dt>
    <dt><a name="stats_ebnf_set_expression">set_expression</a> ::=</dt><dd>
      <a class="ebnf" href="#expr_ebnf_expression">expression</a> .</dd>
</dl></tt></dd></dl><p>

  Declaration:
</p><pre class="indent">
$ <span class="keywd">syntax</span> <a class="type" href="#types_expr">expr</a>: .case.().of.().end.case <span class="keywd">is</span>                      -> 25;
$ <span class="keywd">syntax</span> <a class="type" href="#types_expr">expr</a>: .case.().of.().otherwise. : .().end.case <span class="keywd">is</span>     -> 25;
$ <span class="keywd">syntax</span> <a class="type" href="#types_expr">expr</a>: .case.().of.end.case <span class="keywd">is</span>                         -> 25;

$ <span class="keywd">syntax</span> <a class="type" href="#types_expr">expr</a>: .when.(). : .().() <span class="keywd">is</span>              &lt;- 60;
$ <span class="keywd">syntax</span> <a class="type" href="#types_expr">expr</a>: .when.(). : .() <span class="keywd">is</span>                 &lt;- 60;

<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: CASE_DECLS (<span class="keywd">in</span> <a class="type" href="#types_type">type</a>: aType) <span class="keywd">is func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="#types_type">type</a>: WHEN_RESULT <span class="keywd">is</span> <a class="type" href="#types_void">void</a>;
    <span class="keywd">var</span> <a class="type" href="#types_type">type</a>: WHEN_PROC <span class="keywd">is</span> <a class="type" href="#types_void">void</a>;
    <span class="keywd">var</span> <a class="type" href="#types_type">type</a>: SELECTOR_TYPE <span class="keywd">is</span> <a class="type" href="#types_void">void</a>;
  <span class="keywd">begin</span>
    <span class="type">WHEN_RESULT</span> := newtype;
    <span class="type">WHEN_PROC</span> := (<a class="type" href="#types_func">func</a> <span class="type">WHEN_RESULT</span>);
    <span class="type">SELECTOR_TYPE</span> := <a class="type" href="#types_set">set</a> <a class="type" href="#types_set">of</a> <span class="type">aType</span>;
    <span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: case (<span class="keywd">ref</span> <span class="type">aType</span> <span class="keywd">param</span>) of end case                       <span class="keywd">is</span> noop;
    <span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: case (<span class="keywd">ref</span> <span class="type">aType</span> <span class="keywd">param</span>) of
                  (<span class="keywd">ref</span> <span class="type">WHEN_PROC</span> <span class="keywd">param</span>)
                end case                                                 <span class="keywd">is action</span> <span class="stri">"PRC_CASE"</span>;
    <span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: case (<span class="keywd">ref</span> <span class="type">aType</span> <span class="keywd">param</span>) of
                  (<span class="keywd">ref</span> <span class="type">WHEN_PROC</span> <span class="keywd">param</span>)
                  otherwise : (<span class="keywd">ref</span> <a class="type" href="#types_proc">proc</a> <span class="keywd">param</span>)
                end case                                                 <span class="keywd">is action</span> <span class="stri">"PRC_CASE_DEF"</span>;
    <span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: (<span class="keywd">ref</span> <span class="type">WHEN_RESULT</span> <span class="keywd">param</span>) ::= enumlit                      <span class="keywd">is action</span> <span class="stri">"ENU_GENLIT"</span>;
    <span class="keywd">const</span> <span class="type">WHEN_RESULT</span>: WHEN_EMPTY (<span class="keywd">attr</span> <span class="type">aType</span>) is enumlit;
    <span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: (<span class="keywd">ref</span> <span class="type">WHEN_PROC</span> <span class="keywd">param</span>) ::= (<span class="keywd">ref</span> <span class="type">WHEN_RESULT</span> <span class="keywd">param</span>)        <span class="keywd">is action</span> <span class="stri">"ENU_CREATE"</span>;
    <span class="keywd">const</span> <span class="type">WHEN_PROC</span>: when (<span class="keywd">ref</span> <span class="type">SELECTOR_TYPE</span> <span class="keywd">param</span>) : (<span class="keywd">ref</span> <a class="type" href="#types_proc">proc</a> <span class="keywd">param</span>)   <span class="keywd">is</span> WHEN_EMPTY(<span class="type">aType</span>);
    <span class="keywd">const</span> <span class="type">WHEN_PROC</span>: when (<span class="keywd">ref</span> <span class="type">SELECTOR_TYPE</span> <span class="keywd">param</span>) : (<span class="keywd">ref</span> <a class="type" href="#types_proc">proc</a> <span class="keywd">param</span>)
                       (<span class="keywd">ref</span> <span class="type">WHEN_PROC</span> <span class="keywd">param</span>)                             <span class="keywd">is</span> WHEN_EMPTY(<span class="type">aType</span>);
  <span class="keywd">end func</span>;

CASE_DECLS(<a class="type" href="#types_integer">integer</a>);
CASE_DECLS(<a class="type" href="#types_char">char</a>);
</pre><p></p>

<a name="types_file_start"></a><p></p>
<a name="types_PREDEFINED_TYPES"><h2>5. PREDEFINED TYPES</h2></a>

<p>
    In the following subchapters the predefined types of the
  standard library are introduced. The operators have, when not
  stated otherwise, the type described in the subchapter as
  parameter type and result type. The relations have also the
  type described in the subchapter as parameter type and
  a result of type <tt><a class="type" href="#types_boolean">boolean</a></tt>. In the descriptions <tt><b>&rArr;</b></tt> is used
  to show an equivalent expression.
</p>

<a name="types_boolean"><h3>5.1 boolean</h3></a>
<p>
    The type <tt><span class="type">boolean</span></tt> consists of the two truth values
  <tt><span class="var">TRUE</span></tt> and <tt><span class="var">FALSE</span></tt>. The <tt><span class="type">boolean</span></tt> functions are defined in
  the library <span class="stri">"<span class="lib">boolean.s7i</span>"</span>.
</p><pre class="tt">
    Prefix operators:
      <span class="op">not</span>       Negation
                  ( <span class="op">not</span> <span class="var">TRUE</span> <b>&rArr;</b> <span class="var">FALSE</span>,
                    <span class="op">not</span> <span class="var">FALSE</span> <b>&rArr;</b> <span class="var">TRUE</span> )
    Infix operators:
      <span class="op">and</span>       Logical and
                  ( <span class="var">TRUE</span> <span class="op">and</span> <span class="var">TRUE</span> <b>&rArr;</b> <span class="var">TRUE</span>,
                    A <span class="op">and</span> B <b>&rArr;</b> <span class="var">FALSE</span> else )
      <span class="op">or</span>        Inclusive logical or
                  ( <span class="var">FALSE</span> <span class="op">or</span> <span class="var">FALSE</span> <b>&rArr;</b> <span class="var">FALSE</span>,
                    A <span class="op">or</span> B <b>&rArr;</b> <span class="var">TRUE</span> else )
      <a class="type" href="#types_boolean">boolean</a> <span class="op">conv</span> A   Conversion of <a class="type" href="#types_integer">integer</a> to <a class="type" href="#types_boolean">boolean</a>
                  ( Type of argument A: <a class="type" href="#types_integer">integer</a>,
                    <a class="type" href="#types_boolean">boolean</a> <span class="op">conv</span> 0 <b>&rArr;</b> <span class="var">FALSE</span>,
                    <a class="type" href="#types_boolean">boolean</a> <span class="op">conv</span> 1 <b>&rArr;</b> <span class="var">TRUE</span> )
      <a class="type" href="#types_boolean">boolean</a> <span class="op">parse</span> A   Conversion of <a class="type" href="#types_string">string</a> to <a class="type" href="#types_boolean">boolean</a>
                  ( Type of argument A: <a class="type" href="#types_string">string</a>,
                    <a class="type" href="#types_boolean">boolean</a> <span class="op">parse</span> <span class="stri">"FALSE"</span> <b>&rArr;</b> <span class="var">FALSE</span>,
                    <a class="type" href="#types_boolean">boolean</a> <span class="op">parse</span> <span class="stri">"TRUE"</span> <b>&rArr;</b> <span class="var">TRUE</span>,
                    <a class="type" href="#types_boolean">boolean</a> <span class="op">parse</span> <span class="stri">"TRUE "</span> <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a>,
                    <a class="type" href="#types_boolean">boolean</a> <span class="op">parse</span> <span class="stri">"ASDF"</span> <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> )
    Relations:
      <span class="op">=</span>, <span class="op">&lt;></span>, <span class="op">&lt;</span>, <span class="op">&lt;=</span>, <span class="op">></span>, <span class="op">>=</span>
                  ( A relation B <b>&rArr;</b>
                    ord(A) relation ord(B) )
    Functions:
      <span class="func">ord</span>(A)    Ordinal number
                  ( Type of result: <a class="type" href="#types_integer">integer</a>,
                    ord(<span class="var">FALSE</span>) <b>&rArr;</b> 0, ord(<span class="var">TRUE</span>) <b>&rArr;</b> 1 )
      <span class="func">succ</span>(A)   Successor
                  ( succ(<span class="var">FALSE</span>) <b>&rArr;</b> <span class="var">TRUE</span>,
                    succ(<span class="var">TRUE</span>) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> )
      <span class="func">pred</span>(A)   Predecessor
                  ( pred(<span class="var">FALSE</span>) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> )
                    pred(<span class="var">TRUE</span>) <b>&rArr;</b> <span class="var">FALSE</span> )
      <span class="func">str</span>(A)    Conversion to <a class="type" href="#types_string">string</a>
                  ( Type of result: <a class="type" href="#types_string">string</a>,
                    str(<span class="var">FALSE</span>) <b>&rArr;</b> <span class="stri">"FALSE"</span>,
                    str(<span class="var">TRUE</span>) <b>&rArr;</b> <span class="stri">"TRUE"</span> )
      <span class="func">rand</span>(A, B) Random value in the range [A, B]
                 The random values are uniform distributed.
                  ( rand(A, B) returns a random value such that
                    A &lt;= rand(A, B) <span class="op">and</span> rand(A, B) &lt;= B holds.
                    rand(A, A) <b>&rArr;</b> A,
                    rand(<span class="var">TRUE</span>, <span class="var">FALSE</span>) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> )
      <span class="func">compare</span>(A, B) Compare function
                  ( Type of result: <a class="type" href="#types_integer">integer</a>,
                    compare(<span class="var">FALSE</span>, <span class="var">TRUE</span>) <b>&rArr;</b> -1,
                    compare(<span class="var">TRUE</span>, <span class="var">TRUE</span>) <b>&rArr;</b> 0,
                    compare(<span class="var">TRUE</span>, <span class="var">FALSE</span>) <b>&rArr;</b> 1 )
      <span class="func">hashCode</span>(A) Hash function
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
    Statements:
      <span class="func">incr</span>(A)   Increment
                  ( incr(A) <b>&rArr;</b> A:=succ(A) )
      <span class="func">decr</span>(A)   Decrement
                  ( decr(A) <b>&rArr;</b> A:=pred(A) )
</pre><p>

    The logical operators <tt><span class="op">and</span></tt> and <tt><span class="op">or</span></tt> work strictly left
  to right. First they evaluate the left operand and then
  the right operand. When the result of the operation can be
  determined after evaluation of the left operand the right
  operand is not evaluated. This can be used to check for
  a boundary in a boolean expression. Naturally side effects
  of the right operand of the <tt><span class="op">and</span></tt> and <tt><span class="op">or</span></tt> operator only
  take place when the operand is executed.

</p><p>
  Table for the behavior of different boolean expressions:
</p><dl><dd><table class="tt" border="1" cellspacing="0" cellpadding="3">
    
    <tr><th rowspan="2"> Expression                  </th><th align="center" colspan="2">  Result when the first  
      operand evaluates to   </th></tr>
    
    <tr><th align="center">   <span class="var">FALSE</span>    </th><th align="center">    <span class="var">TRUE</span>    </th></tr>
    
    <tr><td> <span class="op">not</span> A                       </td><td align="center">    <span class="var">TRUE</span>    </td><td align="center">   <span class="var">FALSE</span>    </td></tr>
    
    <tr><td> A <span class="op">and</span> B  <b>respectively</b><br />       
     <span class="op">not</span>((<span class="op">not</span> A)<span class="op">or</span>(<span class="op">not</span> B))       </td><td align="center">   <span class="var">FALSE</span>    </td><td align="center">     B      </td></tr>
    
    <tr><td> A <span class="op">or</span>  B  <b>respectively</b><br />       
     <span class="op">not</span>((<span class="op">not</span> A)<span class="op">and</span>(<span class="op">not</span> B))      </td><td align="center">     B      </td><td align="center">    <span class="var">TRUE</span>    </td></tr>
    
    <tr><td> A >  B  <b>respectively</b><br />        
     A <span class="op">and</span>(<span class="op">not</span> B)                </td><td align="center">   <span class="var">FALSE</span>    </td><td align="center">   <span class="op">not</span> B    </td></tr>
    
    <tr><td> A >= B  <b>respectively</b><br />        
     A <span class="op">or</span>(<span class="op">not</span> B)                 </td><td align="center">   <span class="op">not</span> B    </td><td align="center">    <span class="var">TRUE</span>    </td></tr>
    
    <tr><td> A &lt;  B  <b>respectively</b><br />        
     (<span class="op">not</span> A)<span class="op">and</span> B                </td><td align="center">     B      </td><td align="center">   <span class="var">FALSE</span>    </td></tr>
    
    <tr><td> A &lt;= B  <b>respectively</b><br />        
     (<span class="op">not</span> A)<span class="op">or</span> B                 </td><td align="center">    <span class="var">TRUE</span>    </td><td align="center">     B      </td></tr>
    
    <tr><td> <span class="op">not</span> (A <span class="op">and</span> B)  <b>respectively</b><br /> 
     (<span class="op">not</span> A)<span class="op">or</span>(<span class="op">not</span> B)            </td><td align="center">    <span class="var">TRUE</span>    </td><td align="center">   <span class="op">not</span> B    </td></tr>
    
    <tr><td> <span class="op">not</span> (A <span class="op">or</span> B)  <b>respectively</b><br />  
     (<span class="op">not</span> A)<span class="op">and</span>(<span class="op">not</span> B)           </td><td align="center">   <span class="op">not</span> B    </td><td align="center">   <span class="var">FALSE</span>    </td></tr>
    
</table></dd></dl><p>

  Optimizing boolean expressions:
</p><p>
    When the result of a boolean expression can be
  determined at compile time, the expression can be
  replaced by a constant. Additionally the following
  equations can be used:
</p><pre class="box">
    (A <span class="op">or</span>  B) <span class="op">and</span> (A <span class="op">or</span>  C)  =  A <span class="op">or</span>  (B <span class="op">and</span> C)
    (A <span class="op">and</span> B) <span class="op">or</span>  (A <span class="op">and</span> C)  =  A <span class="op">and</span> (B <span class="op">or</span>  C)
</pre><p></p>

<a name="types_integer"><h3>5.2 integer</h3></a>
<p>
    The type <tt><a class="type" href="#types_integer">integer</a></tt> consists of signed integer numbers
  which are at least 32 bits wide. An <a class="link" href="#tokens_Integer_literals">integer literal</a> is
  a sequence of digits which is taken to be decimal. The
  sequence of digits may be followed by the letter E or e
  an optional + sign and a decimal exponent. Based numbers
  can be specified when the sequence of digits is followed
  by the # character and a sequence of extended digits.
  The decimal number in front of the # character specifies
  the base of the number which follows the # character.
  As base a number between 2 and 36 is allowed. As
  extended digits the letters A or a can be used for 10,
  B or b can be used for 11 and so on to Z or z which can
  be used as 35. Examples of <tt><a class="type" href="#types_integer">integer</a></tt> literals are:
</p><pre class="box">
    0   2147483647   1E6   2e+9   16#c0   16#FFFF   8#177777   2#1010101010
</pre><p>
  The result of an <tt><a class="type" href="#types_integer">integer</a></tt> operation is undefined when
  it overflows. The <tt><a class="type" href="#types_integer">integer</a></tt> functions are defined in
  the library <span class="stri">"<span class="lib">integer.s7i</span>"</span>.
</p><pre class="tt">
    Prefix operators:
      <span class="op">+</span>         Identity
      <span class="op">-</span>         Change sign
      <span class="op">!</span>         Factorial
    Infix operators:
      <span class="op">+</span>         Addition
      <span class="op">-</span>         Subtraction
      <span class="op">*</span>         Multiplication
      <span class="op">div</span>       Integer division truncated towards zero
                  ( A <span class="op">div</span> B <b>&rArr;</b> trunc(flt(A) / flt(B)),
                    A <span class="op">div</span> 0 <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_NUMERIC_ERROR">NUMERIC_ERROR</a> )
      <span class="op">rem</span>       Reminder of integer division <span class="op">div</span>
                  ( A <span class="op">rem</span> B <b>&rArr;</b> A - (A <span class="op">div</span> B) * B,
                    A <span class="op">rem</span> 0 <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_NUMERIC_ERROR">NUMERIC_ERROR</a> )
      <span class="op">mdiv</span>      Integer division truncated towards negative infinity
                  ( A <span class="op">mdiv</span> B <b>&rArr;</b> round(floor(flt(A) / flt(B))),
                    A <span class="op">mdiv</span> 0 <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_NUMERIC_ERROR">NUMERIC_ERROR</a> )
      <span class="op">mod</span>       Reminder of integer division <span class="op">mdiv</span>
                  ( A <span class="op">mod</span> B <b>&rArr;</b> A - (A <span class="op">mdiv</span> B) * B,
                    A <span class="op">mod</span> 0 <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_NUMERIC_ERROR">NUMERIC_ERROR</a> )
      <span class="op">**</span>        Power
                  ( A ** B is okay for B >= 0,
                    A ** 0 <b>&rArr;</b> 1 for every A, even for A = 0,
                    1 ** B <b>&rArr;</b> 1 for B >= 0,
                    A ** B <b>&rArr;</b> -(-A) ** B for A &lt;= 0 and B >= 0 and odd(B),
                    A ** B <b>&rArr;</b> (-A) ** B for A &lt;= 0 and B >= 0 and not odd(B),
                    A ** -1 <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_NUMERIC_ERROR">NUMERIC_ERROR</a> )
      A <span class="op">&lt;&lt;</span> B    Shift left
                  ( A &lt;&lt; B is okay for B >= 0 and B &lt;= 31,
                    A &lt;&lt; B <b>&rArr;</b> A * 2 ** B,
                    A &lt;&lt; 0 <b>&rArr;</b> A )
      A <span class="op">>></span> B    Arithmetic shift right
                  ( A >> B is okay for B >= 0 and B &lt;= 31,
                    A >> B <b>&rArr;</b> A <span class="op">mdiv</span> 2 ** B  for B &lt;= 30,
                    A >> 0 <b>&rArr;</b> A,
                    A >> B <b>&rArr;</b> C for A >= 0 holds: C >= 0,
                    A >> B <b>&rArr;</b> C for A &lt; 0 holds: C &lt; 0,
                    A >> B <b>&rArr;</b> 0 for A >= 0 and B > ord(log2(A)),
                    A >> B <b>&rArr;</b> -1 for A &lt; 0 and B > ord(log2(-A)),
                    0 >> B <b>&rArr;</b> 0 )
      <span class="op">!</span>         Binomial coefficient
                  ( A ! B <b>&rArr;</b> !A <span class="op">div</span> (!B * !(A - B)) )
      A <span class="op">radix</span> B  Convert the <a class="type" href="#types_integer">integer</a> A to a <a class="type" href="#types_string">string</a>. The conversion
                 uses the numeral system with the base B.
                  ( Type of result: <a class="type" href="#types_string">string</a>,
                    48879 <span class="op">radix</span> 16 <b>&rArr;</b> <span class="stri">"beef"</span>,
                    -48879 <span class="op">radix</span> 16 <b>&rArr;</b> <span class="stri">"-beef"</span>,
                    123 <span class="op">radix</span> 37 <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> )
      A <span class="op">RADIX</span> B  Convert the <a class="type" href="#types_integer">integer</a> A to a <a class="type" href="#types_string">string</a>. The conversion
                 uses the numeral system with the base B.
                  ( Type of result: <a class="type" href="#types_string">string</a>,
                    48879 <span class="op">RADIX</span> 16 <b>&rArr;</b> <span class="stri">"BEEF"</span>,
                    -48879 <span class="op">RADIX</span> 16 <b>&rArr;</b> <span class="stri">"-BEEF"</span>,
                    123 <span class="op">RADIX</span> 37 <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> )
      <span class="op">lpad</span>      Left padding with spaces
                  ( 123 <span class="op">lpad</span>  8 <b>&rArr;</b> <span class="stri">"     123"</span>,
                    123 <span class="op">lpad</span>  4 <b>&rArr;</b> <span class="stri">" 123"</span>,
                    123 <span class="op">lpad</span>  3 <b>&rArr;</b> <span class="stri">"123"</span>,
                    123 <span class="op">lpad</span>  2 <b>&rArr;</b> <span class="stri">"123"</span>,
                    123 <span class="op">lpad</span> -8 <b>&rArr;</b> <span class="stri">"123"</span> )
                    -12 <span class="op">lpad</span>  4 <b>&rArr;</b> <span class="stri">" -12"</span>,
                    -12 <span class="op">lpad</span>  3 <b>&rArr;</b> <span class="stri">"-12"</span>,
                    -12 <span class="op">lpad</span>  2 <b>&rArr;</b> <span class="stri">"-12"</span> )
      <span class="op">lpad0</span>     Left padding with zeros
                  ( 123 <span class="op">lpad0</span>  8 <b>&rArr;</b> <span class="stri">"00000123"</span>,
                    123 <span class="op">lpad0</span>  4 <b>&rArr;</b> <span class="stri">"0123"</span>,
                    123 <span class="op">lpad0</span>  3 <b>&rArr;</b> <span class="stri">"123"</span>,
                    123 <span class="op">lpad0</span>  2 <b>&rArr;</b> <span class="stri">"123"</span>,
                    123 <span class="op">lpad0</span> -8 <b>&rArr;</b> <span class="stri">"123"</span>,
                    -12 <span class="op">lpad0</span>  4 <b>&rArr;</b> <span class="stri">"-012"</span>,
                    -12 <span class="op">lpad0</span>  3 <b>&rArr;</b> <span class="stri">"-12"</span>,
                    -12 <span class="op">lpad0</span>  2 <b>&rArr;</b> <span class="stri">"-12"</span> )
      <span class="op">rpad</span>      Right padding with spaces
                  ( 123 <span class="op">rpad</span>  8 <b>&rArr;</b> <span class="stri">"123     "</span>,
                    123 <span class="op">rpad</span>  4 <b>&rArr;</b> <span class="stri">"123 "</span>,
                    123 <span class="op">rpad</span>  3 <b>&rArr;</b> <span class="stri">"123"</span>,
                    123 <span class="op">rpad</span>  2 <b>&rArr;</b> <span class="stri">"123"</span>,
                    123 <span class="op">rpad</span> -8 <b>&rArr;</b> <span class="stri">"123"</span> )
                    -12 <span class="op">rpad</span>  4 <b>&rArr;</b> <span class="stri">"-12 "</span>,
                    -12 <span class="op">rpad</span>  3 <b>&rArr;</b> <span class="stri">"-12"</span>,
                    -12 <span class="op">rpad</span>  2 <b>&rArr;</b> <span class="stri">"-12"</span> )
      <a class="type" href="#types_integer">integer</a> <span class="op">conv</span> A   Identity
                  ( <a class="type" href="#types_integer">integer</a> <span class="op">conv</span> A <b>&rArr;</b> A )
      <a class="type" href="#types_integer">integer</a> <span class="op">parse</span> A   Conversion of <a class="type" href="#types_string">string</a> to <a class="type" href="#types_integer">integer</a>
                  ( Type of argument A: <a class="type" href="#types_string">string</a>,
                    <a class="type" href="#types_integer">integer</a> <span class="op">parse</span> <span class="stri">"123"</span> <b>&rArr;</b> 123,
                    <a class="type" href="#types_integer">integer</a> <span class="op">parse</span> <span class="stri">"-123"</span> <b>&rArr;</b> -123,
                    <a class="type" href="#types_integer">integer</a> <span class="op">parse</span> <span class="stri">"+5"</span> <b>&rArr;</b> 5,
                    <a class="type" href="#types_integer">integer</a> <span class="op">parse</span> <span class="stri">" 1"</span> <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a>,
                    <a class="type" href="#types_integer">integer</a> <span class="op">parse</span> <span class="stri">"10 "</span> <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a>,
                    <a class="type" href="#types_integer">integer</a> <span class="op">parse</span> <span class="stri">"ASDF"</span> <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> )
    Relations:
      <span class="op">=</span>, <span class="op">&lt;></span>, <span class="op">&lt;</span>, <span class="op">&lt;=</span>, <span class="op">></span>, <span class="op">>=</span>
    Functions:
      <span class="func">ord</span>(A)    Identity
      <span class="func">succ</span>(A)   Successor
                  ( succ(A) <b>&rArr;</b> A+1 )
      <span class="func">pred</span>(A)   Predecessor
                  ( pred(A) <b>&rArr;</b> A-1 )
      <span class="func">abs</span>(A)    Absolute value
      <span class="func">odd</span>(A)    Odd value
                  ( Type of result: <a class="type" href="#types_boolean">boolean</a> )
      <span class="func">str</span>(A)    Conversion to <a class="type" href="#types_string">string</a>
                  ( Type of result: <a class="type" href="#types_string">string</a>,
                    str(12345) <b>&rArr;</b> <span class="stri">"12345"</span> )
      <span class="func">literal</span>(A) Conversion to a literal
                  ( Type of result: <a class="type" href="#types_string">string</a>,
                    literal(A) <b>&rArr;</b> str(A) )
      <span class="func">sqrt</span>(A)   Integer square root
                  ( sqrt(A) is okay for A >= 0
                    sqrt(A) <b>&rArr;</b> trunc(sqrt(flt(A))),
                    sqrt(-1) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_NUMERIC_ERROR">NUMERIC_ERROR</a> )
      <span class="func">log2</span>(A)   Truncated base 2 logarithm
                  ( log2(A) returns the position of the
                    highest bit set. It is defined for A >= 0
                    log2(2 ** A) = A for A >= 0,
                    log2(pred(2 ** A)) = pred(A) for A >= 0,
                    log2(2) <b>&rArr;</b> 1,
                    log2(1) <b>&rArr;</b> 0,
                    log2(0) <b>&rArr;</b> -1,
                    log2(-1) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_NUMERIC_ERROR">NUMERIC_ERROR</a> )
      <span class="func">bitLength</span>(A) Number of bits in the minimal two's-complement
                   representation, excluding the sign bit.
                  ( bitLength(A) <b>&rArr;</b> succ(log2(A)) for A >= 0,
                    bitLength(A) <b>&rArr;</b> bitLength(pred(-A)) for A &lt; 0,
                    bitLength(0) <b>&rArr;</b> 0,
                    bitLength(-1) <b>&rArr;</b> 0 )
      <span class="func">lowestSetBit</span>(A) Index of the lowest-order one bit
                      For A &lt;> 0 this is equal to the number of
                      lowest-order zero bits.
                  ( A >> B &lt;&lt; B = A for A &lt;> 0 and B = lowestSetBit(A),
                    lowestSetBit(0) <b>&rArr;</b> -1,
                    lowestSetBit(1) <b>&rArr;</b> 0,
                    lowestSetBit(2) <b>&rArr;</b> 1 )
      <span class="func">rand</span>(A, B) Random number in the range [A, B]
                 The random values are uniform distributed.
                  ( rand(A, B) returns a random number such that
                    A &lt;= rand(A, B) <span class="op">and</span> rand(A, B) &lt;= B holds.
                    rand(A, A) <b>&rArr;</b> A,
                    rand(1, 0) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> )
      <span class="func">min</span>(A, B) Minimum of two numbers.
                  ( min(1, 2) <b>&rArr;</b> 1 )
      <span class="func">max</span>(A, B) Maximum of two numbers.
                  ( max(1, 2) <b>&rArr;</b> 2 )
      <span class="func">compare</span>(A, B) Compare function
                  ( compare(1, 2) <b>&rArr;</b> -1,
                    compare(5, 5) <b>&rArr;</b> 0,
                    compare(8, 7) <b>&rArr;</b> 1 )
      <span class="func">hashCode</span>(A) Hash function
    Statements:
      A <span class="op">+:=</span> B   Increment A by B
                  ( A +:= B <b>&rArr;</b> A := A + B )
      A <span class="op">-:=</span> B   Decrement A by B
                  ( A -:= B <b>&rArr;</b> A := A - B )
      A <span class="op">*:=</span> B   Multiplying copy
                  ( A *:= B <b>&rArr;</b> A := A * B )
      A <span class="op">&lt;&lt;:=</span> B  Shift left copy
                  ( A &lt;&lt;:= B <b>&rArr;</b> A := A &lt;&lt; B )
      A <span class="op">>>:=</span> B  Shift right copy
                  ( A >>:= B <b>&rArr;</b> A := A >> B )
      <span class="func">incr</span>(A)   Increment with 1
                  ( incr(A) <b>&rArr;</b> A +:= 1 )
      <span class="func">decr</span>(A)   Decrement with 1
                  ( decr(A) <b>&rArr;</b> A -:= 1 )
</pre><p>
  For the operations <tt><span class="op">div</span></tt> and <tt><span class="op">rem</span></tt> holds for all A:</p><pre class="box">
    (A <span class="op">div</span> B) * B + A <span class="op">rem</span> B = A           when B &lt;> 0
    -A <span class="op">div</span> B = -(A <span class="op">div</span> B)                 when B &lt;> 0
    -A <span class="op">rem</span> B = -(A <span class="op">rem</span> B)                 when B &lt;> 0
    A <span class="op">rem</span> B >= 0 <span class="op">and</span> A <span class="op">rem</span> B &lt; abs(B)     when B &lt;> 0 and A >= 0
    A <span class="op">rem</span> B &lt;= 0 <span class="op">and</span> A <span class="op">rem</span> B > -abs(B)    when B &lt;> 0 and A &lt;= 0
</pre><p>
  For the operations <tt><span class="op">mdiv</span></tt> and <tt><span class="op">mod</span></tt> holds for all A:</p><pre class="box">
    (A <span class="op">mdiv</span> B) * B + A <span class="op">mod</span> B = A          when B &lt;> 0
    -A <span class="op">mdiv</span> B = A <span class="op">mdiv</span> -B                 when B &lt;> 0
    -A <span class="op">mod</span> -B = -(A <span class="op">mod</span> B)                when B &lt;> 0
    A <span class="op">mod</span> B >= 0 <span class="op">and</span> A <span class="op">mod</span> B &lt; B          when B > 0
    A <span class="op">mod</span> B &lt;= 0 <span class="op">and</span> A <span class="op">mod</span> B > B          when B &lt; 0
</pre><p>
  For the operation <tt><span class="op">mdiv</span></tt> holds:</p><pre class="box">
    A <span class="op">mdiv</span> B = A <span class="op">div</span> B - 1            when A and B have different
                                      signs and A <span class="op">rem</span> B &lt;> 0 holds.
    A <span class="op">mdiv</span> B = A <span class="op">div</span> B                when A and B have the same
                                      sign or A <span class="op">rem</span> B = 0 holds.
    A <span class="op">mdiv</span> B = (A - 1) <span class="op">div</span> B - 1      when A > 0 and B &lt; 0 holds.
    A <span class="op">mdiv</span> B = (A + 1) <span class="op">div</span> B - 1      when A &lt; 0 and B > 0 holds.
    A <span class="op">mdiv</span> 2 ** B = A >> B            when B >= 0 holds
</pre><p>
  For the operation <tt><span class="op">mod</span></tt> holds:</p><pre class="box">
    A <span class="op">mod</span> B = A <span class="op">rem</span> B + B      when A and B have different
                               signs and A <span class="op">rem</span> B &lt;> 0 holds.
    A <span class="op">mod</span> B = A <span class="op">rem</span> B          when A and B have the same
                               sign or A <span class="op">rem</span> B = 0 holds.
</pre><p>

  Tables for the behavior of <tt><span class="op">div</span></tt>, <tt><span class="op">rem</span></tt>, <tt><span class="op">mdiv</span></tt> and <tt><span class="op">mod</span></tt>:
</p><dl><dd><table class="tt" border="1" cellspacing="0" cellpadding="3">
    
    <tr><th>  A  </th><th>  B  </th><th> A <span class="op">div</span> B </th><th> A <span class="op">rem</span> B </th><th> A <span class="op">mdiv</span> B </th><th> A <span class="op">mod</span> B </th></tr>
    
    <tr><td align="center">  5  </td><td align="center">  3  </td><td align="center">    1    </td><td align="center">    2    </td><td align="center">     1    </td><td align="center">    2    </td></tr>
    <tr><td align="center">  4  </td><td align="center">  3  </td><td align="center">    1    </td><td align="center">    1    </td><td align="center">     1    </td><td align="center">    1    </td></tr>
    <tr><td align="center">  3  </td><td align="center">  3  </td><td align="center">    1    </td><td align="center">    0    </td><td align="center">     1    </td><td align="center">    0    </td></tr>
    <tr><td align="center">  2  </td><td align="center">  3  </td><td align="center">    0    </td><td align="center">    2    </td><td align="center">     0    </td><td align="center">    2    </td></tr>
    <tr><td align="center">  1  </td><td align="center">  3  </td><td align="center">    0    </td><td align="center">    1    </td><td align="center">     0    </td><td align="center">    1    </td></tr>
    <tr><td align="center">  0  </td><td align="center">  3  </td><td align="center">    0    </td><td align="center">    0    </td><td align="center">     0    </td><td align="center">    0    </td></tr>
    <tr><td align="center"> -1  </td><td align="center">  3  </td><td align="center">    0    </td><td align="center">   -1    </td><td align="center">    -1    </td><td align="center">    2    </td></tr>
    <tr><td align="center"> -2  </td><td align="center">  3  </td><td align="center">    0    </td><td align="center">   -2    </td><td align="center">    -1    </td><td align="center">    1    </td></tr>
    <tr><td align="center"> -3  </td><td align="center">  3  </td><td align="center">   -1    </td><td align="center">    0    </td><td align="center">    -1    </td><td align="center">    0    </td></tr>
    <tr><td align="center"> -4  </td><td align="center">  3  </td><td align="center">   -1    </td><td align="center">   -1    </td><td align="center">    -2    </td><td align="center">    2    </td></tr>
    <tr><td align="center"> -5  </td><td align="center">  3  </td><td align="center">   -1    </td><td align="center">   -2    </td><td align="center">    -2    </td><td align="center">    1    </td></tr>
    
</table></dd></dl><dl><dd><table class="tt" border="1" cellspacing="0" cellpadding="3">
    
    <tr><th>  A  </th><th>  B  </th><th> A <span class="op">div</span> B </th><th> A <span class="op">rem</span> B </th><th> A <span class="op">mdiv</span> B </th><th> A <span class="op">mod</span> B </th></tr>
    
    <tr><td align="center">  5  </td><td align="center"> -3  </td><td align="center">   -1    </td><td align="center">    2    </td><td align="center">    -2    </td><td align="center">   -1    </td></tr>
    <tr><td align="center">  4  </td><td align="center"> -3  </td><td align="center">   -1    </td><td align="center">    1    </td><td align="center">    -2    </td><td align="center">   -2    </td></tr>
    <tr><td align="center">  3  </td><td align="center"> -3  </td><td align="center">   -1    </td><td align="center">    0    </td><td align="center">    -1    </td><td align="center">    0    </td></tr>
    <tr><td align="center">  2  </td><td align="center"> -3  </td><td align="center">    0    </td><td align="center">    2    </td><td align="center">    -1    </td><td align="center">   -1    </td></tr>
    <tr><td align="center">  1  </td><td align="center"> -3  </td><td align="center">    0    </td><td align="center">    1    </td><td align="center">    -1    </td><td align="center">   -2    </td></tr>
    <tr><td align="center">  0  </td><td align="center"> -3  </td><td align="center">    0    </td><td align="center">    0    </td><td align="center">     0    </td><td align="center">    0    </td></tr>
    <tr><td align="center"> -1  </td><td align="center"> -3  </td><td align="center">    0    </td><td align="center">   -1    </td><td align="center">     0    </td><td align="center">   -1    </td></tr>
    <tr><td align="center"> -2  </td><td align="center"> -3  </td><td align="center">    0    </td><td align="center">   -2    </td><td align="center">     0    </td><td align="center">   -2    </td></tr>
    <tr><td align="center"> -3  </td><td align="center"> -3  </td><td align="center">    1    </td><td align="center">    0    </td><td align="center">     1    </td><td align="center">    0    </td></tr>
    <tr><td align="center"> -4  </td><td align="center"> -3  </td><td align="center">    1    </td><td align="center">   -1    </td><td align="center">     1    </td><td align="center">   -1    </td></tr>
    <tr><td align="center"> -5  </td><td align="center"> -3  </td><td align="center">    1    </td><td align="center">   -2    </td><td align="center">     1    </td><td align="center">   -2    </td></tr>
    
</table></dd></dl><p>

  For the <tt><span class="func">sqrt</span></tt> function holds (when A >= 0):</p><pre class="box">
    sqrt(A) * sqrt(A) &lt;= A <span class="op">and</span>
    (sqrt(A) + 1) * (sqrt(A) + 1) > A
</pre><p></p>

<a name="types_bigInteger"><h3>5.3 bigInteger</h3></a>
<p>
    The type <tt><span class="type">bigInteger</span></tt> describes signed integer numbers of
  unlimited size. A <a class="link" href="#tokens_BigInteger_literals">bigInteger literal</a> is a sequence of digits
  followed by an underscore character (for example 1_ ). Based
  numbers can be specified when the sequence of digits is
  followed by the # character and a sequence of extended digits.
  The decimal number in front of the # character specifies the
  base of the number which follows the # character. As base a
  number between 2 and 36 is allowed. As extended digits the
  letters A or a can be used for 10, B or b can be used for 11
  and so on to Z or z which can be used as 35. Like decimal
  <tt><span class="type">bigInteger</span></tt> literals the extended digits must be followed by
  an underscore character. Examples of <tt><span class="type">bigInteger</span></tt> literals are:
</p><pre class="box">
    0_   18446744073709551616_ 16#deadbeefcafe_
</pre><p>
  Although <tt><span class="type">bigInteger</span></tt> operations cannot overflow, it can happen
  that there is not enough memory to represent a <tt><span class="type">bigInteger</span></tt> value.
  In this case the exception <tt><a class="exception" href="#errors_MEMORY_ERROR">MEMORY_ERROR</a></tt> is raised. The <tt><span class="type">bigInteger</span></tt>
  functions are defined in the library <span class="stri">"<span class="lib">bigint.s7i</span>"</span>.
</p><pre class="tt">
    Prefix operators:
      <span class="op">+</span>         Identity
      <span class="op">-</span>         Change sign
      <span class="op">!</span>         Factorial
    Infix operators:
      <span class="op">+</span>         Addition
      <span class="op">-</span>         Subtraction
      <span class="op">*</span>         Multiplication
      <span class="op">div</span>       Integer division truncated towards zero
                  ( A <span class="op">div</span> B <b>&rArr;</b> trunc(A / B),
                    A <span class="op">div</span> 0_ <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_NUMERIC_ERROR">NUMERIC_ERROR</a> )
      <span class="op">rem</span>       Reminder of integer division <span class="op">div</span>
                  ( A <span class="op">rem</span> B <b>&rArr;</b> A - (A <span class="op">div</span> B) * B,
                    A <span class="op">rem</span> 0_ <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_NUMERIC_ERROR">NUMERIC_ERROR</a> )
      <span class="op">mdiv</span>      Integer division truncated towards negative infinity
                  ( A <span class="op">mdiv</span> B <b>&rArr;</b> floor(A / B),
                    A <span class="op">mdiv</span> 0_ <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_NUMERIC_ERROR">NUMERIC_ERROR</a> )
      <span class="op">mod</span>       Reminder of integer division <span class="op">mdiv</span>
                  ( A <span class="op">mod</span> B <b>&rArr;</b> A - (A <span class="op">mdiv</span> B) * B,
                    A <span class="op">mod</span> 0_ <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_NUMERIC_ERROR">NUMERIC_ERROR</a> )
      A <span class="op">**</span> B    Power
                  ( Type of argument B: <a class="type" href="#types_integer">integer</a>,
                    A ** B is okay for B >= 0,
                    A ** 0 <b>&rArr;</b> 1_ for every A, even for A = 0_,
                    1_ ** B <b>&rArr;</b> 1_ for B >= 0,
                    A ** B <b>&rArr;</b> -(-A) ** B for A &lt;= 0 and B >= 0 and odd(B),
                    A ** B <b>&rArr;</b> (-A) ** B for A &lt;= 0 and B >= 0 and not odd(B),
                    A ** -1 <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_NUMERIC_ERROR">NUMERIC_ERROR</a> )
      A <span class="op">&lt;&lt;</span> B    Shift left
                  ( Type of argument B: <a class="type" href="#types_integer">integer</a>,
                    A &lt;&lt; B <b>&rArr;</b> A * 2_ ** B  for B >= 0,
                    A &lt;&lt; B <b>&rArr;</b> A >> -B for B < 0,
                    A &lt;&lt; 0 <b>&rArr;</b> A,
                    0_ &lt;&lt; B <b>&rArr;</b> 0_ for every B )
      A <span class="op">>></span> B    Arithmetic shift right
                  ( Type of argument B: <a class="type" href="#types_integer">integer</a>,
                    A >> B <b>&rArr;</b> A <span class="op">mdiv</span> 2_ ** B for B >= 0,
                    A >> B <b>&rArr;</b> A &lt;&lt; -B for B < 0,
                    A >> 0 <b>&rArr;</b> A,
                    A >> B <b>&rArr;</b> C for A >= 0_ holds: C >= 0_,
                    A >> B <b>&rArr;</b> C for A &lt; 0_ holds: C &lt; 0_,
                    A >> B <b>&rArr;</b> 0_ for A >= 0_ and B > ord(log2(A)),
                    A >> B <b>&rArr;</b> -1_ for A &lt; 0_ and B > ord(log2(-A)),
                    0_ >> B <b>&rArr;</b> 0_ for every B )
      A <span class="op">radix</span> B  Convert the <a class="type" href="#types_bigInteger">bigInteger</a> A to a <a class="type" href="#types_string">string</a>. The conversion
                 uses the numeral system with the base B.
                  ( Type of result: <a class="type" href="#types_string">string</a>,
                    3735928559_ <span class="op">radix</span> 16 <b>&rArr;</b> <span class="stri">"deadbeef"</span>,
                    -3735928559_ <span class="op">radix</span> 16 ) <b>&rArr;</b> <span class="stri">"-deadbeef"</span>,
                    123_ <span class="op">radix</span> 37 <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> )
      A <span class="op">RADIX</span> B  Convert the <a class="type" href="#types_integer">integer</a> A to a <a class="type" href="#types_string">string</a>. The conversion
                 uses the numeral system with the base B.
                  ( Type of result: <a class="type" href="#types_string">string</a>,
                    3735928559_ <span class="op">RADIX</span> 16 <b>&rArr;</b> <span class="stri">"DEADBEEF"</span>,
                    -3735928559_ <span class="op">RADIX</span> 16 ) <b>&rArr;</b> <span class="stri">"-DEADBEEF"</span>,
                    123_ <span class="op">RADIX</span> 37 <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> )
      <a class="type" href="#types_bigInteger">bigInteger</a> <span class="op">conv</span> A   Conversion of <a class="type" href="#types_integer">integer</a> to <a class="type" href="#types_bigInteger">bigInteger</a>
                  ( Type of argument A: <a class="type" href="#types_integer">integer</a>,
                    <a class="type" href="#types_bigInteger">bigInteger</a> <span class="op">conv</span> 1 <b>&rArr;</b> 1_ )
      <a class="type" href="#types_bigInteger">bigInteger</a> <span class="op">parse</span> A   Conversion of <a class="type" href="#types_string">string</a> to <a class="type" href="#types_integer">integer</a>
                  ( Type of argument A: <a class="type" href="#types_string">string</a>,
                    <a class="type" href="#types_bigInteger">bigInteger</a> <span class="op">parse</span> <span class="stri">"123"</span> <b>&rArr;</b> 123_,
                    <a class="type" href="#types_bigInteger">bigInteger</a> <span class="op">parse</span> <span class="stri">"-123"</span> <b>&rArr;</b> -123_,
                    <a class="type" href="#types_bigInteger">bigInteger</a> <span class="op">parse</span> <span class="stri">"+5"</span> <b>&rArr;</b> 5_,
                    <a class="type" href="#types_bigInteger">bigInteger</a> <span class="op">parse</span> <span class="stri">" 1"</span> <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a>,
                    <a class="type" href="#types_bigInteger">bigInteger</a> <span class="op">parse</span> <span class="stri">"10 "</span> <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a>,
                    <a class="type" href="#types_bigInteger">bigInteger</a> <span class="op">parse</span> <span class="stri">"ASDF"</span> <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> )
    Relations:
      <span class="op">=</span>, <span class="op">&lt;></span>, <span class="op">&lt;</span>, <span class="op">&lt;=</span>, <span class="op">></span>, <span class="op">>=</span>
    Functions:
      <span class="func">ord</span>(A)    Ordinal number
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
                    ord(99999999999999999999_) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> )
      <span class="func">succ</span>(A)   Successor
                  ( succ(A) <b>&rArr;</b> A+1_ )
      <span class="func">pred</span>(A)   Predecessor
                  ( pred(A) <b>&rArr;</b> A-1_ )
      <span class="func">abs</span>(A)    Absolute value
      <span class="func">odd</span>(A)    Odd value
                  ( Type of result: <a class="type" href="#types_boolean">boolean</a> )
      <span class="func">str</span>(A)    Conversion to <a class="type" href="#types_string">string</a>
                  ( Type of result: <a class="type" href="#types_string">string</a>,
                    str(9876543210_) <b>&rArr;</b> <span class="stri">"9876543210"</span> )
      <span class="func">sqrt</span>(A)   Integer square root
                  ( sqrt(A) is okay for A >= 0_
                    sqrt(A) <b>&rArr;</b> trunc(sqrt(flt(A))),
                    sqrt(-1_) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_NUMERIC_ERROR">NUMERIC_ERROR</a> )
      <span class="func">modInverse</span>(A, B) Compute the modular multiplicative inverse of A modulo B
      <span class="func">log2</span>(A)   Truncated base 2 logarithm
                  ( log2(A) returns the position of the
                    highest bit set. It is defined for A >= 0
                    log2(2_ ** A) = A for A >= 0,
                    log2(pred(2_ ** A)) = pred(A) for A >= 0,
                    log2(2_) <b>&rArr;</b> 1_,
                    log2(1_) <b>&rArr;</b> 0_,
                    log2(0_) <b>&rArr;</b> -1_,
                    log2(-1_) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_NUMERIC_ERROR">NUMERIC_ERROR</a> )
      <span class="func">gcd</span>(A, B) Greatest common divisor of A and B.
                  ( gcd(A, B) = gcd(B, A),
                    gcd(A, B) = gcd(-A, B),
                    gcd(A, 0) = abs(A) )
      <span class="func">bitLength</span>(A) Number of bits in the minimal two's-complement
                   representation, excluding the sign bit.
                  ( Type of result: <a class="type" href="#types_integer">integer</a>,
                    bitLength(A) <b>&rArr;</b> ord(succ(log2(A))) for A >= 0_,
                    bitLength(A) <b>&rArr;</b> bitLength(pred(-A)) for A &lt; 0_,
                    bitLength(0_) <b>&rArr;</b> 0,
                    bitLength(-1_) <b>&rArr;</b> 0 )
      <span class="func">lowestSetBit</span>(A) Index of the lowest-order one bit
                      For A &lt;> 0_ this is equal to the number of
                      lowest-order zero bits.
                  ( Type of result: <a class="type" href="#types_integer">integer</a>,
                    A >> B &lt;&lt; B = A for A &lt;> 0_ and B = lowestSetBit(A),
                    lowestSetBit(0_) <b>&rArr;</b> -1,
                    lowestSetBit(1_) <b>&rArr;</b> 0,
                    lowestSetBit(2_) <b>&rArr;</b> 1 )
      <span class="func">rand</span>(A, B) Random number in the range [A, B]
                 The random values are uniform distributed.
                  ( rand(A, B) returns a random number such that
                    A &lt;= rand(A, B) <span class="op">and</span> rand(A, B) &lt;= B holds.
                    rand(A, A) <b>&rArr;</b> A,
                    rand(1_, 0_) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> )
      <span class="func">min</span>(A, B) Minimum of two numbers.
                  ( min(1_, 2_) <b>&rArr;</b> 1_ )
      <span class="func">max</span>(A, B) Maximum of two numbers.
                  ( max(1_, 2_) <b>&rArr;</b> 2_ )
      <span class="func">compare</span>(A, B) Compare function
                  ( Type of result: <a class="type" href="#types_integer">integer</a>,
                    compare(1_, 2_) <b>&rArr;</b> -1,
                    compare(5_, 5_) <b>&rArr;</b> 0,
                    compare(8_, 7_) <b>&rArr;</b> 1 )
      <span class="func">hashCode</span>(A) Hash function
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
    Statements:
      A <span class="op">+:=</span> B   Increment A by B
                  ( A +:= B <b>&rArr;</b> A := A + B )
      A <span class="op">-:=</span> B   Decrement A by B
                  ( A -:= B <b>&rArr;</b> A := A - B )
      A <span class="op">*:=</span> B   Multiplying copy
                  ( A *:= B <b>&rArr;</b> A := A * B )
      A <span class="op">&lt;&lt;:=</span> B  Shift left copy
                  ( A &lt;&lt;:= B <b>&rArr;</b> A := A &lt;&lt; B )
      A <span class="op">>>:=</span> B  Shift right copy
                  ( A >>:= B <b>&rArr;</b> A := A >> B )
      <span class="func">incr</span>(A)   Increment with 1
                  ( incr(A) <b>&rArr;</b> A +:= 1_ )
      <span class="func">decr</span>(A)   Decrement with 1
                  ( decr(A) <b>&rArr;</b> A -:= 1_ )
</pre><p>
  For the operations <tt><span class="op">div</span></tt> and <tt><span class="op">rem</span></tt> holds for all A:</p><pre class="box">
    (A <span class="op">div</span> B) * B + A <span class="op">rem</span> B = A           when B &lt;> 0_
    -A <span class="op">div</span> B = -(A <span class="op">div</span> B)                 when B &lt;> 0_
    -A <span class="op">rem</span> B = -(A <span class="op">rem</span> B)                 when B &lt;> 0_
    A <span class="op">rem</span> B >= 0_ <span class="op">and</span> A <span class="op">rem</span> B &lt; abs(B)    when B &lt;> 0_ and A >= 0_
    A <span class="op">rem</span> B &lt;= 0_ <span class="op">and</span> A <span class="op">rem</span> B > -abs(B)   when B &lt;> 0_ and A &lt;= 0_
</pre><p>
  For the operations <tt><span class="op">mdiv</span></tt> and <tt><span class="op">mod</span></tt> holds for all A:</p><pre class="box">
    (A <span class="op">mdiv</span> B) * B + A <span class="op">mod</span> B = A          when B &lt;> 0_
    -A <span class="op">mdiv</span> B = A <span class="op">mdiv</span> -B                 when B &lt;> 0_
    -A <span class="op">mod</span> -B = -(A <span class="op">mod</span> B)                when B &lt;> 0_
    A <span class="op">mod</span> B >= 0_ <span class="op">and</span> A <span class="op">mod</span> B &lt; B         when B > 0_
    A <span class="op">mod</span> B &lt;= 0_ <span class="op">and</span> A <span class="op">mod</span> B > B         when B &lt; 0_
</pre><p>
  For the operation <tt><span class="op">mdiv</span></tt> holds:</p><pre class="box">
    A <span class="op">mdiv</span> B = A <span class="op">div</span> B - 1_           when A and B have different
                                      signs and A <span class="op">rem</span> B &lt;> 0_ holds.
    A <span class="op">mdiv</span> B = A <span class="op">div</span> B                when A and B have the same
                                      sign or A <span class="op">rem</span> B = 0_ holds.
    A <span class="op">mdiv</span> B = (A - 1_) <span class="op">div</span> B - 1_    when A > 0_ and B &lt; 0_ holds.
    A <span class="op">mdiv</span> B = (A + 1_) <span class="op">div</span> B - 1_    when A &lt; 0_ and B > 0_ holds.
    A <span class="op">mdiv</span> 2_ ** B = A >> B           when B >= 0 holds
</pre><p>
  For the operation <tt><span class="op">mod</span></tt> holds:</p><pre class="box">
    A <span class="op">mod</span> B = A <span class="op">rem</span> B + B      when A and B have different
                               signs and A <span class="op">rem</span> B &lt;> 0_ holds.
    A <span class="op">mod</span> B = A <span class="op">rem</span> B          when A and B have the same
                               sign or A <span class="op">rem</span> B = 0_ holds.
</pre><p>

  Tables for the behavior of <tt><span class="op">div</span></tt>, <tt><span class="op">rem</span></tt>, <tt><span class="op">mdiv</span></tt> and <tt><span class="op">mod</span></tt>:
</p><dl><dd><table class="tt" border="1" cellspacing="0" cellpadding="3">
    
    <tr><th>  A  </th><th>  B  </th><th> A <span class="op">div</span> B </th><th> A <span class="op">rem</span> B </th><th> A <span class="op">mdiv</span> B </th><th> A <span class="op">mod</span> B </th></tr>
    
    <tr><td align="center">  5_ </td><td align="center">  3_ </td><td align="center">    1_   </td><td align="center">    2_   </td><td align="center">     1_   </td><td align="center">    2_   </td></tr>
    <tr><td align="center">  4_ </td><td align="center">  3_ </td><td align="center">    1_   </td><td align="center">    1_   </td><td align="center">     1_   </td><td align="center">    1_   </td></tr>
    <tr><td align="center">  3_ </td><td align="center">  3_ </td><td align="center">    1_   </td><td align="center">    0_   </td><td align="center">     1_   </td><td align="center">    0_   </td></tr>
    <tr><td align="center">  2_ </td><td align="center">  3_ </td><td align="center">    0_   </td><td align="center">    2_   </td><td align="center">     0_   </td><td align="center">    2_   </td></tr>
    <tr><td align="center">  1_ </td><td align="center">  3_ </td><td align="center">    0_   </td><td align="center">    1_   </td><td align="center">     0_   </td><td align="center">    1_   </td></tr>
    <tr><td align="center">  0_ </td><td align="center">  3_ </td><td align="center">    0_   </td><td align="center">    0_   </td><td align="center">     0_   </td><td align="center">    0_   </td></tr>
    <tr><td align="center"> -1_ </td><td align="center">  3_ </td><td align="center">    0_   </td><td align="center">   -1_   </td><td align="center">    -1_   </td><td align="center">    2_   </td></tr>
    <tr><td align="center"> -2_ </td><td align="center">  3_ </td><td align="center">    0_   </td><td align="center">   -2_   </td><td align="center">    -1_   </td><td align="center">    1_   </td></tr>
    <tr><td align="center"> -3_ </td><td align="center">  3_ </td><td align="center">   -1_   </td><td align="center">    0_   </td><td align="center">    -1_   </td><td align="center">    0_   </td></tr>
    <tr><td align="center"> -4_ </td><td align="center">  3_ </td><td align="center">   -1_   </td><td align="center">   -1_   </td><td align="center">    -2_   </td><td align="center">    2_   </td></tr>
    <tr><td align="center"> -5_ </td><td align="center">  3_ </td><td align="center">   -1_   </td><td align="center">   -2_   </td><td align="center">    -2_   </td><td align="center">    1_   </td></tr>
    
</table></dd></dl><dl><dd><table class="tt" border="1" cellspacing="0" cellpadding="3">
    
    <tr><th>  A  </th><th>  B  </th><th> A <span class="op">div</span> B </th><th> A <span class="op">rem</span> B </th><th> A <span class="op">mdiv</span> B </th><th> A <span class="op">mod</span> B </th></tr>
    
    <tr><td align="center">  5_ </td><td align="center"> -3_ </td><td align="center">   -1_   </td><td align="center">    2_   </td><td align="center">    -2_   </td><td align="center">   -1_   </td></tr>
    <tr><td align="center">  4_ </td><td align="center"> -3_ </td><td align="center">   -1_   </td><td align="center">    1_   </td><td align="center">    -2_   </td><td align="center">   -2_   </td></tr>
    <tr><td align="center">  3_ </td><td align="center"> -3_ </td><td align="center">   -1_   </td><td align="center">    0_   </td><td align="center">    -1_   </td><td align="center">    0_   </td></tr>
    <tr><td align="center">  2_ </td><td align="center"> -3_ </td><td align="center">    0_   </td><td align="center">    2_   </td><td align="center">    -1_   </td><td align="center">   -1_   </td></tr>
    <tr><td align="center">  1_ </td><td align="center"> -3_ </td><td align="center">    0_   </td><td align="center">    1_   </td><td align="center">    -1_   </td><td align="center">   -2_   </td></tr>
    <tr><td align="center">  0_ </td><td align="center"> -3_ </td><td align="center">    0_   </td><td align="center">    0_   </td><td align="center">     0_   </td><td align="center">    0_   </td></tr>
    <tr><td align="center"> -1_ </td><td align="center"> -3_ </td><td align="center">    0_   </td><td align="center">   -1_   </td><td align="center">     0_   </td><td align="center">   -1_   </td></tr>
    <tr><td align="center"> -2_ </td><td align="center"> -3_ </td><td align="center">    0_   </td><td align="center">   -2_   </td><td align="center">     0_   </td><td align="center">   -2_   </td></tr>
    <tr><td align="center"> -3_ </td><td align="center"> -3_ </td><td align="center">    1_   </td><td align="center">    0_   </td><td align="center">     1_   </td><td align="center">    0_   </td></tr>
    <tr><td align="center"> -4_ </td><td align="center"> -3_ </td><td align="center">    1_   </td><td align="center">   -1_   </td><td align="center">     1_   </td><td align="center">   -1_   </td></tr>
    <tr><td align="center"> -5_ </td><td align="center"> -3_ </td><td align="center">    1_   </td><td align="center">   -2_   </td><td align="center">     1_   </td><td align="center">   -2_   </td></tr>
    
</table></dd></dl><p>

  For the <tt><span class="func">sqrt</span></tt> function holds (when A >= 0_):</p><pre class="box">
    sqrt(A) * sqrt(A) &lt;= A <span class="op">and</span>
    (sqrt(A) + 1_) * (sqrt(A) + 1_) > A
</pre><p></p>

<a name="types_rational"><h3>5.4 rational</h3></a>
<p>
    The type <tt><span class="type">rational</span></tt> consists of rational numbers
  represented with an <tt><a class="type" href="#types_integer">integer</a></tt> numerator and an <tt><a class="type" href="#types_integer">integer</a></tt>
  denominator. The values of the type <tt><span class="type">rational</span></tt> are
  finite and periodical decimal numbers. Rational literals
  do not exist. The result of a <tt><span class="type">rational</span></tt> operation is
  undefined when it overflows. In <tt><a class="type" href="#types_integer">integer</a></tt> computations an
  overflow can only happen with very huge positive or negative
  numbers. In <tt><span class="type">rational</span></tt> computations an overflow can
  happen with small numbers. Because of widening big denominators
  can be produced easily. E.g.: <tt>1/1777 + 1/1999 = 3776/3552223</tt> .
  The <tt><span class="type">rational</span></tt> functions are defined in the library <span class="stri">"<span class="lib">rational.s7i</span>"</span>.
</p><pre class="tt">
    Elements:
      <span class="keywd">var</span> <a class="type" href="#types_integer">integer</a>: numerator <span class="keywd">is</span> 0;
      <span class="keywd">var</span> <a class="type" href="#types_integer">integer</a>: denominator <span class="keywd">is</span> 1;
    Prefix operators:
      <span class="op">+</span>         Identity
      <span class="op">-</span>         Change sign
    Infix operators:
      <span class="op">+</span>         Addition
      <span class="op">-</span>         Subtraction
      <span class="op">*</span>         Multiplication
      <span class="op">/</span>         Division
      <span class="op">/</span>         Create <a class="type" href="#types_rational">rational</a> from numerator and denominator
                  ( Type of left operand: <a class="type" href="#types_integer">integer</a>,
                    Type of right operand: <a class="type" href="#types_integer">integer</a> )
      <span class="op">**</span>        Power
                  ( <a class="type" href="#types_rational">rational</a> ** <a class="type" href="#types_integer">integer</a> )
      <a class="type" href="#types_rational">rational</a> <span class="op">conv</span> A   Conversion of <a class="type" href="#types_integer">integer</a> to <a class="type" href="#types_rational">rational</a>
                  ( Type of argument A: <a class="type" href="#types_integer">integer</a>,
                    <a class="type" href="#types_rational">rational</a> <span class="op">conv</span> 1 <b>&rArr;</b> 1 / 1 )
      <span class="op">digits</span>    Conversion to <a class="type" href="#types_string">string</a> with specified precision
                  ( Type of right operand: <a class="type" href="#types_integer">integer</a>,
                    Type of result: <a class="type" href="#types_string">string</a> )
      <a class="type" href="#types_rational">rational</a> <span class="op">parse</span> A   Conversion of <a class="type" href="#types_string">string</a> to <a class="type" href="#types_rational">rational</a>
                  ( Type of argument A: <a class="type" href="#types_string">string</a> )
    Relations:
      <span class="op">=</span>, <span class="op">&lt;></span>, <span class="op">&lt;</span>, <span class="op">&lt;=</span>, <span class="op">></span>, <span class="op">>=</span>
    Functions:
      <span class="func">abs</span>(A)    Absolute value
      <span class="func">rat</span>(A)    Conversion of <a class="type" href="#types_integer">integer</a> to <a class="type" href="#types_rational">rational</a>
                  ( Type of argument A: <a class="type" href="#types_integer">integer</a>,
                    rat(1) <b>&rArr;</b> 1 / 1 )
      <span class="func">floor</span>(A)  Truncation towards negative infinity
                  ( Type of result: <a class="type" href="#types_integer">integer</a>,
                    floor(9/5) <b>&rArr;</b>  1, floor(1/1) <b>&rArr;</b>  1,
                    floor(-1/1) <b>&rArr;</b> -1, floor(-9/5) <b>&rArr;</b> -2 )
      <span class="func">ceil</span>(A)   Rounding up towards positive infinity
                  ( Type of result: <a class="type" href="#types_integer">integer</a>,
                    ceil(6/5) <b>&rArr;</b>  2, ceil(1/1) <b>&rArr;</b>  1,
                    ceil(-1/1) <b>&rArr;</b> -1, ceil(-6/5) <b>&rArr;</b> -1 )
      <span class="func">trunc</span>(A)  Truncation towards zero
                  ( Type of result: <a class="type" href="#types_integer">integer</a>,
                    trunc(9/5) <b>&rArr;</b>  1, trunc(1/1) <b>&rArr;</b>  1,
                    trunc(-1/1) <b>&rArr;</b> -1, trunc(-9/5) <b>&rArr;</b> -1 )
      <span class="func">round</span>(A)  Round towards zero
                  ( Type of result: <a class="type" href="#types_integer">integer</a>,
                    round(1/2) <b>&rArr;</b> 1, round(-1/2) <b>&rArr;</b> -1,
                    round(2/5) <b>&rArr;</b> 0, round(-2/5) <b>&rArr;</b> 0 )
      <span class="func">str</span>(A)    Conversion to <a class="type" href="#types_string">string</a>
                  ( Type of result: <a class="type" href="#types_string">string</a> )
      <span class="func">min</span>(A, B) Minimum of two numbers.
                  ( min(2/5, 1/2) <b>&rArr;</b> 2/5 )
      <span class="func">max</span>(A, B) Maximum of two numbers.
                  ( max(2/5, 1/2) <b>&rArr;</b> 1/2 )
      <span class="func">compare</span>(A, B) Compare function
                  ( Type of result: <a class="type" href="#types_integer">integer</a>,
                    compare(19/10, 2/1) <b>&rArr;</b> -1,
                    compare(26/5, 26/5) <b>&rArr;</b> 0,
                    compare(8/1, 79/10) <b>&rArr;</b> 1 )
      <span class="func">hashCode</span>(A) Hash function
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
    Statements:
      A <span class="op">+:=</span> B   Increment A by B
                  ( A +:= B <b>&rArr;</b> A := A + B )
      A <span class="op">-:=</span> B   Decrement A by B
                  ( A -:= B <b>&rArr;</b> A := A - B )
      A <span class="op">*:=</span> B   Multiplying copy
                  ( A *:= B <b>&rArr;</b> A := A * B )
      A <span class="op">/:=</span> B   Dividing copy
                  ( A /:= B <b>&rArr;</b> A := A / B )
</pre><p>
  All calculations with <tt><span class="type">rational</span></tt> numbers are done exact.
  (Without any rounding)
</p><p></p>

<a name="types_bigRational"><h3>5.5 bigRational</h3></a>
<p>
    The type <tt><span class="type">bigRational</span></tt> consists of rational numbers
  represented with an <tt><a class="type" href="#types_bigInteger">bigInteger</a></tt> numerator and an
  <tt><a class="type" href="#types_bigInteger">bigInteger</a></tt> denominator. The values of the type
  <tt><span class="type">bigRational</span></tt> are finite and periodical decimal numbers.
  BigRational literals do not exist. Although <tt><span class="type">bigRational</span></tt>
  operations cannot overflow, it can happen that there
  is not enough memory to represent a <tt><span class="type">bigRational</span></tt> value.
  In this case the exception <tt><a class="exception" href="#errors_MEMORY_ERROR">MEMORY_ERROR</a></tt> is raised.
  The <tt><span class="type">bigRational</span></tt> functions are defined in the library
  <span class="stri">"<span class="lib">bigrat.s7i</span>"</span>.
</p><pre class="tt">
    Elements:
      <span class="keywd">var</span> <a class="type" href="#types_bigInteger">bigInteger</a>: numerator <span class="keywd">is</span> 0_;
      <span class="keywd">var</span> <a class="type" href="#types_bigInteger">bigInteger</a>: denominator <span class="keywd">is</span> 1_;
    Prefix operators:
      <span class="op">+</span>         Identity
      <span class="op">-</span>         Change sign
    Infix operators:
      <span class="op">+</span>         Addition
      <span class="op">-</span>         Subtraction
      <span class="op">*</span>         Multiplication
      <span class="op">/</span>         Division
      <span class="op">/</span>         Create <a class="type" href="#types_bigRational">bigRational</a> from numerator and denominator
                  ( Type of left argument: <a class="type" href="#types_bigInteger">bigInteger</a>,
                    Type of right argument: <a class="type" href="#types_bigInteger">bigInteger</a> )
      <span class="op">**</span>        Power
                  ( <a class="type" href="#types_bigRational">bigRational</a> ** <a class="type" href="#types_integer">integer</a> )
      <a class="type" href="#types_bigRational">bigRational</a> <span class="op">conv</span> A   Conversion of <a class="type" href="#types_integer">integer</a> to <a class="type" href="#types_bigRational">bigRational</a>
                  ( Type of argument A: <a class="type" href="#types_integer">integer</a>,
                    <a class="type" href="#types_bigRational">bigRational</a> <span class="op">conv</span> 1 <b>&rArr;</b> 1_ / 1_ )
      <a class="type" href="#types_bigRational">bigRational</a> <span class="op">conv</span> A   Conversion of <a class="type" href="#types_bigInteger">bigInteger</a> to <a class="type" href="#types_bigRational">bigRational</a>
                  ( Type of argument A: <a class="type" href="#types_bigInteger">bigInteger</a>,
                    <a class="type" href="#types_bigRational">bigRational</a> <span class="op">conv</span> 1_ <b>&rArr;</b> 1_ / 1_ )
      <span class="op">digits</span>    Conversion to <a class="type" href="#types_string">string</a> with specified precision
                  ( Type of right operand: <a class="type" href="#types_integer">integer</a>,
                    Type of result: <a class="type" href="#types_string">string</a> )
      <a class="type" href="#types_bigRational">bigRational</a> <span class="op">parse</span> A   Conversion of <a class="type" href="#types_string">string</a> to <a class="type" href="#types_bigRational">bigRational</a>
                  ( Type of argument A: <a class="type" href="#types_string">string</a> )
    Relations:
      <a class="op" href="#..s/libraries/bigrat_(in_bigRational)=(in_bigRational)">=</a>, <span class="op">&lt;></span>, <span class="op">&lt;</span>, <span class="op">&lt;=</span>, <span class="op">></span>, <span class="op">>=</span>
    Functions:
      <span class="func">abs</span>(A)    Absolute value
      <span class="func">rat</span>(A)    Conversion of <a class="type" href="#types_bigInteger">bigInteger</a> to <a class="type" href="#types_bigRational">bigRational</a>
                  ( Type of argument A: <a class="type" href="#types_bigInteger">bigInteger</a>,
                    rat(1_) <b>&rArr;</b> 1_ / 1_ )
      <span class="func">floor</span>(A)  Truncation towards negative infinity
                  ( Type of result: <a class="type" href="#types_bigInteger">bigInteger</a>,
                    floor(9_/5_) <b>&rArr;</b>  1_, floor(1_/1_) <b>&rArr;</b>  1_,
                    floor(-1_/1_) <b>&rArr;</b> -1_, floor(-9_/5_) <b>&rArr;</b> -2_ )
      <span class="func">ceil</span>(A)   Rounding up towards positive infinity
                  ( Type of result: <a class="type" href="#types_bigInteger">bigInteger</a>,
                    ceil(6_/5_) <b>&rArr;</b>  2_, ceil(1_/1_) <b>&rArr;</b>  1_,
                    ceil(-1_/1_) <b>&rArr;</b> -1_, ceil(-6_/5_) <b>&rArr;</b> -1_ )
      <span class="func">trunc</span>(A)  Truncation towards zero
                  ( Type of result: <a class="type" href="#types_bigInteger">bigInteger</a>,
                    trunc(9_/5_) <b>&rArr;</b>  1_, trunc(1_/1_) <b>&rArr;</b>  1_,
                    trunc(-1_/1_) <b>&rArr;</b> -1_, trunc(-9_/5_) <b>&rArr;</b> -1_ )
      <span class="func">round</span>(A)  Round towards zero
                  ( Type of result: <a class="type" href="#types_bigInteger">bigInteger</a>,
                    round(1_/2_) <b>&rArr;</b> 1_, round(-1_/2_) <b>&rArr;</b> -1_,
                    round(2_/5_) <b>&rArr;</b> 0_, round(-2_/5_) <b>&rArr;</b> 0_ )
      <span class="func">str</span>(A)    Conversion to <a class="type" href="#types_string">string</a>
                  ( Type of result: <a class="type" href="#types_string">string</a> )
      <span class="func">min</span>(A, B) Minimum of two numbers.
                  ( min(2_/5_, 1_/2_) <b>&rArr;</b> 2_/5_ )
      <span class="func">max</span>(A, B) Maximum of two numbers.
                  ( max(2_/5_, 1_/2_) <b>&rArr;</b> 1_/2_ )
      <span class="func">compare</span>(A, B) Compare function
                  ( Type of result: <a class="type" href="#types_integer">integer</a>,
                    compare(19_/10_, 2_/1_) <b>&rArr;</b> -1,
                    compare(26_/5_, 26_/5_) <b>&rArr;</b> 0,
                    compare(8_/1_, 79_/10_) <b>&rArr;</b> 1 )
      <span class="func">hashCode</span>(A) Hash function
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
    Statements:
      A <span class="op">+:=</span> B   Increment A by B
                  ( A +:= B <b>&rArr;</b> A := A + B )
      A <span class="op">-:=</span> B   Decrement A by B
                  ( A -:= B <b>&rArr;</b> A := A - B )
      A <span class="op">*:=</span> B   Multiplying copy
                  ( A *:= B <b>&rArr;</b> A := A * B )
      A <span class="op">/:=</span> B   Dividing copy
                  ( A /:= B <b>&rArr;</b> A := A / B )
</pre><p>
  All calculations with <tt><span class="type">bigRational</span></tt> numbers are done exact.
  (Without any rounding)
</p>

<a name="types_float"><h3>5.6 float</h3></a>
<p>
    The type <tt><span class="type">float</span></tt> consists of single precision floating point
  numbers. <a class="link" href="#tokens_Float_literals">Float literals</a> use base 10 and contain a decimal point.
  There must be at least one digit before and after the decimal point.
  An exponent part, which is introduced with E or e, is optional.
  The exponent can be signed, but the mantissa is not. A literal does
  not have a sign, + or - are unary operations. Examples of <tt><span class="type">float</span></tt>
  literals are:
</p><pre class="box">
  3.14159265358979
  1.0E-12
  0.1234
</pre><p>
  The function <tt><span class="func">str</span></tt> and the operators <tt><span class="op">digits</span></tt> and <tt><span class="op">parse</span></tt>
  create and accept float literals with sign. Basic <tt><span class="type">float</span></tt>
  functions are defined in the library <span class="stri">"<span class="lib">float.s7i</span>"</span>.
  Trigonometric- and other mathematical functions are defined
  in the library <span class="stri">"<span class="lib">math.s7i</span>"</span>.
</p><pre class="tt">
    Constants:
      <span class="var">Infinity</span>  Positive infinity
      <span class="var">NaN</span>       Not-a-Number
    Prefix operators:
      <span class="op">+</span>         Identity
      <span class="op">-</span>         Change sign
    Infix operators:
      <span class="op">+</span>         Addition
      <span class="op">-</span>         Subtraction
      <span class="op">*</span>         Multiplication
      <span class="op">/</span>         Division
                  ( A / 0.0 <b>&rArr;</b>  Infinity for A > 0.0,
                    A / 0.0 <b>&rArr;</b> -Infinity for A &lt; 0.0,
                    0.0 / 0.0 <b>&rArr;</b> NaN )
      <span class="op">**</span>        Power
                  ( A ** B is okay for A > 0.0,
                    A ** B is okay for A &lt; 0.0 and B is integer,
                    A ** B <b>&rArr;</b> NaN for A &lt; 0.0 and B is not integer,
                    A ** 0.0 <b>&rArr;</b> 1.0,
                    0.0 ** B <b>&rArr;</b> 0.0 for B > 0.0,
                    0.0 ** 0.0 <b>&rArr;</b> 1.0,
                    0.0 ** B <b>&rArr;</b> Infinity for B &lt; 0.0 )
      <span class="op">**</span>        Power
                  ( Type of right operand: <a class="type" href="#types_integer">integer</a>
                    A ** B is okay for A > 0.0,
                    A ** B is okay for A &lt; 0.0,
                    A ** 0 <b>&rArr;</b> 1.0,
                    0.0 ** B <b>&rArr;</b> 0.0 for B > 0,
                    0.0 ** 0 <b>&rArr;</b> 1.0,
                    0.0 ** B <b>&rArr;</b> Infinity for B &lt; 0 )
      <a class="type" href="#types_float">float</a> <span class="op">conv</span> A   Conversion of <a class="type" href="#types_integer">integer</a> to <a class="type" href="#types_float">float</a>
                  ( Type of argument A: <a class="type" href="#types_integer">integer</a>,
                    <a class="type" href="#types_float">float</a> <span class="op">conv</span> 1 <b>&rArr;</b> 1.0 )
      <span class="op">digits</span>    Conversion to <a class="type" href="#types_string">string</a> with specified precision
                  ( Type of right operand: <a class="type" href="#types_integer">integer</a>,
                    Type of result: <a class="type" href="#types_string">string</a>,
                    0.012345 <span class="op">digits</span> 4 <b>&rArr;</b> <span class="stri">"0.0123"</span>,
                    1.2468 <span class="op">digits</span> 2 <b>&rArr;</b> <span class="stri">"1.25"</span>,
                    0.125 <span class="op">digits</span> 2 <b>&rArr;</b> <span class="stri">"0.12"</span>,
                    0.375 <span class="op">digits</span> 2 <b>&rArr;</b> <span class="stri">"0.38"</span>,
                    Infinity <span class="op">digits</span> A <b>&rArr;</b> <span class="stri">"Infinity"</span>,
                    -Infinity <span class="op">digits</span> A <b>&rArr;</b> <span class="stri">"-Infinity"</span>,
                    NaN <span class="op">digits</span> A <b>&rArr;</b> <span class="stri">"NaN"</span> )
      <span class="op">sci</span>       Conversion to a <a class="type" href="#types_string">string</a> in scientific notation
                  ( Type of right operand: <a class="type" href="#types_integer">integer</a>,
                    Type of result: <a class="type" href="#types_string">string</a>,
                    0.012345 <span class="op">sci</span> 4 <b>&rArr;</b> <span class="stri">"1.2345e-2"</span>,
                    1.2468 <span class="op">sci</span> 2 <b>&rArr;</b> <span class="stri">"1.25e+0"</span>,
                    3.1415 <span class="op">sci</span> 0 <b>&rArr;</b> <span class="stri">"3e+0"</span>,
                    0.125 <span class="op">sci</span> 1 <b>&rArr;</b> <span class="stri">"1.2e-1"</span>,
                    0.375 <span class="op">sci</span> 1 <b>&rArr;</b> <span class="stri">"3.8e-1"</span>,
                    Infinity <span class="op">sci</span> 5 <b>&rArr;</b> <span class="stri">"Infinity"</span>,
                    -Infinity <span class="op">sci</span> 6 <b>&rArr;</b> <span class="stri">"-Infinity"</span>,
                    NaN <span class="op">sci</span> 7 <b>&rArr;</b> <span class="stri">"NaN"</span>,
                    -0.004 <span class="op">sci</span> 2 <b>&rArr;</b> <span class="stri">"-4.00e-3"</span> )
      <span class="op">exp</span>       Set the number of exponent digits in a scientific float notation.
                  ( Type of left operand: <a class="type" href="#types_string">string</a>,
                    Type of right operand: <a class="type" href="#types_integer">integer</a>,
                    Type of result: <a class="type" href="#types_string">string</a>,
                    0.012345 <span class="op">sci</span> 4 <span class="op">exp</span> 2 <b>&rArr;</b> <span class="stri">"1.2345e-02"</span>,
                    1.2468e15 <span class="op">sci</span> 2 <span class="op">exp</span> 1 <b>&rArr;</b> <span class="stri">"1.25e+15"</span>,
                    3.1415 <span class="op">sci</span> 0 <span class="op">exp</span> 3 <b>&rArr;</b> <span class="stri">"3e+000"</span>,
                    0.125 <span class="op">sci</span> 1 <span class="op">exp</span> 2 <b>&rArr;</b> <span class="stri">"1.2e-01"</span>,
                    0.375 <span class="op">sci</span> 1 <span class="op">exp</span> 2 <b>&rArr;</b> <span class="stri">"3.8e-01"</span>,
                    Infinity <span class="op">sci</span> 5 <span class="op">exp</span> 2 <b>&rArr;</b> <span class="stri">"Infinity"</span>,
                    -Infinity <span class="op">sci</span> 6 <span class="op">exp</span> 2 <b>&rArr;</b> <span class="stri">"-Infinity"</span>,
                    NaN <span class="op">sci</span> 7 <span class="op">exp</span> 2 <b>&rArr;</b> <span class="stri">"NaN"</span>,
                    -0.004 <span class="op">sci</span> 2 <span class="op">exp</span> 2 <b>&rArr;</b> <span class="stri">"-4.00e-03"</span> )
      <a class="type" href="#types_float">float</a> <span class="op">parse</span> A   Conversion of <a class="type" href="#types_string">string</a> to <a class="type" href="#types_float">float</a>
                  ( Type of argument A: <a class="type" href="#types_string">string</a> )
    Relations:
      <span class="op">=</span>, <span class="op">&lt;></span>, <span class="op">&lt;</span>, <span class="op">&lt;=</span>, <span class="op">></span>, <span class="op">>=</span>
    Functions:
      <span class="func">abs</span>(A)    Absolute value
      <span class="func">flt</span>(A)    Conversion of <a class="type" href="#types_integer">integer</a> to <a class="type" href="#types_float">float</a>
                  ( Type of argument A: <a class="type" href="#types_integer">integer</a>,
                    flt(1) <b>&rArr;</b> 1.0 )
      <span class="func">floor</span>(A)  Truncation towards negative infinity
                  ( floor( 1.8) <b>&rArr;</b>  1.0, floor( 1.0) <b>&rArr;</b>  1.0,
                    floor(-1.0) <b>&rArr;</b> -1.0, floor(-1.2) <b>&rArr;</b> -2.0,
                    floor( 0.9) <b>&rArr;</b>  0.0, floor(-0.1) <b>&rArr;</b> -1.0 )
      <span class="func">ceil</span>(A)   Rounding up towards positive infinity
                  ( ceil( 1.2) <b>&rArr;</b>  2.0, ceil( 1.0) <b>&rArr;</b>  1.0,
                    ceil(-1.8) <b>&rArr;</b> -1.0, ceil(-1.0) <b>&rArr;</b> -1.0,
                    ceil( 0.1) <b>&rArr;</b>  1.0, ceil(-0.9) <b>&rArr;</b>  0.0 )
      <span class="func">trunc</span>(A)  Truncation towards zero
                  ( Type of result: <a class="type" href="#types_integer">integer</a>,
                    trunc( 1.8) <b>&rArr;</b>  1, trunc( 1.0) <b>&rArr;</b>  1,
                    trunc(-1.8) <b>&rArr;</b> -1, trunc(-1.0) <b>&rArr;</b> -1,
                    trunc( 0.9) <b>&rArr;</b>  0, trunc(-0.9) <b>&rArr;</b>  0 )
      <span class="func">round</span>(A)  Round towards zero
                  ( Type of result: <a class="type" href="#types_integer">integer</a>,
                    round(1.5) <b>&rArr;</b> 2, round(-1.5) <b>&rArr;</b> -2,
                    round(0.5) <b>&rArr;</b> 1, round(-0.5) <b>&rArr;</b> -1,
                    round(0.4) <b>&rArr;</b> 0, round(-0.4) <b>&rArr;</b> 0 )
      <span class="func">str</span>(A)    Conversion to <a class="type" href="#types_string">string</a>
                  ( Type of result: <a class="type" href="#types_string">string</a>,
                    str(Infinity) <b>&rArr;</b> <span class="stri">"Infinity"</span>,
                    str(-Infinity) <b>&rArr;</b> <span class="stri">"-Infinity"</span>,
                    str(NaN) <b>&rArr;</b> <span class="stri">"NaN"</span> )
      <span class="func">isNaN</span>(A)  Check if A is Not-a-Number
      <span class="func">sin</span>(A)    Sine
      <span class="func">cos</span>(A)    Cosine
      <span class="func">tan</span>(A)    Tangent
      <span class="func">exp</span>(A)    Exponential function
      <span class="func">log</span>(A)    Natural logarithm
                  ( log(A) is okay for A > 0.0,
                    log(0.0)  <b>&rArr;</b> -Infinity,
                    log(-1.0) <b>&rArr;</b>  NaN )
      <span class="func">log10</span>(A)  Base 10 logarithm
                  ( log10(A) is okay for A > 0.0,
                    log10(0.0)  <b>&rArr;</b> -Infinity,
                    log10(-1.0) <b>&rArr;</b>  NaN )
      <span class="func">sqrt</span>(A)   Square root
                  ( sqrt(A) is okay for A >= 0.0,
                    sqrt(-1.0) <b>&rArr;</b> NaN )
      <span class="func">asin</span>(A)   Inverse sine
                  ( asin(A) is okay for A >= -1.0 and A &lt;= 1.0,
                    asin(2.0) <b>&rArr;</b> NaN )
      <span class="func">acos</span>(A)   Inverse cosine
                  ( acos(A) is okay for A >= -1.0 and A &lt;= 1.0,
                    acos(2.0) <b>&rArr;</b> NaN )
      <span class="func">atan</span>(A)   Inverse tangent
      <span class="func">atan2</span>(A, B) Inverse tangent of A / B
      <span class="func">sinh</span>(A)   Hyperbolic sine
      <span class="func">cosh</span>(A)   Hyperbolic cosine
      <span class="func">tanh</span>(A)   Hyperbolic tangent
      <span class="func">rand</span>(A, B) Random number in the range [A, B]
                 The random values are uniform distributed.
                  ( rand(A, B) returns a random number such that
                    A &lt;= rand(A, B) <span class="op">and</span> rand(A, B) &lt;= B holds.
                    rand(A, A) <b>&rArr;</b> A,
                    rand(1.0, 0.0) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> )
      <span class="func">min</span>(A, B) Minimum of two numbers.
                  ( min(2.5, 4.5) <b>&rArr;</b> 2.5 )
      <span class="func">max</span>(A, B) Maximum of two numbers.
                  ( max(2.5, 4.5) <b>&rArr;</b> 4.5 )
      <span class="func">compare</span>(A, B) Compare function
                  ( Type of result: <a class="type" href="#types_integer">integer</a>,
                    compare(1.9, 2.1) <b>&rArr;</b> -1,
                    compare(5.3, 5.3) <b>&rArr;</b> 0,
                    compare(7.8, 7.7) <b>&rArr;</b> 1 )
      <span class="func">hashCode</span>(A) Hash function
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
    Statements:
      A <span class="op">+:=</span> B   Increment A by B
                  ( A +:= B <b>&rArr;</b> A := A + B )
      A <span class="op">-:=</span> B   Decrement A by B
                  ( A -:= B <b>&rArr;</b> A := A - B )
      A <span class="op">*:=</span> B   Multiplying copy
                  ( A *:= B <b>&rArr;</b> A := A * B )
      A <span class="op">/:=</span> B   Dividing copy
                  ( A /:= B <b>&rArr;</b> A := A / B )
</pre><p></p>

<a name="types_complex"><h3>5.7 complex</h3></a>
<p>
    The type <tt><span class="type">complex</span></tt> consists of complex numbers represented
  with an <tt><a class="type" href="#types_float">float</a></tt> real part and an <tt><a class="type" href="#types_float">float</a></tt> imaginary part.
  Complex literals do not exist. The <tt><span class="type">complex</span></tt> functions are
  defined in the library <span class="stri">"<span class="lib">complex.s7i</span>"</span>.
</p><pre class="tt">
    Elements:
      <span class="keywd">var</span> <a class="type" href="#types_float">float</a>: re <span class="keywd">is</span> 0.0;
      <span class="keywd">var</span> <a class="type" href="#types_float">float</a>: im <span class="keywd">is</span> 0.0;
    Prefix operators:
      <span class="op">+</span>         Identity
      <span class="op">-</span>         Change sign
      <span class="op">conj</span>      Complex conjugate
    Infix operators:
      <span class="op">+</span>         Addition
      <span class="op">-</span>         Subtraction
      <span class="op">*</span>         Multiplication
      <span class="op">/</span>         Division
                  ( A / complex(0.0) <b>&rArr;</b> complex(NaN, NaN) )
      <span class="op">**</span>        Power
                  ( Type of right operand: <a class="type" href="#types_integer">integer</a>
                    A ** B is okay for A > complex(0.0),
                    A ** B is okay for A &lt; complex(0.0),
                    A ** 0 <b>&rArr;</b> complex(1.0),
                    complex(0.0) ** B <b>&rArr;</b> complex(0.0) for B > 0,
                    complex(0.0) ** 0 <b>&rArr;</b> complex(1.0),
                    complex(0.0) ** B <b>&rArr;</b> complex(Infinity, NaN) for B &lt; 0 )
      <a class="type" href="#types_complex">complex</a> <span class="op">conv</span> A   Conversion of <a class="type" href="#types_integer">integer</a> to <a class="type" href="#types_complex">complex</a>
                  ( Type of argument A: <a class="type" href="#types_integer">integer</a>,
                    <a class="type" href="#types_complex">complex</a> <span class="op">conv</span> A <b>&rArr;</b> complex(flt(A)) )
      <a class="type" href="#types_complex">complex</a> <span class="op">conv</span> A   Conversion of <a class="type" href="#types_float">float</a> to <a class="type" href="#types_complex">complex</a>
                  ( Type of argument A: <a class="type" href="#types_float">float</a>,
                    <a class="type" href="#types_complex">complex</a> <span class="op">conv</span> A <b>&rArr;</b> complex(A) )
      <span class="op">digits</span>    Conversion to <a class="type" href="#types_string">string</a> with specified precision
                  ( Type of right operand: <a class="type" href="#types_integer">integer</a>,
                    Type of result: <a class="type" href="#types_string">string</a>,
                    complex(3.1415) <span class="op">digits</span> 2 <b>&rArr;</b> <span class="stri">"3.14+0.00i"</span> )
      <a class="type" href="#types_complex">complex</a> <span class="op">parse</span> A   Conversion of <a class="type" href="#types_string">string</a> to <a class="type" href="#types_complex">complex</a>
                  ( Type of argument A: <a class="type" href="#types_string">string</a> )
    Relations:
      <span class="op">=</span>, <span class="op">&lt;></span>
    Functions:
      <span class="func">abs</span>(A)    Absolute value
                  ( Type of result: <a class="type" href="#types_float">float</a> )
      <span class="func">sqrAbs</span>(A) Square of absolute value
                  ( Type of result: <a class="type" href="#types_float">float</a> )
      <span class="func">arg</span>(A)    Argument (=angle of the polar form of A)
                  ( Type of result: <a class="type" href="#types_float">float</a> )
      <span class="func">complex</span>(A, B)  Return a <a class="type" href="#types_complex">complex</a> number from its real and imaginary part
                  ( Type of argument A: <a class="type" href="#types_float">float</a>,
                    Type of argument B: <a class="type" href="#types_float">float</a> )
      <span class="func">complex</span>(A)  Return a <a class="type" href="#types_complex">complex</a> number from its real part
                  ( Type of argument A: <a class="type" href="#types_float">float</a> )
      <span class="func">polar</span>(A, B)  Return a <a class="type" href="#types_complex">complex</a> number from polar coordinates
                  ( Type of argument A: <a class="type" href="#types_float">float</a>,
                    Type of argument B: <a class="type" href="#types_float">float</a> )
      <span class="func">str</span>(A)    Conversion to <a class="type" href="#types_string">string</a>
                  ( Type of result: <a class="type" href="#types_string">string</a>,
                    str(complex(1.125)) <b>&rArr;</b> <span class="stri">"1.125+0.0i"</span> )
      <span class="func">compare</span>(A, B) Compare function
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
      <span class="func">hashCode</span>(A) Hash function
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
    Statements:
      A <span class="op">+:=</span> B   Increment A by B
                  ( A +:= B <b>&rArr;</b> A := A + B )
      A <span class="op">-:=</span> B   Decrement A by B
                  ( A -:= B <b>&rArr;</b> A := A - B )
      A <span class="op">*:=</span> B   Multiplying copy
                  ( A *:= B <b>&rArr;</b> A := A * B )
      A <span class="op">/:=</span> B   Dividing copy
                  ( A /:= B <b>&rArr;</b> A := A / B )
</pre><p></p>

<a name="types_char"><h3>5.8 char</h3></a>
<p>
    The type <tt><span class="type">char</span></tt> describes Unicode characters encoded
  with UTF-32. In the source file a <a class="link" href="#tokens_Character_literals">character literal</a> is
  written as UTF-8 encoded Unicode character enclosed in
  single quotes. In order to represent non-printable
  characters and certain printable characters the following
  escape sequences may be used.
</p><dl><dd><table border="0" cellspacing="0">
    <tr><td>audible alert   </td> <td width="20"></td><td>BEL     </td> <td width="20"></td><td><tt><span class="stri">\a</span></tt></td></tr>
    <tr><td>backspace       </td> <td width="20"></td><td>BS      </td> <td width="20"></td><td><tt><span class="stri">\b</span></tt></td></tr>
    <tr><td>escape          </td> <td width="20"></td><td>ESC     </td> <td width="20"></td><td><tt><span class="stri">\e</span></tt></td></tr>
    <tr><td>formfeed        </td> <td width="20"></td><td>FF      </td> <td width="20"></td><td><tt><span class="stri">\f</span></tt></td></tr>
    <tr><td>newline         </td> <td width="20"></td><td>NL (LF) </td> <td width="20"></td><td><tt><span class="stri">\n</span></tt></td></tr>
    <tr><td>carriage return </td> <td width="20"></td><td>CR      </td> <td width="20"></td><td><tt><span class="stri">\r</span></tt></td></tr>
    <tr><td>horizontal tab  </td> <td width="20"></td><td>HT      </td> <td width="20"></td><td><tt><span class="stri">\t</span></tt></td></tr>
    <tr><td>vertical tab    </td> <td width="20"></td><td>VT      </td> <td width="20"></td><td><tt><span class="stri">\v</span></tt></td></tr>
    <tr><td>backslash       </td> <td width="20"></td><td>(\)     </td> <td width="20"></td><td><tt><span class="stri">\\</span></tt></td></tr>
    <tr><td>apostrophe      </td> <td width="20"></td><td>(')     </td> <td width="20"></td><td><tt><span class="stri">\'</span></tt></td></tr>
    <tr><td>double quote    </td> <td width="20"></td><td>(")     </td> <td width="20"></td><td><tt><span class="stri">\"</span></tt></td></tr>
    <tr><td>control-A       </td> <td width="20"></td><td>        </td> <td width="20"></td><td><tt><span class="stri">\A</span></tt></td></tr>
    <tr><td>  ...</td></tr>
    <tr><td>control-Z       </td> <td width="20"></td><td>        </td> <td width="20"></td><td><tt><span class="stri">\Z</span></tt></td></tr>
</table></dd></dl><p>
  Additionally the following escape sequence can be used:
</p><ul>
    <li>Two backslashes with an integer literal between them are
      interpreted as character with the specified ordinal number.
      Note that the integer literal is interpreted decimal unless
      it is written as based integer.</li>
</ul><p>
  Examples of character literals are:
</p><pre class="box">
    <span class="stri">'a'</span>   <span class="stri">' '</span>   <span class="stri">'\n'</span>   <span class="stri">'!'</span>   <span class="stri">'\\'</span>   <span class="stri">'2'</span>   <span class="stri">'"'</span>   <span class="stri">'\"'</span>   <span class="stri">'\''</span>   <span class="stri">'\8\'</span>
</pre><p>
  To use characters beyond ASCII (which is a subset of Unicode)
  in the source file make sure that the editor uses UTF-8
  encoded characters. The <tt><span class="type">char</span></tt> functions are defined in
  the library <span class="stri">"<span class="lib">char.s7i</span>"</span>.
</p><pre class="tt">
    Infix operators:
      <a class="type" href="#types_char">char</a> <span class="op">conv</span> A   Conversion of <a class="type" href="#types_integer">integer</a> to <a class="type" href="#types_char">char</a>
                  ( Type of argument A: <a class="type" href="#types_integer">integer</a>,
                    <a class="type" href="#types_char">char</a> <span class="op">conv</span> 65 <b>&rArr;</b> 'A' )
      <a class="type" href="#types_char">char</a> <span class="op">parse</span> A   Conversion of <a class="type" href="#types_string">string</a> to <a class="type" href="#types_char">char</a>
                  ( Type of argument A: <a class="type" href="#types_string">string</a> )
    Relations:
      <span class="op">=</span>, <span class="op">&lt;></span>, <span class="op">&lt;</span>, <span class="op">&lt;=</span>, <span class="op">></span>, <span class="op">>=</span>
    Functions:
      <span class="func">ord</span>(A)    Ordinal number
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
      <span class="func">chr</span>(A)    Conversion of <a class="type" href="#types_integer">integer</a> to <a class="type" href="#types_char">char</a>
                  ( Type of argument: <a class="type" href="#types_integer">integer</a> )
      <span class="func">succ</span>(A)   Successor
                  ( succ(A) <b>&rArr;</b> chr(succ(ord(A))) )
      <span class="func">pred</span>(A)   Predecessor
                  ( pred(A) <b>&rArr;</b> chr(pred(ord(A))) )
      <span class="func">str</span>(A)    Conversion to <a class="type" href="#types_string">string</a>
                  ( Type of result: <a class="type" href="#types_string">string</a>,
                    str(<span class="stri">'A'</span>) <b>&rArr;</b> <span class="stri">"A"</span> )
      <span class="func">literal</span>(A) Conversion to a literal
                  ( Type of result: <a class="type" href="#types_string">string</a>,
                    literal(<span class="stri">'A'</span>) <b>&rArr;</b> <span class="stri">"'A'"</span> )
      <span class="func">upper</span>(A)  Conversion to upper case character
                  ( upper(<span class="stri">'A'</span>) <b>&rArr;</b> <span class="stri">'A'</span> )
                  ( upper(<span class="stri">'z'</span>) <b>&rArr;</b> <span class="stri">'Z'</span> )
      <span class="func">lower</span>(A)  Conversion to lower case character
                  ( lower(<span class="stri">'A'</span>) <b>&rArr;</b> <span class="stri">'a'</span> )
                  ( lower(<span class="stri">'z'</span>) <b>&rArr;</b> <span class="stri">'z'</span> )
      <span class="func">rand</span>(A, B) Random character in the range [A, B]
                 The random values are uniform distributed.
                  ( rand(A, B) returns a random character such that
                    A &lt;= rand(A, B) <span class="op">and</span> rand(A, B) &lt;= B holds.
                    rand(A, A) <b>&rArr;</b> A,
                    rand('B', <span class="stri">'A'</span>) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> )
      <span class="func">compare</span>(A, B) Compare function
                  ( Type of result: <a class="type" href="#types_integer">integer</a>,
                    compare(<span class="stri">'A'</span>, <span class="stri">'B'</span>) <b>&rArr;</b> -1,
                    compare(<span class="stri">'A'</span>, <span class="stri">'A'</span>) <b>&rArr;</b> 0,
                    compare(<span class="stri">'B'</span>, <span class="stri">'A'</span>) <b>&rArr;</b> 1 )
      <span class="func">hashCode</span>(A) Hash function
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
    Statements:
      <span class="func">incr</span>(A)   Increment
                  ( incr(A) <b>&rArr;</b> A := succ(A) )
      <span class="func">decr</span>(A)   Decrement
                  ( decr(A) <b>&rArr;</b> A := pred(A) )
</pre><p></p>

<a name="types_string"><h3>5.9 string</h3></a>
<p>
    The type <tt><a class="type" href="#types_string">string</a></tt> describes sequences of Unicode characters
  (including the empty string). The characters in the <tt><a class="type" href="#types_string">string</a></tt>
  use the UTF-32 encoding. Strings are not <tt><span class="stri">'\0\'</span></tt> terminated
  and therefore can also contain binary data. Although <tt><a class="type" href="#types_string">string</a></tt>s
  are allowed to grow very big, it can happen that there is not
  enough memory to represent a <tt><a class="type" href="#types_string">string</a></tt> value. In this case the
  exception <tt><a class="exception" href="#errors_MEMORY_ERROR">MEMORY_ERROR</a></tt> is raised. In the source file a <a class="link" href="#tokens_String_literals">string
  literal</a> is a sequence of UTF-8 encoded Unicode characters
  surrounded by double quotes.
</p><p>
  To represent control characters and certain other characters
  in strings the same escape sequences as for character literals
  may be used. E.g.: Quotation characters (") inside strings can
  be represented by preceding them with a backslash ( \" ).
  Additionally there is the following possibility:
</p><ul>
    <li>Two backslashes with a sequence of blanks, horizontal tabs,
      carriage returns and new lines between them are completely
      ignored. The ignored characters are not part of the string.
      This can be used to continue a string in the following line.
      Note that in this case the leading spaces in the new line
      are not part of the string. Although this possibility exists
      also for character literals it is mentioned here, since it
      makes more sense to use it with string literals</li>
</ul><p>
  Examples of string literals are:
</p><pre class="box">
    <span class="stri">""</span>   <span class="stri">" "</span>   <span class="stri">"\""</span>   <span class="stri">"'"</span>   <span class="stri">"String"</span>   <span class="stri">"CAN\"T !"</span>
</pre><p>
  To use characters beyond ASCII (which is a subset of Unicode)
  in the source file make sure that the editor uses UTF-8
  encoded characters. The <tt><a class="type" href="#types_string">string</a></tt> functions are defined in
  the library <span class="stri">"<span class="lib">string.s7i</span>"</span>.
</p><pre class="tt">
    Infix operators:
      <span class="op">&amp;</span>         String concatenation
                  ( <span class="stri">"All "</span> &amp; <span class="stri">"OK"</span> <b>&rArr;</b> <span class="stri">"All OK"</span> )
      <span class="op">&lt;&amp;</span>        String concatenation with weak priority
                Overloaded for various types with <span class="func">enable_output</span> or <span class="func">enable_io</span>
                  ( write(<span class="stri">"i="</span> &lt;&amp; i <span class="op">digits</span> 2 <span class="op">lpad</span> 6 &lt;&amp; <span class="stri">" $"</span>); )
      <span class="op">mult</span>      String multiplication
                  ( Type of right operand: <a class="type" href="#types_integer">integer</a>,
                    <span class="stri">"LA"</span> <span class="op">mult</span> 3 <b>&rArr;</b> <span class="stri">"LALALA"</span>,
                    <span class="stri">"WORD"</span> <span class="op">mult</span> 0 <b>&rArr;</b> <span class="stri">""</span>,
                    <span class="stri">"ANY"</span> <span class="op">mult</span> -1 <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> )
      <span class="op">lpad</span>      Left padding with spaces
                  ( Type of right operand: <a class="type" href="#types_integer">integer</a>,
                    <span class="stri">"HELLO"</span> <span class="op">lpad</span>  8 <b>&rArr;</b> <span class="stri">"   HELLO"</span>,
                    <span class="stri">"HELLO"</span> <span class="op">lpad</span>  6 <b>&rArr;</b> <span class="stri">" HELLO"</span>,
                    <span class="stri">"HELLO"</span> <span class="op">lpad</span>  5 <b>&rArr;</b> <span class="stri">"HELLO"</span>,
                    <span class="stri">"HELLO"</span> <span class="op">lpad</span>  4 <b>&rArr;</b> <span class="stri">"HELLO"</span>,
                    <span class="stri">"HELLO"</span> <span class="op">lpad</span>  0 <b>&rArr;</b> <span class="stri">"HELLO"</span>,
                    <span class="stri">"HELLO"</span> <span class="op">lpad</span> -8 <b>&rArr;</b> <span class="stri">"HELLO"</span> )
      <span class="op">lpad0</span>      Left padding with zeroes
                  ( Type of right operand: <a class="type" href="#types_integer">integer</a>,
                    <span class="stri">"12"</span> <span class="op">lpad0</span>  5 <b>&rArr;</b> <span class="stri">"00012"</span>,
                    <span class="stri">"12"</span> <span class="op">lpad0</span>  3 <b>&rArr;</b> <span class="stri">"012"</span>,
                    <span class="stri">"12"</span> <span class="op">lpad0</span>  2 <b>&rArr;</b> <span class="stri">"12"</span>,
                    <span class="stri">"12"</span> <span class="op">lpad0</span>  1 <b>&rArr;</b> <span class="stri">"12"</span>,
                    <span class="stri">"12"</span> <span class="op">lpad0</span>  0 <b>&rArr;</b> <span class="stri">"12"</span>,
                    <span class="stri">"12"</span> <span class="op">lpad0</span> -5 <b>&rArr;</b> <span class="stri">"12"</span> )
      <span class="op">rpad</span>      Right padding with spaces
                  ( Type of right operand: <a class="type" href="#types_integer">integer</a>,
                    <span class="stri">"HELLO"</span> <span class="op">rpad</span>  8 <b>&rArr;</b> <span class="stri">"HELLO   "</span>,
                    <span class="stri">"HELLO"</span> <span class="op">rpad</span>  6 <b>&rArr;</b> <span class="stri">"HELLO "</span>,
                    <span class="stri">"HELLO"</span> <span class="op">rpad</span>  5 <b>&rArr;</b> <span class="stri">"HELLO"</span>,
                    <span class="stri">"HELLO"</span> <span class="op">rpad</span>  4 <b>&rArr;</b> <span class="stri">"HELLO"</span>,
                    <span class="stri">"HELLO"</span> <span class="op">rpad</span>  0 <b>&rArr;</b> <span class="stri">"HELLO"</span>,
                    <span class="stri">"HELLO"</span> <span class="op">rpad</span> -8 <b>&rArr;</b> <span class="stri">"HELLO"</span> )
      <a class="type" href="#types_string">string</a> <span class="op">parse</span> A   Identity
    Indices:
      <span class="op">[</span> A ]     Access one character
                  ( Type of argument A: <a class="type" href="#types_integer">integer</a>,
                    Type of result: <a class="type" href="#types_char">char</a>,
                    <span class="stri">"abcde"</span>[1] <b>&rArr;</b> <span class="stri">'a'</span>,
                    <span class="stri">"abcde"</span>[5] <b>&rArr;</b> <span class="stri">'e'</span>,
                    <span class="stri">"abcde"</span>[0] <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a>,
                    <span class="stri">"abcde"</span>[6] <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> )
      <span class="op">[</span> A .. B ] Access a substring from position A to B
                  ( Type of arguments A and B: <a class="type" href="#types_integer">integer</a>,
                    <span class="stri">"abcde"</span>[2 .. 4] <b>&rArr;</b> <span class="stri">"bcd"</span>,
                    <span class="stri">"abcde"</span>[2 .. 7] <b>&rArr;</b> <span class="stri">"bcde"</span>,
                    <span class="stri">"abcde"</span>[4 .. 2] <b>&rArr;</b> <span class="stri">""</span>,
                    <span class="stri">"abcde"</span>[6 .. 8] <b>&rArr;</b> <span class="stri">""</span>,
                    <span class="stri">"abcde"</span>[-3 .. 4] <b>&rArr;</b> <span class="stri">"abcd"</span>,
                    <span class="stri">"abcde"</span>[-3 .. 7] <b>&rArr;</b> <span class="stri">"abcde"</span>,
                    <span class="stri">"abcde"</span>[-3 .. 0] <b>&rArr;</b> <span class="stri">""</span> )
      <span class="op">[</span> A <span class="keywd">len</span> B ] Access a substring from position A with length B
                  ( Type of arguments A and B: <a class="type" href="#types_integer">integer</a>,
                    <span class="stri">"abcde"</span>[2 <span class="keywd">len</span> 3] <b>&rArr;</b> <span class="stri">"bcd"</span>,
                    <span class="stri">"abcde"</span>[2 <span class="keywd">len</span> 5] <b>&rArr;</b> <span class="stri">"bcde"</span>,
                    <span class="stri">"abcde"</span>[-3 <span class="keywd">len</span> 8] <b>&rArr;</b> <span class="stri">"abcd"</span>,
                    <span class="stri">"abcde"</span>[-1 <span class="keywd">len</span> 9] <b>&rArr;</b> <span class="stri">"abcde"</span> )
      <span class="op">[</span> A .. ]  Access a substring beginning at position A
                  ( Type of argument A: <a class="type" href="#types_integer">integer</a>,
                    <span class="stri">"abcde"</span>[3 ..] <b>&rArr;</b> <span class="stri">"cde"</span>,
                    <span class="stri">"abcde"</span>[6 ..] <b>&rArr;</b> <span class="stri">""</span>,
                    <span class="stri">"abcde"</span>[-3 ..] <b>&rArr;</b> <span class="stri">"abcde"</span>,
                    <span class="stri">""</span>[1 ..] <b>&rArr;</b> <span class="stri">""</span> )
      <span class="op">[</span> .. A ]  Access a substring ending at position A
                  ( Type of argument A: <a class="type" href="#types_integer">integer</a>,
                    <span class="stri">"abcde"</span>[.. 4] <b>&rArr;</b> <span class="stri">"abcd"</span>,
                    <span class="stri">"abcde"</span>[.. 6] <b>&rArr;</b> <span class="stri">"abcde"</span>,
                    <span class="stri">"abcde"</span>[.. -3] <b>&rArr;</b> <span class="stri">""</span>,
                    <span class="stri">""</span>[.. 5] <b>&rArr;</b> <span class="stri">""</span> )
    Relations:
      <span class="op">=</span>, <span class="op">&lt;></span>, <span class="op">&lt;</span>, <span class="op">&lt;=</span>, <span class="op">></span>, <span class="op">>=</span>
    Functions:
      <span class="func">length</span>(A) Length of <a class="type" href="#types_string">string</a>
                  ( Type of result: <a class="type" href="#types_integer">integer</a>,
                    length(<span class="stri">""</span>) <b>&rArr;</b> 0 )
      <span class="func">pos</span>(A,B)  First position of <a class="type" href="#types_char">char</a> B in <a class="type" href="#types_string">string</a> A
                  ( Type of argument B: <a class="type" href="#types_char">char</a>,
                    Type of result: <a class="type" href="#types_integer">integer</a>,
                    pos(<span class="stri">"ABCABC"</span>,<span class="stri">'B'</span>) <b>&rArr;</b> 2,
                    pos(<span class="stri">"XYZ"</span>,<span class="stri">'A'</span>) <b>&rArr;</b> 0 )
      <span class="func">pos</span>(A,B)  First position of <a class="type" href="#types_string">string</a> B in <a class="type" href="#types_string">string</a> A
                  ( Type of result: <a class="type" href="#types_integer">integer</a>,
                    pos(<span class="stri">"ABCDE ABCDE"</span>,<span class="stri">"BC"</span>) <b>&rArr;</b> 2,
                    pos(<span class="stri">"XYZXYZ"</span>,<span class="stri">"ZYX"</span>) <b>&rArr;</b> 0,
                    pos(<span class="stri">"123456789"</span>,<span class="stri">""</span>) <b>&rArr;</b> 0 )
      <span class="func">pos</span>(A,B,C) First position of <a class="type" href="#types_char">char</a> B in <a class="type" href="#types_string">string</a> A
                 The search starts at position C of <a class="type" href="#types_string">string</a> A
                  ( Type of argument B: <a class="type" href="#types_char">char</a>,
                    Type of argument C: <a class="type" href="#types_integer">integer</a>,
                    Type of result: <a class="type" href="#types_integer">integer</a>,
                    pos(<span class="stri">"ABCABC"</span>,<span class="stri">'B'</span>, 3) <b>&rArr;</b> 5,
                    pos(<span class="stri">"XYZYX"</span>,<span class="stri">'Z'</span>, 4) <b>&rArr;</b> 0,
                    pos(<span class="stri">"12345"</span>,<span class="stri">'3'</span>, 7) <b>&rArr;</b> 0 )
      <span class="func">pos</span>(A,B,C) First position of <a class="type" href="#types_string">string</a> B in <a class="type" href="#types_string">string</a> A
                 The search starts at position C of <a class="type" href="#types_string">string</a> A
                  ( Type of argument C: <a class="type" href="#types_integer">integer</a>,
                    Type of result: <a class="type" href="#types_integer">integer</a>,
                    pos(<span class="stri">"ABCDE ABCDE"</span>,<span class="stri">"BC"</span>, 3) <b>&rArr;</b> 8,
                    pos(<span class="stri">"XYZXYZ"</span>,<span class="stri">"ZXY"</span>, 4) <b>&rArr;</b> 0,
                    pos(<span class="stri">"12345"</span>,<span class="stri">"34"</span>, 7) <b>&rArr;</b> 0 )
                    pos(<span class="stri">"123456789"</span>,<span class="stri">""</span>, 2) <b>&rArr;</b> 0 )
      <span class="func">rpos</span>(A,B) Last position of <a class="type" href="#types_char">char</a> B in <a class="type" href="#types_string">string</a> A
                  ( Type of argument B: <a class="type" href="#types_char">char</a>,
                    Type of result: <a class="type" href="#types_integer">integer</a>,
                    rpos(<span class="stri">"ABCABC"</span>,<span class="stri">'B'</span>) <b>&rArr;</b> 5,
                    rpos(<span class="stri">"XYZ"</span>,<span class="stri">'A'</span>) <b>&rArr;</b> 0 )
      <span class="func">rpos</span>(A,B) Last position of <a class="type" href="#types_string">string</a> B in <a class="type" href="#types_string">string</a> A
                  ( Type of result: <a class="type" href="#types_integer">integer</a>,
                    rpos(<span class="stri">"ABCDE ABCDE"</span>,<span class="stri">"BC"</span>) <b>&rArr;</b> 8,
                    rpos(<span class="stri">"XYZXYZ"</span>,<span class="stri">"ZYX"</span>) <b>&rArr;</b> 0,
                    rpos(<span class="stri">"123456789"</span>,<span class="stri">""</span>) <b>&rArr;</b> 0 )
      <span class="func">rpos</span>(A,B,C) Last position of <a class="type" href="#types_char">char</a> B in <a class="type" href="#types_string">string</a> A
                 The search starts at position C of <a class="type" href="#types_string">string</a> A
                  ( Type of argument B: <a class="type" href="#types_char">char</a>,
                    Type of argument C: <a class="type" href="#types_integer">integer</a>,
                    Type of result: <a class="type" href="#types_integer">integer</a>,
                    rpos(<span class="stri">"ABCABC"</span>,<span class="stri">'B'</span>, 4) <b>&rArr;</b> 2,
                    rpos(<span class="stri">"XYZYX"</span>,<span class="stri">'Z'</span>, 2) <b>&rArr;</b> 0,
                    rpos(<span class="stri">"12345"</span>,<span class="stri">'3'</span>, 5) <b>&rArr;</b> 3 )
      <span class="func">rpos</span>(A,B,C) Last position of <a class="type" href="#types_char">char</a> B in <a class="type" href="#types_string">string</a> A
                 The search starts at position C of <a class="type" href="#types_string">string</a> A
                  ( Type of argument C: <a class="type" href="#types_integer">integer</a>,
                    Type of result: <a class="type" href="#types_integer">integer</a>,
                    rpos(<span class="stri">"ABCABC"</span>,<span class="stri">"BC"</span>, 4) <b>&rArr;</b> 2,
                    rpos(<span class="stri">"XYZYX"</span>,<span class="stri">"ZY"</span>, 2) <b>&rArr;</b> 0,
                    rpos(<span class="stri">"12345"</span>,<span class="stri">"34"</span>, 5) <b>&rArr;</b> 3 )
      <span class="func">startsWith</span>(A,B) Determine if a string starts with a prefix.
                  ( Type of result: <a class="type" href="#types_boolean">boolean</a>,
                    startsWith(<span class="stri">"tmp_s7c.c"</span>, <span class="stri">"tmp_"</span>) <b>&rArr;</b> <span class="var">TRUE</span>,
                    startsWith(<span class="stri">"example"</span>, <span class="stri">"E"</span>) <b>&rArr;</b> <span class="var">FALSE</span> )
      <span class="func">endsWith</span>(A,B) Determine if a string ends with a suffix.
                  ( Type of result: <a class="type" href="#types_boolean">boolean</a>,
                    endsWith(<span class="stri">"hello.sd7"</span>, <span class="stri">".sd7"</span>) <b>&rArr;</b> <span class="var">TRUE</span>,
                    endsWith(<span class="stri">"A string"</span>, <span class="stri">"\0\"</span>) <b>&rArr;</b> <span class="var">FALSE</span> )
      <span class="func">equalAtIndex</span>(A,B,C) Check if A has the searched characters B starting from C. 
                  ( Type of result: <a class="type" href="#types_boolean">boolean</a>,
                    equalAtIndex(<span class="stri">"The quick brown fox"</span>, <span class="stri">"quick"</span>, 5) <b>&rArr;</b> <span class="var">TRUE</span>,
                    equalAtIndex(<span class="stri">"axis"</span>, <span class="stri">"xi"</span>, 3) <b>&rArr;</b> <span class="var">FALSE</span> )
      <span class="func">replace</span>(A,B,C) Search A for occurrences of B and replace them with C
                  ( replace(<span class="stri">"old gold"</span>, <span class="stri">"old"</span>, <span class="stri">"one"</span>) <b>&rArr;</b> <span class="stri">"one gone"</span> )
      <span class="func">replace2</span>(A,B,C,D) Search A for occurrences of B followed by C and
                replace them with D.
                  ( replace2(<span class="stri">"x := (*ord*) y;"</span>, <span class="stri">"(*"</span>, <span class="stri">"*)"</span>, <span class="stri">""</span>) <b>&rArr;</b> <span class="stri">"x :=  y;"</span> )
      split(A,B) Split A into strings delimited by B
                  ( Type of argument B: <a class="type" href="#types_char">char</a>,
                    Type of result: <a class="type" href="#types_array">array</a> <a class="type" href="#types_string">string</a>,
                    split(<span class="stri">""</span>, <span class="stri">':'</span>) <b>&rArr;</b> [](<span class="stri">""</span>),
                    split(<span class="stri">":"</span>, <span class="stri">':'</span>) <b>&rArr;</b> [](<span class="stri">""</span>, <span class="stri">""</span>),
                    split(<span class="stri">"15:30"</span>, <span class="stri">':'</span>) <b>&rArr;</b> [](<span class="stri">"15"</span>, <span class="stri">"30"</span>) )
      split(A,B) Split A into strings delimited by B
                  ( Type of result: <a class="type" href="#types_array">array</a> <a class="type" href="#types_string">string</a>,
                    split(<span class="stri">""</span>, <span class="stri">""</span>) <b>&rArr;</b> [](<span class="stri">""</span>),
                    split(<span class="stri">"ABC"</span>, <span class="stri">""</span>) <b>&rArr;</b> [](<span class="stri">"ABC"</span>),
                    split(<span class="stri">""</span>, <span class="stri">"; "</span>) <b>&rArr;</b> [](<span class="stri">""</span>),
                    split(<span class="stri">"writeln; readln;"</span>, <span class="stri">"; "</span>) <b>&rArr;</b> [](<span class="stri">"writeln"</span>, <span class="stri">"readln;"</span>) )
      join(A,B) Join the elements of A together with B's between them
                  ( Type of argument A: <a class="type" href="#types_array">array</a> <a class="type" href="#types_string">string</a>,
                    Type of argument B: <a class="type" href="#types_char">char</a>,
                    join([](<span class="stri">"This"</span>, <span class="stri">"is"</span>, <span class="stri">"a"</span>, <span class="stri">"test"</span>), <span class="stri">' '</span>) <b>&rArr;</b> <span class="stri">"This is a test"</span> )
      join(A,B) Join the elements of A together with B's between them
                  ( Type of argument A: <a class="type" href="#types_array">array</a> <a class="type" href="#types_string">string</a>,
                    Type of argument B: <a class="type" href="#types_string">string</a>,
                    join([](<span class="stri">"pro"</span>, <span class="stri">"gram"</span>), <span class="stri">""</span>) <b>&rArr;</b> <span class="stri">"program"</span> )
      <span class="func">trim</span>(A)   Removes leading and trailing spaces and control chars
                  ( trim(<span class="stri">" /n xyz /r"</span>) <b>&rArr;</b> <span class="stri">"xyz"</span> )
      <span class="func">ltrim</span>(A)   Removes leading spaces and control chars
                  ( ltrim(<span class="stri">" /n xyz /r"</span>) <b>&rArr;</b> <span class="stri">"xyz /r"</span> )
      <span class="func">rtrim</span>(A)   Removes trailing spaces and control chars
                  ( rtrim(<span class="stri">" /n xyz /r"</span>) <b>&rArr;</b> <span class="stri">" /n xyz"</span> )
      <span class="func">str</span>(A)    Conversion to <a class="type" href="#types_string">string</a>
                  ( Type of result: <a class="type" href="#types_string">string</a>,
                    str(A) <b>&rArr;</b> A )
      literal(A) Conversion to a literal
                  ( Type of result: <a class="type" href="#types_string">string</a>,
                    literal(<span class="stri">"ABC"</span>) <b>&rArr;</b> <span class="stri">"\"ABC\""</span>,
                    literal(<span class="stri">"O' \"X\""</span>) <b>&rArr;</b> <span class="stri">"\"O\' \\\"X\\\"\""</span> )
      <span class="func">upper</span>(A)  Conversion to upper case characters
                  ( upper(<span class="stri">"Upper"</span>) <b>&rArr;</b> <span class="stri">"UPPER"</span> )
      <span class="func">lower</span>(A)  Conversion to lower case characters
                  ( lower(<span class="stri">"Lower"</span>) <b>&rArr;</b> <span class="stri">"lower"</span> )
      <span class="func">compare</span>(A, B) Compare function
                  ( Type of result: <a class="type" href="#types_integer">integer</a>,
                    compare(<span class="stri">"ABC"</span>, <span class="stri">"ABCD"</span>) <b>&rArr;</b> -1,
                    compare(<span class="stri">"ABC"</span>, <span class="stri">"ABC"</span>) <b>&rArr;</b> 0,
                    compare(<span class="stri">"ABCD"</span>, <span class="stri">"ABCC"</span>) <b>&rArr;</b> 1 )
      <span class="func">hashCode</span>(A) Hash function
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
    Statements:
      A <span class="op">&amp;:=</span> B   Append B to A
                  ( A &amp;:= B <b>&rArr;</b> A := A &amp; B )
      A <span class="op">&amp;:=</span> B   Append B to A
                  ( Type of argument B: <a class="type" href="#types_char">char</a>,
                    A &amp;:= B <b>&rArr;</b> A := A &amp; str(B) )
      A <span class="op">@:=</span> [B] C  Assign C to element B of <a class="type" href="#types_string">string</a> A
                  ( Type of argument B: <a class="type" href="#types_integer">integer</a>,
                    Type of argument C: <a class="type" href="#types_char">char</a>,
                    A @:= [B] C <b>&rArr;</b>
                        A := A[..pred(B)] &amp; str(C) &amp; A[succ(B)..],
                    A @:= [0] 'x' <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a>,
                    A @:= [succ(length(A))] 'x' <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> )
</pre><p></p>

<a name="types_array"><h3>5.10 array</h3></a>
<p>
    The type <tt><a class="type" href="#types_array">array</a> <span class="type">baseType</span></tt> describes sequences of <tt><span class="type">baseType</span></tt>
  elements (including the empty sequence).
</p><dl>
    <dt></dt><dd>For example: <tt><a class="type" href="#types_array">array</a> <a class="type" href="#types_integer">integer</a></tt> describes arrays of integer elements.</dd>
</dl><p>
  An element of an array can be accessed with an <tt><a class="type" href="#types_integer">integer</a></tt> index.
  The minimal and maximal indices of an array are part of the value
  and can be obtained with the functions <tt>'minIdx'</tt> and <tt>'maxIdx'</tt>.
  There are functions which generate arrays with the default minimal
  index of 1 and other functions which generate arrays with the minimal
  index taken from a parameter. The <tt><span class="type">array</span></tt> functions are defined
  in the library <span class="stri">"<span class="lib">array.s7i</span>"</span>. Arrays with non-integer index are defined
  in the library <span class="stri">"<span class="lib">idxarray.s7i</span>"</span>.
</p><pre class="tt">
    Literal:
      [] (elem1, elem2)  Create an array with the given elements
                    The starting index of the array is 1.
      [0] (elem1, elem2)  Create an array with the given elements
                    The starting index of the array is 0.
    Infix operators:
      <span class="op">&amp;</span>         Array concatenation
      <span class="op">times</span>     Array generation
                  ( Left operand: <a class="type" href="#types_integer">integer</a>,
                    Right operand: <span class="type">baseType</span>,
                    A <span class="op">times</span> B Generates an <a class="type" href="#types_array">array</a> <span class="type">baseType</span>
                    with A elements of B,
                    (1 <span class="op">times</span> B)[1] <b>&rArr;</b> B
                    -1 <span class="op">times</span> B <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> )
      [ A .. B ] <span class="op">times</span> C    Array generation
                  ( Type of arguments A and B: <a class="type" href="#types_integer">integer</a> )
                    Type of argument C: <span class="type">baseType</span>,
                    [ A .. B ] <span class="op">times</span> C Generates an <a class="type" href="#types_array">array</a> <span class="type">baseType</span>
                    with pred(B - A) elements of C,
                    [ -1 .. -2 ] <span class="op">times</span> B <b>&rArr;</b> empty array,
                    [ -1 .. -3 ] <span class="op">times</span> B <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> )
    Indices:
      <span class="op">[</span> A ]     Access one array element
                  ( Type of argument A: <a class="type" href="#types_integer">integer</a>,
                    Type of result: <span class="type">baseType</span>,
                    A[minIdx(A)] <b>&rArr;</b> First element,
                    A[maxIdx(A)] <b>&rArr;</b> Last element,
                    A[pred(minIdx(A))] <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a>,
                    A[succ(maxIdx(A))] <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> )
      <span class="op">[</span> A .. B ]  Get a sub array from the position A to the position B 
                  ( Type of arguments A and B: <a class="type" href="#types_integer">integer</a> )
      <span class="op">[</span> A <span class="keywd">len</span> B ]  Get a sub array from the position A with maximum length B 
                  ( Type of arguments A and B: <a class="type" href="#types_integer">integer</a> )
      <span class="op">[</span> A .. ]  Get a sub array beginning at position A
                  ( Type of argument A: <a class="type" href="#types_integer">integer</a> )
      <span class="op">[</span> .. A ]  Get a sub array ending at position A
                  ( Type of argument A: <a class="type" href="#types_integer">integer</a> )
    Relations:
      =, &lt;>
    Functions:
      <span class="func">length</span>(A) Length of array
                  ( Type of result: <a class="type" href="#types_integer">integer</a>,
                    length(A) = succ(maxIdx(A) - minIdx(A)),
                    length(0 <span class="op">times</span> <span class="var">TRUE</span>) <b>&rArr;</b> 0,
                    length(5 <span class="op">times</span> <span class="var">TRUE</span>) <b>&rArr;</b> 5 )
      <span class="func">minIdx</span>(A) Minimal index of array
                  ( Type of result: <a class="type" href="#types_integer">integer</a>,
                    minIdx(3 <span class="op">times</span> <span class="var">TRUE</span>) <b>&rArr;</b> 1,
                    minIdx([-1 .. 4] <span class="op">times</span> <span class="var">TRUE</span>) <b>&rArr;</b> -1 )
      <span class="func">maxIdx</span>(A) Maximal index of array
                  ( Type of result: <a class="type" href="#types_integer">integer</a>,
                    maxIdx(3 <span class="op">times</span> <span class="var">TRUE</span>) <b>&rArr;</b> 3 )
      <span class="func">rand</span>(A)   Random element from an array
                The random elements are uniform distributed.
                  ( Type of result:  <span class="type">baseType</span> )
      <span class="func">remove</span>(A,B) Remove element with index B from array A and
                  return the removed element
                  ( Type of argument B: <a class="type" href="#types_integer">integer</a>,
                    Type of result: <span class="type">baseType</span>,
                    remove(0 <span class="op">times</span> <span class="var">TRUE</span>, 1) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> )
      <a class="func" href="#types_..">sort</a>(A)   Sort array using the compare(<span class="type">baseType</span>, <span class="type">baseType</span>) function
    Statements:
      A <span class="op">&amp;:=</span> B   Append B to A
                  ( A &amp;:= B <b>&rArr;</b> A := A &amp; B )
      A <span class="op">&amp;:=</span> B   Append element B to A
                  ( Type of argument B: <span class="type">baseType</span>,
                    A &amp;:= B <b>&rArr;</b> A := A &amp; [] (B) )
      <span class="keywd">for</span> A <span class="keywd">range</span> B <span class="keywd">do</span>
        C
      <span class="keywd">end for</span>   Loop over all elements of an array
                  ( Type of argument A: <span class="type">baseType</span>,
                    Type of argument C: <a class="type" href="#types_proc">proc</a> )
      insert(A, B, C) Insert C to the array A at position B
                  ( Type of argument B: <a class="type" href="#types_integer">integer</a>,
                    Type of argument C: <span class="type">baseType</span> )
      insert(A, B) Insert B into the sorted array A
                  ( Type of argument C: <span class="type">baseType</span> )
</pre><p></p>

<a name="types_hash"><h3>5.11 hash</h3></a>
<p>
    The type <tt><a class="type" href="#types_hash">hash</a> <span class="type">[keyType]</span> <span class="type">baseType</span></tt> describes hash tables with
  elements of <tt><span class="type">baseType</span></tt>. The elements can be accessed with an index
  of <tt><span class="type">keyType</span></tt>.
</p><dl>
    <dt></dt><dd>For example: <tt><a class="type" href="#types_hash">hash</a> <span class="type">[</span><a class="type" href="#types_string">string</a><span class="type">]</span> <a class="type" href="#types_integer">integer</a></tt> describes hash tables with
    <tt><a class="type" href="#types_integer">integer</a></tt> elements and <tt><a class="type" href="#types_string">string</a></tt> keys.</dd>
</dl><p>
  The <tt><span class="type">keyType</span></tt> of a hash needs to provide the functions <tt>'hashCode'</tt>
  and <tt>'compare'</tt>. Besides this the <tt><span class="type">keyType</span></tt> can be any type. The
  <tt><span class="type">hash</span></tt> functions are defined in the library <span class="stri">"<span class="lib">hash.s7i</span>"</span>.
</p><pre class="tt">
    Constants:
      <span class="type">hashType</span>.EMPTY_HASH  Empty hash table
    Infix operators:
      <span class="op">in</span>        Element
                  ( Left argument: <span class="type">baseType</span>,
                    Type of result: <a class="type" href="#types_boolean">boolean</a> )
      <span class="op">not in</span>    Is not Element
                  ( Left argument: <span class="type">baseType</span>,
                    Type of result: <a class="type" href="#types_boolean">boolean</a> )
    Indices:
      <span class="op">[</span> A ]     Access one hash table element
                  ( Type of argument A: <span class="type">keyType</span>,
                    Type of result: <span class="type">baseType</span> )
    Functions:
      <span class="func">length</span>(A) Number of elements in hash table A
                  ( Type of result: <a class="type" href="#types_integer">integer</a>,
                    length(hashType.EMPTY_HASH) <b>&rArr;</b> 0 )
      <span class="func">keys</span>(A)   Unsorted array of keys from hash table A
                  ( Type of result: <a class="type" href="#types_array">array</a> <span class="type">keyType</span> )
      <span class="func">values</span>(A) Unsorted array of values from hash table A
                  ( Type of result: <a class="type" href="#types_array">array</a> <span class="type">baseType</span> )
      <span class="func">flip</span>(A)   Deliver a hash with keys and values flipped
                  ( Type of result: <a class="type" href="#types_hash">hash</a> <span class="type">[baseType]</span> <a class="type" href="#types_array">array</a> <span class="type">keyType</span> )
    Statements:
      <span class="func">incl</span>(A,B,C) Include element B to hash table A
                  ( Type of argument B: <span class="type">keyType</span>,
                    Type of argument C: <span class="type">baseType</span> )
      <span class="func">excl</span>(A,B) Exclude element B from hash table A
                  ( Type of argument B: <span class="type">keyType</span> )
      A <span class="op">@:=</span> [B] C  Assign C to element B of hash table A
                  ( Type of argument B: <span class="type">keyType</span>,
                    Type of argument C: <span class="type">baseType</span> )
      <span class="keywd">for</span> A <span class="keywd">range</span> B <span class="keywd">do</span>
        C
      <span class="keywd">end for</span>   Unsorted loop over all values of a hash
                  ( Type of argument A: <span class="type">baseType</span>,
                    Type of argument C: <a class="type" href="#types_proc">proc</a> )
      <span class="keywd">for</span> <span class="keywd">key</span> A <span class="keywd">range</span> B <span class="keywd">do</span>
        C
      <span class="keywd">end for</span>   Unsorted loop over all keys of a hash
                  ( Type of argument A: <span class="type">keyType</span>,
                    Type of argument C: <a class="type" href="#types_proc">proc</a> )
      <span class="keywd">for</span> A <span class="keywd">key</span> B <span class="keywd">range</span> C <span class="keywd">do</span>
        D
      <span class="keywd">end for</span>   Unsorted loop over all values and keys of a hash
                  ( Type of argument A: <span class="type">baseType</span>,
                    Type of argument B: <span class="type">keyType</span>,
                    Type of argument D: <a class="type" href="#types_proc">proc</a> )
</pre><p></p>

<a name="types_set"><h3>5.12 set</h3></a>
<p>
    The type <tt><a class="type" href="#types_set">set</a> <span class="type">of</span> <span class="type">baseType</span></tt> describes a set of elements of a
  <tt><span class="type">baseType</span></tt>. (including the empty set). The type <tt><a class="type" href="#types_set">set</a> <span class="type">of</span> <span class="type">baseType</span></tt> is
  defined in the library <span class="stri">"<span class="lib">set.s7i</span>"</span>. This abstract data type decides
  about the implementation of the set. When <tt><span class="type">baseType</span></tt> values can be
  mapped to <tt><a class="type" href="#types_integer">integer</a></tt> with the <tt><span class="func">ord</span></tt> function and <tt><span class="func">ord</span></tt> does never
  raise an exception the set is implemented as <tt><span class="type">bitset(baseType)</span></tt>
  (defined in the library <span class="stri">"<span class="lib">bitsetof.htm</span>"</span>), otherwise the set is
  implemented as <tt><span class="type">hashset(baseType)</span></tt> (defined in the library
  <span class="stri">"<span class="lib">hashsetof.htm</span>"</span>). The type <tt><a class="type" href="#types_set">set</a> <span class="type">of</span> <a class="type" href="#types_integer">integer</a></tt> is an alternate name
  for <tt><span class="type">bitset</span></tt>, which is defined in the library <span class="stri">"<span class="lib">bitset.s7i</span>"</span>.
</p><pre class="tt">
    Constants:
      <span class="type">setType</span>.EMPTY_SET  Empty set
      EMPTY_SET  Empty set of the type <a class="type" href="#types_set">bitset</a>
    Infix operators:
      <span class="op">|</span>         Union
                  ( {1, 3} | {2, 3} <b>&rArr;</b> {1, 2, 3} )
      <span class="op">&amp;</span>         Intersection
                  ( {1, 3} & {2, 3} <b>&rArr;</b> {3} )
      <span class="op">-</span>         Difference
                  ( {1, 3} - {2, 3} <b>&rArr;</b> {1} )
      <span class="op">>&lt;</span>        Symmetric Difference
                  ( {1, 3} >&lt; {2, 3} <b>&rArr;</b> {1, 2} )
      <span class="op">in</span>        Element
                  ( Left argument: <span class="type">baseType</span>,
                    Type of result: <a class="type" href="#types_boolean">boolean</a> )
      <span class="op">not in</span>    Is not Element
                  ( Left argument: <span class="type">baseType</span>,
                    Type of result: <a class="type" href="#types_boolean">boolean</a> )
    Relations:
      <span class="op">=</span>, <span class="op">&lt;></span>     Equal and not equal
                  ( Type of result: <a class="type" href="#types_boolean">boolean</a> )
      <span class="op">&lt;=</span>        Subset
                  ( Type of result: <a class="type" href="#types_boolean">boolean</a>,
                    A &lt;= B <b>&rArr;</b> <span class="var">TRUE</span> when no element X exists for which
                       X <span class="op">in</span> A <span class="op">and</span> X <span class="op">not in</span> B
                    holds.
                    A &lt;= B <b>&rArr;</b> <span class="var">FALSE</span> when an element X exists for which
                       X <span class="op">in</span> A <span class="op">and</span> X <span class="op">not in</span> B
                    holds.
                    <span class="type">setType</span>.EMPTY_SET &lt;= A <b>&rArr;</b> <span class="var">TRUE</span>,
                    A &lt;= <span class="type">setType</span>.EMPTY_SET <b>&rArr;</b> <span class="var">FALSE</span> for A &lt;> EMPTY_SET,
                    A &lt;= B <b>&rArr;</b> B >= A )
      <span class="op">&lt;</span>         Proper subset
                  ( Type of result: <a class="type" href="#types_boolean">boolean</a>,
                    A &lt; B <b>&rArr;</b> A &lt;= B <span class="op">and</span> A &lt;> B,
                    <span class="type">setType</span>.EMPTY_SET &lt; A <b>&rArr;</b> <span class="var">TRUE</span> for A &lt;> EMPTY_SET,
                    A &lt; <span class="type">setType</span>.EMPTY_SET <b>&rArr;</b> <span class="var">FALSE</span>,
                    A &lt; B <b>&rArr;</b> B > A )
      <span class="op">>=</span>        Superset
                  ( Type of result: <a class="type" href="#types_boolean">boolean</a>,
                    A >= B <b>&rArr;</b> <span class="var">TRUE</span> when no element X exists for which
                       X <span class="op">in</span> B <span class="op">and</span> X <span class="op">not in</span> A
                    holds.
                    A >= B <b>&rArr;</b> <span class="var">FALSE</span> when an element X exists for which
                       X <span class="op">in</span> B <span class="op">and</span> X <span class="op">not in</span> A
                    holds.
                    A >= <span class="type">setType</span>.EMPTY_SET <b>&rArr;</b> <span class="var">TRUE</span>,
                    <span class="type">setType</span>.EMPTY_SET >= A <b>&rArr;</b> <span class="var">FALSE</span> for A &lt;> EMPTY_SET,
                    A >= B <b>&rArr;</b> B &lt;= A )
      <span class="op">></span>         Proper superset
                  ( Type of result: <a class="type" href="#types_boolean">boolean</a>,
                    A > B <b>&rArr;</b> A >= B <span class="op">and</span> A &lt;> B,
                    A > <span class="type">setType</span>.EMPTY_SET <b>&rArr;</b> <span class="var">TRUE</span> for A &lt;> EMPTY_SET,
                    <span class="type">setType</span>.EMPTY_SET > A <b>&rArr;</b> <span class="var">FALSE</span>,
                    A > B <b>&rArr;</b> B &lt; A )
    Functions:
      <span class="func">card</span>      Cardinality of a set
                  ( Type of result: <a class="type" href="#types_integer">integer</a>,
                    card(<span class="type">setType</span>.EMPTY_SET) <b>&rArr;</b> 0  )
      <span class="func">min</span>       Minimal element
                  ( Type of result: <span class="type">baseType</span>,
                    Delivers the element from the set for
                    which the following condition holds:
                       Element &lt;= X
                    for all X which are in the set.
                    min(<span class="type">setType</span>.EMPTY_SET) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> )
      <span class="func">max</span>       Maximum element
                  ( Type of result: <span class="type">baseType</span>,
                    Delivers the element from the set for
                    which the following condition holds:
                       Element >= X
                    for all X which are in the set.
                    min(<span class="type">setType</span>.EMPTY_SET) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> )
      <span class="func">str</span>(A)    Conversion to <a class="type" href="#types_string">string</a>
                  ( Type of result: <a class="type" href="#types_string">string</a>,
                    str(<span class="type">setType</span>.EMPTY_SET) <b>&rArr;</b> <span class="stri">"{}"</span>,
                    str({}) <b>&rArr;</b> <span class="stri">"{}"</span> )
                    str({1, 2}) <b>&rArr;</b> <span class="stri">"{1, 2}"</span> )
      <span class="func">rand</span>      Random element from a set
                The random elements are uniform distributed.
                  ( Type of result: <span class="type">baseType</span>,
                    rand(<span class="type">setType</span>.EMPTY_SET) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> )
      <span class="func">compare</span>(A, B) Compare function
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
      <span class="func">hashCode</span>(A) Hash function
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
    Statements:
      <span class="func">incl</span>(A,B) Include element B to set A
                  ( Type of argument B: <span class="type">baseType</span> )
      <span class="func">excl</span>(A,B) Exclude element B from set A
                  ( Type of argument B: <span class="type">baseType</span> )
      <span class="keywd">for</span> A <span class="keywd">range</span> B <span class="keywd">do</span>
        C
      <span class="keywd">end for</span>   Loop over all elements of a set
                  ( Type of argument A: <span class="type">baseType</span>,
                    Type of argument C: <a class="type" href="#types_proc">proc</a> )
</pre><p></p>

<a name="types_struct"><h3>5.13 struct</h3></a>
<p>
    The type <tt><a class="type" href="#types_struct">struct</a></tt> describes all structured types.
</p><pre class="tt">
    Type generators:
      <span class="keywd">new struct</span>
        <span class="keywd">var</span> <span class="type">aType</span>: name <span class="keywd">is</span> value;
        ...
      <span class="keywd">end struct</span>
                Create new structure type

      <span class="keywd">new</span> <span class="type">metaType</span> <span class="keywd">struct</span>
        <span class="keywd">var</span> <span class="type">aType</span>: name <span class="keywd">is</span> value;
        ...
      <span class="keywd">end struct</span>
                Create new structure type as subtype of <tt><span class="type">metaType</span></tt>,
                which is not a structure

      <span class="keywd">sub</span> <span class="type">metaType</span> <span class="keywd">struct</span>
        <span class="keywd">var</span> <span class="type">aType</span>: name <span class="keywd">is</span> value;
        ...
      <span class="keywd">end struct</span>
                Create new structure type as subtype of <tt><span class="type">metaType</span></tt>,
                which is a structure type. The new structure type inherits all
                elements of the structure type <tt><span class="type">metaType</span></tt>.

      <span class="keywd">var</span> <span class="type">aType</span>: name <span class="keywd">is</span> value
                Declare structure element 'name' with 'value'

    Infixoperators:
      .         Access Element of STRUCT
                  ( example.element )
      ->        Access Element of ptr STRUCT
                  ( example->element )
    Relations:
      =, &lt;>
    Functions:
      incl(A, B) Include element in MODULE
                  ( Type of argument B: <a class="type" href="#types_reference">reference</a> )
      excl(A, B) Exclude element from MODULE
                  ( Type of argument B: <a class="type" href="#types_reference">reference</a> )
</pre><p></p>

<a name="types_category"><h3>5.14 category</h3></a>
<p>
    The type <tt><a class="type" href="#types_category">category</a></tt> describes the category of a <tt><a class="type" href="#types_reference">reference</a></tt>.
  The <tt><a class="type" href="#types_category">category</a></tt> functions are defined in the library <span class="stri">"<span class="lib">category.s7i</span>"</span>.
</p><pre class="tt">
    Constants:
      SYMBOLOBJECT, DECLAREDOBJECT, FORWARDOBJECT, FWDREFOBJECT, BLOCKOBJECT,
      CALLOBJECT,MATCHOBJECT, TYPEOBJECT, FORMPARAMOBJECT, INTOBJECT,
      BIGINTOBJECT, CHAROBJECT, STRIOBJECT, BSTRIOBJECT, ARRAYOBJECT,
      HASHOBJECT, STRUCTOBJECT, CLASSOBJECT, INTERFACEOBJECT, SETOBJECT,
      FILEOBJECT, SOCKETOBJECT, LISTOBJECT, FLOATOBJECT, WINOBJECT,
      ENUMLITERALOBJECT, CONSTENUMOBJECT, VARENUMOBJECT, REFOBJECT,
      REFLISTOBJECT, EXPROBJECT, ACTOBJECT, VALUEPARAMOBJECT, REFPARAMOBJECT,
      RESULTOBJECT, LOCALVOBJECT, PROGOBJECT
    Infix operators:
      <a class="type" href="#types_category">category</a> <span class="op">conv</span> A   Conversion of <a class="type" href="#types_integer">integer</a> to <a class="type" href="#types_category">category</a>
                  ( Type of argument A: <a class="type" href="#types_integer">integer</a>,
                    <a class="type" href="#types_category">category</a> <span class="op">conv</span> ord(INTOBJECT) <b>&rArr;</b> INTOBJECT )
      <a class="type" href="#types_category">category</a> <span class="op">parse</span> A   Conversion of <a class="type" href="#types_string">string</a> to <a class="type" href="#types_category">category</a>
                  ( Type of argument A: <a class="type" href="#types_string">string</a>,
                    <a class="type" href="#types_category">category</a> <span class="op">parse</span> <span class="stri">"FLOATOBJECT"</span> <b>&rArr;</b> FLOATOBJECT,
                    <a class="type" href="#types_category">category</a> <span class="op">parse</span> <span class="stri">"does not exist"</span> <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> )
    Relations:
      <span class="op">=</span>, <span class="op">&lt;></span>
    Functions:
      <span class="func">ord</span>(A)    Ordinal number
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
      <span class="func">str</span>(A)    Conversion to <a class="type" href="#types_string">string</a>
                  ( Type of result: <a class="type" href="#types_string">string</a>,
                    str(CHAROBJECT) <b>&rArr;</b> <span class="stri">"CHAROBJECT"</span> )
    Statements:
      <span class="keywd">for</span> A <span class="keywd">range</span> B <span class="keywd">to</span> C <span class="keywd">do</span>
        D
      <span class="keywd">end for</span>   Loop over all categories from B to C
                  ( Type of argument D: <a class="type" href="#types_proc">proc</a> )
      <span class="keywd">for</span> A <span class="keywd">range</span> B <span class="keywd">downto</span> C <span class="keywd">do</span>
        D
      <span class="keywd">end for</span>   Loop over all categories from B down to C
                  ( Type of argument D: <a class="type" href="#types_proc">proc</a> )
</pre><p></p>

<a name="types_reference"><h3>5.15 reference</h3></a>
<p>
    The type <tt><a class="type" href="#types_reference">reference</a></tt> describes a reference to any
  object. The <tt><span class="type">reference</span></tt> functions are defined in
  the library <span class="stri">"<span class="lib">reference.s7i</span>"</span>.

</p><pre class="tt">
    Constants:
      NIL       Reference to no element.
    Relations:
      <span class="op">=</span>, <span class="op">&lt;></span>
    Functions:
      <span class="func">category</span>(A) Get the category of the referenced object
                  ( Type of result: <a class="type" href="#types_category">category</a>,
                    category(NIL) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> )
      <span class="func">str</span>(A)    Conversion to <a class="type" href="#types_string">string</a>
                  ( Type of result: <a class="type" href="#types_string">string</a> )
      <span class="func">getType</span>(A) Get the type of the referenced object
                  ( Type of result: <a class="type" href="#types_type">type</a>,
                    getType(NIL) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> )
      <span class="func">objNumber</span>(A) Delivers an unique number for each object
                  ( Type of result: <a class="type" href="#types_integer">integer</a>,
                    objNumber(NIL) <b>&rArr;</b> 0 )
      <span class="func">isVar</span>(A)  Reference to a variable object
                  ( Type of result: <a class="type" href="#types_boolean">boolean</a>,
                    isVar(NIL) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> )
      <span class="func">formalParams</span>(A) Gets the formal parameters of a function
                  ( Type of result: <a class="type" href="#types_ref_list">ref_list</a>,
                    formalParams(NIL) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> )
      <span class="func">localVars</span>(A) Gets the local variables of a function
                  ( Type of result: <a class="type" href="#types_ref_list">ref_list</a>,
                    localVars(NIL) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a>,
                    localVars(A) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> for category(A) &lt;> BLOCKOBJECT )
      <span class="func">localConsts</span>(A) Gets the local constants of a function
                  ( Type of result: <a class="type" href="#types_ref_list">ref_list</a>,
                    localConsts(NIL) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a>,
                    localConsts(A) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> for category(A) &lt;> BLOCKOBJECT )
      <span class="func">body</span>(A)   Gets the body of a function
                  ( body(NIL) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a>,
                    body(A) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> for category(A) &lt;> BLOCKOBJECT )
      <span class="func">resultVar</span>(A) Gets the result variable of a function
                  ( resultVar(NIL) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a>,
                    resultVar(A) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> for category(A) &lt;> BLOCKOBJECT )
      <span class="func">resultInitValue</span>(A) Gets the initialization value of the result
                         object of a function
                  ( resultInitValue(NIL) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a>,
                    resultInitValue(A) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> for category(A) &lt;> BLOCKOBJECT )
      arrayToList(A) Return the array elements as list
                  ( Type of result: <a class="type" href="#types_ref_list">ref_list</a>,
                    arrayToList(NIL) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a>,
                    arrayToList(A) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> for category(A) &lt;> ARRAYOBJECT )
      arrayMinIdx(A) Return the minimal index of an array
                  ( Type of result: <a class="type" href="#types_integer">integer</a>,
                    arrayMinIdx(NIL) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a>,
                    arrayMinIdx(A) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> for category(A) &lt;> ARRAYOBJECT )
      arrayMaxIdx(A) Return the maximal index of an array
                  ( Type of result: <a class="type" href="#types_integer">integer</a>,
                    arrayMaxIdx(NIL) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a>,
                    arrayMaxIdx(A) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> for category(A) &lt;> ARRAYOBJECT )
      structToList(A) Return the struct elements as list
                  ( Type of result: <a class="type" href="#types_ref_list">ref_list</a>,
                    structToList(NIL) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a>,
                    structToList(A) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> for category(A) &lt;> STRUCTOBJECT )
      interfaceToStruct(A) Return the struct to which the interface object points.
                  ( interfaceToStruct(NIL) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a>,
                    interfaceToStruct(A) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> for category(A) &lt;> INTERFACEOBJECT )
      <span class="func">file</span>(A)   File name of the referenced object
                  ( Type of result: <a class="type" href="#types_string">string</a>,
                    file(NIL) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> )
      <span class="func">line</span>(A)   Line number of the referenced object
                  ( Type of result: <a class="type" href="#types_integer">integer</a>,
                    line(NIL) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> )
      alloc(A)  Create a copy of the object referenced by A
                The object value of the copy is set to NULL
      getValue(A, <a class="type" href="#types_reference">reference</a>) Dereference as <a class="type" href="#types_reference">reference</a>
                  ( Type of result: <a class="type" href="#types_reference">reference</a>,
                    getValue(NIL, <a class="type" href="#types_reference">reference</a>) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a>,
                    getValue(A, <a class="type" href="#types_reference">reference</a>) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> for
                        category(A) not in {FWDREFOBJECT, REFOBJECT, REFPARAMOBJECT, RESULTOBJECT,
                        LOCALVOBJECT, ENUMLITERALOBJECT, CONSTENUMOBJECT, VARENUMOBJECT} )
      getValue(A, <a class="type" href="#types_ref_list">ref_list</a>) Dereference as <a class="type" href="#types_ref_list">ref_list</a>
                  ( Type of result: <a class="type" href="#types_ref_list">ref_list</a>,
                    getValue(NIL, <a class="type" href="#types_ref_list">ref_list</a>) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a>,
                    getValue(A, <a class="type" href="#types_ref_list">ref_list</a>) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> for
                        category(A) not in {MATCHOBJECT, CALLOBJECT, REFLISTOBJECT} )
      getValue(A, <a class="type" href="#types_integer">integer</a>) Dereference as <a class="type" href="#types_integer">integer</a>
                  ( Type of result: <a class="type" href="#types_integer">integer</a>,
                    getValue(NIL, <a class="type" href="#types_integer">integer</a>) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a>,
                    getValue(A, <a class="type" href="#types_integer">integer</a>) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> for category(A) &lt;> INTOBJECT )
      getValue(A, <a class="type" href="#types_bigInteger">bigInteger</a>) Dereference as <a class="type" href="#types_bigInteger">bigInteger</a>
                  ( Type of result: <a class="type" href="#types_bigInteger">bigInteger</a>,
                    getValue(NIL, <a class="type" href="#types_bigInteger">bigInteger</a>) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a>,
                    getValue(A, <a class="type" href="#types_bigInteger">bigInteger</a>) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> for category(A) &lt;> BIGINTOBJECT )
      getValue(A, <a class="type" href="#types_float">float</a>) Dereference as <a class="type" href="#types_float">float</a>
                  ( Type of result: <a class="type" href="#types_float">float</a>,
                    getValue(NIL, <a class="type" href="#types_float">float</a>) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a>,
                    getValue(A, <a class="type" href="#types_float">float</a>) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> for category(A) &lt;> FLOATOBJECT )
      getValue(A, <a class="type" href="#types_char">char</a>) Dereference as <a class="type" href="#types_char">char</a>
                  ( Type of result: <a class="type" href="#types_char">char</a>,
                    getValue(NIL, <a class="type" href="#types_char">char</a>) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a>,
                    getValue(A, <a class="type" href="#types_char">char</a>) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> for category(A) &lt;> CHAROBJECT )
      getValue(A, <a class="type" href="#types_string">string</a>) Dereference as <a class="type" href="#types_string">string</a>
                  ( Type of result: <a class="type" href="#types_string">string</a>,
                    getValue(NIL, <a class="type" href="#types_string">string</a>) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a>,
                    getValue(A, <a class="type" href="#types_string">string</a>) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> for category(A) &lt;> STRIOBJECT )
      getValue(A, <a class="type" href="#types_set">bitset</a>) Dereference as <a class="type" href="#types_set">bitset</a>
                  ( Type of result: <a class="type" href="#types_set">bitset</a>,
                    getValue(NIL, <a class="type" href="#types_set">bitset</a>) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a>,
                    getValue(A, <a class="type" href="#types_set">bitset</a>) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> for category(A) &lt;> SETOBJECT )
      getValue(A, <span class="type">clib_file</span>) Dereference as <span class="type">clib_file</span>
                  ( Type of result: <span class="type">clib_file</span>,
                    getValue(NIL, <span class="type">clib_file</span>) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a>,
                    getValue(A, <span class="type">clib_file</span>) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> for category(A) &lt;> FILEOBJECT )
      getValue(A, <a class="type" href="#types_program">program</a>) Dereference as <a class="type" href="#types_program">program</a>
                  ( Type of result: <a class="type" href="#types_program">program</a>,
                    getValue(NIL, <a class="type" href="#types_program">program</a>) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a>,
                    getValue(A, <a class="type" href="#types_program">program</a>) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> for category(A) &lt;> PROGOBJECT )
      getValue(A, <font color=red>ACTION</font>) Dereference as <font color=red>ACTION</font>
                  ( Type of result: <font color=red>ACTION</font>,
                    getValue(NIL, <font color=red>ACTION</font>) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a>,
                    getValue(A, <font color=red>ACTION</font>) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> for category(A) &lt;> ACTOBJECT )
      getValue(A, <a class="type" href="#types_type">type</a>) Dereference as <a class="type" href="#types_type">type</a>
                  ( Type of result: <a class="type" href="#types_type">type</a>,
                    getValue(NIL, <a class="type" href="#types_type">type</a>) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a>,
                    getValue(A, <a class="type" href="#types_type">type</a>) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> for category(A) &lt;> TYPEOBJECT )
      <span class="func">compare</span>(A, B) Compare function
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
      <span class="func">hashCode</span>(A) Hash function
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
    Statements:
      <span class="func">setVar</span>(A, B) Set var flag of referenced object A to B
                  ( Type of argument B: <a class="type" href="#types_boolean">boolean</a>,
                    setVar(NIL, B) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> )
      <span class="func">setCategory</span>(A, B) Set the category of the referenced object A to B
                  ( Type of argument B: <a class="type" href="#types_category">category</a>,
                    setCategory(NIL, B) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> )
      <span class="func">setType</span>(A, B) Set the type of the referenced object A to B
                  ( Type of argument B: <a class="type" href="#types_type">type</a>,
                    setType(NIL, B) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> )
      setValue(A, B) Set the value of the referenced object A to B
                  ( Type of argument B: <a class="type" href="#types_ref_list">ref_list</a> )
      setFormalParams(A, B) Set the formal parameters of a function
                  ( Type of argument B: <a class="type" href="#types_ref_list">ref_list</a>,
                    setFormalParams(NIL, B) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> )
</pre><p></p>

<a name="types_ref_list"><h3>5.16 ref_list</h3></a>
<p>
    The type <tt><a class="type" href="#types_ref_list">ref_list</a></tt> describes a list of <tt><a class="type" href="#types_reference">reference</a></tt> objects.
  The <tt><span class="type">ref_list</span></tt> functions are defined in
  the library <span class="stri">"<span class="lib">ref_list.s7i</span>"</span>.
</p><pre class="tt">
    Constants:
      <a class="type" href="#types_ref_list">ref_list</a>.EMPTY  Empty reference list.
    Infix operators:
      <span class="op">&amp;</span>         Ref_list list concatenation
      A <span class="op">in</span> B    Is element in ref_list
                  ( Type of argument A: <a class="type" href="#types_reference">reference</a>,
                    Type of result: <a class="type" href="#types_boolean">boolean</a> )
      A <span class="op">not in</span> B  Is element not in ref_list
                  ( Type of argument A: <a class="type" href="#types_reference">reference</a>,
                    Type of result: <a class="type" href="#types_boolean">boolean</a> )
    Indices:
      <span class="op">[</span> A ]     Access one ref_list element
                  ( Type of argument A: <a class="type" href="#types_integer">integer</a>,
                    Type of result: <a class="type" href="#types_reference">reference</a>,
                    A[1]<b>&rArr;</b>First element,
                    A[length(A)]<b>&rArr;</b>Last element,
                    A[0] <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a>,
                    A[succ(length(A))] <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> )
      <span class="op">[</span> A .. B ]  Access a sub list
                  ( Type of arguments A and B: <a class="type" href="#types_integer">integer</a> )
      <span class="op">[</span> A .. ]  Access a sub list beginning at position A
                  ( Type of argument A: <a class="type" href="#types_integer">integer</a> )
      <span class="op">[</span> .. A ]  Access a sub list ending at position A
                  ( Type of argument A: <a class="type" href="#types_integer">integer</a> )
    Relations:
      <span class="op">=</span>, <span class="op">&lt;></span>
    Functions:
      <span class="func">length</span>(A) Length of ref_list
                  ( Type of result: <a class="type" href="#types_integer">integer</a>,
                    length(<a class="type" href="#types_ref_list">ref_list</a>.EMPTY) <b>&rArr;</b> 0 )
      <span class="func">make_list</span>(A) Create ref_list with element A
                  ( Type of argument A: <a class="type" href="#types_reference">reference</a> )
      <span class="func">pos</span>(A,B)  First position of <a class="type" href="#types_reference">reference</a> B in <a class="type" href="#types_ref_list">ref_list</a> A
                  ( Type of argument B: <a class="type" href="#types_reference">reference</a>,
                    Type of result: <a class="type" href="#types_integer">integer</a> )
      <span class="func">pos</span>(A,B,C) First position of <a class="type" href="#types_reference">reference</a> B in <a class="type" href="#types_ref_list">ref_list</a> A
                 The search starts at position C of <a class="type" href="#types_ref_list">ref_list</a> A
                  ( Type of argument B: <a class="type" href="#types_reference">reference</a>,
                    Type of argument C: <a class="type" href="#types_integer">integer</a>,
                    Type of result: <a class="type" href="#types_integer">integer</a> )
      incl(A, B) Include element in list
                  ( Type of argument B: <a class="type" href="#types_reference">reference</a> )
      excl(A, B) Exclude element from list
                  ( Type of argument B: <a class="type" href="#types_reference">reference</a> )
    Statements:
      A <span class="op">&amp;:=</span> B   Append B to A
                  ( A &amp;:= B <b>&rArr;</b> A := A &amp; B )
      A <span class="op">@:=</span> [B] C  Assign C to element B of ref_list A
                  ( Type of argument B: <a class="type" href="#types_integer">integer</a>,
                    Type of argument C: <a class="type" href="#types_reference">reference</a>,
                    A @:= [B] C <b>&rArr;</b>
                        A := A[..pred(B)] &amp; make_list(C) &amp; A[succ(B)..],
                    A @:= [0] C <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a>,
                    A @:= [succ(length(A))] C <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> )
      <span class="keywd">for</span> A <span class="keywd">range</span> B <span class="keywd">do</span>
        C
      <span class="keywd">end</span> <span class="keywd">for</span>   Loop over all elements of a ref_list
                  ( Type of argument A: <a class="type" href="#types_reference">reference</a>,
                    Type of argument C: <a class="type" href="#types_proc">proc</a> )
</pre><p></p>

<a name="types_program"><h3>5.17 program</h3></a>
<p>
    The type <tt><a class="type" href="#types_program">program</a></tt> describes a Seed7 program.
  The <tt><a class="type" href="#types_program">program</a></tt> functions are defined in the library <span class="stri">"<span class="lib">progs.s7i</span>"</span>.
</p><pre class="tt">
    Constants:
      <a class="type" href="#types_program">program</a>.EMPTY  Empty program.
    Relations:
      <span class="op">=</span>, <span class="op">&lt;></span>
    Functions:
      <span class="func">parseFile</span>(A)  Parse the file with the name A
                  ( Type of argument A: <a class="type" href="#types_string">string</a> )
      <span class="func">parseStri</span>(A)  Parse the string A
                  ( Type of argument A: <a class="type" href="#types_string">string</a> )
      <span class="func">evaluate</span>(A, B)  Evaluate the expression B which is part of program A
                  ( Type of result: <a class="type" href="#types_reference">reference</a>,
                    Type of argument B: <a class="type" href="#types_reference">reference</a> )
      <span class="func">sysVar</span>(A, B)  Return a reference of the system var B of program A
                  ( Type of result: <a class="type" href="#types_reference">reference</a>,
                    Type of argument B: <a class="type" href="#types_string">string</a> )
      <span class="func">errorCount</span>(A)  Number of errors in the program A
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
      <span class="func">globalObjects</span>(A)  List of global defined objects in the program A
                  ( Type of result: <a class="type" href="#types_ref_list">ref_list</a> )
      <span class="func">syobject</span>(A, B)  Return object with name B in program A
                  ( Type of result: <a class="type" href="#types_reference">reference</a>,
                    Type of argument B: <a class="type" href="#types_string">string</a> )
      <span class="func">match</span>(A, B)  Return object from program A which matches B
                  ( Type of result: <a class="type" href="#types_reference">reference</a>,
                    Type of argument B: <a class="type" href="#types_ref_list">ref_list</a> )
    Statements:
      <span class="func">execute</span>(A) Execute the program referred by A
</pre><p></p>

<a name="types_ptr"><h3>5.18 ptr</h3></a>
<p>
    The type <tt><a class="type" href="#types_ptr">ptr</a> <span class="type">baseType</span></tt> describes a pointer to an object
  of a <tt><span class="type">baseType</span></tt>. With
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_type">type</a>: ptrType <span class="keywd">is</span> <a class="type" href="#types_ptr">ptr</a> <span class="type">baseType</span>;
</pre><p>
  a new pointer type <tt><span class="type">ptrType</span></tt> is declared.
</p><pre class="tt">
    Constants:
      <span class="type">ptrType</span>.NIL   Reference to no element
    Prefix operators:
      &amp;         Address of
                  ( Type of operand: <span class="type">baseType</span> )
    Postfix operators:
      ^         Dereference
                  ( Type of result: <span class="type">baseType</span> )
    Infix operators:
      <span class="type">ptrType</span> <font color=blue>conv</font> A  Conversion from <a class="type" href="#types_reference">reference</a> A to <span class="type">ptrType</span>
      <a class="type" href="#types_reference">reference</a> <font color=blue>conv</font> A  Conversion from <span class="type">ptrType</span> A to <a class="type" href="#types_reference">reference</a>
    Relations:
      =, &lt;>
    Functions:
      base_type(<span class="type">ptrType</span>)  Gets the <span class="type">baseType</span> of a <span class="type">ptrType</span>
                  ( Type of argument <span class="type">ptrType</span>: <a class="type" href="#types_type">type</a> )
</pre><p></p>

<a name="types_ENUMERATION"><h3>5.19 ENUMERATION</h3></a>
<p>
    With
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_type">type</a>: enumType <span class="keywd">is new enum</span>
    enum_literal1, enum_literal2
  <span class="keywd">end enum</span>;
</pre><p>
  a new enumeration type is declared. The values of this type are:
</p><pre class="box">
    enum_literal1 and enum_literal2
</pre><p>
  For a enumeration type only few operations are predefined.
  Additional operations must be defined separately. So it is
  necessary to define the functions <tt><span class="func">str</span></tt> and <tt><font color=blue>parse</font></tt> in order to
  do I/O for a new enumeration type.
</p><pre class="tt">
    Infix operators:
      <span class="type">enumType</span> <span class="op">conv</span> A  Conversion from <a class="type" href="#types_integer">integer</a> A to <span class="type">enumType</span>
                  ( Type of argument A: <a class="type" href="#types_integer">integer</a>,
                    <span class="type">enumType</span> <span class="op">conv</span> 0 <b>&rArr;</b> enum_literal1 )
      <a class="type" href="#types_integer">integer</a> <span class="op">conv</span> A   Conversion from <span class="type">enumType</span> A to <a class="type" href="#types_integer">integer</a>
                  ( Type of result: <a class="type" href="#types_integer">integer</a>,
                    <a class="type" href="#types_integer">integer</a> <span class="op">conv</span> enum_literal1 <b>&rArr;</b> 0 )
    Relations:
      =, &lt;>, &lt;, &lt;=, >, >=
    Functions:
      ord(A)    Ordinal number
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
      succ(A)   Successor
                  ( succ(A) <b>&rArr;</b> enumType <span class="op">conv</span>(succ(ord(A))) )
      pred(A)   Predecessor
                  ( pred(A) <b>&rArr;</b> enumType <span class="op">conv</span>(pred(ord(A))) )
      compare(A, B) Compare function
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
      hashCode(A) Hash function
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
    Statements:
      incr(A)   Increment
                  ( incr(A) <b>&rArr;</b> A:=succ(A) )
      decr(A)   Decrement
                  ( decr(A) <b>&rArr;</b> A:=pred(A) )
</pre><p></p>

<a name="types_color"><h3>5.20 color</h3></a>
<p>
    The type <tt><span class="type">color</span></tt> describes colors. The <tt><span class="type">color</span></tt>
  functions are defined in the library <span class="stri">"<span class="lib">color.s7i</span>"</span>.
</p><pre class="tt">
    Elements:
      <span class="keywd">var</span> <a class="type" href="#types_integer">integer</a>: red_part <span class="keywd">is</span> 0;
      <span class="keywd">var</span> <a class="type" href="#types_integer">integer</a>: green_part <span class="keywd">is</span> 0;
      <span class="keywd">var</span> <a class="type" href="#types_integer">integer</a>: blue_part <span class="keywd">is</span> 0;
    Constants:
      black         is color(0, 0, 0);
      dark_red      is color(32768, 0, 0);
      dark_green    is color(0, 32768, 0);
      brown         is color(32768, 16384, 0);
      dark_blue     is color(0, 0, 32768);
      dark_magenta  is color(32768, 0, 32768);
      dark_cyan     is color(0, 65535, 65535);
      light_gray    is color(49152, 49152, 49152);
      dark_gray     is color(16384, 16384, 16384);
      light_red     is color(65535, 0, 0);
      light_green   is color(0, 65535, 0);
      yellow        is color(65535, 65535, 0);
      light_blue    is color(0, 0, 65535);
      light_magenta is color(65535, 0, 65535);
      light_cyan    is color(32768, 65535, 65535);
      white         is color(65535, 65535, 65535);
      orange        is color(65535, 32768, 0);
      amber         is color(49152, 32768, 16384);
      pink          is color(65535, 32768, 32768);
    Infix operators:
      <span class="op">+</span>         Add two colors in an additive color system
    Relations:
      <span class="op">=</span>, <span class="op">&lt;></span>
    Functions:
      <span class="func">color</span>(R,G,B) Creates a color from Red, Green and Blue
                  ( Type of argument R: <a class="type" href="#types_integer">integer</a>,
                    Type of argument G: <a class="type" href="#types_integer">integer</a>,
                    Type of argument B: <a class="type" href="#types_integer">integer</a> )
      <span class="func">gray</span>(BR)  Create a gray color value from BR
                  ( Type of argument BR: <a class="type" href="#types_integer">integer</a> )
      <span class="func">compare</span>(A, B) Compare function
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
      <span class="func">hashCode</span>(A) Hash function
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
</pre><p></p>

<a name="types_time"><h3>5.21 time</h3></a>
<p>
    The type <tt><span class="type">time</span></tt> describes times and dates.
  For dates the proleptic Gregorian calendar is used (which assumes
  that the Gregorian calendar was even in effect at dates preceding
  its official introduction). This convention is used according to
  ISO 8601 which also defines that positive and negative years exist
  and that the year preceding 1 is 0. Time is measured in hours,
  minutes, seconds and micro seconds. Additionally information about
  the difference to UTC and a flag indicating daylight saving time
  is maintained also. The <tt><span class="type">time</span></tt> functions are defined in the
  library <span class="stri">"<span class="lib">time.s7i</span>"</span>.
</p><pre class="tt">
    Elements:
      <span class="keywd">var</span> <a class="type" href="#types_integer">integer</a>: year <span class="keywd">is</span> 0;
      <span class="keywd">var</span> <a class="type" href="#types_integer">integer</a>: month <span class="keywd">is</span> 1;
      <span class="keywd">var</span> <a class="type" href="#types_integer">integer</a>: day <span class="keywd">is</span> 1;
      <span class="keywd">var</span> <a class="type" href="#types_integer">integer</a>: hour <span class="keywd">is</span> 0;
      <span class="keywd">var</span> <a class="type" href="#types_integer">integer</a>: minute <span class="keywd">is</span> 0;
      <span class="keywd">var</span> <a class="type" href="#types_integer">integer</a>: second <span class="keywd">is</span> 0;
      <span class="keywd">var</span> <a class="type" href="#types_integer">integer</a>: micro_second <span class="keywd">is</span> 0;
    Infix operators:
      <a class="type" href="#types_time">time</a> <span class="op">parse</span> A   Conversion of <a class="type" href="#types_string">string</a> to <a class="type" href="#types_time">time</a>
                  ( Type of argument A: <a class="type" href="#types_string">string</a>,
                    <a class="type" href="#types_time">time</a> <span class="op">parse</span> <span class="stri">"2005-02-28 12:00:01"</span> <b>&rArr;</b> 2005-02-28 12:00:01,
                    <a class="type" href="#types_time">time</a> <span class="op">parse</span> <span class="stri">"2005-02-29 12:00:01"</span> <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> )
    Relations:
      <span class="op">=</span>, <span class="op">&lt;></span>, <span class="op">&lt;</span>, <span class="op">&lt;=</span>, <span class="op">></span>, <span class="op">>=</span>
    Functions:
      <span class="func">time</span>(NOW)  Gets the current time
      <span class="func">str</span>(A)    Conversion to <a class="type" href="#types_string">string</a>
                  ( Type of result: <a class="type" href="#types_string">string</a> )
      <span class="func">strDate</span>(A)  Conversion of the date to <a class="type" href="#types_string">string</a>
                  ( Type of result: <a class="type" href="#types_string">string</a> )
      <span class="func">strTime</span>(A)  Conversion of the daytime to <a class="type" href="#types_string">string</a>
                  ( Type of result: <a class="type" href="#types_string">string</a> )
      strTimeZone(A)  Conversion of the time zone to <a class="type" href="#types_string">string</a>
                  ( Type of result: <a class="type" href="#types_string">string</a> )
      <span class="func">truncToSecond</span>(A)  Truncate a time to a second
      <span class="func">truncToMinute</span>(A)  Truncate a time to a minute
      <span class="func">truncToHour</span>(A)  Truncate a time to a hour
      <span class="func">truncToDay</span>(A)  Truncate a time to a day
      <span class="func">truncToMonth</span>(A)  Truncate a time to a month
      <span class="func">truncToYear</span>(A)  Truncate a time to a year
      <span class="func">isLeapYear</span>(A)  Determine if a given year is a leap year
                  ( Type of argument A: <a class="type" href="#types_integer">integer</a> )
                  ( Type of result: <a class="type" href="#types_boolean">boolean</a> )
      <span class="func">daysInYear</span>(Y)  Calculate the number of days in a year
                  ( Type of argument Y: <a class="type" href="#types_integer">integer</a>,
                    Type of result: <a class="type" href="#types_integer">integer</a> )
      <span class="func">daysInMonth</span>(Y, M)  Calculate the number of days in a month
                  ( Type of argument Y: <a class="type" href="#types_integer">integer</a>,
                    Type of argument M: <a class="type" href="#types_integer">integer</a>,
                    Type of result: <a class="type" href="#types_integer">integer</a> )
      <span class="func">daysInMonth</span>(A)  Calculate the number of days in a month
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
      <span class="func">dayOfWeek</span>(A)  Day of the week with Monday as 1
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
      <span class="func">dayOfYear</span>(A)  Day of the year with 1 January as 1
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
      <span class="func">weekOfYear</span>(Y, D)  Compute the week number of a year (0 to 53).
                    According to ISO 8601: Week number 1 of
                    every year contains the 4. of january.
                  ( Type of argument Y: <a class="type" href="#types_integer">integer</a>,
                    Type of argument D: <a class="type" href="#types_integer">integer</a>,
                    Type of result: <a class="type" href="#types_integer">integer</a> )
      <span class="func">weekOfYear</span>(A)  Compute the week number of a year (0 to 53).
                    According to ISO 8601: Week number 1 of
                    every year contains the 4. of january.
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
      <span class="func">weekDateYear</span>(A)  Compute the year of the ISO 8601 week date
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
      <span class="func">weekDateWeek</span>(A)  Compute the week of the ISO 8601 week date
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
      <span class="func">toUTC</span>(A)  Conversion to Coordinated Universal Time (UTC)
      <span class="func">julianDayNumber</span>(A)  Number of days that have elapsed since
                January 1, 4713 BC in the proleptic Julian calendar
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
      <span class="func">julianDayNumToTime</span>(A)  Convert julian day number to time
                  ( Type of argument A: <a class="type" href="#types_integer">integer</a> )
      <span class="func">timestamp1970</span>(A)  Time expressed in seconds since the
                Unix Epoch (1970-01-01 00:00:00 UTC)
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
      <span class="func">timestamp1970ToTime</span>(A)  Convert a timestamp into a time from
                the local time zone
                  ( Type of argument A: <a class="type" href="#types_integer">integer</a> )
      <span class="func">compare</span>(A, B)  Compare function
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
      <span class="func">hashCode</span>(A)  Hash function
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
    Statements:
      <span class="func">await</span>(A)  Wait until the given time
</pre><p></p>

<a name="types_duration"><h3>5.22 duration</h3></a>
<p>
    The type <tt><span class="type">duration</span></tt> describes time and date durations.
  The <tt><span class="type">duration</span></tt> functions are defined in the library
  <span class="stri">"<span class="lib">duration.s7i</span>"</span>.
</p><pre class="tt">
    Prefix operators:
      <span class="op">+</span>         Identity
      <span class="op">-</span>         Change sign
    Infix operators:
      <span class="op">+</span>         Add two durations
      <span class="op">-</span>         Subtract two durations
      <span class="op">*</span>         Multiply a duration by an <a class="type" href="#types_integer">integer</a>
                  ( Type of left operand: <a class="type" href="#types_integer">integer</a> )
      <span class="op">*</span>         Multiply a duration by an <a class="type" href="#types_integer">integer</a>
                  ( Type of right operand: <a class="type" href="#types_integer">integer</a> )
      <span class="op">+</span>         Add a duration to a time
                  ( Type of left operand: <a class="type" href="#types_time">time</a>,
                    Type of result: <a class="type" href="#types_time">time</a> )
      <span class="op">-</span>         Subtract a duration from a time
                  ( Type of left operand: <a class="type" href="#types_time">time</a>,
                    Type of result: <a class="type" href="#types_time">time</a> )
      <span class="op">-</span>         Subtract two times
                  ( Type of left operand: <a class="type" href="#types_time">time</a>,
                    Type of right operand: <a class="type" href="#types_time">time</a> )
      <a class="type" href="#types_duration">duration</a> <span class="op">parse</span> A   Conversion of <a class="type" href="#types_string">string</a> to <a class="type" href="#types_duration">duration</a>
                  ( Type of argument A: <a class="type" href="#types_string">string</a>,
                    <a class="type" href="#types_duration">duration</a> <span class="op">parse</span> <span class="stri">"0-02-28 12:00:01"</span> <b>&rArr;</b> 0-02-28 12:00:01,
                    <a class="type" href="#types_duration">duration</a> <span class="op">parse</span> <span class="stri">"0-13-29 12:00:01"</span> <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> )
    Relations:
      <span class="op">=</span>, <span class="op">&lt;></span>, <span class="op">&lt;</span>, <span class="op">&lt;=</span>, <span class="op">></span>, <span class="op">>=</span>
    Functions:
      <span class="func">getYears</span>(A)  Obtains the years of a <a class="type" href="#types_duration">duration</a>
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
      <span class="func">getMonths</span>(A) Obtains the months of a <a class="type" href="#types_duration">duration</a>
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
      <span class="func">getDays</span>(A)   Obtains the days of a <a class="type" href="#types_duration">duration</a>
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
      <span class="func">getHours</span>(A)  Obtains the hours of a <a class="type" href="#types_duration">duration</a>
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
      <span class="func">getMinutes</span>(A) Obtains the minutes of a <a class="type" href="#types_duration">duration</a>
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
      <span class="func">getSeconds</span>(A) Obtains the seconds of a <a class="type" href="#types_duration">duration</a>
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
      <span class="func">getMicroSeconds</span>(A)  Obtains the micro seconds of a <a class="type" href="#types_duration">duration</a>
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
      <span class="func">toYears</span>(A)  Return the <a class="type" href="#types_duration">duration</a> in years
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
      <span class="func">toMonths</span>(A) Return the <a class="type" href="#types_duration">duration</a> in months
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
      <span class="func">toDays</span>(A)   Return the <a class="type" href="#types_duration">duration</a> in days
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
      <span class="func">toHours</span>(A)  Return the <a class="type" href="#types_duration">duration</a> in hours
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
      <span class="func">toMinutes</span>(A) Return the <a class="type" href="#types_duration">duration</a> in minutes
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
      <span class="func">toSeconds</span>(A) Return the <a class="type" href="#types_duration">duration</a> in seconds
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
      <span class="func">toMicroSeconds</span>(A)  Return the <a class="type" href="#types_duration">duration</a> in micro seconds
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
      <span class="func">str</span>(A)    Conversion to <a class="type" href="#types_string">string</a>
                  ( Type of result: <a class="type" href="#types_string">string</a> )
      <span class="func">compare</span>(A, B) Compare function
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
      <span class="func">hashCode</span>(A) Hash function
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
    Statements:
      A <span class="op">+:=</span> B   Increment A by B
                  ( A <span class="op">+:=</span> B <b>&rArr;</b> A := A <span class="op">+</span> B )
      A <span class="op">-:=</span> B   Decrement A by B
                  ( A <span class="op">-:=</span> B <b>&rArr;</b> A := A <span class="op">-</span> B )
      A <span class="op">+:=</span> B   Increment <a class="type" href="#types_time">time</a> A by B
                  ( Type of argument A: <a class="type" href="#types_time">time</a>,
                    A <span class="op">+:=</span> B <b>&rArr;</b> A := A <span class="op">+</span> B )
      A <span class="op">-:=</span> B   Decrement <a class="type" href="#types_time">time</a> A by B
                  ( Type of argument A: <a class="type" href="#types_time">time</a>,
                    A <span class="op">-:=</span> B <b>&rArr;</b> A := A <span class="op">-</span> B )
      wait(A)   Wait for given duration
</pre><p>
  For the operations <tt><span class="op">-</span></tt> (negate a <a class="type" href="#types_duration">duration</a>) and
  <tt><span class="op">-</span></tt> (subtract two <a class="type" href="#types_time">time</a> values) holds:</p><pre class="box">
    (tim1 <span class="op">-</span> tim2) <span class="op">=</span> <span class="op">-</span> (tim2 <span class="op">-</span> tim1)
</pre><p>
  For the operations <tt><span class="op">+</span></tt> (add a <a class="type" href="#types_duration">duration</a> to a <a class="type" href="#types_time">time</a>) and
  <tt><span class="op">-</span></tt> (subtract two <a class="type" href="#types_time">time</a> values) holds:</p><pre class="box">
    tim2 <span class="op">+</span> (tim1 <span class="op">-</span> tim2) <span class="op">=</span> tim1
</pre><p>
  For the operations <tt><span class="op">-</span></tt> (subtract a <a class="type" href="#types_duration">duration</a> from a <a class="type" href="#types_time">time</a>) and
  <tt><span class="op">-</span></tt> (subtract two <a class="type" href="#types_time">time</a> values) holds:</p><pre class="box">
    tim1 <span class="op">-</span> (tim1 <span class="op">-</span> tim2) <span class="op">=</span> tim2
</pre><p></p>

<a name="types_file"><h3>5.23 file</h3></a>
<p>
    The type <tt><span class="type">file</span></tt> is the interface type for sequential files.
  The <tt><span class="type">file</span></tt> functions are defined in the library <span class="stri">"<span class="lib">file.s7i</span>"</span>.
</p><pre class="tt">
    Variables:
      <span class="var">STD_NULL</span>  Standard null file
      <span class="var">STD_IN</span>    Standard input of the operating system
      <span class="var">STD_OUT</span>   Standard output of the operating system
      <span class="var">STD_ERR</span>   Standard error output of the operating system
      <span class="var">IN</span>        Standard input file used for file input
                  operations when no file is specified
                  ( <span class="var">IN</span> is initialized with <span class="var">STD_IN</span> )
      <span class="var">OUT</span>       Standard output file used for file output
                  operations when no file is specified
                  ( <span class="var">OUT</span> is initialized with <span class="var">STD_OUT</span> )
    Relations:
      =, &lt;>
    Functions:
      <span class="func">open</span>(A, B) Open external <a class="type" href="#types_file">file</a>
                  ( Type of argument A: <a class="type" href="#types_string">string</a>,
                    Type of argument B: <a class="type" href="#types_string">string</a>,
                    Type of result: <a class="type" href="#types_file">file</a>,
                    Returns STD_NULL if open was not
                    possible )
      <span class="func">open_utf8</span>(A, B) Open external UTF-8 <a class="type" href="#types_file">file</a>
                  ( Type of argument A: <a class="type" href="#types_string">string</a>,
                    Type of argument B: <a class="type" href="#types_string">string</a>,
                    Type of result: <a class="type" href="#types_file">file</a>,
                    Returns STD_NULL if open was not
                    possible )
      <span class="func">open_utf16</span>(A, B) Open external UTF-16 <a class="type" href="#types_file">file</a>
                  ( Type of argument A: <a class="type" href="#types_string">string</a>,
                    Type of argument B: <a class="type" href="#types_string">string</a>,
                    Type of result: <a class="type" href="#types_file">file</a>,
                    Returns STD_NULL if open was not
                    possible )
      <span class="func">popen</span>(A, B) Open a pipe to a process
                  ( Type of argument A: <a class="type" href="#types_string">string</a>,
                    Type of argument B: <a class="type" href="#types_string">string</a>,
                    Type of result: <a class="type" href="#types_file">file</a>,
                    Returns STD_NULL if popen was not
                    possible )
      <span class="func">popen8</span>(A, B) Open a UTF-8 pipe to a process
                  ( Type of argument A: <a class="type" href="#types_string">string</a>,
                    Type of argument B: <a class="type" href="#types_string">string</a>,
                    Type of result: <a class="type" href="#types_file">file</a>,
                    Returns STD_NULL if popen8 was not
                    possible )
      <span class="func">openInetSocket</span>(port) Open local Internet client socket
                  ( Type of argument port: <a class="type" href="#types_integer">integer</a>,
                    Type of result: <a class="type" href="#types_file">file</a>,
                    Returns STD_NULL if open was not
                    possible )
      <span class="func">openInetSocket</span>(addr, port) Open Internet client socket
                  ( Type of argument addr: <a class="type" href="#types_string">string</a>,
                    Type of argument port: <a class="type" href="#types_integer">integer</a>,
                    Type of result: <a class="type" href="#types_file">file</a>,
                    Returns STD_NULL if open was not
                    possible )
      <span class="func">length</span>(A) Length of <a class="type" href="#types_file">file</a> A
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
      <span class="func">tell</span>(A)   Return the actual <a class="type" href="#types_file">file</a> position
                  ( Type of argument: <a class="type" href="#types_file">file</a>,
                    The first position in the file is 1 )
      <span class="func">getc</span>(A)   Get one character from <a class="type" href="#types_file">file</a> A
                  ( Type of result: <a class="type" href="#types_char">char</a> )
      <span class="func">gets</span>(A, B) Get <a class="type" href="#types_string">string</a> with maximum length B from <a class="type" href="#types_file">file</a> A
                  ( Type of argument A: <a class="type" href="#types_integer">integer</a>,
                    Type of argument B: <a class="type" href="#types_file">file</a>,
                    Type of result: <a class="type" href="#types_string">string</a>,
                    gets(A, -1) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> )
      <span class="func">getwd</span>(A)  Get one word from <a class="type" href="#types_file">file</a> A
                  ( Type of result: <a class="type" href="#types_string">string</a> )
      <span class="func">getln</span>(A)  Get one line from <a class="type" href="#types_file">file</a> A
                  ( Type of result: <a class="type" href="#types_string">string</a> )
      eoln(A)   End of line
                  ( Type of result: <a class="type" href="#types_boolean">boolean</a> )
      <span class="func">hasNext</span>(A) A call of getc does not return the EOF character
                  ( Type of result: <a class="type" href="#types_boolean">boolean</a> )
      <span class="func">eof</span>(A)    End of file
                  ( Type of result: <a class="type" href="#types_boolean">boolean</a> )
      <span class="func">compare</span>(A, B) Compare function
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
      <span class="func">hashCode</span>(A) Hash function
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
    Statements:
      <span class="func">write</span>(A, B) Write <a class="type" href="#types_string">string</a> B to <a class="type" href="#types_file">file</a> A
                  ( Type of argument B: <a class="type" href="#types_string">string</a> )
      <span class="func">writeln</span>(A) Write a new line to <a class="type" href="#types_file">file</a> A
      <span class="func">writeln</span>(A, B) Write <a class="type" href="#types_string">string</a> B and new line to <a class="type" href="#types_file">file</a> A
                  ( Type of argument B: <a class="type" href="#types_string">string</a> )
      <span class="func">read</span>(A, B) Read a word from <a class="type" href="#types_file">file</a> A into <a class="type" href="#types_string">string</a> B
                  ( Type of right operand: <a class="type" href="#types_string">string</a> )
      <span class="func">readln</span>(A)  Read a line from <a class="type" href="#types_file">file</a> A
      <span class="func">readln</span>(A, B) Read a line from <a class="type" href="#types_file">file</a> A into the <a class="type" href="#types_string">string</a> B
                  ( Type of right operand: <a class="type" href="#types_string">string</a> )
      backSpace(A) Write backspace to <a class="type" href="#types_file">file</a> A
      <span class="func">close</span>(A)  Close <a class="type" href="#types_file">file</a> A
      <span class="func">flush</span>(A)  Flush <a class="type" href="#types_file">file</a> A
      <span class="func">seek</span>(A, B) Set actual file position of <a class="type" href="#types_file">file</a> A to B
                  ( Type of argument B: <a class="type" href="#types_integer">integer</a>,
                    seek(A, 1) <b>&rArr;</b> Set to file begin,
                    seek(A, length(A)) <b>&rArr;</b> Set to last position,
                    seek(A, length(A) + 1) <b>&rArr;</b> Set to end of file,
                    seek(A, 0) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> )
</pre><p></p>

<a name="types_text"><h3>5.24 text</h3></a>
<p>
    The type <tt><span class="type">text</span></tt> describes two dimensional files.
  The <tt><span class="type">text</span></tt> functions are defined in the library <span class="stri">"<span class="lib">text.s7i</span>"</span>.
</p><pre class="tt">
    Relations:
      =, &lt;>
    Functions:
      <span class="func">open_window</span>(F, A, B, C, D) Open a <a class="type" href="#types_text">text</a>
                  ( Type of argument A: <a class="type" href="#types_integer">integer</a>,
                    Type of argument B: <a class="type" href="#types_integer">integer</a>,
                    Type of argument C: <a class="type" href="#types_integer">integer</a>,
                    Type of argument D: <a class="type" href="#types_integer">integer</a> )
      <span class="func">height</span>(A) Height of the <a class="type" href="#types_text">text</a>
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
      <span class="func">width</span>(A)  Width of the <a class="type" href="#types_text">text</a>
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
      <span class="func">line</span>(A)   Current line of the <a class="type" href="#types_text">text</a>
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
      <span class="func">column</span>(A) Current column of the <a class="type" href="#types_text">text</a>
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
    Statements:
      <span class="func">write</span>(A, B) Write <a class="type" href="#types_string">string</a> B to <a class="type" href="#types_text">text</a> A
                  ( Type of argument B: <a class="type" href="#types_string">string</a> )
      <span class="func">writeln</span>(A) Write a new line to <a class="type" href="#types_text">text</a> A
      <span class="func">writeln</span>(A, B) Write <a class="type" href="#types_string">string</a> B and new line to <a class="type" href="#types_text">text</a> A
                  ( Type of argument B: <a class="type" href="#types_string">string</a> )
      <span class="func">read</span>(A, B) Read a word from <a class="type" href="#types_text">text</a> A into <a class="type" href="#types_string">string</a> B
                  ( Type of right operand: <a class="type" href="#types_string">string</a> )
      <span class="func">readln</span>(A)  Read a line from <a class="type" href="#types_text">text</a> A
      <span class="func">readln</span>(A, B) Read a line from <a class="type" href="#types_text">text</a> A into the <a class="type" href="#types_string">string</a> B
                  ( Type of right operand: <a class="type" href="#types_string">string</a> )
      backSpace(A) Write backspace to <a class="type" href="#types_text">text</a> A
      <span class="func">close</span>(A)  Close <a class="type" href="#types_text">text</a> A
      <span class="func">flush</span>(A)  Flush <a class="type" href="#types_text">text</a> A
      <span class="func">clear</span>(A)  Clear the window
      <span class="func">clear</span>(A, UP, LO, LE, RI)  Clear an area of the window
                  ( Type of argument UP: <a class="type" href="#types_integer">integer</a>
                    Type of argument LO: <a class="type" href="#types_integer">integer</a>
                    Type of argument LE: <a class="type" href="#types_integer">integer</a>
                    Type of argument RI: <a class="type" href="#types_integer">integer</a> )
      v_scroll(A) Scroll the window vertical
      h_scroll(A) Scroll the window horizontal
      <span class="func">color</span>(A, B) Set foreground color of the <a class="type" href="#types_text">text</a> A
                  ( Type of argument B: <a class="type" href="#types_color">color</a> )
      <span class="func">color</span>(A, B, C) Set foreground and background color of the <a class="type" href="#types_text">text</a> A
                  ( Type of argument B: <a class="type" href="#types_color">color</a>,
                    Type of argument C: <a class="type" href="#types_color">color</a> )
      <span class="func">setPos</span>(A, B, C) Set the current position of the <a class="type" href="#types_text">text</a> A
                  ( Type of argument B: <a class="type" href="#types_integer">integer</a>
                    Type of argument C: <a class="type" href="#types_integer">integer</a> )
      <span class="func">setLine</span>(A, B) Set the current line of the <a class="type" href="#types_text">text</a> A
                  ( Type of argument B: <a class="type" href="#types_integer">integer</a> )
      <span class="func">setColumn</span>(A, B) Set the current column of the <a class="type" href="#types_text">text</a> A
                  ( Type of argument B: <a class="type" href="#types_integer">integer</a> )
      box(A)    Write a box around the window
      clear_box(A) Clear the box around the window
      cursor_on(A) Make the cursor visible
      cursor_off(A) Make the cursor invisible
</pre><p></p>

<a name="types_func"><h3>5.25 func</h3></a>
<p>
    The type <tt><a class="type" href="#types_func">func</a> <span class="type">baseType</span></tt> describes functions which return
  a <tt><span class="type">baseType</span></tt>. For example: <tt><a class="type" href="#types_func">func</a> <a class="type" href="#types_integer">integer</a></tt> describes an <tt><a class="type" href="#types_integer">integer</a></tt>
  function.
</p><pre class="tt">
    Values:
      ord, str, abs, sqrt, rand, A + B, A * B, A ** B,
      trunc, round, sin, cos, compare, hashCode, pos,
      replace, trim, length, keys, color, dayOfWeek,
      ...
                Every function declared with <span class="keywd">const</span> <a class="type" href="#types_func">func</a> ... is a value

    Prefix operators:
      <span class="keywd">func</span>
      <span class="keywd">result</span>
        <span class="keywd">var</span> <span class="type">baseType</span>: resultVariable <span class="keywd">is</span> <span class="type">baseType</span>.value;
      <span class="keywd">begin</span>
        statements
      <span class="keywd">end func</span>
                Create a <span class="type">baseType</span> function
                  ( Type of <tt>'statements'</tt>: <a class="type" href="#types_proc">proc</a>,
                    Type of result: <a class="type" href="#types_func">func</a> <span class="type">baseType</span> )

      <span class="keywd">func</span>
      <span class="keywd">result</span>
        <span class="keywd">var</span> <span class="type">baseType</span>: resultVariable <span class="keywd">is</span> <span class="type">baseType</span>.value;
      <span class="keywd">local</span>
        declarations
      <span class="keywd">begin</span>
        statements
      <span class="keywd">end func</span>
                Create a <span class="type">baseType</span> function with local variables
                  ( Type of <tt>'declarations'</tt>: <a class="type" href="#types_proc">proc</a>,
                    Type of <tt>'statements'</tt>: <a class="type" href="#types_proc">proc</a>,
                    Type of result: <a class="type" href="#types_func">func</a> <span class="type">baseType</span> )

      <span class="keywd">return</span> value
                Create a function with the result type of value
                  ( Type of value: <span class="type">anyType</span> - which means: any type,
                    Type of result: <a class="type" href="#types_func">func</a> <span class="type">anyType</span> )
</pre><p>
  Functions are declared as constants with a <tt><a class="type" href="#types_func">func</a></tt> type and
  are initialized with a <tt><span class="keywd">func result</span> ...</tt> or <tt><span class="keywd">return</span> ...</tt> operator.
  For example:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_func">func</a> <a class="type" href="#types_integer">integer</a>: tak (<span class="keywd">in</span> <a class="type" href="#types_integer">integer</a>: x, <span class="keywd">in</span> <a class="type" href="#types_integer">integer</a>: y, <span class="keywd">in</span> <a class="type" href="#types_integer">integer</a>: z) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="#types_integer">integer</a>: tak <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> y >= x <span class="keywd">then</span>
      tak := z;
    <span class="keywd">else</span>
      tak := tak(tak(pred(x), y, z),
                 tak(pred(y), z, x),
                 tak(pred(z), x, y));
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>
</pre><p>
  Another example using the <tt><span class="keywd">return</span></tt> function:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_func">func</a> <a class="type" href="#types_float">float</a>: convertRadianToDegree (<span class="keywd">in</span> <a class="type" href="#types_float">float</a>: x) <span class="keywd">is</span>
  <span class="keywd">return</span> x * 57.295779513082320876798154814114;
</pre><p>
  This <tt><span class="keywd">return</span></tt> function should not be confused with a <tt><span class="keywd">return</span></tt>
  statement. It is important to note that no <tt><span class="keywd">return</span></tt> statement
  exists. The declaration for the <tt><span class="keywd">return</span></tt> function is as follows:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_func">func</a> <a class="type" href="#types_func">func</a> <span class="type">aType</span>: return (<span class="keywd">ref</span> <a class="type" href="#types_func">func</a> <span class="type">aType</span> <span class="keywd">param</span>)  <span class="keywd">is action</span> <span class="stri">"PRC_RETURN"</span>;
<span class="keywd">const</span> <a class="type" href="#types_func">func</a> <a class="type" href="#types_func">func</a> <span class="type">aType</span>: return (<span class="keywd">ref</span> <span class="type">aType</span> <span class="keywd">param</span>)       <span class="keywd">is action</span> <span class="stri">"PRC_RETURN"</span>;
</pre><p>
  The <tt><a class="type" href="#types_func">func</a></tt> types can also be used for parameters.
  Functions which use a <tt><a class="type" href="#types_func">func</a></tt> parameter do not evaluate this
  parameter before the function call. Instead this parameter can
  be evaluated zero or more times inside the function. For example:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_func">func</a> <a class="type" href="#types_boolean">boolean</a>: (<span class="keywd">in</span> <a class="type" href="#types_boolean">boolean</a>: first) and (<span class="keywd">in</span> <a class="type" href="#types_func">func</a> <a class="type" href="#types_boolean">boolean</a>: second) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="#types_boolean">boolean</a>: conjunction <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> first <span class="keywd">then</span>
      conjunction := second;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre><p>
  Here the second parameter is only evaluated when the first
  parameter is <tt><span class="var">TRUE</span></tt>.
</p>

<a name="types_varfunc"><h3>5.26 varfunc</h3></a>
<p>
    The type <tt><a class="type" href="#types_varfunc">varfunc</a> <span class="type">baseType</span></tt> describes functions which return
  a <tt><span class="type">baseType</span></tt> variable. For example: A function which returns an
  <tt><a class="type" href="#types_integer">integer</a></tt> variable is described with <tt><a class="type" href="#types_varfunc">varfunc</a> <a class="type" href="#types_integer">integer</a></tt>. A call
  of a <tt><a class="type" href="#types_varfunc">varfunc</a></tt> can be used at the left side of an assignment.
  Generally a <tt><a class="type" href="#types_varfunc">varfunc</a></tt> can be used at places where an <tt><span class="keywd">inout</span></tt>
  parameter requests a variable.
</p><pre class="tt">
    Prefix operators:
      <span class="keywd">return var</span> value;
                Create a varfunc which returns the variable <tt>'value'</tt>
                  ( Type of value: <span class="type">anyType</span> - which means: any type,
                    Accessright of value: <span class="keywd">var</span> = A variable, an <tt><span class="keywd">inout</span></tt> parameter or a <tt><a class="type" href="#types_varfunc">varfunc</a></tt>
                    Type of result: <a class="type" href="#types_varfunc">varfunc</a> <span class="type">anyType</span> )
</pre><p>
    Varfunctions are used to express <tt><a class="type" href="#types_array">array</a></tt>, <tt><a class="type" href="#types_hash">hash</a></tt> and <tt><a class="type" href="#types_struct">struct</a></tt>
  accesses which can be used at the left and right side of an
  assignment. The access function for a <tt><a class="type" href="#types_hash">hash</a></tt> is defined as:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_func">func</a> <span class="type">baseType</span>: (<span class="keywd">in</span> <span class="type">hashType</span>: aHash) [ (<span class="keywd">in</span> <span class="type">keyType</span>: aKey) ] <span class="keywd">is</span>
  <span class="keywd">return</span> INDEX(aHash, aKey, hashCode(aKey), <span class="type">hashType</span>.keyCompare);

<span class="keywd">const</span> <a class="type" href="#types_varfunc">varfunc</a> <span class="type">baseType</span>: (<span class="keywd">inout</span> <span class="type">hashType</span>: aHash) [ (<span class="keywd">in</span> <span class="type">keyType</span>: aKey) ] <span class="keywd">is</span>
  <span class="keywd">return var</span> INDEX(aHash, aKey, hashCode(aKey), <span class="type">hashType</span>.keyCompare);
</pre><p>
  The example above shows that functions with <tt><span class="keywd">in</span></tt> and <tt><span class="keywd">inout</span></tt>
  parameters can be overloaded. At the right side of an assignment
  the <tt><a class="type" href="#types_func">func</a></tt> is called, while at the left side the <tt><a class="type" href="#types_varfunc">varfunc</a></tt>
  is called. That way the access functions of <a class="type" href="#types_array">array</a>s, <a class="type" href="#types_hash">hash</a>s
  and <a class="type" href="#types_struct">struct</a>s can be used in the usual way.
</p>

<a name="types_void"><h3>5.27 void</h3></a>
<p>
    The type <tt><a class="type" href="#types_void">void</a></tt> describes the empty type.
</p><pre class="tt">
    Value:
      empty     This is the only value of the type <a class="type" href="#types_void">void</a>.
</pre><p></p>

<a name="types_proc"><h3>5.28 proc</h3></a>
<p>
    The type <tt><a class="type" href="#types_proc">proc</a></tt> describes procedures. The type <tt><a class="type" href="#types_proc">proc</a></tt>
  is defined as <tt><a class="type" href="#types_func">func</a> <a class="type" href="#types_void">void</a></tt>.
</p><pre class="tt">
    Values:
      noop;
      <span class="keywd">while</span> ... <span class="keywd">do</span> ... <span class="keywd">end while</span>;
      <span class="keywd">repeat</span> ... <span class="keywd">until</span> ... ;
      writeln( ... );
      A := B;
      incr(A);
      ...
                Every procedure declared with <span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: ... is a value
                The procedure <tt>'noop'</tt> does nothing and is used as empty procedure.

    Prefix operators:
      <span class="keywd">func</span>
      <span class="keywd">begin</span>
        statements
      <span class="keywd">end func</span>
                Create a procedure
                  ( Type of <tt>'statements'</tt>: <a class="type" href="#types_proc">proc</a>,
                    Type of result: <a class="type" href="#types_proc">proc</a> )

      <span class="keywd">func</span>
      <span class="keywd">local</span>
        declarations
      <span class="keywd">begin</span>
        statements
      <span class="keywd">end func</span>
                Create a procedure with local variables
                  ( Type of <tt>'declarations'</tt>: <a class="type" href="#types_proc">proc</a>,
                    Type of <tt>'statements'</tt>: <a class="type" href="#types_proc">proc</a>,
                    Type of result: <a class="type" href="#types_proc">proc</a> )
</pre><p></p>

<a name="types_type"><h3>5.29 type</h3></a>
<p>
    The type <tt><a class="type" href="#types_type">type</a></tt> describes all types.
</p><pre class="tt">
    Values:
      <a class="type" href="#types_void">void</a>, <a class="type" href="#types_boolean">boolean</a>, <a class="type" href="#types_integer">integer</a>, <a class="type" href="#types_rational">rational</a>, <a class="type" href="#types_float">float</a>, <a class="type" href="#types_char">char</a>,
      <a class="type" href="#types_string">string</a>, <a class="type" href="#types_reference">reference</a>, <a class="type" href="#types_ref_list">ref_list</a>, <a class="type" href="#types_color">color</a>, <a class="type" href="#types_time">time</a>, <a class="type" href="#types_duration">duration</a>
      <a class="type" href="#types_file">file</a>, <a class="type" href="#types_proc">proc</a>, <a class="type" href="#types_type">type</a>, ...
                Every type declared with <span class="keywd">const</span> <a class="type" href="#types_type">type</a>: ... is a value
                The type <a class="type" href="#types_void">void</a> is used as empty type.
    Prefix operators:
      func      Function type
                  ( <a class="type" href="#types_func">func</a> <a class="type" href="#types_char">char</a> <b>&rArr;</b> Function which returns a <a class="type" href="#types_char">char</a> )
      varfunc   Varfunc type
                  ( <a class="type" href="#types_varfunc">varfunc</a> <a class="type" href="#types_char">char</a> <b>&rArr;</b> Function which returns a <a class="type" href="#types_char">char</a> variable )
      ptr       Pointer type
                  ( <a class="type" href="#types_ptr">ptr</a> <a class="type" href="#types_set">bitset</a> <b>&rArr;</b> Pointer to <a class="type" href="#types_set">bitset</a> )
      array     Array type
                  ( <a class="type" href="#types_array">array</a> <a class="type" href="#types_string">string</a> <b>&rArr;</b> Array of <a class="type" href="#types_string">string</a>s )
      set of    Set type
                  ( <a class="type" href="#types_set">set</a> <span class="type">of</span> <a class="type" href="#types_integer">integer</a> <b>&rArr;</b> Set of <a class="type" href="#types_integer">integer</a> )
      subtype   Create subtype of existing type
                  ( <font color=red>subtype</font> <a class="type" href="#types_char">char</a> <b>&rArr;</b> Subtype of <a class="type" href="#types_char">char</a> )
    Relations:
      =, &lt;>
    Functions:
      str(A)    Conversion to <a class="type" href="#types_string">string</a>
                  ( Type of result: <a class="type" href="#types_string">string</a> )
      newtype   Create a new type
      gentype   Generate a type
      gensub(A) Generate a subtype
      typeof(A) Get the type of an expression
                  ( Type of argument A: Defined for all types,
                    typeof(1) <b>&rArr;</b> <a class="type" href="#types_integer">integer</a>,
                    typeof(<span class="stri">"asdf"</span>) <b>&rArr;</b> <a class="type" href="#types_string">string</a> )
      isFunc(A)  Is this type a <a class="type" href="#types_func">func</a> type
                  ( Type of result: <a class="type" href="#types_boolean">boolean</a>,
                    isFunc(<a class="type" href="#types_func">func</a> <a class="type" href="#types_char">char</a>) <b>&rArr;</b> <span class="var">TRUE</span>,
                    isFunc(<a class="type" href="#types_varfunc">varfunc</a> <a class="type" href="#types_char">char</a>) <b>&rArr;</b> <span class="var">FALSE</span> )
                    isFunc(<a class="type" href="#types_char">char</a>) <b>&rArr;</b> <span class="var">FALSE</span> )
      isVarfunc(A)  Is this type a <a class="type" href="#types_varfunc">varfunc</a> type
                  ( Type of result: <a class="type" href="#types_boolean">boolean</a>,
                    isVarfunc(<a class="type" href="#types_func">func</a> <a class="type" href="#types_char">char</a>) <b>&rArr;</b> <span class="var">FALSE</span>,
                    isVarfunc(<a class="type" href="#types_varfunc">varfunc</a> <a class="type" href="#types_char">char</a>) <b>&rArr;</b> <span class="var">TRUE</span>,
                    isVarfunc(<a class="type" href="#types_char">char</a>) <b>&rArr;</b> <span class="var">FALSE</span> )
      resultType(A)  Get the result type of a <a class="type" href="#types_func">func</a> or <a class="type" href="#types_varfunc">varfunc</a> type
                  ( resultType(<a class="type" href="#types_func">func</a> <a class="type" href="#types_char">char</a>) <b>&rArr;</b> <a class="type" href="#types_char">char</a>,
                    resultType(<a class="type" href="#types_proc">proc</a>) <b>&rArr;</b> <a class="type" href="#types_void">void</a>,
                    resultType(<a class="type" href="#types_integer">integer</a>) <b>&rArr;</b> EXCEPTION <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> )
      isDerived(A)  Is this type derived from another type
                  ( Type of result: <a class="type" href="#types_boolean">boolean</a>,
                    isDerived(<font color=red>subtype</font> <a class="type" href="#types_char">char</a>) <b>&rArr;</b> <span class="var">TRUE</span> )
      meta(A)       Get the type from which type A is derived
                  ( meta(<font color=red>subtype</font> <a class="type" href="#types_char">char</a>) <b>&rArr;</b> <a class="type" href="#types_char">char</a> )
      base_type(A)  Get the base type of an array, pointer or
                    set type
                  ( base_type(<a class="type" href="#types_array">array</a> <a class="type" href="#types_char">char</a>) <b>&rArr;</b> <a class="type" href="#types_char">char</a>,
                    base_type(<a class="type" href="#types_ptr">ptr</a> <a class="type" href="#types_string">string</a>) <b>&rArr;</b> <a class="type" href="#types_string">string</a>,
                    base_type(<a class="type" href="#types_set">set</a> <span class="type">of</span> <a class="type" href="#types_integer">integer</a>) <b>&rArr;</b> <a class="type" href="#types_integer">integer</a> )
      typeNumber(A)  Get an unique number for a type
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
      typeObject(A)  Get a unique object (match object) of a type
                  ( Type of result: <a class="type" href="#types_reference">reference</a> )
      compare(A, B) Compare function
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
      hashCode(A) Hash function
                  ( Type of result: <a class="type" href="#types_integer">integer</a> )
    Statements:
      addInterface(A, B)  Adds the interface type B to the implementation type A
      <span class="keywd">const</span> <span class="type">aType</span>: name <span class="keywd">is</span> value
                Declare constant 'name' with 'value'
      <span class="keywd">var</span> <span class="type">aType</span>: name <span class="keywd">is</span> value
                Declare variable 'name' with 'value'
</pre><p></p>

<a name="types_object"><h3>5.30 object</h3></a>
<p>
    The type <tt><a class="type" href="#types_object">object</a></tt> is used as meta type for various types.
  This allows defining common operations for all this types.
  The type <tt><a class="type" href="#types_object">object</a></tt> is not used as element type for container
  classes since this can be done much better and type safe
  with abstract data types like <tt><a class="type" href="#types_array">array</a></tt>, <tt><a class="type" href="#types_set">set</a></tt>, <tt><a class="type" href="#types_hash">hash</a></tt> and
  others.
</p><pre class="tt">
    Functions:
      TRACE_OBJ(A)  Write internal information
</pre><p></p>

<a name="types_expr"><h3>5.31 expr</h3></a>
<p>
    The type <tt><a class="type" href="#types_expr">expr</a></tt> is used to describe unmatched expressions.
  These are expressions where the recognizing of the functions
  and the type check is not done yet. This is used for example
  in the definition of function bodies.
</p><pre class="tt">
    Functions:
      WRITE_EXPR(A)
                Write expr A to FILE OUT
</pre><p></p>

<a name="params_file_start"></a><p></p>
<a name="params_PARAMETERS"><h2>6. PARAMETERS</h2></a>

<p>
    The following subchapters introduce the parameter types of
  Seed7.
</p>

<a name="params_val_parameter"><h3>6.1 'val' parameter</h3></a>
<p>
  Value parameters are marked with the keyword <tt>'<span class="keywd">val</span>'</tt>.
  A value parameter copies the value of the actual parameter.
  Value parameters are used, when copying is cheap or
  when copying  is necessary for the correct behavior.
  The function below appends a comma and a string to the
  variable <tt>'globalStri'</tt>:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: appendStri (<span class="keywd">val</span> <a class="type" href="#types_string">string</a>: stri) <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    globalStri &amp;:= <span class="stri">","</span>;
    globalStri &amp;:= stri;
  <span class="keywd">end func</span>;
</pre><p>
  After doing
</p><pre class="indent">
globalStri &amp;:= <span class="stri">"a"</span>;
appendStri(globalStri);
</pre><p>
  the variable globalStri contains the value <tt><span class="stri">"a,a"</span></tt>. If the function
  header would be
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: appendStri (<span class="keywd">in</span> <a class="type" href="#types_string">string</a>: stri) <span class="keywd">is func</span>
</pre><p>
  the variable globalStri would contain the value <tt><span class="stri">"a,a,"</span></tt>. This
  difference is because of the following reasons:
</p><p>
  For arrays <tt>'<span class="keywd">in</span>'</tt> parameters are equal to <tt>'<span class="keywd">ref</span>'</tt> parameters.
  When appendStri is called with globalStri as parameter an unwanted
  side effect takes place: Every change of globalStri changes also
  the <tt>'<span class="keywd">ref</span>'</tt> parameter stri. Changes to the <tt>'<span class="keywd">ref</span>'</tt> parameter would
  also change the global variable. Such unwanted side effects can
  also take place between parameters (when at least one parameter
  is an <tt>'<span class="keywd">inout</span>'</tt> parameter).
</p><p>
  In most cases such unwanted side effects are impossible or can
  be avoided easily. An <tt>'<span class="keywd">in</span>'</tt> parameter should be preferred
  over an <tt>'<span class="keywd">val</span>'</tt> parameter, when possible.
</p><dl><dt>
  Semantics:</dt><dd>
    When calling a function a formal <tt>'<span class="keywd">val</span>'</tt> parameter gets its
    value from the corresponding actual parameter. This is done
    with a create procedure ( ::= ). In the function it is only
    possible to read a formal <tt>'<span class="keywd">val</span>'</tt> parameter. Changing a formal
    <tt>'<span class="keywd">val</span>'</tt> parameter is not possible. When a function is left a
    <tt>'destr'</tt> procedure is called for every <tt>'<span class="keywd">val</span>'</tt> parameter. Formal
    <tt>'<span class="keywd">val</span>'</tt> parameters have the access right <tt>'<span class="keywd">const</span>'</tt>.
</dd></dl>
<dl><dt>
  Syntax:
</dt><dd><tt><dl>
    <dt>val_parameter ::=</dt><dd>
      '<span class="keywd">val</span>' type_expression ':' identifier_declaration |<br />
      '<span class="keywd">val</span>' type_expression '<span class="keywd">param</span>' .</dd>
</dl></tt></dd></dl><p>

  Declaration:
</p><pre class="indent">
$ <span class="keywd">syntax</span> <a class="type" href="#types_expr">expr</a>: .val.().param       <span class="keywd">is</span> -> 40;
$ <span class="keywd">syntax</span> <a class="type" href="#types_expr">expr</a>: .val.(). : .(<a class="type" href="#types_expr">expr</a>)  <span class="keywd">is</span> -> 40;

<span class="keywd">const</span> <a class="type" href="#types_func">func</a> <span class="type">f_param</span>: val (<span class="keywd">ref</span> <a class="type" href="#types_type">type</a> <span class="keywd">param</span>) param               <span class="keywd">is action</span> <span class="stri">"DCL_VAL1"</span>;
<span class="keywd">const</span> <a class="type" href="#types_func">func</a> <span class="type">f_param</span>: val (<span class="keywd">ref</span> <a class="type" href="#types_type">type</a> <span class="keywd">param</span>) : (<span class="keywd">ref</span> <a class="type" href="#types_expr">expr</a> <span class="keywd">param</span>)  <span class="keywd">is action</span> <span class="stri">"DCL_VAL2"</span>;
</pre><p></p>

<a name="params_ref_parameter"><h3>6.2 'ref' parameter</h3></a>
<p>
  Reference parameters are marked with the keyword <tt>'<span class="keywd">ref</span>'</tt>.
  A reference parameter refers to the value of the actual parameter.
  Reference parameters are used, when copying is expensive and
  referring to the value does not change the correct behavior.
  The function below defines the primitive action for the
  semicolon operator:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: (<span class="keywd">ref</span> <a class="type" href="#types_void">void</a> <span class="keywd">param</span>) ; (<span class="keywd">ref</span> <a class="type" href="#types_void">void</a> <span class="keywd">param</span>) <span class="keywd">is</span> noop;
</pre><p>
  In this definition and other definitions of primitive actions
  <tt>'<span class="keywd">ref</span>'</tt> parameters are used. For normal functions usually
  <tt>'<span class="keywd">in</span>'</tt> parameters are used instead of <tt>'<span class="keywd">ref</span>'</tt> parameters:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_func">func</a> <a class="type" href="#types_integer">integer</a>: total_length (<span class="keywd">in</span> <a class="type" href="#types_array">array</a> <a class="type" href="#types_string">string</a>: arr) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="#types_integer">integer</a>: lengthSum <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="#types_integer">integer</a>: index <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> length(arr) <span class="keywd">do</span>
      lengthSum +:= length(arr[index]);
    <span class="keywd">end for</span>;
  <span class="keywd">end func</span>;
</pre><p>
  Above function could also be defined with the following
  function head:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_func">func</a> <a class="type" href="#types_integer">integer</a>: total_length (<span class="keywd">ref</span> <a class="type" href="#types_array">array</a> <a class="type" href="#types_string">string</a>: arr) <span class="keywd">is func</span>
</pre><p>
  Since for array types (and also for struct types) <tt>'<span class="keywd">in</span>'</tt>
  parameters are defined to act as <tt>'<span class="keywd">ref</span>'</tt> parameters both
  definitions are equal. An <tt>'<span class="keywd">in</span>'</tt> parameter should be
  preferred over an <tt>'<span class="keywd">ref</span>'</tt> parameter, when possible.
</p><dl><dt>
  Semantics:</dt><dd>
    When calling a function a formal <tt>'<span class="keywd">ref</span>'</tt> parameter is set to
    refer to the corresponding actual parameter. In the function
    it is only possible to read a formal <tt>'<span class="keywd">ref</span>'</tt> parameter.
    Changing a formal <tt>'<span class="keywd">ref</span>'</tt> parameter is not possible. Formal
    <tt>'<span class="keywd">ref</span>'</tt> parameters have the access right <tt>'<span class="keywd">const</span>'</tt>.
</dd></dl>
<dl><dt>
  Syntax:
</dt><dd><tt><dl>
    <dt>ref_parameter ::=</dt><dd>
      '<span class="keywd">ref</span>' type_expression ':' identifier_declaration |<br />
      '<span class="keywd">ref</span>' type_expression '<span class="keywd">param</span>' .</dd>
</dl></tt></dd></dl><p>

  Declaration:
</p><pre class="indent">
$ <span class="keywd">syntax</span> <a class="type" href="#types_expr">expr</a>: .ref.().param       <span class="keywd">is</span> -> 40;
$ <span class="keywd">syntax</span> <a class="type" href="#types_expr">expr</a>: .ref.(). : .(<a class="type" href="#types_expr">expr</a>)  <span class="keywd">is</span> -> 40;

<span class="keywd">const</span> <a class="type" href="#types_func">func</a> <span class="type">f_param</span>: ref (<span class="keywd">ref</span> <a class="type" href="#types_type">type</a> <span class="keywd">param</span>) param               <span class="keywd">is action</span> <span class="stri">"DCL_REF1"</span>;
<span class="keywd">const</span> <a class="type" href="#types_func">func</a> <span class="type">f_param</span>: ref (<span class="keywd">ref</span> <a class="type" href="#types_type">type</a> <span class="keywd">param</span>) : (<span class="keywd">ref</span> <a class="type" href="#types_expr">expr</a> <span class="keywd">param</span>)  <span class="keywd">is action</span> <span class="stri">"DCL_REF2"</span>;
</pre><p></p>

<a name="params_in_parameter"><h3>6.3 'in' parameter</h3></a>
<p>
  Input parameters are marked with the keyword <tt>'<span class="keywd">in</span>'</tt>.
  Depending on the type an input parameter is either a
  value or a reference parameter. The function below
  checks if a given number is a prime number:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_func">func</a> <a class="type" href="#types_boolean">boolean</a>: is_prime (<span class="keywd">in</span> <a class="type" href="#types_integer">integer</a>: number) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="#types_boolean">boolean</a>: prime <span class="keywd">is</span> FALSE;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="#types_integer">integer</a>: count <span class="keywd">is</span> 2;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> number = 2 <span class="keywd">then</span>
      prime := TRUE;
    <span class="keywd">elsif</span> number >= 3 <span class="keywd">then</span>
      <span class="keywd">while</span> number <span class="op">rem</span> count &lt;> 0 <span class="op">and</span> count * count &lt;= number <span class="keywd">do</span>
        incr(count);
      <span class="keywd">end while</span>;
      prime := number <span class="op">rem</span> count &lt;> 0;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre><p>
  The following function defines the ex (outer) product:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_func">func</a> <a class="type" href="#types_array">array</a> <a class="type" href="#types_array">array</a> <a class="type" href="#types_integer">integer</a>:
    (<span class="keywd">in</span> <a class="type" href="#types_array">array</a> <a class="type" href="#types_integer">integer</a>: a) ex (<span class="keywd">in</span> <a class="type" href="#types_array">array</a> <a class="type" href="#types_integer">integer</a>: b) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="#types_array">array</a> <a class="type" href="#types_array">array</a> <a class="type" href="#types_integer">integer</a>: product <span class="keywd">is</span> 0 <span class="op">times</span> 0 <span class="op">times</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="#types_integer">integer</a>: index1 <span class="keywd">is</span> 1;
  <span class="keywd">begin</span>
    product := length(a) <span class="op">times</span> length(b) <span class="op">times</span> 0;
    <span class="keywd">for</span> index1 <span class="keywd">range</span> 1 <span class="keywd">to</span> length(a) <span class="keywd">do</span>
      <span class="keywd">for</span> index2 <span class="keywd">range</span> 1 <span class="keywd">to</span> length(b) <span class="keywd">do</span>
        product[index1][index2] := a[index1] * b[index2];
      <span class="keywd">end for</span>;
    <span class="keywd">end for</span>;
  <span class="keywd">end func</span>;
</pre><p>
  Although both examples use <tt>'<span class="keywd">in</span>'</tt> parameters the parameter in the
  first example is actually a <tt>'<span class="keywd">val</span>'</tt> parameter while the parameters
  in the second example are actually <tt>'<span class="keywd">ref</span>'</tt> parameters. When a new
  type is created with the <tt>'newtype'</tt> function it is necessary to
  specify the meaning of the <tt>'<span class="keywd">in</span>'</tt> parameter. This is done with a
  call of the IN_PARAM_IS_VALUE or the IN_PARAM_IS_REFERENCE function
  with the new generated type as parameter. If a new type is created
  with the <tt>'subtype'</tt> function this specification is optional since
  the base type has already a specification of the <tt>'<span class="keywd">in</span>'</tt> parameter.
</p><dl><dt>
  Semantics:</dt><dd>
    Depending on the type an <tt>'<span class="keywd">in</span>'</tt> parameter is equivalent to an
    <tt>'<span class="keywd">val</span>'</tt> (call by value) parameter or to an <tt>'<span class="keywd">ref</span>'</tt> (call by reference)
    parameter. Formal <tt>'<span class="keywd">in</span>'</tt> parameters have the access right <tt>'<span class="keywd">const</span>'</tt>.
</dd></dl>
<dl><dt>
  Syntax:
</dt><dd><tt><dl>
    <dt>in_parameter ::=</dt><dd>
      '<span class="keywd">in</span>' type_expression ':' identifier_declaration .</dd>
</dl></tt></dd></dl><p>

  Declaration:
</p><pre class="indent">
$ <span class="keywd">syntax</span> <a class="type" href="#types_expr">expr</a>: .in.().param       <span class="keywd">is</span> -> 40;
$ <span class="keywd">syntax</span> <a class="type" href="#types_expr">expr</a>: .in.(). : .(<a class="type" href="#types_expr">expr</a>)  <span class="keywd">is</span> -> 40;

<span class="keywd">const</span> <a class="type" href="#types_func">func</a> <span class="type">f_param</span>: in (<span class="keywd">ref</span> <a class="type" href="#types_type">type</a> <span class="keywd">param</span>) param                <span class="keywd">is action</span> <span class="stri">"DCL_REF1"</span>;

<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: IN_PARAM_IS_VALUE (<span class="keywd">ref</span> <a class="type" href="#types_type">type</a>: aType) <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    <span class="keywd">const</span> <a class="type" href="#types_func">func</a> <span class="type">f_param</span>: in (<span class="keywd">attr</span> <span class="type">aType</span>) : (<span class="keywd">ref</span> <a class="type" href="#types_expr">expr</a> <span class="keywd">param</span>)   <span class="keywd">is action</span> <span class="stri">"DCL_VAL2"</span>;
  <span class="keywd">end func</span>;

<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: IN_PARAM_IS_REFERENCE (<span class="keywd">ref</span> <a class="type" href="#types_type">type</a>: aType) <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    <span class="keywd">const</span> <a class="type" href="#types_func">func</a> <span class="type">f_param</span>: in (<span class="keywd">attr</span> <span class="type">aType</span>) : (<span class="keywd">ref</span> <a class="type" href="#types_expr">expr</a> <span class="keywd">param</span>)   <span class="keywd">is action</span> <span class="stri">"DCL_REF2"</span>;
  <span class="keywd">end func</span>;
</pre><p></p>

<a name="params_in_var_parameter"><h3>6.4 'in var' parameter</h3></a>
<p>
  This function computes the greatest common divisor:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_func">func</a> <a class="type" href="#types_integer">integer</a>: gcd (<span class="keywd">in var</span> <a class="type" href="#types_integer">integer</a>: a, <span class="keywd">in var</span> <a class="type" href="#types_integer">integer</a>: b) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="#types_integer">integer</a>: gcd <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="#types_integer">integer</a>: help <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">while</span> a &lt;> 0 <span class="keywd">do</span>
      help := b <span class="op">rem</span> a;
      b := a;
      a := help;
    <span class="keywd">end while</span>;
    gcd := b;
  <span class="keywd">end func</span>;
</pre><p></p><dl><dt>
  Semantics:</dt><dd>
    When calling a function a formal <tt><span class="keywd">in var</span></tt> parameter gets its
    value from the corresponding actual parameter. This is done
    with a create procedure ( ::= ). In the function it is
    possible to read and change a formal <tt><span class="keywd">in var</span></tt> parameter.
    Changing a formal <tt><span class="keywd">in var</span></tt> parameter has no effect on the
    actual parameter. When a function is left a <tt>'destr'</tt> procedure
    is called for every <tt><span class="keywd">in var</span></tt> parameter. Formal <tt><span class="keywd">in var</span></tt>
    parameters have the access right <tt><span class="keywd">var</span></tt>.
</dd></dl>
<dl><dt>
  Syntax:
</dt><dd><tt><dl>
    <dt>in_var_parameter ::=</dt><dd>
      '<span class="keywd">in var</span>' type-expression ':' identifier_declaration .</dd>
</dl></tt></dd></dl><p>

  Declaration:
</p><pre class="indent">
$ <span class="keywd">syntax</span> <a class="type" href="#types_expr">expr</a>: .in.var.().param       <span class="keywd">is</span> -> 40;
$ <span class="keywd">syntax</span> <a class="type" href="#types_expr">expr</a>: .in.var.(). : .(<a class="type" href="#types_expr">expr</a>)  <span class="keywd">is</span> -> 40;

<span class="keywd">const</span> <a class="type" href="#types_func">func</a> <span class="type">f_param</span>: in var (<span class="keywd">ref</span> <a class="type" href="#types_type">type</a> <span class="keywd">param</span>) <span class="keywd">param</span>               <span class="keywd">is action</span> <span class="stri">"DCL_IN1VAR"</span>;
<span class="keywd">const</span> <a class="type" href="#types_func">func</a> <span class="type">f_param</span>: in var (<span class="keywd">ref</span> <a class="type" href="#types_type">type</a> <span class="keywd">param</span>) : (<span class="keywd">ref</span> <a class="type" href="#types_expr">expr</a> <span class="keywd">param</span>)  <span class="keywd">is action</span> <span class="stri">"DCL_IN2VAR"</span>;
</pre><p></p>

<a name="params_inout_parameter"><h3>6.5 'inout' parameter</h3></a>
<p>
  This procedure doubles the given parameter 'number':
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: double (<span class="keywd">inout</span> <a class="type" href="#types_integer">integer</a>: number) <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    number := 2 * number;
  <span class="keywd">end func</span>;
</pre><p></p><dl><dt>
  Semantics:</dt><dd>
    When calling a function a formal <tt>'<span class="keywd">inout</span>'</tt> parameter is set to
    refer to the corresponding actual parameter. In the function
    it is possible to read and change a formal <tt>'<span class="keywd">inout</span>'</tt> parameter.
    Changing a formal <tt>'<span class="keywd">inout</span>'</tt> parameter changes the actual
    parameter as well. Formal <tt>'<span class="keywd">inout</span>'</tt> parameters have the
    access right <tt>'<span class="keywd">var</span>'</tt>.
</dd></dl>
<dl><dt>
  Syntax:
</dt><dd><tt><dl>
    <dt>inout_parameter ::=</dt><dd>
      '<span class="keywd">inout</span>' type_expression ':' identifier_declaration .</dd>
</dl></tt></dd></dl><p>

  Declaration:
</p><pre class="indent">
$ <span class="keywd">syntax</span> <a class="type" href="#types_expr">expr</a>: .inout.().param       <span class="keywd">is</span> -> 40;
$ <span class="keywd">syntax</span> <a class="type" href="#types_expr">expr</a>: .inout.(). : .(expr)  <span class="keywd">is</span> -> 40;

<span class="keywd">const</span> <a class="type" href="#types_func">func</a> <span class="type">f_param</span>: inout (<span class="keywd">ref</span> <a class="type" href="#types_type">type</a> <span class="keywd">param</span>) param               <span class="keywd">is action</span> <span class="stri">"DCL_INOUT1"</span>;
<span class="keywd">const</span> <a class="type" href="#types_func">func</a> <span class="type">f_param</span>: inout (<span class="keywd">ref</span> <a class="type" href="#types_type">type</a> <span class="keywd">param</span>) : (<span class="keywd">ref</span> <a class="type" href="#types_expr">expr</a> <span class="keywd">param</span>)  <span class="keywd">is action</span> <span class="stri">"DCL_INOUT2"</span>;
</pre><p></p>

<a name="params_Symbol_parameter"><h3>6.6 Symbol parameter</h3></a>
<p>
  Some functions need symbols at fixed places in the parameter
  list. The following IF-statement requests the keywords <tt>'<span class="keywd">THEN</span>'</tt>,
  <tt>'<span class="keywd">END</span>'</tt> and <tt>'<span class="keywd">IF</span>'</tt> at specific places:
</p><pre class="indent">
<span class="keywd">IF</span> condition <span class="keywd">THEN</span>
  statement
<span class="keywd">END IF</span>;
</pre><p>
  After defining the syntax of this IF-statement with
</p><pre class="indent">
$ <span class="keywd">syntax</span> <a class="type" href="#types_expr">expr</a>: .IF.().THEN.().END.IF  <span class="keywd">is</span> -> 25;
</pre><p>
  the semantic can be defined with:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: IF (<span class="keywd">in</span> <a class="type" href="#types_boolean">boolean</a>: condition) THEN
              (<span class="keywd">in</span> <a class="type" href="#types_proc">proc</a>: statement)
            END IF <span class="keywd">is func</span>

              <span class="keywd">begin</span>
                <span class="keywd">case</span> condition <span class="keywd">of</span>
                  <span class="keywd">when</span> {TRUE}: statement;
                <span class="keywd">end case</span>;
              <span class="keywd">end func</span>;
</pre><p>
  The symbol parameters are just written outside the parentheses.
  A call of this statement could be:
</p><pre class="indent">
<span class="keywd">IF</span> value &lt; maximum <span class="keywd">THEN</span>
  write(value)
<span class="keywd">END IF</span>;
</pre><p></p><dl><dt>
  Semantics:</dt><dd>
    Symbol parameters must be defined in a syntax definition and in
    a corresponding semantic definition. In the semantic definition
    symbol parameters are written outside of the parentheses.
    In the actual parameter list the corresponding symbol of the
    formal parameter list must be written.
</dd></dl>
<dl><dt>
  Syntax:
</dt><dd><tt><dl>
    <dt>symbol_parameter ::=</dt><dd>
      name_identifier | special_identifier .</dd>
</dl></tt></dd></dl><p></p>

<a name="params_attr_parameter"><h3>6.7 'attr' parameter</h3></a>
<p>
  This declaration associates a name to the type <tt>'<a class="type" href="#types_char">char</a>'</tt>:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_string">string</a>: name (<span class="keywd">attr</span> <a class="type" href="#types_char">char</a>) <span class="keywd">is</span> <span class="stri">"char"</span>;
</pre><p>
  This <tt>'name'</tt> can be used as follows:
</p><pre class="indent">
writeln(name(<a class="type" href="#types_char">char</a>));
</pre><p>
  It is possible to overload such declarations:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_string">string</a>: name (<span class="keywd">attr</span> <a class="type" href="#types_boolean">boolean</a>)  <span class="keywd">is</span> <span class="stri">"boolean"</span>;
<span class="keywd">const</span> <a class="type" href="#types_string">string</a>: name (<span class="keywd">attr</span> <a class="type" href="#types_float">float</a>)    <span class="keywd">is</span> <span class="stri">"float"</span>;
</pre><p>
  An <tt>'<span class="keywd">attr</span>'</tt> parameter can be used in a function also:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_func">func</a> <a class="type" href="#types_char">char</a>: (<span class="keywd">attr</span> <a class="type" href="#types_char">char</a>) parse (<span class="keywd">in</span> <a class="type" href="#types_string">string</a>: stri) <span class="keywd">is</span>
  <span class="keywd">return</span> stri[1];
</pre><p></p><dl><dt>
  Semantics:</dt><dd>
    The actual parameter which corresponds to an <tt>'<span class="keywd">attr</span>'</tt> parameter
    must be the type mentioned in the declaration of the <tt>'<span class="keywd">attr</span>'</tt> parameter.
    An <tt>'<span class="keywd">attr</span>'</tt> parameter does not declare a formal parameter
    variable which could be used inside a function.
</dd></dl>
<dl><dt>
  Syntax:
</dt><dd><tt><dl>
    <dt>attr_parameter ::=</dt><dd>
      '<span class="keywd">attr</span>' type_expression .</dd>
</dl></tt></dd></dl><p></p>

<a name="objects_file_start"></a><p></p>
<a name="objects_OBJECT_ORIENTATION"><h2>7. OBJECT ORIENTATION</h2></a>

<p>
    Many people will be familiar with object-orientation from
  languages like C++, Smalltalk, and Java. Seed7 follows the
  route of declaring "interfaces". An interface is a common
  set of operations supported by an object. For instance
  cars, motorcycles, lorries and vans can all accelerate or
  brake, if they are legal to drive on the road they can all
  indicate right and left.
</p><p>
  This view isn't new. C provides a primitive form of
  interfacing. When you write to a <tt>'file'</tt> in C you use the same
  interface (<tt>'fprintf'</tt>) for hard disk files, console output and
  printer output. The implementation does totally different
  things for these files. Unix has used the "everything is a
  file" philosophy for ages (even network communication uses
  the <tt>'file'</tt> interface (see <tt><a class="type" href="#file_Sockets">sockets</a></tt>)).
</p><p>
  For short: An interface defines which methods are supported
  while the implementation describes how this is done.
  Several types with different method implementations can
  share the same interface.
</p>

<a name="objects_interface_and_implementation"><h3>7.1 Interface and implementation</h3></a>
<p>
  Seed7 uses interface types and implementation types.
  Objects declared with an interface type refer to a value
  which has an implementation type. This situation is
  described with the following picture:
</p><pre class="box">
              +----------------+
    declared  |    interface   |&lt;--- interface type
    object:   |     object     |     (known at compile-time)
              +----------------+
                      |
                      | refer to value
                      V
              +----------------+
    value:    | implementation |&lt;--- implementation type
              |     object     |     (unknown at compile-time)
              +----------------+
</pre><p>
  The interface type of an object can always be determined
  at compile-time. Several implementation types can belong
  to one interface type (they implement the interface type).
  E.g.: The types <tt><span class="type">null_file</span></tt>, <tt><span class="type">external_file</span></tt> and <tt><span class="type">socket</span></tt>
  implement the <tt><a class="type" href="#types_file">file</a></tt> interface. On the other hand: An
  implementation type can also implement several interface
  types. An interface object can only refer to a value with
  an implementation type that implements the interface.
  E.g.: A <tt><span class="type">shape</span></tt> variable cannot refer to a <tt><span class="type">socket</span></tt>.
</p><p>
  A new interface type is declared with:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_type">type</a>: shape <span class="keywd">is</span> <span class="keywd">new interface</span>;
</pre><p>
  Interface (DYNAMIC) functions describe what can be done
  with objects of an interface type. An interface function
  for a <tt><span class="type">shape</span></tt> could be:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: draw (<span class="keywd">in</span> <span class="type">shape</span> <span class="keywd">param</span>, <span class="keywd">inout</span> <span class="type">window</span> <span class="keywd">param</span>) <span class="keywd">is DYNAMIC</span>;
</pre><p>
  Now we know that it is possible to <tt>'draw'</tt> a <tt><span class="type">shape</span></tt> to a
  <tt><span class="type">window</span></tt>. How this drawing is done is described in the
  implementation type. An implementation type for <tt><span class="type">shape</span></tt> is:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_type">type</a>: circle <span class="keywd">is</span> <span class="keywd">new struct</span>
    <span class="keywd">var</span> <a class="type" href="#types_integer">integer</a>: radius <span class="keywd">is</span> 0;
  <span class="keywd">end struct</span>;
</pre><p>
  The fact that the type <tt><span class="type">circle</span></tt> is an implementation type of
  <tt><span class="type">shape</span></tt> is described with:
</p><pre class="indent">
type_implements_interface(<span class="type">circle</span>, <span class="type">shape</span>);
</pre><p>
  The function which implements <tt>'draw'</tt> for <tt><span class="type">circle</span>s</tt> is:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: draw (<span class="keywd">in</span> <span class="type">circle</span>: aCircle, <span class="keywd">inout</span> <span class="type">window</span>: aWindow) <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    circle(aWindow.win, aWindow.currX, aWindow.currY,
        aCircle.radius, aWindow.foreground);
  <span class="keywd">end func</span>;
</pre><p>
  In the classic OOP philosophy a message is sent to an object.
  To express this situation classic OO languages use the
  following method call syntax:
</p><pre class="indent">
param1.method(param2, param3)
</pre><p>
  In the method the receiving object is referred with <tt>'self'</tt> or
  <tt>'this'</tt>. The other parameters use the same mechanisms as in
  procedural programming languages (value or reference parameter).
  Seed7 uses a different approach: Instead of an implicit defined
  <tt>'self'</tt> or <tt>'this'</tt> parameter, all formal parameters get a user
  defined name. To reflect this symmetric approach a Seed7 method
  call looks like a normal function call:
</p><pre class="indent">
method(param1, param2, param3)
</pre><p>
  The definition of the <tt>'draw'</tt> function above uses the formal
  parameter <tt>'aCircle'</tt> in the role of a <tt>'self'</tt> or <tt>'this'</tt> parameter.
  Formal parameters which have an implementation type are
  automatically in the role of a <tt>'self'</tt> or <tt>'this'</tt> parameter.
</p><p>
  A function to create new circle objects can also be helpful:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_func">func</a> <span class="type">circle</span>: circle (<span class="keywd">in</span> <a class="type" href="#types_integer">integer</a>: radius) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">circle</span>: aCircle <span class="keywd">is</span> <span class="type">circle</span>.value;
  <span class="keywd">begin</span>
    aCircle.radius := radius;
  <span class="keywd">end func</span>;
</pre><p>
  Now we can draw a <tt><span class="type">circle</span></tt> object with:
</p><pre class="indent">
draw(circle(50), aWindow);
</pre><p>
  Although the statement above does exactly what it should
  do and the separation between interface and implementation
  is obvious, most OO enthusiasts would not be thrilled. All
  decisions which implementation function should be called
  can be made at compile time. To please the OO fans such
  decisions must be made at runtime. This decision process
  is called dynamic dispatch.
</p>

<a name="objects_dynamic_dispatch"><h3>7.2 Dynamic dispatch</h3></a>
<p>
    When the implementation types have different implementations
  of the same function (method) a dynamic dispatch is necessary.
  The type of the value, referred by an interface object, is not
  known at compile-time. In this case the program must decide at
  runtime which implementation of the function should be invoked.
  This decision is based on the implementation type of the value
  (referred by the interface object). A dynamic dispatch only
  takes place when a DYNAMIC (or interface) function is called.
  When the program is analyzed (in the interpreter or compiler)
  the interface functions take precedence over normal functions
  when both are to be considered.
</p><p>
  To demonstrate the dynamic dispatch we define the type <tt><span class="type">line</span></tt>
  which also implements a <tt><span class="type">shape</span></tt>:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_type">type</a>: line <span class="keywd">is</span> <span class="keywd">new struct</span>
    <span class="keywd">var</span> <a class="type" href="#types_integer">integer</a>: xLen <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <a class="type" href="#types_integer">integer</a>: yLen <span class="keywd">is</span> 0.0;
  <span class="keywd">end func</span>;

type_implements_interface(<span class="type">line</span>, <span class="type">shape</span>);

<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: draw (<span class="keywd">in</span> <span class="type">line</span>: aLine, <span class="keywd">in</span> <span class="type">window</span>: aWindow) <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    line(aWindow.win, aWindow.currX, aWindow.currY,
        aLine.xLen, aLine.yLen, aWindow.foreground);
  <span class="keywd">end func</span>;

<span class="keywd">const</span> <a class="type" href="#types_func">func</a> <span class="type">line</span>: line (<span class="keywd">in</span> <a class="type" href="#types_integer">integer</a>: xLen, <span class="keywd">in</span> <a class="type" href="#types_integer">integer</a>: yLen) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">line</span>: aLine <span class="keywd">is</span> <span class="type">line</span>.value;
  <span class="keywd">begin</span>
    aLine.xLen := xLen;
    aLine.yLen := yLen;
  <span class="keywd">end func</span>;
</pre><p>
  In addition we define a normal (not DYNAMIC) function
  which draws <tt><span class="type">shape</span>s</tt> to the <tt>'currWindow'</tt>:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: draw (<span class="keywd">in</span> <span class="type">shape</span>: aShape) <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    draw(aShape, currWindow);
  <span class="keywd">end func</span>;
</pre><p>
  In the example above the call of the (DYNAMIC) interface
  function is <tt>'draw(aShape, currWindow)'</tt>. The
  interface function declared with
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: draw (<span class="keywd">in</span> <span class="type">shape</span> <span class="keywd">param</span>, <span class="keywd">inout</span> <span class="type">window</span> <span class="keywd">param</span>) <span class="keywd">is DYNAMIC</span>;
</pre><p>
  decides which implementation function has to be called.
  The dynamic dispatch works as follows:
</p><ul>
<li>For all parameters which have an interface type the
    parameter is replaced with its value. In this case the
    parameter <tt>'aShape'</tt> is replaced by a value of type
    <tt><span class="type">circle</span></tt> or <tt><span class="type">line</span></tt>.</li>

<li>The same logic as in the analyze part of the compiler
    is used to find the matching function. In this search
    normal functions take precedence over interface functions.</li>

<li>When a matching function is found it is called.</li>
</ul><p>
  This process describes the principal logic of the dynamic
  dispatch. In practice it is not necessary to execute the
  analyze part of the compiler during the runtime. It is
  possible to simplify this process with tables and function
  pointers.
</p>

<a name="objects_inheritance"><h3>7.3 Inheritance</h3></a>
<p>
    When a new <tt><a class="type" href="#types_struct">struct</a></tt> type is defined it is possible to
  inherit from an existing <tt><a class="type" href="#types_struct">struct</a></tt> type. E.g.:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_type">type</a>: external_file <span class="keywd">is</span> <span class="keywd">sub</span> <span class="type">null_file</span> <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">clib_file</span>: ext_file <span class="keywd">is</span> PRIMITIVE_NULL_FILE;
    <span class="keywd">var</span> <a class="type" href="#types_string">string</a>: name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">end struct</span>;
</pre><p>
  That way the type <tt><span class="type">external_file</span></tt> inherits the fields and
  methods of <tt><span class="type">null_file</span></tt>, which is declared as:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_type">type</a>: null_file <span class="keywd">is</span> <span class="keywd">new struct</span>
  <span class="keywd">var</span> <a class="type" href="#types_char">char</a>: bufferChar <span class="keywd">is</span> '\n';
  <span class="keywd">var</span> <a class="type" href="#types_boolean">boolean</a>: io_empty <span class="keywd">is</span> FALSE;
  <span class="keywd">var</span> <a class="type" href="#types_boolean">boolean</a>: io_ok <span class="keywd">is</span> TRUE;
<span class="keywd">end struct</span>;
</pre><p>
  In most situations it makes sense when the implementation
  types inherit from a basic implementation type such as
  <tt><span class="type">null_file</span></tt>. That way it is possible to define functions
  which are inherited by all derived implementation types.
  In the standard library <tt><span class="func">getln</span></tt> is such a function:
<p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_func">func</a> <a class="type" href="#types_string">string</a>: getln (<span class="keywd">inout</span> <span class="type">null_file</span>: aFile) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="#types_string">string</a>: stri <span class="keywd">is</span> "";
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="#types_string">string</a>: buffer <span class="keywd">is</span> "";
  <span class="keywd">begin</span>
    buffer := gets(aFile, 1);
    <span class="keywd">while</span> buffer &lt;> <span class="stri">"\n"</span> <span class="op">and</span> buffer &lt;> <span class="stri">""</span> <span class="keywd">do</span>
      stri &amp;:= buffer;
      buffer := gets(aFile, 1);
    <span class="keywd">end while</span>;
    aFile.bufferChar := buffer[1];
  <span class="keywd">end func</span>;
</pre><p>
  All inherited types of <tt><span class="type">null_file</span></tt> inherit the function
  <tt><span class="func">getln</span></tt>, but they are also free to redefine it. In the
  <tt><span class="func">getln</span></tt> function above the function call <tt>'<span class="func">gets</span>(aFile, 1)'</tt>
  uses the (DYNAMIC) interface function:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_func">func</a> <a class="type" href="#types_string">string</a>: gets (<span class="keywd">inout</span> <a class="type" href="#types_file">file</a> <span class="keywd">param</span>, <span class="keywd">in</span> <a class="type" href="#types_integer">integer</a> <span class="keywd">param</span>) <span class="keywd">is DYNAMIC</span>;
</pre><p>
  In other OO languages the distinction between interface type
  and basic implementation type is not done. Such languages
  either use a dynamic dispatch for every method call (as Java
  does) or need a keyword to request a dynamic dispatch (as C++
  does with the <tt>'virtual'</tt> keyword).
</p><p>
  When assignments take place between inherited implementation
  types it is important to note that structure assignments are
  done with (deep) copies. Naturally such assignments can only
  copy the elements that are present in both structures.
  In the following example just the <tt><span class="type">null_file</span></tt> elements
  are copied from <tt>'anExternalFile'</tt> to <tt>'aNullFile'</tt>:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: example <span class="keywd">is func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">null_file</span>: aNullFile <span class="keywd">is</span> <span class="type">null_file</span>.value;
    <span class="keywd">var</span> <span class="type">external_file</span>: anExternalFile <span class="keywd">is</span> <span class="type">external_file</span>.value;
  <span class="keywd">begin</span>
    aNullFile := anExternalFile;
    write(aNullFile, "hello");
  <span class="keywd">end func</span>;
</pre><p>
  Although the variable <tt>'anExternalFile'</tt> is assigned to
  <tt>'aNullFile'</tt>, the statement <tt>'<span class="func">write</span>(aNullFile, "hello")'</tt>
  calls the <tt><span class="func">write</span></tt> function (method) of the type <tt><span class="type">null_file</span></tt>.
</p><p>
  A new interface type can also inherit from an existing
  interface type:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_type">type</a>: shape <span class="keywd">is</span> <span class="keywd">sub</span> <span class="type">object</span> <span class="keywd">interface</span>;
</pre><p>
  Although inheritance is a very powerful feature it should
  be used with care. In many situations it makes more sense
  that a new type has an element of another type (so called
  has-a relation) instead of inheriting from that type (so
  called is-a relation).
</p>

<a name="objects_class_methods"><h3>7.4 Class methods</h3></a>
<p>
    Many object-oriented programming languages support methods
  that are associated with a class instead of an instantiated
  object. Such methods are called class methods or static
  methods. Seed7 supports class methods via attribute (<tt>'<span class="keywd">attr</span>'</tt>)
  parameters which allow that a function is attached to a <tt><a class="type" href="#types_type">type</a></tt>:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_func">func</a> <span class="type">circle</span>: create (<span class="keywd">attr</span> <span class="type">circle</span>, <span class="keywd">in</span> <a class="type" href="#types_integer">integer</a>: radius) <span class="keywd">is</span>
  <span class="keywd">return</span> circle(radius);
</pre><p>
  This <tt>'create'</tt> function is attached to the type <tt><span class="type">circle</span></tt> and can be called with
</p><pre class="indent">
create(<span class="type">circle</span>, 10)
</pre><p>
  Many languages require that the class name must precede the
  method name when a class method is called (E.g. <tt>'circle::create(10)'</tt>
  in C++). In contrast to that <tt>'<span class="keywd">attr</span>'</tt> parameters are not
  restricted to a specific parameter position. They can be used
  in any parameter position as in the following example:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_func">func</a> <span class="type">circle</span>: create (<span class="keywd">in</span> <a class="type" href="#types_integer">integer</a>: radius, <span class="keywd">attr</span> <span class="type">circle</span>) <span class="keywd">is</span>
  <span class="keywd">return</span> circle(radius);
</pre><p>
  This function can be called with
</p><pre class="indent">
create(10, <span class="type">circle</span>)
</pre><p>
  Attribute parameters can be used for any type not just for
  interface and implementation types. Objects which do not
  have a function type such as a character constant can also
  be attached to a type:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_char">char</a>: (<span class="keywd">attr</span> <a class="type" href="#types_char">char</a>) . value <span class="keywd">is</span> <span class="stri">' '</span>;
</pre><p>
  This way attributes can be used to specify properties
  of a type such as its default <tt>'value'</tt>.
  Programming languages such as Seed7 which support function
  definitions outside a class can also use normal functions
  instead of class methods. It is a matter of tast if a
  function should be grouped to a type or if it should
  exist stand alone and is called with:
</p><pre class="indent">
circle(10)
</pre><p>
</p>

<a name="objects_multiple_dispatch"><h3>7.5 Multiple dispatch</h3></a>
<p>
    The Seed7 object system allows multiple dispatch (not to
  be confused with multiple inheritance). The methods are
  not assigned to one type (class). The decision which
  function (method) is called at runtime is done based upon
  the types of several arguments. The classic object
  orientation is a special case where a method is connected
  to one class and the dispatch decision is done based on
  the type of the <tt>'self'</tt> or <tt>'this'</tt> parameter.
  The classic object orientation is a single dispatch system.
</p><p>
  In the following example the type <tt><span class="type">Number</span></tt> is introduced
  which is capable to unify numerical types. The type
  <tt><span class="type">Number</span></tt> is an interface type which defines
  the interface function for the <tt>'+'</tt> operation:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_type">type</a>: Number <span class="keywd">is</span> <span class="keywd">sub</span> <span class="type">object</span> <span class="keywd">interface</span>;

<span class="keywd">const</span> <a class="type" href="#types_func">func</a> <span class="type">Number</span>: (<span class="keywd">in</span> <span class="type">Number</span> <span class="keywd">param</span>) + (<span class="keywd">in</span> <span class="type">Number</span> <span class="keywd">param</span>) <span class="keywd">is DYNAMIC</span>;
</pre><p>
  The interface type <tt><span class="type">Number</span></tt> can represent an <tt>'<span class="type">Integer</span>'</tt> or a <tt>'<span class="type">Float</span>'</tt>:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_type">type</a>: Integer <span class="keywd">is</span> </font><span class="keywd">new struct</span>
    <span class="keywd">var</span> <a class="type" href="#types_integer">integer</a>: val <span class="keywd">is</span> 0;
  <span class="keywd">end struct</span>;

type_implements_interface(<span class="type">Integer</span>, <span class="type">Number</span>);

<span class="keywd">const</span> <a class="type" href="#types_type">type</a>: Float <span class="keywd">is</span> </font><span class="keywd">new struct</span>
    <span class="keywd">var</span> <a class="type" href="#types_float">float</a>: val <span class="keywd">is</span> 0.0;
  <span class="keywd">end struct</span>;

type_implements_interface(<span class="type">Float</span>, <span class="type">Number</span>);
</pre><p>
  The declarations of the converting <tt>'+'</tt> operators are:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_func">func</a> <span class="type">Float</span>: (<span class="keywd">in</span> <span class="type">Integer</span>: a) + (<span class="keywd">in</span> <span class="type">Float</span>: b) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">Float</span>: sum <span class="keywd">is</span> <span class="type">Float</span>.value;
  <span class="keywd">begin</span>
    sum.val := flt(a.val) + b.val;
  <span class="keywd">end func</span>;

<span class="keywd">const</span> <a class="type" href="#types_func">func</a> <span class="type">Float</span>: (<span class="keywd">in</span> <span class="type">Float</span>: a) + (<span class="keywd">in</span> <span class="type">Integer</span>: b) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">Float</span>: sum <span class="keywd">is</span> <span class="type">Float</span>.value;
  <span class="keywd">begin</span>
    sum.val := a.val + flt(b.val);
  <span class="keywd">end func</span>;
</pre><p>
  The declarations of the normal <tt>'+'</tt> operators (which do not convert) are:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_func">func</a> <span class="type">Integer</span>: (<span class="keywd">in</span> <span class="type">Integer</span>: a) + (<span class="keywd">in</span> <span class="type">Integer</span>: b) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">Integer</span>: sum <span class="keywd">is</span> <span class="type">Integer</span>.value;
  <span class="keywd">begin</span>
    sum.val := a.val + b.val;
  <span class="keywd">end func</span>;

<span class="keywd">const</span> <a class="type" href="#types_func">func</a> <span class="type">Float</span>: (<span class="keywd">in</span> <span class="type">Float</span>: a) + (<span class="keywd">in</span> <span class="type">Float</span>: b) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">Float</span>: sum <span class="keywd">is</span> <span class="type">Float</span>.value;
  <span class="keywd">begin</span>
    sum.val := a.val + b.val;
  <span class="keywd">end func</span>;
</pre><p>
  The type <tt><span class="type">Number</span></tt> can be extended to support other
  operators and there can be also implementations using
  <tt><a class="type" href="#types_complex">complex</a></tt>, <tt><a class="type" href="#types_bigInteger">bigInteger</a></tt>, <tt><a class="type" href="#types_bigRational">bigRational</a></tt>, etc. . That way
  <tt><span class="type">Number</span></tt> can be used as universal type for math
  calculation. Further extending can lead to an universal
  type. Such an universal type is loved by proponents of
  dynamic typed languages, but there are also good reasons
  to have distinct types for different purposes.
</p>

<a name="objects_replacing_pointers"><h3>7.6 Replacing pointers with interface types</h3></a>
<p>
    Many languages have the concept of a pointer. It is possible
  to implement data structures, such as lists and trees, with
  pointers. Although Seed7 supports the concept of a pointer, they
  are not well suited to describe such data structures. Instead of
  pointers interface types can be used. This way list, trees and
  other advanced data structures can be defined.
</p><p>
  The following example shows how to do this:
  The interface type <tt><span class="type">element</span></tt> will be used as "pointer":
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_type">type</a>: element <span class="keywd">is</span> <span class="keywd">new interface</span>;
</pre><p>
  An implementation type for the empty <tt><span class="type">element</span></tt> (emptyElement)
  can be used as basic implementation type from which other
  implementation types can inherit:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_type">type</a>: emptyElement <span class="keywd">is</span> </font><span class="keywd">new struct</span>
  end struct</font>;
</pre><p>
  That the implementation type <tt><span class="type">emptyElement</span></tt> implements the
  interface type <tt><span class="type">element</span></tt> is described with:
</p><pre class="indent">
type_implements_interface(<span class="type">emptyElement</span>, <span class="type">element</span>);
</pre><p>
  Since every Seed7 expression has exactly one type, it is
  necessary to define a special <tt>'NIL'</tt> value (used with  <tt>'<span class="type">element</span>.NIL'</tt>)
  for the type <tt><span class="type">element</span></tt>:
</p><pre class="indent">
<span class="keywd">const</span> <span class="type">element</span>: (<span class="keywd">attr</span> element) . NIL <span class="keywd">is</span> <span class="type">emptyElement</span>.value;
</pre><p>
  Now the struct with two "pointers" and an <tt><a class="type" href="#types_integer">integer</a></tt> can be
  declared:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_type">type</a>: treeElement <span class="keywd">is</span> <span class="keywd">sub</span> <span class="type">emptyElement</span> <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">element</span>: left <span class="keywd">is</span> <span class="type">element</span>.NIL;
    <span class="keywd">var</span> <span class="type">element</span>: right <span class="keywd">is</span> <span class="type">element</span>.NIL;
    <span class="keywd">var</span> <a class="type" href="#types_integer">integer</a>: item <span class="keywd">is</span> 0;
  <span class="keywd">end struct</span>;
</pre><p>
  Finally the type <tt><span class="type">treeElement</span></tt> is defined as implementation
  of the type <tt><span class="type">element</span></tt>:
</p><pre class="indent">
type_implements_interface(<span class="type">treeElement</span>, <span class="type">element</span>);
</pre><p>
  To allow the direct access to the structure elements <tt>'left'</tt>, <tt>'right'</tt>
  and <tt>'item'</tt> for objects of type <tt><span class="type">element</span></tt> the following declarations
  are necessary:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_func">func</a>    <span class="type">element</span>: (<span class="keywd">ref</span>   <span class="type">element</span> <span class="keywd">param</span>).left  <span class="keywd">is DYNAMIC</span>;
<span class="keywd">const</span> <a class="type" href="#types_varfunc">varfunc</a> <span class="type">element</span>: (<span class="keywd">inout</span> <span class="type">element</span> <span class="keywd">param</span>).left  <span class="keywd">is DYNAMIC</span>;
<span class="keywd">const</span> <a class="type" href="#types_func">func</a>    <span class="type">element</span>: (<span class="keywd">ref</span>   <span class="type">element</span> <span class="keywd">param</span>).right <span class="keywd">is DYNAMIC</span>;
<span class="keywd">const</span> <a class="type" href="#types_varfunc">varfunc</a> <span class="type">element</span>: (<span class="keywd">inout</span> <span class="type">element</span> <span class="keywd">param</span>).right <span class="keywd">is DYNAMIC</span>;
<span class="keywd">const</span> <a class="type" href="#types_func">func</a>    <a class="type" href="#types_integer">integer</a>: (<span class="keywd">ref</span>   <span class="type">element</span> <span class="keywd">param</span>).item  <span class="keywd">is DYNAMIC</span>;
<span class="keywd">const</span> <a class="type" href="#types_varfunc">varfunc</a> <a class="type" href="#types_integer">integer</a>: (<span class="keywd">inout</span> <span class="type">element</span> <span class="keywd">param</span>).item  <span class="keywd">is DYNAMIC</span>;
</pre><p>
  When all this was declared the following code is possible:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: addItem (<span class="keywd">inout</span> <span class="type">element</span>: anElem, <span class="keywd">in</span> <a class="type" href="#types_integer">integer</a>: item) <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> anElem = <span class="type">element</span>.NIL <span class="keywd">then</span>
      anElem := xalloc(<span class="type">treeElement</span>.value);
      anElem.item := item;
    <span class="keywd">elsif</span> item < anElem.item <span class="keywd">then</span>
      addItem(anElem.left, item);
    <span class="keywd">elsif</span> item > anElem.item <span class="keywd">then</span>
      addItem(anElem.right, item);
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;

<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: listItems (<span class="keywd">in</span> <span class="type">element</span>: anElem) <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> anElem &lt;> <span class="type">element</span>.NIL <span class="keywd">then</span>
      listItems(anElem.left);
      write(<span class="stri">" "</span> &lt;&amp; anElem.item);
      listItems(anElem.right);
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;

<span class="keywd">const</span> <a class="type" href="#types_func">func</a> <a class="type" href="#types_integer">integer</a>: sum (<span class="keywd">in</span> <span class="type">element</span>: anElem) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="#types_integer">integer</a>: sum <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> anElem &lt;> <span class="type">element</span>.NIL <span class="keywd">then</span>
      sum := anElem.item + sum(anElem.left) + sum(anElem.right);
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre><p>
  New elements can be created with the function 'xalloc'.
  This way interface and implementation types help to provide the
  pointer functionality.
</p><p>
  Pointers and interface types are not always the best solution.
  Abstract data types like dynamic arrays, hash tables, struct
  types and set types can also be used to declare data structures.
</p>
<a name="file_file_start"></a><p></p>
<a name="file_THE_FILE_SYSTEM"><h2>8. THE FILE SYSTEM</h2></a>

<p>
    The file system is used for communication in various ways.
  For example: To write strings on the screen we use the
  following statements:
</p><pre class="indent">
write(<span class="stri">"hello world"</span>);
writeln;
</pre><p>
  The procedure <tt><span class="func">write</span></tt> writes a given string and <tt><span class="func">writeln</span></tt> means: Write newline.
  We can also write data of various types with <tt>'write'</tt>:
</p><pre class="indent">
write(<span class="stri">"result = "</span>);
write(number <span class="keywd">div</span> 5);
write(<span class="stri">" "</span>);
writeln(<span class="keywd">not</span> error);
</pre><p>
  The <tt>'writeln'</tt> above writes data and then terminates the line.
  This is equal to a <tt>'write'</tt> followed by a <tt>'writeln'</tt>. Instead of
  multiple write statements the <tt><span class="keywd">&lt;&amp;</span></tt> operator can be used to
  concatenate the elements to be written:
</p><pre class="indent">
writeln(<span class="stri">"result = "</span> &lt;&amp; number <span class="keywd">div</span> 5 &lt;&amp; <span class="stri">" "</span> &lt;&amp; <span class="keywd">not</span> error);
</pre><p>
  The <tt><span class="keywd">&lt;&amp;</span></tt> operator needs a <tt><a class="type" href="#types_string">string</a></tt> as left operand and
  is overloaded for various types as right operand. To allow things like
</p><pre class="indent">
write(next_time &lt;&amp; <span class="stri">" \r"</span>);
</pre><p>
  the <tt><span class="keywd">&lt;&amp;</span></tt> operator is also overloaded for various types as
  left operand and a <tt><a class="type" href="#types_string">string</a></tt> as right operand.
  This allows you to concatenate several objects with <tt><span class="keywd">&lt;&amp;</span></tt> when
  at least the first or the second object is a <tt><a class="type" href="#types_string">string</a></tt>.
  We can also read data from the keyboard:
</p><pre class="indent">
write(<span class="stri">"Amount? "</span>);
read(amount);
</pre><p>
  The user is allowed to use backspace and sends the input
  to the program with the RETURN-key. To let the user respond
  with the RETURN-key we can write:
</p><pre class="indent">
writeln(<span class="stri">"Type RETURN"</span>);
readln;
</pre><p>
  To read a line of data we can use <tt>'readln'</tt>:
</p><pre class="indent">
write(<span class="stri">"Your comment? "</span>);
readln(user_comment_string);
</pre><p>
  In the previous examples all <tt>'read'</tt> statements read from the
  file <tt><span class="var">IN</span></tt> and all <tt>'write'</tt> statements write to the file <tt><span class="var">OUT</span></tt>. The
  files <tt><span class="var">IN</span></tt> and <tt><span class="var">OUT</span></tt> are initialized with <tt><span class="var">STD_IN</span></tt> and <tt><span class="var">STD_OUT</span></tt>
  which are the stdin and stdout files of the operating system.
  (Usually the keyboard and the screen). When we want to write
  to other files we use write statements with the file as first
  parameter. To write a line of text to the file <tt><span class="stri">"info.fil"</span></tt> we
  use the following statements:
</p><pre class="indent">
info_file := open(<span class="stri">"info.fil"</span>, <span class="stri">"w"</span>);
writeln(info_file, <span class="stri">"This is the first line of the info file."</span>);
close(info_file);
</pre><p>
  First the external file is opened for writing and then it is
  used. To read the file back in the string <tt>'stri'</tt> we write:
</p><pre class="indent">
info_file := open(<span class="stri">"info.fil"</span>, <span class="stri">"r"</span>);
readln(info_file, stri);
close(info_file);
</pre><p>
  It is also possible to write values of other types to
  <tt>'info_file'</tt>:
</p><pre class="indent">
writeln(info_file, number);
</pre><p>
  Here the <tt>'number'</tt> is converted to a string which is written
  to the file. A <tt>'number'</tt> is read back with:
</p><pre class="indent">
readln(info_file, number);
</pre><p>
  For doing I/O to a window on the screen we write:
</p><pre class="indent">
window1 := open_window(screen, 10, 10, 5, 60);
box(window1);
setPos(window1, 3, 1);
write(window1, <span class="stri">"hello there"</span>);
</pre><p>
  This opens the window <tt>'window1'</tt> on the <tt>'screen'</tt> at the position
  10, 10. This window has 5 lines and 60 columns. A box (of
  characters: - | + ) is written to surround the <tt>'window1'</tt> and
  finally the string <tt><span class="stri">"hello there"</span></tt> is written in the window
  <tt>'window1'</tt> at Position 3, 1. If we want to clear the <tt>'window1'</tt>
  we write:
</p><pre class="indent">
clear(window1);
</pre><p>
  Files can be used for much more things. Here is a list of
  goals for a file system:
</p><ul>
    <li>A concept which provides conversions from arbitrary
      types to strings and back.</li>

    <li>Basic input and output operations to process a file
      character wise, word wise or line wise.</li>

    <li>Input and output statements which combine input with
      conversion respectively conversion with output.</li>

    <li>Simple read and write statements for standard
      input and output for arbitrary types.</li>

    <li>Standard input and output files and the possibility
      to route the standard I/O to any file.</li>

    <li>Access to operating system files and devices.</li>

    <li>An interface which allows the user to define
      his own file types.</li>
</ul><p>
  In the following subchapters we discuss each of these goals.
</p>

<a name="file_Conversion_to_strings_and_back"><h3>8.1 Conversion to strings and back</h3></a>
<p>
    We archive the goal of doing I/O for arbitrary types with
  two conversion functions. In order to do I/O with a type
  the <tt><span class="func">str</span></tt> and <tt><span class="op">parse</span></tt> functions must be defined for that
  type. As an example we show the conversion functions for the
  type <tt><a class="type" href="#types_boolean">boolean</a></tt>:
</p><pre class="indent">
<span class="keywd">const</span> <span class="type">func string</span>: str (<span class="keywd">in</span> <span class="type">boolean</span>: aBool) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> aBool <span class="keywd">then</span>
      stri := <span class="stri">"TRUE"</span>;
    <span class="keywd">else</span>
      stri := <span class="stri">"FALSE"</span>;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;

<span class="keywd">const</span> <span class="type">func boolean</span>: (<span class="keywd">attr</span> <span class="type">boolean</span>) parse (<span class="keywd">in</span> <span class="type">string</span>: stri) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: aBoolean <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> stri = <span class="stri">"TRUE"</span> <span class="keywd">then</span>
      aBoolean := TRUE;
    <span class="keywd">elsif</span> stri = <span class="stri">"FALSE"</span> <span class="keywd">then</span>
      aBoolean := FALSE;
    <span class="keywd">else</span>
      raise RANGE_ERROR;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre><p>
  The <tt><span class="func">str</span></tt> function must deliver a corresponding string for
  every value of the type. The <tt><span class="keywd">parse</span></tt> operator parses a string
  and delivers the converted value as result. If the conversion
  is not successful the exception <tt><a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a></tt> is raised. The
  attribute used with <tt><span class="op">parse</span></tt> allows that it is overloaded for
  different types.
</p><p>
  After defining the <tt><span class="func">str</span></tt> and <tt><span class="op">parse</span></tt> functions for a type the
  <tt><span class="func">enable_io</span></tt> function can be called for this type as in:
</p><pre class="indent">
enable_io(<span class="type">boolean</span>);
</pre><p>
  The <tt><span class="func">enable_io</span></tt> template declares various io functions like
  <tt>'read'</tt>, <tt>'write'</tt> and others for the provided type (in this
  example <tt><a class="type" href="#types_boolean">boolean</a></tt>). If only output (or only input) is needed
  for a type it is possible to define just <tt><span class="func">str</span></tt> (or <tt><span class="op">parse</span></tt>)
  and activate just <tt><span class="func">enable_output</span></tt> (or <tt><span class="func">enable_input</span></tt>).
</p><p>
  There is also a formatting operator called <tt><span class="keywd">lpad</span></tt> which is based
  on the <tt><span class="func">str</span></tt> function. The statements
</p><pre class="indent">
write(12 <span class="keywd">lpad</span> 6);
write(3 <span class="keywd">lpad</span> 6);
writeln(45 <span class="keywd">lpad</span> 6);
write(678 <span class="keywd">lpad</span> 6);
write(98765 <span class="keywd">lpad</span> 6);
writeln(4321 <span class="keywd">lpad</span> 6);
</pre><p>
  produce the following output:
</p><pre class="indent">
    12     3    45
   678 98765  4321
</pre><p>
  As we see the <tt><span class="keywd">lpad</span></tt> operator can be used to produce right
  justified output. There is also <tt><span class="keywd">rpad</span></tt> operator to produce
  left justified output. The basic definitions of the <tt><span class="keywd">lpad</span></tt>
  and <tt><span class="keywd">rpad</span></tt> operators work on strings and are as follows:
</p><pre class="indent">
<span class="keywd">const</span> <span class="type">func string</span>: (<span class="keywd">ref</span> <span class="type">string</span>: stri) lpad (<span class="keywd">in</span> <span class="type">integer</span>: leng) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: padded <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> leng > length(stri) <span class="keywd">then</span>
      padded := <span class="stri">" "</span> <span class="keywd">mult</span> leng - length(stri) & stri;
    <span class="keywd">else</span>
      padded := stri;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;

<span class="keywd">const</span> <span class="type">func string</span>: (<span class="keywd">ref</span> <span class="type">string</span>: stri) rpad (<span class="keywd">in</span> <span class="type">integer</span>: leng) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: padded <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> leng > length(stri) <span class="keywd">then</span>
      padded := stri & <span class="stri">" "</span> <span class="keywd">mult</span> leng - length(stri);
    <span class="keywd">else</span>
      padded := stri;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre><p>
  The <tt><span class="func">enable_io</span></tt> template contains definitions of <tt><span class="keywd">lpad</span></tt> and <tt><span class="keywd">rpad</span></tt>
  to work on the type specified with <tt><span class="func">enable_io</span></tt>:
</p><pre class="indent">
<span class="keywd">const</span> <span class="type">func string</span>: (<span class="keywd">in</span> <span class="type">aType</span>: aValue) lpad (<span class="keywd">in</span> <span class="type">integer</span>: leng) <span class="keywd">is</span>
  <span class="keywd">return</span> str(aValue) <span class="keywd">lpad</span> leng;

<span class="keywd">const</span> <span class="type">func string</span>: (<span class="keywd">in</span> <span class="type">aType</span>: aValue) rpad (<span class="keywd">in</span> <span class="type">integer</span>: leng) <span class="keywd">is</span>
  <span class="keywd">return</span> str(aValue) <span class="keywd">rpad</span> leng;
</pre><p>
  Values of type <tt><a class="type" href="#types_integer">integer</a></tt> and <tt><a class="type" href="#types_bigInteger">bigInteger</a></tt> can be written in
  a numeral system with a radix (base) other than 10. The
  operators <tt><span class="keywd">radix</span></tt> and <tt><span class="keywd">RADIX</span></tt> can be used for this purpose.
  E.g. the statements
</p><pre class="indent">
writeln(48879 <span class="keywd">radix</span> 16);
writeln(3735928559_ <span class="keywd">RADIX</span> 16);
</pre><p>
  produce the following output:
</p><pre class="indent">
beef
DEADBEEF
</pre><p>
  For <tt><a class="type" href="#types_float">float</a></tt> values exist additional ways to convert them to
  strings. The <tt><span class="keywd">digits</span></tt> operator allows the specification of a
  precision. E.g. the statements
</p><pre class="indent">
writeln(3.1415 <span class="keywd">digits</span> 2);
writeln(4.0 <span class="keywd">digits</span> 2);
</pre><p>
  produce the following output:
</p><pre class="indent">
3.14
4.00
</pre><p>
  A combination with the <tt><span class="keywd">lpad</span></tt> operator as in
</p><pre class="indent">
writeln(3.1415 <span class="keywd">digits</span> 2 <span class="keywd">lpad</span> 6);
writeln(99.9 <span class="keywd">digits</span> 2 <span class="keywd">lpad</span> 6);
</pre><p>
  is also possible and produces the following output:
</p><pre class="indent">
  3.14
 99.90
</pre><p>
  Scientific notation for <tt><a class="type" href="#types_float">float</a></tt> is supported with the
  conversion operator <tt><span class="keywd">sci</span></tt>. The statements
</p><pre class="indent">
writeln(0.012345 <span class="keywd">sci</span> 4);
writeln(1.2468 <span class="keywd">sci</span> 2 );
writeln(3.1415 <span class="keywd">sci</span> 0);
writeln(0.125 <span class="keywd">sci</span> 1);
writeln(0.375 <span class="keywd">sci</span> 1);
</pre><p>
  produce the following output:
</p><pre class="indent">
1.2345e-2
1.25e+0
3e+0
1.2e-1
3.8e-1
</pre><p>
  The operator <tt><span class="keywd">exp</span></tt> is used to specifie the number of exponent digits.  The statements
</p><pre class="indent">
writeln(0.012345 <span class="keywd">sci</span> 4 <span class="keywd">exp</span> 2);
writeln(1.2468e15 <span class="keywd">sci</span> 2 <span class="keywd">exp</span> 1);
writeln(3.1415 <span class="keywd">sci</span> 0 <span class="keywd">exp</span> 3);
writeln(0.125 <span class="keywd">sci</span> 1 <span class="keywd">exp</span> 2);
writeln(0.375 <span class="keywd">sci</span> 1 <span class="keywd">exp</span> 2);
</pre><p>
  produce the following output:
</p><pre class="indent">
1.2345e-02
1.25e+15
3e+000
1.2e-01
3.8e-01
</pre><p></p>

<a name="file_Basic_input_and_output_operations"><h3>8.2 Basic input and output operations</h3></a>
<p>
    To allow arbitrary user defined file-types beside the
  operating system files we chose a model in which the
  I/O methods are assigned to the type of the file-value and
  not to the type of the file-variable. This allows a file
  variable to point to any file-value. The file-variables
  have the type <tt><a class="type" href="#types_file">file</a></tt>, which is the interface type for sequencial
  files. For the operating system files and for each user
  defined file a file-type must be declared which has the
  I/O methods defined. These file-types are derived (direct
  or indirect) from the type <tt><span class="type">null_file</span></tt> for which all I/O
  methods are defined upon a base of basic string I/O
  methods. So for a new user defined file-type only the
  basic string I/O methods must be defined.
</p><p>
  The two basic I/O methods defined for <tt><span class="type">null_file</span></tt> are
</p><pre class="indent">
<span class="keywd">const</span> <span class="type">proc</span>: write (<span class="keywd">ref</span> <span class="type">null_file</span>: aFile, <span class="keywd">in</span> <span class="type">string</span>: stri) <span class="keywd">is</span> noop;
<span class="keywd">const</span> <span class="type">string</span>: gets (<span class="keywd">ref</span> <span class="type">null_file</span>: aFile, <span class="keywd">ref</span> <span class="type">integer</span>: maxLength) <span class="keywd">is</span> <span class="stri">""</span>;
</pre><p>
  A <tt><span class="func">write</span></tt> to <tt><span class="type">null_file</span></tt> with any string has no effect.
  Reading any number of characters with <tt><span class="func">gets</span></tt> from
  <tt><span class="type">null_file</span></tt> delivers the empty string. When a user defined
  file type is declared these are the two methods, which must
  be redefined, for the new file-type. Based upon these
  two methods three more methods are defined for
  <tt><span class="type">null_file</span></tt>, named  <tt><span class="func">getc</span></tt>, <tt><span class="func">getwd</span></tt> and <tt><span class="func">getln</span></tt>.
  These methods get a character, a word and a line
  respectively. A word is terminated by a space, a tab
  or a linefeed. A line is terminated by a linefeed.
  This methods need not to be redefined for a user defined
  file type but for performance reasons they can also be
  redefined. The definitions for <tt><span class="func">getc</span></tt>, <tt><span class="func">getwd</span></tt> and <tt><span class="func">getln</span></tt> for
  <tt><span class="type">null_file</span></tt> are
</p><pre class="indent">
<span class="keywd">const</span> <span class="type">func char</span>: getc (<span class="keywd">inout</span> <span class="type">null_file</span>: aFile) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">char</span>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: buffer <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    buffer := gets(aFile, 1);
    <span class="keywd">if</span> buffer = <span class="stri">""</span> <span class="keywd">then</span>
      ch := EOF;
    <span class="keywd">else</span>
      ch := buffer[1];
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;

<span class="keywd">const</span> <span class="type">func string</span>: getwd (<span class="keywd">inout</span> <span class="type">null_file</span>: aFile) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: buffer <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">repeat</span>
      buffer := gets(aFile, 1);
    <span class="keywd">until</span> buffer &lt;> <span class="stri">" "</span> <span class="keywd">and</span> buffer &lt;> <span class="stri">"\t"</span>;
    <span class="keywd">while</span> buffer &lt;> <span class="stri">" "</span> <span class="keywd">and</span> buffer &lt;> <span class="stri">"\t"</span> <span class="keywd">and</span>
        buffer &lt;> <span class="stri">"\n"</span> <span class="keywd">and</span> buffer &lt;> <span class="stri">""</span> <span class="keywd">do</span>
      stri &amp;:= buffer;
      buffer := gets(aFile, 1);
    <span class="keywd">end while</span>;
    <span class="keywd">if</span> buffer = <span class="stri">""</span> <span class="keywd">then</span>
      aFile.bufferChar := EOF;
    <span class="keywd">else</span>
      aFile.bufferChar := buffer[1];
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;

<span class="keywd">const</span> <span class="type">func string</span>: getln (<span class="keywd">inout</span> <span class="type">null_file</span>: aFile) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: buffer <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    buffer := gets(aFile, 1);
    <span class="keywd">while</span> buffer &lt;> <span class="stri">"\n"</span> <span class="keywd">and</span> buffer &lt;> <span class="stri">""</span> <span class="keywd">do</span>
      stri &amp;:= buffer;
      buffer := gets(aFile, 1);
    <span class="keywd">end while</span>;
    <span class="keywd">if</span> buffer = <span class="stri">""</span> <span class="keywd">then</span>
      aFile.bufferChar := EOF;
    <span class="keywd">else</span>
      aFile.bufferChar := buffer[1];
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre><p>
  Note that <tt><span class="func">getwd</span></tt> skips leading spaces and tabs while <tt><span class="func">getc</span></tt> and
  <tt><span class="func">getln</span></tt> do not.
  When <tt><span class="func">getc</span></tt>, <tt><span class="func">getwd</span></tt> or <tt><span class="func">getln</span></tt> is not defined for a new user defined
  file type the declarations from the <tt><span class="type">null_file</span></tt> are used instead.
  These declarations are based on the method <tt><a class="func" href="#..libraries/file_gets(inout_file,in_integer)">gets</a></tt> which must be
  defined for every new user defined file-type.
</p><p>
  Note that there is an assignment to the variable <tt>'bufferChar'</tt>.
  This variable is an element of <tt><span class="type">null_file</span></tt> and therefore also
  an element of all derived file types. This allows an
  <tt>'eoln'</tt> function to test if the last <tt><span class="func">getwd</span></tt> or <tt><span class="func">getln</span></tt> reach the end
  of a line. Here is a definition of the <tt>'eoln'</tt> function:
</p><pre class="indent">
<span class="keywd">const</span> <span class="type">func boolean</span>: eoln (<span class="keywd">in</span> <span class="type">null_file</span>: inFile) <span class="keywd">is</span>
  <span class="keywd">return</span> inFile.bufferChar = '\n';
</pre><p>
  Besides assigning a value to <tt>'bufferChar'</tt> in <tt><span class="func">getwd</span></tt> and <tt><span class="func">getln</span></tt>
  and using it in <tt>'eoln'</tt> the standard <tt><a class="type" href="#types_file">file</a></tt> functions do nothing
  with <tt>'bufferChar'</tt>. The functions of the <span class="stri">"<span class="lib">scanfile.s7i</span>"</span> library
  use the <tt>'bufferChar'</tt> variable as current character in the scan
  process. As such all functions of the <span class="stri">"<span class="lib">scanfile.s7i</span>"</span> library
  assume that the first character to be processed is always in
  <tt>'bufferChar'</tt>. Since the standard <tt><a class="type" href="#types_file">file</a></tt> functions do not have
  this behavior, care has to be taken when mixing scanner and
  file functions.
</p><p>
  The type <tt><span class="type">null_file</span></tt> provides default functions to write end-of-line:
</p><pre class="indent">
<span class="keywd">const</span> <span class="type">proc</span>: writeln (<span class="keywd">inout</span> <span class="type">null_file</span>: outFile) <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    write(outFile, <span class="stri">"\n"</span>);
  <span class="keywd">end func</span>;

<span class="keywd">const</span> <span class="type">proc</span>: writeln (<span class="keywd">inout</span> <span class="type">null_file</span>: outFile, <span class="keywd">in</span> <span class="type">string</span>: stri) <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    write(outFile, stri);
    writeln(outFile);
  <span class="keywd">end func</span>;
</pre><p>
  The next declarations allow various I/O operations for strings:
</p><pre class="indent">
<span class="keywd">const</span> <span class="type">proc</span>: read (<span class="keywd">inout</span> <span class="type">file</span>: aFile, <span class="keywd">inout</span> <span class="type">string</span>: stri) <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    stri := getwd(aFile);
    aFile.io_empty := stri = <span class="stri">""</span>;
    aFile.io_ok := TRUE;
  <span class="keywd">end func</span>;

<span class="keywd">const</span> <span class="type">proc</span>: readln (<span class="keywd">inout</span> <span class="type">file</span>: aFile, <span class="keywd">inout</span> <span class="type">string</span>: stri) <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    stri := getln(aFile);
    aFile.io_empty := stri = <span class="stri">""</span>;
    aFile.io_ok := TRUE;
  <span class="keywd">end func</span>;
</pre><p></p>

<a name="file_Input_and_output_with_conversion"><h3>8.3 Input and output with conversion</h3></a>
<p>
    Normally we need a combination of an I/O operation with
  a conversion operation. There are several functions which are
  based on the <tt><span class="func">str</span></tt> and <tt><span class="op">parse</span></tt> conversions and on the basic
  I/O-functions. The declaration of this functions is done by
  the templates <tt><span class="func">enable_io</span></tt>, <tt><span class="func">enable_input</span></tt> and <tt><span class="func">enable_output</span></tt>.
  The templates <tt><span class="func">enable_io</span></tt> and <tt><span class="func">enable_output</span></tt> define the following
  <tt><span class="func">write</span></tt> function:
</p><pre class="indent">
<span class="keywd">const</span> <span class="type">proc</span>: write (<span class="keywd">in</span> <span class="type">file</span>: aFile, <span class="keywd">in</span> <span class="type">aType</span>: aValue) <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    write(aFile, str(aValue));
  <span class="keywd">end func</span>;
</pre><p>
  The templates <tt><span class="func">enable_io</span></tt> and <tt><span class="func">enable_input</span></tt> define the following
  <tt><span class="func">read</span></tt> and <tt><span class="func">readln</span></tt> functions:
</p><pre class="indent">
<span class="keywd">const</span> <span class="type">proc</span>: read (<span class="keywd">inout</span> <span class="type">file</span>: aFile, <span class="keywd">inout</span> <span class="type">aType</span>: aValue) <span class="keywd">is func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    stri := getwd(aFile);
    aFile.io_empty := stri = <span class="stri">""</span>;
    <span class="keywd">block</span>
      aValue := <span class="type">aType</span> <span class="op">parse</span> stri;
      aFile.io_ok := TRUE;
    <span class="keywd">exception</span>
      <span class="keywd">catch</span> RANGE_ERROR:
        aFile.io_ok := FALSE;
    <span class="keywd">end block</span>;
  <span class="keywd">end func</span>;

<span class="keywd">const</span> <span class="type">proc</span>: readln (<span class="keywd">inout</span> <span class="type">file</span>: aFile, <span class="keywd">inout</span> <span class="type">aType</span>: aValue) <span class="keywd">is func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    stri := getln(aFile);
    aFile.io_empty := stri = <span class="stri">""</span>;
    <span class="keywd">block</span>
      aValue := <span class="type">aType</span> <span class="op">parse</span> stri;
      aFile.io_ok := TRUE;
    <span class="keywd">exception</span>
      <span class="keywd">catch</span> RANGE_ERROR:
        aFile.io_ok := FALSE;
    <span class="keywd">end block</span>;
  <span class="keywd">end func</span>;
</pre><p>
  The next declaration defines <tt>'backSpace'</tt>:
</p><pre class="indent">
<span class="keywd">const</span> <span class="type">proc</span>: backSpace (<span class="keywd">ref</span> <span class="type">external_file</span>: aFile) <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    write(aFile, <span class="stri">"\b \b"</span>);
  <span class="keywd">end func</span>;
</pre><p></p>

<a name="file_Simple_read_and_write_statements"><h3>8.4 Simple read and write statements</h3></a>
<p>
    The simple input/output for the standard I/O-files are
  <tt>'read'</tt> and <tt>'write'</tt> which are defined with <tt><span class="func">enable_io</span></tt>. Simple
  I/O may look like:
</p><pre class="indent">
write(<span class="stri">"Amount? "</span>);
read(amount);
</pre><p>
  <tt>'read'</tt> and <tt>'write'</tt> use the files <tt><span class="var">IN</span></tt> and <tt><span class="var">OUT</span></tt>, which are described
  in the next chapter.  Here is the definition of the <tt>'read'</tt> and
  <tt>'write'</tt> procedures done with <tt><span class="func">enable_io</span></tt>:
</p><pre class="indent">
<span class="keywd">const</span> <span class="type">proc</span>: read (<span class="keywd">inout</span> <span class="type">aType</span>: aValue) <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    read(IN, aValue);
  <span class="keywd">end func</span>;

<span class="keywd">const</span> <span class="type">proc</span>: readln (<span class="keywd">inout</span> <span class="type">aType</span>: aValue) <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    readln(IN, aValue);
  <span class="keywd">end func</span>;

<span class="keywd">const</span> <span class="type">proc</span>: write (<span class="keywd">in</span> <span class="type">aType</span>: aValue) <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    write(OUT, aValue);
  <span class="keywd">end func</span>;

<span class="keywd">const</span> <span class="type">proc</span>: writeln (<span class="keywd">in</span> <span class="type">aType</span>: aValue) <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    writeln(OUT, aValue);
  <span class="keywd">end func</span>;
</pre><p>
  Additional procedures defined outside of <tt><span class="func">enable_io</span></tt> are:
</p><pre class="indent">
<span class="keywd">const</span> <span class="type">proc</span>: readln <span class="keywd">is func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    stri := getln(IN);
    IN.io_empty := stri = <span class="stri">""</span>;
    IN.io_ok := TRUE;
  <span class="keywd">end func</span>;

<span class="keywd">const</span> <span class="type">proc</span>: writeln <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    writeln(OUT);
  <span class="keywd">end func</span>;
</pre><p>
  As an example when you call
</p><pre class="indent">
readln(number);
</pre><p>
  the readln(integer) procedure calls
</p><pre class="indent">
readln(IN, number);
</pre><p>
  if the file IN has not redefined readln(IN, integer) this
  procedure calls
</p><pre class="indent">
stri := getln(IN);
</pre><p>
  and <tt>'getln'</tt> may call gets(IN, 1) in a loop or may be defined
  for the file <tt><span class="var">IN</span></tt>. Finally the <tt><span class="op">parse</span></tt> function converts the
  string read into an <tt><a class="type" href="#types_integer">integer</a></tt> and assigns it to <tt>'number'</tt>
</p><pre class="indent">
number := <span class="type">integer</span> <span class="op">parse</span> stri;
</pre><p></p>

<a name="file_Standard_input_and_output_files"><h3>8.5 Standard input and output files</h3></a>
<p>
    The standard I/O files are <tt><span class="var">IN</span></tt> for input and <tt><span class="var">OUT</span></tt> for output.
  <tt><span class="var">IN</span></tt> and <tt><span class="var">OUT</span></tt> are <tt><a class="type" href="#types_file">file</a></tt> variables, which are defined as follows:
</p><pre class="indent">
<span class="keywd">var</span> <span class="type">file</span>: IN <span class="keywd">is</span> STD_IN;
<span class="keywd">var</span> <span class="type">file</span>: OUT <span class="keywd">is</span> STD_OUT;
</pre><p>
  The files <tt><span class="var">STD_IN</span></tt> and <tt><span class="var">STD_OUT</span></tt> are the standard input and
  output files of the operating system (Usually the keyboard and
  the screen). Because <tt><span class="var">IN</span></tt> and <tt><span class="var">OUT</span></tt> are variables redirection of
  standard input or standard output can be done easily by
  assigning a new value to them:
</p><pre class="indent">
IN := OTHER_FILE;
</pre><p>
  After that all <tt>'read'</tt> statements refer to <tt>OTHER_FILE</tt>.
  Most operating systems have also a stderr file which
  can be accessed via the name <tt><span class="var">STD_ERR</span></tt>. If you want to
  write error messages to the screen even when stdout
  is redirected elsewhere you can write:
</p><pre class="indent">
writeln(STD_ERR, <span class="stri">"ERROR MESSAGE"</span>);
</pre><p>
  To redirect the standard output to <tt>'STD_ERR'</tt> you can write:
</p><pre class="indent">
OUT := STD_ERR;
</pre><p>
  There is also a file <tt><span class="var">STD_NULL</span></tt> defined. Anything written to
  it is ignored. Reading from it does deliver empty strings.
  This file can be used to initialize file variables as in:
</p><pre class="indent">
<span class="keywd">var</span> <span class="type">file</span>: MY_FILE <span class="keywd">is</span> STD_NULL;
</pre><p>
  It is also used to represent an illegal file value, when for
  example an attempt to <tt><span class="func">open</span></tt> a <tt><a class="type" href="#types_file">file</a></tt> fails.
</p>

<a name="file_Access_to_operating_system_files"><h3>8.6 Access to operating system files</h3></a>
<p>
    The interface type <tt><a class="type" href="#types_file">file</a></tt> is also used to access
  operating system files. Usually a file variable is defined
</p><pre class="indent">
<span class="keywd">var</span> <span class="type">file</span>: my_out <span class="keywd">is</span> STD_NULL;
</pre><p>
  and the result of the <tt><span class="func">open</span></tt> function is assigned to this file
  variable
</p><pre class="indent">
my_out := open(<span class="stri">"my_file"</span>, <span class="stri">"w"</span>);
</pre><p>
  The first parameter of <tt><span class="func">open</span></tt> is the path of the file to
  be opened. Seed7 always uses the slash (<tt>'/'</tt>) as path
  delimiter. The use of a backslash in a path may raise the
  exception <tt><a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a></tt>. The second parameter of <tt><span class="func">open</span></tt>
  specifies the mode:
</p><dl><dd><dl>
    <dt>Binary mode:</dt><dd><table border="0" cellspacing="0">
      <tr><td><span class="stri">"r"</span></td>   <td>...&nbsp;</td><td>Open file for reading.</td></tr>
      <tr><td><span class="stri">"w"</span></td>   <td>...&nbsp;</td><td>Truncate to zero length or create file for writing.</td></tr>
      <tr><td><span class="stri">"a"</span></td>   <td>...&nbsp;</td><td>Append; open or create file for writing at end-of-file.</td></tr>
      <tr><td><span class="stri">"r+"</span></td>  <td>...&nbsp;</td><td>Open file for update (reading and writing).</td></tr>
      <tr><td><span class="stri">"w+"</span></td>  <td>...&nbsp;</td><td>Truncate to zero length or create file for update.</td></tr>
      <tr><td><span class="stri">"a+"</span></td>  <td>...&nbsp;</td><td>Append; open or create file for update, writing at end-of-file.</td></tr></table>
    <dt>Text mode:</dt><dd><table border="0" cellspacing="0">
      <tr><td><span class="stri">"rt"</span></td>  <td>...&nbsp;</td><td>Open file for reading.</td></tr>
      <tr><td><span class="stri">"wt"</span></td>  <td>...&nbsp;</td><td>Truncate to zero length or create file for writing.</td></tr>
      <tr><td><span class="stri">"at"</span></td>  <td>...&nbsp;</td><td>Append; open or create file for writing at end-of-file.</td></tr>
      <tr><td><span class="stri">"rt+"</span></td> <td>...&nbsp;</td><td>Open file for update (reading and writing).</td></tr>
      <tr><td><span class="stri">"wt+"</span></td> <td>...&nbsp;</td><td>Truncate to zero length or create file for update.</td></tr>
      <tr><td><span class="stri">"at+"</span></td> <td>...&nbsp;</td><td>Append; open or create file for update, writing at end-of-file.</td></tr></table>
</dl></dd></dl><p>
  Note that Seed7 defines the modes <tt><span class="stri">"r"</span></tt>, <tt><span class="stri">"w"</span></tt>, <tt><span class="stri">"a"</span></tt>, <tt><span class="stri">"r+"</span></tt>, <tt><span class="stri">"w+"</span></tt>
  and <tt><span class="stri">"a+"</span></tt> as binary modes. When <tt><span class="func">open</span></tt> is called, with a mode
  not listed in the table above, the exception <tt><a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a></tt>
  is raised. When there is not enough memory to convert <tt>'path'</tt>
  to the system path type the exception <tt><a class="exception" href="#errors_MEMORY_ERROR">MEMORY_ERROR</a></tt>
  is raised. When <tt><span class="func">open</span></tt> fails for other reasons it returns
  <tt><span class="var">STD_NULL</span></tt>. E.g.: It is not allowed to <tt><span class="func">open</span></tt> a directory.
  An attempt to <tt><span class="func">open</span></tt> a directory returns <tt><span class="var">STD_NULL</span></tt>. It is
  recommended to check the file variable after opening a file:
</p><pre class="indent">
<span class="keywd">if</span> my_out &lt;> STD_NULL <span class="keywd">then</span>
</pre><p>
  After that output to <tt>'my_out'</tt> is possible with
</p><pre class="indent">
writeln(my_out, <span class="stri">"hi there"</span>);
</pre><p>
  When processing of a file is finished it should be closed
</p><pre class="indent">
close(my_out);
</pre><p>
  Writing to a file after it has been closed results in the
  exception <tt><a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a></tt>. The following program writes
  <tt><span class="stri">"hi there"</span></tt> to the file <tt><span class="stri">"my_file"</span></tt>:
</p><pre class="indent">
$ <span class="keywd">include</span> <span class="stri">"seed7_05.s7i"</span>;

<span class="keywd">const</span> <span class="type">proc</span>: main <span class="keywd">is func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">file</span>: my_out <span class="keywd">is</span> STD_NULL;
  <span class="keywd">begin</span>
    my_out := open(<span class="stri">"my_file"</span>, <span class="stri">"w"</span>);
    <span class="keywd">if</span> my_out &lt;> STD_NULL <span class="keywd">then</span>
      writeln(my_out, <span class="stri">"hi there"</span>);
      close(my_out);
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre><p>
  Note that <tt><span class="func">open</span></tt> opens BYTE files. Writing
  a character with an ordinal >= 256 such as
</p><pre class="indent">
writeln(my_out, <span class="stri">"illegal char: \256\"</span>);
</pre><p>
  results in the exception <tt><a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a></tt>. To write Unicode
  characters other file types must be used. The libraries
  <span class="stri">"<span class="lib">utf8.s7i</span>"</span> and <span class="stri">"<span class="lib">utf16.s7i</span>"</span> provide access to UTF-8 and
  UTF-16 files. The function <tt><span class="func">open_utf8</span></tt> can be used the same
  way as <tt><span class="func">open</span></tt>:
</p><pre class="indent">
my_out := open_utf8(<span class="stri">"utf8_file"</span>, <span class="stri">"w"</span>);
</pre><p>
  An UTF-8 file accepts all Unicode characters. That way
</p><pre class="indent">
writeln(my_out, <span class="stri">"Unicode char: \256\"</span>);
</pre><p>
  works without problems. UTF-8 files are byte order independent.
  Therefore they do not need a byte order mark (BOM).
  In case a BOM is required it can be written by the user program:
</p><pre class="indent">
my_out := open_utf8(<span class="stri">"utf8_file"</span>, <span class="stri">"w"</span>);
write(<span class="stri">"\16#FEFF\"</span>);
</pre><p>
  The following example expects a mandatory BOM at the beginning of an UTF-8 file:
</p><pre class="indent">
my_out := open_utf8(<span class="stri">"utf8_file"</span>, <span class="stri">"r"</span>);
<span class="keywd">if</span> getc(my_file) &lt;> <span class="stri">'\16#FEFF\'</span> <span class="keywd">then</span>
  writeln(<span class="stri">"The BOM is missing"</span>");
<span class="keywd">else</span>
  ...
<span class="keywd">end if</span>;
</pre><p>
  Accepting an optional BOM at the beginning of an UTF-8 file is done with:
</p><pre class="indent">
my_out := open_utf8(<span class="stri">"utf8_file"</span>, <span class="stri">"r"</span>);
<span class="keywd">if</span> getc(my_file) &lt;> <span class="stri">'\16#FEFF\'</span> <span class="keywd">then</span>
  <span class="comment"># This is a file without BOM (the first character will be read later).</span>
  seek(my_file, 1);
<span class="keywd">end if</span>;
...
</pre><p>
  UTF-16 comes in two flavors UTF-16LE and UTF-16BE. To support
  both flavors the <span class="stri">"<span class="lib">utf16.s7i</span>"</span> library defines several functions.
</p><p>
  The function <tt><span class="func">open_utf16</span></tt> opens an Unicode file which uses the
  UTF-16LE or UTF-16BE encoding. The function <tt><span class="func">open_utf16</span></tt> checks for
  a BOM and depending on that it opens an UTF-16LE or UTF-16BE file.
</p><p>
  The functions <tt><span class="func">open_utf16le</span></tt> and <tt><span class="func">open_utf16be</span></tt> open Unicode files
  with the UTF-16LE and UTF-16BE encoding respectively. When the
  file is opened with one of the modes <tt><span class="stri">"w"</span></tt>, <tt><span class="stri">"w+"</span></tt>, <tt><span class="stri">"wt"</span></tt> or <tt><span class="stri">"wt+"</span></tt> an
  appropriate BOM is created. When the file is opened with any other
  mode the application program is in charge to handle optional BOM
  markers. This way <tt><span class="func">open_utf16le</span></tt> and <tt><span class="func">open_utf16be</span></tt> can be used
  to open existing files without BOM.
</p><p>
  External BYTE files use the implementation type <tt><span class="type">external_file</span></tt>.
  The type <tt><span class="type">external_file</span></tt> is defined as:
</p><pre class="indent">
<span class="keywd">const</span> <span class="type">type</span>: external_file <span class="keywd">is sub</span> <span class="type">null_file</span> <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">clib_file</span>: ext_file <span class="keywd">is</span> PRIMITIVE_null_file;
    <span class="keywd">var</span> <span class="type">string</span>: name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">end struct</span>;
</pre><p>
  This means that every data item of the type <tt><span class="type">external_file</span></tt>
  has the elements from <tt><span class="type">null_file</span></tt> and additionally the
  elements <tt>'ext_file'</tt> and <tt>'name'</tt>. The type <tt><span class="type">clib_file</span></tt>
  points directly to an operating system file. Objects
  of type <tt><span class="type">clib_file</span></tt> can only have operating system
  files as values while objects of type <tt><a class="type" href="#types_file">file</a></tt> can also have
  other files as values. To allow the implementation of the
  type <tt><span class="type">external_file</span></tt> several operations for the type
  <tt><span class="type">clib_file</span></tt> are defined. But outside <tt><span class="type">external_file</span></tt> the
  type <tt><span class="type">clib_file</span></tt> and its operations should not be used.
</p><p>
  There are three predefined external files <tt><span class="var">STD_IN</span></tt>, <tt><span class="var">STD_OUT</span></tt>
  and <tt><span class="var">STD_ERR</span></tt> which have the following declarations:
</p><pre class="indent">
<span class="keywd">const</span> <span class="type">func external_file</span>: INIT_STD_FILE (<span class="keywd">ref</span> <span class="type">clib_file</span>: primitive_file,
    <span class="keywd">in</span> <span class="type">string</span>: file_name) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">external_file</span>: standardFile <span class="keywd">is</span> <span class="type">external_file</span>.value;
  <span class="keywd">begin</span>
    standardFile.ext_file := primitive_file;
    standardFile.name := file_name;
  <span class="keywd">end func</span>;

<span class="keywd">var</span> <span class="type">external_file</span>: STD_IN <span class="keywd">is</span>  INIT_STD_FILE(PRIMITIVE_INPUT,  <span class="stri">"STD_IN"</span>);
<span class="keywd">var</span> <span class="type">external_file</span>: STD_OUT <span class="keywd">is</span> INIT_STD_FILE(PRIMITIVE_OUTPUT, <span class="stri">"STD_OUT"</span>);
<span class="keywd">var</span> <span class="type">external_file</span>: STD_ERR <span class="keywd">is</span> INIT_STD_FILE(PRIMITIVE_ERROR,  <span class="stri">"STD_ERR"</span>);
</pre><p>
  It is possible to do I/O directly with them, but it is more wisely
  to use them only to initialize user defined file variables as in:
</p><pre class="indent">
<span class="keywd">var</span> <span class="type">file</span>: err <span class="keywd">is</span> STD_ERR;
</pre><p>
  In the rest of the program references to such a variable can be
  used:
</p><pre class="indent">
writeln(err, <span class="stri">"Some error occurred"</span>);
</pre><p>
  In this case redirection of the file <tt>'err'</tt> can be done very easy.
  Another way to access external files is to use the function
  <tt><span class="func">open</span></tt>. The modes used by <tt><span class="func">open</span></tt> differ from those used
  by the <tt>'fopen'</tt> function in the C library.
  The following table compares the file modes of Seed7 and C:
</p><dl><dd><table border="1" cellspacing="0" cellpadding="5">
    <tr><td>Seed7 <tt>'open'</tt> mode</td>   <td>C <tt>'fopen'</tt> mode</td></tr>
    <tr><td><span class="stri">"r"</span></td>                 <td><span class="stri">"rb"</span></td></tr>
    <tr><td><span class="stri">"w"</span></td>                 <td><span class="stri">"wb"</span></td></tr>
    <tr><td><span class="stri">"a"</span></td>                 <td><span class="stri">"ab"</span></td></tr>
    <tr><td><span class="stri">"r+"</span></td>                <td><span class="stri">"rb+"</span></td></tr>
    <tr><td><span class="stri">"w+"</span></td>                <td><span class="stri">"wb+"</span></td></tr>
    <tr><td><span class="stri">"a+"</span></td>                <td><span class="stri">"ab+"</span></td></tr>
    <tr><td><span class="stri">"rt"</span></td>                <td><span class="stri">"r"</span></td></tr>
    <tr><td><span class="stri">"wt"</span></td>                <td><span class="stri">"w"</span></td></tr>
    <tr><td><span class="stri">"at"</span></td>                <td><span class="stri">"a"</span></td></tr>
    <tr><td><span class="stri">"rt+"</span></td>               <td><span class="stri">"r+"</span></td></tr>
    <tr><td><span class="stri">"wt+"</span></td>               <td><span class="stri">"w+"</span></td></tr>
    <tr><td><span class="stri">"at+"</span></td>               <td><span class="stri">"a+"</span></td></tr>
</table></dd></dl><p>
  The difference between binary and text mode is as follows:
</p><ul>
    <li>Binary mode provides an implementation independent
      behavior on all operating systems. In binary mode no
      conversion to and from the line end character (<tt><span class="stri">'\n'</span></tt>)
      is done. This has the advantage that an <tt><span class="type">external_file</span></tt>
      written in binary mode is identical on all operating
      systems. Reading files with different line endings
      (<tt><span class="stri">"\n"</span></tt> and <tt><span class="stri">"\r\n"</span></tt>) is supported by every <tt><span class="type">external_file</span></tt>:
      The functions <tt><span class="func">getwd</span></tt>, <tt><span class="func">getln</span></tt>, <tt><span class="func">read</span></tt> and <tt><span class="func">readln</span></tt>, of
      <tt><span class="type">external_file</span></tt> skip a carriage return (<tt><span class="stri">'\r'</span></tt>) when it
      is just before a linefeed (<tt><span class="stri">'\n'</span></tt>). The rest of the
      <tt><span class="type">external_file</span></tt> functions like <tt><span class="func">getc</span></tt> and <tt><span class="func">gets</span></tt> deliver
      line endings unchanged.
</li>
    <li>The behavior of an <tt><span class="type">external_file</span></tt> in text mode is
      implementation dependent. Under Unix/Linux/Bsd text and
      binary modes are identical. Other operating systems
      prefer to do some line end conversions in text mode:
      When reading a file all occurrences of <tt><span class="stri">"\r\n"</span></tt> are
      converted to <tt><span class="stri">'\n'</span></tt>. When writing to a file all
      occurrences of <tt><span class="stri">'\n'</span></tt> are converted to <tt><span class="stri">"\r\n"</span></tt>. Note that
      text mode cannot be used to automatically create files
      with <tt><span class="stri">"\r\n"</span></tt> line endings under Unix/Linux/Bsd.</li>
</ul><p>
  The library <span class="stri">"<span class="lib">utf8.s7i</span>"</span> defines the
  implementation type <tt><span class="type">utf8_file</span></tt> as
</p><pre class="indent">
<span class="keywd">const</span> <span class="type">type</span>: utf8_file <span class="keywd">is sub</span> <span class="type">external_file</span> <span class="keywd">struct</span>
  <span class="keywd">end struct</span>;
</pre><p></p>

<a name="file_Keyboard_file"><h3>8.7 Keyboard file</h3></a>
<p>
    As stated earlier <tt><span class="var">STD_IN</span></tt> provides an interface to the keyboard
  which is line buffered and echoed on <tt><span class="var">STD_OUT</span></tt>. This means that
  you can see everything you typed. Additionally you can correct
  your input with BACKSPACE until you press RETURN. But sometimes
  an unbuffered and unechoed input is needed. This is provided in
  the library <span class="stri">"<span class="lib">keybd.s7i</span>"</span>, which defines the type <tt><span class="type">keyboard_file</span></tt>
  and the file <tt><span class="var">KEYBOARD</span></tt>. Characters typed at the keyboard are
  queued (first in first out) and can be read directly from
  <tt><span class="var">KEYBOARD</span></tt> without any possibility to correct. Additionally
  <tt><span class="var">KEYBOARD</span></tt> does not echo the characters. Reading from <tt><span class="var">KEYBOARD</span></tt>
  delivers normal Unicode characters or special codes (which may be
  or may not be Unicode characters) for function and cursor keys.
  Unicode characters and special codes both are <tt><a class="type" href="#types_char">char</a></tt> values. The
  library <span class="stri">"<span class="lib">keybd.s7i</span>"</span> defines <tt><a class="type" href="#types_char">char</a></tt> constants for various keys:
</p><dl><dd><table border="1" cellspacing="0" cellpadding="5">
    <tr><td>Key character constant</td>     <td>Description</td></tr>
    <tr><td><tt>KEY_CTL_A</tt> to <tt>KEY_CTL_Z</tt></td>     <td>The control keys ctrl-a to ctrl-z</td></tr>
    <tr><td><tt>KEY_ALT_A</tt> to <tt>KEY_ALT_Z</tt></td>     <td>The alternate keys alt-a to alt-z</td></tr>
    <tr><td><tt>KEY_ALT_0</tt> to <tt>KEY_ALT_9</tt></td>     <td>The alternate keys alt-0 to alt-9</td></tr>
    <tr><td><tt>KEY_F1</tt> to <tt>KEY_F10</tt></td>          <td>Function keys F1 to F10</td></tr>
    <tr><td><tt>KEY_SFT_F1</tt> to <tt>KEY_SFT_F10</tt></td>  <td>Shifted function keys F1 to F10</td></tr>
    <tr><td><tt>KEY_CTL_F1</tt> to <tt>KEY_CTL_F10</tt></td>  <td>Control function keys F1 to F10</td></tr>
    <tr><td><tt>KEY_ALT_F1</tt> to <tt>KEY_ALT_F10</tt></td>  <td>Alternate function keys F1 to F10</td></tr>
    <tr><td><tt>KEY_BS</tt></td>                     <td>Backspace (equal to KEY_CTL_H)</td></tr>
    <tr><td><tt>KEY_TAB</tt></td>                    <td>Horizontal Tab (equal to KEY_CTL_H)</td></tr>
    <tr><td><tt>KEY_NL</tt></td>                     <td>Newline/enter/return key (equal to KEY_CTL_J)</td></tr>
    <tr><td><tt>KEY_CR</tt></td>                     <td>Carriage return (equal to KEY_CTL_M)</td></tr>
    <tr><td><tt>KEY_ESC</tt></td>                    <td>Escape key</td></tr>
    <tr><td><tt>KEY_NULCHAR</tt></td>                <td>Nul character key</td></tr>
    <tr><td><tt>KEY_BACKTAB</tt></td>                <td>Horizontal back tab</td></tr>
    <tr><td><tt>KEY_LEFT</tt></td>                   <td>Cursor left</td></tr>
    <tr><td><tt>KEY_RIGHT</tt></td>                  <td>Cursor right</td></tr>
    <tr><td><tt>KEY_UP</tt></td>                     <td>Cursor up</td></tr>
    <tr><td><tt>KEY_DOWN</tt></td>                   <td>Cursor down</td></tr>
    <tr><td><tt>KEY_HOME</tt></td>                   <td>Home key</td></tr>
    <tr><td><tt>KEY_END</tt></td>                    <td>End key</td></tr>
    <tr><td><tt>KEY_PGUP</tt></td>                   <td>Page up</td></tr>
    <tr><td><tt>KEY_PGDN</tt></td>                   <td>Page down</td></tr>
    <tr><td><tt>KEY_INS</tt></td>                    <td>Insert key</td></tr>
    <tr><td><tt>KEY_DEL</tt></td>                    <td>Delete key</td></tr>
    <tr><td><tt>KEY_PAD_CENTER</tt></td>             <td>Numeric keypad center key</td></tr>
    <tr><td><tt>KEY_CTL_LEFT</tt></td>               <td>Control cursor left</td></tr>
    <tr><td><tt>KEY_CTL_RIGHT</tt></td>              <td>Control cursor right</td></tr>
    <tr><td><tt>KEY_CTL_UP</tt></td>                 <td>Control cursor up</td></tr>
    <tr><td><tt>KEY_CTL_DOWN</tt></td>               <td>Control cursor down</td></tr>
    <tr><td><tt>KEY_CTL_HOME</tt></td>               <td>Control home key</td></tr>
    <tr><td><tt>KEY_CTL_END</tt></td>                <td>Control end key</td></tr>
    <tr><td><tt>KEY_CTL_PGUP</tt></td>               <td>Control page up</td></tr>
    <tr><td><tt>KEY_CTL_PGDN</tt></td>               <td>Control page down</td></tr>
    <tr><td><tt>KEY_CTL_INS</tt></td>                <td>Control insert key</td></tr>
    <tr><td><tt>KEY_CTL_DEL</tt></td>                <td>Control delete key</td></tr>
    <tr><td><tt>KEY_SCRLUP</tt></td>                 <td>Scroll up key</td></tr>
    <tr><td><tt>KEY_SCRLDN</tt></td>                 <td>Scroll down key</td></tr>
    <tr><td><tt>KEY_INSLN</tt></td>                  <td>Insert line key</td></tr>
    <tr><td><tt>KEY_DELLN</tt></td>                  <td>Delete line key</td></tr>
    <tr><td><tt>KEY_ERASE</tt></td>                  <td>Erase key</td></tr>
    <tr><td><tt>KEY_CTL_NL</tt></td>                 <td>Control newline/enter/return key</td></tr>
    <tr><td><tt>KEY_NULLCMD</tt></td>                <td>Null command of window manager</td></tr>
    <tr><td><tt>KEY_REDRAW</tt></td>                 <td>Redraw command of window manager</td></tr>
    <tr><td><tt>KEY_NEWWINDOW</tt></td>              <td>New window command of window manager</td></tr>
    <tr><td><tt>KEY_MOUSE1</tt></td>                 <td>Mouse key 1 (counted from left)</td></tr>
    <tr><td><tt>KEY_MOUSE2</tt></td>                 <td>Mouse key 2 (counted from left)</td></tr>
    <tr><td><tt>KEY_MOUSE3</tt></td>                 <td>Mouse key 3 (counted from left)</td></tr>
    <tr><td><tt>KEY_MOUSE4</tt></td>                 <td>Mouse key 4 (counted from left)</td></tr>
    <tr><td><tt>KEY_MOUSE5</tt></td>                 <td>Mouse key 5 (counted from left)</td></tr>
    <tr><td><tt>KEY_UNDEF</tt></td>                  <td>Undefined key</td></tr>
    <tr><td><tt>KEY_NONE</tt></td>                   <td>No key pressed (returned by busy_getc)</td></tr>
</table></dd></dl><p>
  The following example uses the <tt><a class="type" href="#types_char">char</a></tt> constant <tt>'KEY_UP'</tt>:
</p><pre class="indent">
$ <span class="keywd">include</span> <span class="stri">"seed7_05.s7i"</span>;
  <span class="keywd">include</span> <span class="stri">"keybd.s7i"</span>;

<span class="keywd">const</span> <span class="type">proc</span>: main <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    writeln(<span class="stri">"Please press cursor up"</span>);
    <span class="keywd">while</span> getc(KEYBOARD) &lt;> KEY_UP <span class="keywd">do</span>
      writeln(<span class="stri">"This was not cursor up"</span>);
    <span class="keywd">end while</span>;
    writeln(<span class="stri">"Cursor up was pressed"</span>);
  <span class="keywd">end func</span>;
</pre><p>
  Programs should use the <tt><a class="type" href="#types_char">char</a></tt> constants defined in <span class="stri">"<span class="lib">keybd.s7i</span>"</span>
  to deal with function and cursor keys, since the special key
  codes may change in future versions of Seed7.
</p><p>
  Additionally to the operations possible with a <tt><a class="type" href="#types_file">file</a></tt> there
  are two functions that are applicable only to files of type
  <tt><span class="type">keyboard_file</span></tt>:
</p><ul>
    <li><tt><span class="func">busy_getc</span></tt>, which delivers the next character
      from the keyboard or <tt>'KEY_NONE'</tt> if no key has been pressed.</li>
    <li><tt><span class="func">keypressed</span></tt>, which returns TRUE if a character
      is available from the keyboard and FALSE otherwise.</li>
</ul><p>
  Note that <tt><span class="func">keypressed</span></tt> does not actually read a character. Reading
  must be done with a different function after <tt><span class="func">keypressed</span></tt> returns
  TRUE. Both functions (<tt><span class="func">busy_getc</span></tt> and <tt><span class="func">keypressed</span></tt>) are useful
  when user input is allowed while some processing takes place.
  The following program uses <tt><span class="func">busy_getc</span>(<span class="var">KEYBOARD</span>)</tt> to display
  the time until a key is pressed:
</p><pre class="indent">
$ <span class="keywd">include</span> <span class="stri">"seed7_05.s7i"</span>;
  <span class="keywd">include</span> <span class="stri">"time.s7i"</span>;
  <span class="keywd">include</span> <span class="stri">"keybd.s7i"</span>;

<span class="keywd">const</span> <span class="type">proc</span>: main <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    writeln;
    <span class="keywd">while</span> busy_getc(KEYBOARD) = KEY_NONE <span class="keywd">do</span>
      write(time(NOW) &lt;&amp; <span class="stri">"\r"</span>);
      flush(OUT);
    <span class="keywd">end while</span>;
    writeln;
    writeln;
  <span class="keywd">end func</span>;
</pre><p>
  Seed7 programs can run in two modes:
</p><ul>
    <li>Console mode, where the program runs in a console/terminal window (the default).</li>
    <li>Graphics mode, where the program has its own graphic window.</li>
</ul><p>
  This two modes are supported with two basic keyboard files:
</p><ul>
    <li><tt><span class="var">CONSOLE_KEYBOARD</span></tt>, which uses a terminfo or console driver.</li>
    <li><tt><span class="var">GRAPH_KEYBOARD</span></tt>, which uses a X11 or GDI driver.</li>
</ul><p>
  The file <tt><span class="var">KEYBOARD</span></tt> is actually a variable which refers to one
  of the two basic keyboard files.  The declaration of the type
  <tt><span class="type">keyboard_file</span></tt> and the file <tt><span class="var">KEYBOARD</span></tt> in <span class="stri">"<span class="lib">keybd.s7i</span>"</span> is:
</p><pre class="indent">
<span class="keywd">const</span> <span class="type">type</span>: keyboard_file <span class="keywd">is</span> <span class="type">subtype file</span>;

<span class="keywd">var</span> <span class="type">keyboard_file</span>: KEYBOARD <span class="keywd">is</span> CONSOLE_KEYBOARD;
</pre><p>
  Graphic programs switch to to the <tt><span class="var">GRAPH_KEYBOARD</span></tt> driver with:
</p><pre class="indent">
KEYBOARD := GRAPH_KEYBOARD;
</pre><p>
  Some file types are defined to support the <tt><span class="var">KEYBOARD</span></tt>. One such
  file type is <tt><span class="type">echo_file</span></tt>, which is defined in the library <span class="stri">"<span class="lib">echo.s7i</span>"</span>.
  An <tt><span class="type">echo_file</span></tt> file can be used to write input characters to
  an output file. This is useful since <tt><span class="var">KEYBOARD</span></tt> does not echo its
  input, but <tt><span class="type">echo_file</span></tt> is not restricted to support <tt><span class="var">KEYBOARD</span></tt>.
  The following program writes echoes of the keys typed and exits as
  soon as a <tt><span class="stri">'!'</span></tt> is encountered:
</p><pre class="indent">
$ <span class="keywd">include</span> <span class="stri">"seed7_05.s7i"</span>;
  <span class="keywd">include</span> <span class="stri">"keybd.s7i"</span>;
  <span class="keywd">include</span> <span class="stri">"echo.s7i"</span>;

<span class="keywd">const</span> <span class="type">proc</span>: main <span class="keywd">is func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">char</span>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    IN := open_echo(KEYBOARD, OUT);
    <span class="keywd">repeat</span>
      ch := getc(IN);
    <span class="keywd">until</span> ch = <span class="stri">'!'</span>;
    writeln;
  <span class="keywd">end func</span>;
</pre><p>
  An <tt><span class="type">echo_file</span></tt> checks also for control-C (KEY_CTL_C). When
  control-C is typed an <tt><span class="type">echo_file</span></tt> asks if the program should be
  terminated:
</p><pre class="indent">
terminate (y/n)?
</pre><p>
  Answering <tt>'y'</tt> or <tt>'Y'</tt> is interpreted as <tt>'yes'</tt> and the program
  is terminated with the following message:
</p><pre class="indent">
*** PROGRAM TERMINATED BY USER
</pre><p>
  Any other input removes the question and the program continues
  to read input.
</p><p>
  Another helpful file type is <tt><span class="type">line_file</span></tt>, which is defined in the
  library <span class="stri">"<span class="lib">line.s7i</span>"</span>. A <tt><span class="type">line_file</span></tt> allows to correct the input with
  BACKSPACE until a RETURN (represented with <tt><span class="stri">'\n'</span></tt>) is encountered.
  In contrast to this editing feature the possibility to edit a line
  of <tt><span class="var">STD_IN</span></tt> is provided by the operating system. The following
  program uses <tt><span class="type">echo_file</span></tt> and <tt><span class="type">line_file</span></tt> to simulate input line
  editing:
</p><pre class="indent">
$ <span class="keywd">include</span> <span class="stri">"seed7_05.s7i"</span>;
  <span class="keywd">include</span> <span class="stri">"keybd.s7i"</span>;
  <span class="keywd">include</span> <span class="stri">"echo.s7i"</span>;
  <span class="keywd">include</span> <span class="stri">"line.s7i"</span>;

<span class="keywd">const</span> <span class="type">proc</span>: main <span class="keywd">is func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">char</span>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    IN := open_echo(KEYBOARD, OUT);
    IN := open_line(IN);
    <span class="keywd">repeat</span>
      ch := getc(IN);
      write(ch);
    <span class="keywd">until</span> ch = <span class="stri">'!'</span>;
  <span class="keywd">end func</span>;
</pre><p>
  This program terminates when a line containing <tt><span class="stri">'!'</span></tt> is confirmed
  with RETURN.
</p>

<a name="file_Files_with_line_structure"><h3>8.8 Files with line structure</h3></a>
<p>
  The library <span class="stri">"<span class="lib">text.s7i</span>"</span> defines the type <tt><a class="type" href="#types_text">text</a></tt>, which is a
  subtype of <tt><a class="type" href="#types_file">file</a></tt>. The type <tt><a class="type" href="#types_text">text</a></tt> adds a line structure and
  other features such as scrolling and color to <tt><a class="type" href="#types_file">file</a></tt>. The
  lines and columns of a <tt><a class="type" href="#types_text">text</a></tt> start with 1 in the upper left
  corner and increase downward and rightward. The function
  <tt><span class="func">setPos</span></tt> sets the current line and column of a <tt><a class="type" href="#types_text">text</a></tt>:
</p><pre class="indent">
setPos(aText, 10, 20);
</pre><p>
  The functions <tt><span class="func">setLine</span></tt> and <tt><span class="func">setColumn</span></tt> set just the
  line and column respectively:
</p><pre class="indent">
setLine(aText, 2);
setColumn(aText, 72);
</pre><p>
  The current line and column of a <tt><a class="type" href="#types_text">text</a></tt> file can be retrieved
  with <tt><span class="func">line</span></tt> and <tt><span class="func">column</span></tt>:
</p><pre class="indent">
writeln(<span class="stri">"The curent line is: "</span> &lt;& line(aText));
writeln(<span class="stri">"The curent column is: "</span> &lt;& column(aText));
</pre><p>
  The current height and width of a <tt><a class="type" href="#types_text">text</a></tt> file can be retrieved
  with <tt><span class="func">height</span></tt> and <tt><span class="func">width</span></tt>:
</p><pre class="indent">
writeln(<span class="stri">"The height is: "</span> &lt;& height(aText));
writeln(<span class="stri">"The width is: "</span> &lt;& width(aText));
</pre><p>
  To allow random access output to a text console (or text window)
  the library <span class="stri">"<span class="lib">console.s7i</span>"</span> defines the type <tt><span class="type">console_file</span></tt>. The function
</p><pre class="indent">
open(CONSOLE)
</pre><p>
  returns a <tt><span class="type">console_file</span></tt>.
</p>

<a name="file_Sockets"><h3>8.9 Sockets</h3></a>
<p>
    The library <span class="stri">"<span class="lib">socket.s7i</span>"</span> defines types and functions to
  access sockets. The implementation type for sockets is
  <tt><span class="type">socket</span></tt>. As interface type <tt><a class="type" href="#types_file">file</a></tt> is used:
</p><pre class="indent">
<span class="keywd">var</span> <span class="type">file</span>: clientSocket <span class="keywd">is</span> STD_NULL;
</pre><p>
  With <tt><span class="func">openInetSocket</span></tt> an Internet client socket can be opened:
</p><pre class="indent">
clientSocket := openInetSocket(<span class="stri">"www.google.com"</span>, 80);
</pre><p>
  The function <tt><span class="func">openInetSocket</span></tt> creates and connects a socket.
  Opening an Internet socket at the local host is also done with
  a variant of <tt><span class="func">openInetSocket</span></tt>:
</p><pre class="indent">
clientSocket := openInetSocket(1080);
</pre><p>
  Since sockets use the <tt><a class="type" href="#types_file">file</a></tt> interface functions
  like <tt><span class="func">writeln</span></tt> and <tt><span class="func">getln</span></tt> can be used:
</p><pre class="indent">
sock := openInetSocket(serverName, 80);
<span class="keywd">if</span> sock &lt;> STD_NULL <span class="keywd">then</span>
  writeln(sock, <span class="stri">"GET "</span> &lt;&amp; address &lt;&amp; <span class="stri">" HTTP/1.1"</span>);
  writeln(sock, <span class="stri">"Host: "</span> &lt;&amp; hostname);
  writeln(sock, <span class="stri">"User-Agent: BlackHole"</span>);
  writeln(sock);
  line := getln(sock);
  <span class="keywd">if</span> startsWith(line, <span class="stri">"HTTP"</span>) <span class="keywd">then</span>
    statusInfo := trim(line[pos(line, <span class="stri">" "</span>) ..]);
    statusCode := statusInfo[.. pred(pos(statusInfo, <span class="stri">" "</span>))];
  <span class="keywd">end if</span>;
<span class="keywd">end if</span>;
</pre><p>
  The example above sends a HTTP request to a server and gets
  the status code from the response. The example above consists
  of code from the library <span class="stri">"<span class="lib">gethttp.s7i</span>"</span>.
</p><p>
  Server sockets are supported with the type <tt><span class="type">listener</span></tt>.
  A listener is defined with:
</p><pre class="indent">
<span class="keywd">var</span> <span class="type">listener</span>: myListener <span class="keywd">is</span> <span class="type">listener</span>.value;
</pre><p>
  The library <span class="stri">"<span class="lib">listener.s7i</span>"</span> defines the function <tt><span class="func">openInetListener</span></tt>,
  which opens a <tt><span class="type">listener</span></tt>:
</p><pre class="indent">
aListener := openInetListener(1080);
</pre><p>
  The function <tt><span class="func">listen</span></tt> is used to listen for incoming socket
  connections of a <tt><span class="type">listener</span></tt>, and to
  limit the incoming queue:
</p><pre class="indent">
listen(aListener, 10);
</pre><p>
  The function <tt><span class="func">accept</span></tt> returns the first connected socked
  of the <tt><span class="type">listener</span></tt>:
</p><pre class="indent">
serverSocket := accept(aListener);
</pre><p>
  Together the functions above can be use to process requests without sessions:
</p><pre class="indent">
aListener := openInetListener(1080);
listen(aListener, 10);
<span class="keywd">while</span> TRUE <span class="keywd">do</span>
  sock := accept(aListener);
  <span class="comment"># Read and process the request from sock.</span>
  close(sock);
<span class="keywd">end while</span>;
</pre><p>
  A similar loop is used in the <span class="link">comanche</span> webserver (see main function).
  The function <tt><span class="func">waitForRequest</span></tt> can be used to process requests with session:
</p><pre class="indent">
aListener := openInetListener(2021);
listen(aListener, 10);
<span class="keywd">while</span> TRUE <span class="keywd">do</span>
  waitForRequest(aListener, existingConnection, newConnection);
  <span class="keywd">if</span> existingConnection &lt;> STD_NULL <span class="keywd">then</span>
    <span class="comment"># Read and process the request from existingConnection.</span>
  <span class="keywd">end if</span>;
  <span class="keywd">if</span> newConnection &lt;> STD_NULL <span class="keywd">then</span>
    <span class="comment"># Send welcome message to newConnection.</span>
  <span class="keywd">end if</span>;
<span class="keywd">end while</span>;
</pre><p>
  Similar code is used in the program <span class="stri">"ftpserv.sd7"</span>.
  The implementation of <tt><span class="func">waitForRequest</span></tt> is based on <tt><span class="type">pollData</span></tt>,
  which is defined in <span class="stri">"<span class="lib">poll.s7i</span>"</span>.
</p>

<a name="file_User_defined_file_types"><h3>8.10 User defined file types</h3></a>
<p>
    In addition to the predefined file types it is often
  necessary to define a new type of file. Such a new file
  has several possibilities:
</p><ul>
    <li>It could store its contents in a string (not only to be
      faster but also to provide additional file operations)</li>

    <li>The information can be processed (e.g. to upper case)
      and sent to another file.</li>

    <li>It could work just like an Unix utility (Think of
      more, sort, tee, uniq ...)</li>

    <li>It could provide a file-like interface for something
      with an other interface. (e.g. The contents of a
      directory, or random access I/O to the screen)</li>
</ul><p>
  With the following declaration we define a new file type:
</p><pre class="indent">
<span class="keywd">const</span> <span class="type">type</span>: my_file_type <span class="keywd">is sub</span> <span class="type">null_file</span> <span class="keywd">struct</span>
    ...
    <span class="comment">(* Local data *)</span>
    ...
  <span class="keywd">end struct</span>;
</pre><p>
  It is not necessary to derive the type <tt><span class="type">my_file_type</span></tt> directly from
  <tt><span class="type">null_file</span></tt>. The type <tt><span class="type">my_file_type</span></tt> may also be an indirect descendant
  of <tt><span class="type">null_file</span></tt>. So it is possible to create file type hierarchies.
  The interface implemented by the new file needs also to be specified:
</p><pre class="indent">
type_implements_interface(<span class="type">my_file_type</span>, <span class="type">file</span>);
</pre><p>
  The type <tt><a class="type" href="#types_file">file</a></tt> is not the only interface
  type which can be used. There is also the type <tt><a class="type" href="#types_text">text</a></tt> which
  is derived from <tt><a class="type" href="#types_file">file</a></tt>. The type <tt><a class="type" href="#types_text">text</a></tt>
  describes a line oriented file which allows <tt><span class="func">setPos</span></tt> (which moves the
  current position to the line and column specified) and other functions.
  It is also possible to define new interface types which derive
  from <tt><a class="type" href="#types_file">file</a></tt> or <tt><a class="type" href="#types_text">text</a></tt>.
</p><p>
  As next an open function is needed to open a <tt><span class="type">my_file_type</span></tt> file:
</p><pre class="indent">
<span class="keywd">const</span> <span class="type">func file</span>: open_my_file (  <span class="comment">(* Parameters *)</span> ) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">file</span>: newFile <span class="keywd">is</span> STD_NULL;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">my_file_type</span>: new_file <span class="keywd">is</span> <span class="type">my_file_type</span>.value;
  <span class="keywd">begin</span>
    ...
    <span class="comment">(* Initialization of the data elements of new_file *)</span>
    newFile := toInterface(new_file);
    ...
  <span class="keywd">end func</span>;
</pre><p>
  Note that the function <tt>'toInterface'</tt> is used to generate a new <tt><a class="type" href="#types_file">file</a></tt>
  object. Now only the two basic I/O operations must be defined:
</p><pre class="indent">
<span class="keywd">const</span> <span class="type">proc</span>: write (<span class="keywd">inout</span> <span class="type">my_file_type</span>: new_fil, <span class="keywd">in</span> <span class="type">string</span>: stri) <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    ...
    <span class="comment">(* Statements that do the output *)</span>
    ...
  <span class="keywd">end func</span>;

<span class="keywd">const</span> <span class="type">proc</span>: gets (<span class="keywd">inout</span> <span class="type">my_file_type</span>: new_fil, <span class="keywd">in</span> <span class="type">integer</span>: leng) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> "";
  <span class="keywd">begin</span>
    ...
    <span class="comment">(* Statements that do the input *)</span>
    ...
  <span class="keywd">end func</span>;
</pre><p></p>

<a name="file_Scanning_a_file"><h3>8.11 Scanning a file</h3></a>
<p>
    The I/O concept introduced in the previous chapters separates
  the input of data from its conversion. The <tt><span class="func">read</span></tt>, <tt><span class="func">readln</span></tt>,
  <tt><span class="func">getwd</span></tt> and <tt><span class="func">getln</span></tt> functions are designed to read whitespace
  separated data elements. When the data elements are not separated
  by whitespace characters this I/O concept is not possible.
  Instead the functions which read from the file need some
  knowledge about the type which they intend to read. Fortunately
  this is a well researched area. The lexical scanners used by
  compilers solve exactly this problem.
</p><p>
  Lexical scanners read symbols from a file and use the concept of
  a current character. A symbol can be a name, a number, a string,
  an operator, a parenthesis or something else. The current
  character is the first character to be processed when scanning a
  symbol. After a scanner has read a symbol the current character
  contains the character just after the symbol. This character
  could be the first character of the next symbol or some
  whitespace character. If the set of symbols is chosen wisely all
  decisions about the type of the symbol and when to stop reading
  characters for a symbol can be done based on the current
  character.
</p><p>
  Every <tt><a class="type" href="#types_file">file</a></tt> contains a <tt>'bufferChar'</tt> variable which is used as
  current character by the scanner functions defined in the
  <span class="stri">"<span class="lib">scanfile.s7i</span>"</span> library. The <span class="stri">"<span class="lib">scanfile.s7i</span>"</span> library contains
  skip... and get... functions. The skip... procedures return void
  and are used to skip input while the get... functions return the
  string of characters they have read. The following basic scanner
  functions are defined in the <span class="stri">"<span class="lib">scanfile.s7i</span>"</span> library:
</p><dl>
    <dt><span class="func">skipComment</span></dt>
      <dd>Skips a possibly nested comment from a <tt><a class="type" href="#types_file">file</a></tt>.</dd>
    <dt><span class="func">getComment</span></dt>
      <dd>Reads a possibly nested comment from a <tt><a class="type" href="#types_file">file</a></tt>.</dd>
    <dt><span class="func">skipLineComment</span></dt>
      <dd>Skips a line comment from a <tt><a class="type" href="#types_file">file</a></tt>.</dd>
    <dt><span class="func">getLineComment</span></dt>
      <dd>Reads a line comment from a <tt><a class="type" href="#types_file">file</a></tt>.</dd>
    <dt><span class="func">getDigits</span></dt>
      <dd>Reads a sequence of digits from a <tt><a class="type" href="#types_file">file</a></tt>.</dd>
    <dt><span class="func">getNumber</span></dt>
      <dd>Reads a numeric literal from a <tt><a class="type" href="#types_file">file</a></tt>.</dd>
    <dt><span class="func">getNonDigits</span></dt>
      <dd>Reads a sequence of non digits from a <tt><a class="type" href="#types_file">file</a></tt>.</dd>
    <dt><span class="func">getQuotedText</span></dt>
      <dd>Reads a text quoted with " or ' from a <tt><a class="type" href="#types_file">file</a></tt>.</dd>
    <dt><span class="func">getCharLiteral</span></dt>
      <dd>Reads a character literal from a <tt><a class="type" href="#types_file">file</a></tt>.</dd>
    <dt><span class="func">getStringLiteral</span></dt>
      <dd>Reads a string literal from a <tt><a class="type" href="#types_file">file</a></tt>.</dd>
    <dt><span class="func">getName</span></dt>
      <dd>Reads an alphanumeric name from a <tt><a class="type" href="#types_file">file</a></tt>.</dd>
</dl><p>
  Contrary to <tt><span class="func">read</span></tt> and <tt><span class="func">getwd</span></tt> basic scanner functions
  do not skip leading whitespace characters. To skip whitespace
  characters one of the following functions can be used:
</p><dl>
    <dt><span class="func">skipSpace</span></dt>
      <dd>Skips space characters from a <tt><a class="type" href="#types_file">file</a></tt>.</dd>
    <dt><span class="func">skipWhiteSpace</span></dt>
      <dd>Skips whitespace characters from a <tt><a class="type" href="#types_file">file</a></tt>.</dd>
    <dt><span class="func">getWhiteSpace</span></dt>
      <dd>Reads whitespace characters from a <tt><a class="type" href="#types_file">file</a></tt>.</dd>
    <dt><span class="func">getWord</span></dt>
      <dd>Reads a white space delimited word from a <tt><a class="type" href="#types_file">file</a></tt>.</dd>
    <dt><span class="func">skipLine</span></dt>
      <dd>Skips a line from a <tt><a class="type" href="#types_file">file</a></tt>.</dd>
    <dt><span class="func">getLine</span></dt>
      <dd>Reads a line from a <tt><a class="type" href="#types_file">file</a></tt>.</dd>
</dl><p>
  The advanced scanner functions do skip whitespace characters
  before reading a symbol:
</p><dl>
    <dt><span class="func">getSymbolOrComment</span></dt>
      <dd>Reads a symbol or a comment from a <tt><a class="type" href="#types_file">file</a></tt>.</dd>
    <dt><span class="func">getSymbol</span></dt>
      <dd>Reads a symbol from a <tt><a class="type" href="#types_file">file</a></tt>.</dd>
    <dt><span class="func">getSymbolWithHtmlEntities</span></dt>
      <dd>Reads a symbol, where html entities are allowed, from a <tt><a class="type" href="#types_file">file</a></tt>.</dd>
    <dt><span class="func">getHtmlTagSymbolOrComment</span></dt>
      <dd>Reads a HTML tag, a symbol or a comment from a <tt><a class="type" href="#types_file">file</a></tt>.</dd>
    <dt><span class="func">skipXmlComment</span></dt>
      <dd>Skips a XML comment from a <tt><a class="type" href="#types_file">file</a></tt>.</dd>
    <dt><span class="func">getXmlTagOrContent</span></dt>
      <dd>Reads a XML/HTML tag or the XML/HTML content text from a <tt><a class="type" href="#types_file">file</a></tt>.</dd>
    <dt><span class="func">getXmlCharacterReference</span></dt>
      <dd>Reads a predefined XML entity from a <tt><a class="type" href="#types_file">file</a></tt>.</dd>
    <dt><span class="func">getXmlTagHeadOrContent</span></dt>
      <dd>Reads a XML/HTML tag head or a XML/HTML content from a <tt><a class="type" href="#types_file">file</a></tt>.</dd>
    <dt><span class="func">getSymbolInXmlTag</span></dt>
      <dd>Reads a symbol which can appear inside a XML/HTML tag from a <tt><a class="type" href="#types_file">file</a></tt>.</dd>
    <dt><span class="func">getNextXmlAttribute</span></dt>
      <dd>Reads name and value of an attribute inside a XML tag from <tt><a class="type" href="#types_file">file</a></tt>.</dd>
    <dt><span class="func">getHtmlAttributeValue</span></dt>
      <dd>Reads a HTML tag attribute value from a <tt><a class="type" href="#types_file">file</a></tt>.</dd>
    <dt><span class="func">getNextHtmlAttribute</span></dt>
      <dd>Reads name and value of an attribute inside a HTML tag from a <tt><a class="type" href="#types_file">file</a></tt>.</dd>
    <dt><span class="func">getSimpleSymbol</span></dt>
      <dd>Reads a simple symbol from a <tt><a class="type" href="#types_file">file</a></tt>.</dd>
</dl><p>
  All scanner functions assume that the first character to be
  processed is in <tt>'bufferChar'</tt> and after they are finished the next
  character which should be processed is also in <tt>'bufferChar'</tt>.
  To use scanner functions for a new opened file it is necessary to
  assign the first character to the <tt>'bufferChar'</tt> with:
</p><pre class="indent">
myFile.bufferChar := getc(myFile);
</pre><p>
  In most cases whole files are either processed with normal I/O
  functions or with scanner functions. When normal I/O functions
  need to be combined with scanner functions care has to be taken:
</p><ul>
    <li>When the last function which read from a file was
      one of <tt><span class="func">read</span></tt>, <tt><span class="func">readln</span></tt>, <tt><span class="func">getwd</span></tt> or <tt><span class="func">getln</span></tt>
      the <tt>'bufferChar'</tt> already contains the character which
      should be processed next and therefore subsequent scanner
      functions can be used.</li>

    <li>Other I/O functions like <tt><span class="func">getc</span></tt> and <tt><span class="func">gets</span></tt>
      do not assign something to <tt>'bufferChar'</tt>. In this
      case something should be assigned to <tt>'bufferChar'</tt>.</li>

    <li>Switching back from scanner functions to
      normal I/O functions is best done when the content of
      <tt>'bufferChar'</tt> is known. For example at the end
      of the line.</li>
</ul><p>
  Scanner functions are helpful when it is necessary to read
  numeric input without failing when no digits are present:
</p><pre class="indent">
skipWhiteSpace(IN);
<span class="keywd">if</span> eoln(IN) <span class="keywd">then</span>
  writeln("empty input");
<span class="keywd">elsif</span> IN.bufferChar <span class="keywd">in</span> {'0' .. '9'} <span class="keywd">then</span>
  number := <span class="type">integer</span> <span class="op">parse</span> getDigits(IN);
  skipLine(IN);
  writeln("number " &lt;&amp; number);
<span class="keywd">else</span>
  stri := getLine(IN);
  writeln("command " &lt;&amp; literal(stri));
<span class="keywd">end if</span>;
</pre><p>
  The function <tt><span class="func">getSymbol</span></tt> is designed to read Seed7 symbols. When
  the end of the file is reached it returns <tt><span class="stri">""</span></tt>.
  With <tt><span class="func">getSymbol</span></tt> name-value pairs can be read:
</p><pre class="indent">
name := getSymbol(inFile);
<span class="keywd">while</span> name &lt;> <span class="stri">""</span> <span class="keywd">do</span>
  <span class="keywd">if</span> name &lt;> <span class="stri">"#"</span> <span class="keywd">and</span> getSymbol(inFile) = nt color=maroon>"="/font> <span class="keywd">then</span>
    aValue = getSymbol(inFile);
    <span class="keywd">if</span> aValue &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      <span class="keywd">if</span> aValue[1] = <span class="stri">'"'</span> <span class="keywd">then</span>
        keyValueHash @:= [name] aValue[2 ..];
      <span class="keywd">elsif</span> aValue[1] <span class="keywd">in</span> {<span class="stri">'0'</span> .. <span class="stri">'9'</span>} <span class="keywd">then</span>
        keyValueHash @:= [name] aValue;
      <span class="keywd">end if</span>;
    <span class="keywd">end if</span>;
  <span class="keywd">end if</span>;
<span class="keywd">end while</span>;
</pre><p>
  The following loop can be used to process the symbols of a Seed7 program:
</p><pre class="indent">
inFile.bufferChar := getc(inFile);
currSymbol := getSymbol(inFile);
<span class="keywd">while</span> currSymbol &lt;> <span class="stri">""</span> <span class="keywd">do</span>
  ... process currSymbol ...
  currSymbol := getSymbol(inFile);
<span class="keywd">end while</span>;
</pre><p>
  Whitespace and comments are automatically skipped with the
  function <tt><span class="func">getSymbol</span></tt>. When comments should also be returned the
  function <tt><span class="func">getSymbolOrComment</span></tt> can be used. Together with the
  function <tt><span class="func">getWhiteSpace</span></tt> it is even possible to get the
  whitespace between the symbols:
</p><pre class="indent">
<span class="keywd">const</span> <span class="type">func string</span>: processFile (<span class="keywd">in</span> <span class="type">string</span>: fileName) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: processed <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">file</span>: inFile <span class="keywd">is</span> STD_NULL;
    <span class="keywd">var</span> <span class="type">string</span>: currSymbol <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    inFile := open(fileName, <span class="stri">"r"</span>);
    <span class="keywd">if</span> inFile &lt;> STD_NULL <span class="keywd">then</span>
      inFile.bufferChar := getc(inFile);
      processed := getWhiteSpace(inFile);
      currSymbol := getSymbolOrComment(inFile);
      <span class="keywd">while</span> currSymbol &lt;> <span class="stri">""</span> <span class="keywd">do</span>
        processed &amp;:= currSymbol;
        processed &amp;:= getWhiteSpace(inFile);
        currSymbol := getSymbolOrComment(inFile);
      <span class="keywd">end while</span>;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre><p>
  In the example above the function <tt>'processFile'</tt> gathers all
  symbols, whitespace and comments in the string it returns. The
  string returned by <tt>'processFile'</tt> is equivalent to the one
  returned by the function <tt>'getf'</tt>. That way it is easy to test
  the scanner functionality.
</p><p>
  The logic with <tt><span class="func">getWhiteSpace</span></tt> and <tt><span class="func">getSymbolOrComment</span></tt> can be used
  to add HTML tags to comments and literals. The following function
  colors comments with green, string and char literals with maroon and
  numeric literals with purple:
</p><pre class="indent">
<span class="keywd">const</span> <span class="type">proc</span>: sourceToHtml (<span class="keywd">inout</span> <span class="type">file</span>: inFile, <span class="keywd">inout</span> <span class="type">file</span>: outFile) <span class="keywd">is func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: currSymbol <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    inFile.bufferChar := getc(inFile);
    write(outFile, <span class="stri">"&lt;pre>\n"</span>);
    write(outFile, getWhiteSpace(inFile));
    currSymbol := getSymbolOrComment(inFile);
    <span class="keywd">while</span> currSymbol &lt;> <span class="stri">""</span> <span class="keywd">do</span>
      currSymbol := replace(currSymbol, <span class="stri">"&amp;"</span>, <span class="stri">"&amp;amp;"</span>);
      currSymbol := replace(currSymbol, <span class="stri">"&lt;"</span>, <span class="stri">"&amp;lt;"</span>);
      <span class="keywd">if</span> currSymbol[1] <span class="keywd">in</span> {<span class="stri">'"'</span>, <span class="stri">'''</span>} <span class="keywd">then</span>
        write(outFile, <span class="stri">"&lt;font color=\"maroon\">"</span>);
        write(outFile, currSymbol);
        write(outFile, <span class="stri">"&lt;/font>"</span>);
      <span class="keywd">elsif</span> currSymbol[1] = <span class="stri">'#'</span> <span class="keywd">or</span> startsWith(currSymbol, <span class="stri">"(*"</span>) <span class="keywd">then</span>
        write(outFile, <span class="stri">"&lt;font color=\"green\">"</span>);
        write(outFile, currSymbol);
        write(outFile, <span class="stri">"&lt;/font>"</span>);
      <span class="keywd">elsif</span> currSymbol[1] <span class="keywd">in</span> digit_char <span class="keywd">then</span>
        write(outFile, <span class="stri">"&lt;font color=\"purple\">"</span>);
        write(outFile, currSymbol);
        write(outFile, <span class="stri">"&lt;/font>"</span>);
      <span class="keywd">else</span>
        write(outFile, currSymbol);
      <span class="keywd">end if</span>;
      write(outFile, getWhiteSpace(inFile));
      currSymbol := getSymbolOrComment(inFile);
    <span class="keywd">end while</span>;
    write(outFile, <span class="stri">"&lt;/pre>\n"</span>);
  <span class="keywd">end func</span>;
</pre><p>
  The functions <tt><span class="func">skipSpace</span></tt> and <tt><span class="func">skipWhiteSpace</span></tt> are defined in
  the <span class="stri">"<span class="lib">scanfile.s7i</span>"</span> library as follows:
</p><pre class="indent">
<span class="keywd">const</span> <span class="type">proc</span>: skipSpace (<span class="keywd">inout</span> <span class="type">file</span>: inFile) <span class="keywd">is func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">char</span>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    ch := inFile.bufferChar;
    <span class="keywd">while</span> ch = ' ' <span class="keywd">do</span>
      ch := getc(inFile);
    <span class="keywd">end while</span>;
    inFile.bufferChar := ch;
  <span class="keywd">end func</span>;

<span class="keywd">const</span> <span class="type">proc</span>: skipWhiteSpace (<span class="keywd">inout</span> <span class="type">file</span>: inFile) <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    <span class="keywd">while</span> inFile.bufferChar <span class="keywd">in</span> white_space_char <span class="keywd">do</span>
      inFile.bufferChar := getc(inFile);
    <span class="keywd">end while</span>;
  <span class="keywd">end func</span>;
</pre><p>
  The functions <tt><span class="func">skipComment</span></tt> and <tt><span class="func">skipLineComment</span></tt>, which can be
  used to skip Seed7 comments, are defined as follows:
</p><pre class="indent">
<span class="keywd">const</span> <span class="type">proc</span>: skipComment (<span class="keywd">inout</span> <span class="type">file</span>: inFile) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">char</span>: character <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    character := getc(inFile);
    <span class="keywd">repeat</span>
      <span class="keywd">repeat</span>
        <span class="keywd">while</span> character <span class="keywd">not</span> <span class="keywd">in</span> special_comment_char <span class="keywd">do</span>
          character := getc(inFile);
        <span class="keywd">end</span> <span class="keywd">while</span>;
        <span class="keywd">if</span> character = <span class="stri">'('</span> <span class="keywd">then</span>
          character := getc(inFile);
          <span class="keywd">if</span> character = <span class="stri">'*'</span> <span class="keywd">then</span>
            skipComment(inFile);
            character := getc(inFile);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">until</span> character = <span class="stri">'*'</span> <span class="keywd">or</span> character = EOF;
      <span class="keywd">if</span> character &lt;> EOF <span class="keywd">then</span>
        character := getc(inFile);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">until</span> character = <span class="stri">')'</span> <span class="keywd">or</span> character = EOF;
    <span class="keywd">if</span> character = EOF <span class="keywd">then</span>
      inFile.bufferChar := EOF;
    <span class="keywd">else</span>
      inFile.bufferChar := getc(inFile);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># skipComment</span>

<span class="keywd">const</span> <span class="type">proc</span>: skipLineComment (<span class="keywd">inout</span> <span class="type">file</span>: inFile) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">char</span>: character <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    <span class="keywd">repeat</span>
      character := getc(inFile);
    <span class="keywd">until</span> character = <span class="stri">'\n'</span> <span class="keywd">or</span> character = EOF;
    inFile.bufferChar := character;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># skipLineComment</span>
</pre><p>
</p>

<a name="syntax_file_start"></a><p></p>
<a name="syntax_STRUCTURED_SYNTAX_DEFINITION"><h2>9. STRUCTURED SYNTAX DEFINITION</h2></a>

<p>
    Most programming languages have only predefined constructs like
  statements and operators. Seed7, on the other hand, additionally
  allows user defined constructs. This chapter introduces the Seed7
  Structured Syntax Description (S7SSD) which is used to define the
  syntax of new constructs. The syntax of predefined constructs is
  also defined with S7SSD.
</p><p>
    The syntax descriptions used in manuals of conventional
  programming languages have no relationship to the approach used by
  the syntax analysis of the corresponding interpreters/compilers.
  S7SSD is a simple syntax description that can be used by humans
  and compilers/interpreters. Although compiler-compilers follow the
  path of machine readable syntax descriptions, they use much more
  complicated syntax and semantic descriptions and do not allow
  users of the language to define new constructs.
</p><p>
    There are different existing notations to specify the syntax of
  programming languages. Backus-Naur Form (BNF) and its variants
  like Extended Backus-Naur Form (EBNF) are examples of such syntax
  specifications. Since it is easier to understand new concepts when
  they are compared to well known concepts, EBNF will be used as a
  base to explain S7SSD.
</p>

<a name="syntax_The_Extended_Backus-Naur_Form"><h3>9.1 The Extended Backus-Naur Form</h3></a>
<p>
    As the name says the Extended Backus-Naur Form is an extension
  of BNF. The extension allows the definition of repetitions and
  optional parts without the use of recursion. EBNF has the
  following elements:
</p><ul>
    <li>Nonterminal symbols are described with identifiers. An
      identifier consist of lower case letters and underline
      characters.</li>

    <li>Terminal symbols are quoted strings or names in upper case
      characters, which describe unprintable characters (control
      characters).</li>

    <li>The concatenation of nonterminal and/or terminal symbols is
      described by writing them in sequence.</li>

    <li>With | two alternatives can be separated.</li>

    <li>Expressions of the extended Backus-Naur form can be put within
      parentheses ( ... ) .</li>

    <li>When an expression is optional it is enclosed in square
      brackets [ ... ] .</li>

    <li>When an expression may be omitted or repeated it is
      enclosed in curly braces { ... } .</li>
</ul><p>
  The syntax of the extended Backus-Naur form can be described in
  extended Backus-Naur form:
</p><dl><dd><tt><dl>
    <dt>syntax_description ::=</dt><dd>
      { <a class="ebnf" href="#syntax_ebnf_ebnf_statement">ebnf_statement</a> } .</dd>
<dt><br /></dt>
    <dt><a name="syntax_ebnf_ebnf_statement">ebnf_statement</a> ::=</dt><dd>
      identifier '::=' <a class="ebnf" href="#syntax_ebnf_ebnf_expression">ebnf_expression</a> '.' .</dd>
<dt><br /></dt>
    <dt><a name="syntax_ebnf_ebnf_expression">ebnf_expression</a> ::=</dt><dd>
      <a class="ebnf" href="#syntax_ebnf_ebnf_term">term</a> { '|' <a class="ebnf" href="#syntax_ebnf_ebnf_term">term</a> } .</dd>
<dt><br /></dt>
    <dt><a name="syntax_ebnf_ebnf_term">term</a> ::=</dt><dd>
      <a class="ebnf" href="#syntax_ebnf_ebnf_factor">factor</a> { <a class="ebnf" href="#syntax_ebnf_ebnf_factor">factor</a> } .</dd>
<dt><br /></dt>
    <dt><a name="syntax_ebnf_ebnf_factor">factor</a> ::=</dt><dd>
      identifier | string | control_character_description |<br />
      '(' <a class="ebnf" href="#syntax_ebnf_ebnf_expression">ebnf_expression</a> ')' | '[' <a class="ebnf" href="#syntax_ebnf_ebnf_expression">ebnf_expression</a> ']' |<br />
      '{' <a class="ebnf" href="#syntax_ebnf_ebnf_expression">ebnf_expression</a> '}' .</dd>
</dl></tt></dd></dl><p></p>

<a name="syntax_The_syntax_of_a_statement"><h3>9.2 The syntax of a statement</h3></a>
<p>
    To explain the Seed7 Structured Syntax Description we design a
  new statement, the <a class="link" href="#syntax_The_syntax_of_a_statement">loop-statement</a>. The <a class="link" href="#syntax_The_syntax_of_a_statement">loop-statement</a> should
  be similar to <a class="link" href="#stats_while-statement">while-</a> and <a class="link" href="#stats_repeat-statement">repeat-loops</a> but instead of having
  the conditional exit at the beginning or at the end, it should
  have a conditional exit in the middle of the loop. This middle
  conditional exit should be part of the <a class="link" href="#syntax_The_syntax_of_a_statement">loop-statement</a>. Note that
  the break-statement, which exists in some programming languages,
  is a statement on its own and is not part of the loop which it
  leaves. Therefore the middle conditional exit should not be
  confused with a break-statement. An example of the new <a class="link" href="#syntax_The_syntax_of_a_statement">loop-statement</a>
  is:
<p><pre class="indent">
<span class="keywd">loop</span>
  ch := getc(inFile);
<span class="keywd">until</span> ch = <span class="stri">'\n'</span> <span class="keywd">do</span>
  stri &amp;:= str(ch);
<span class="keywd">end loop</span>;
</pre><p>
  The <tt>'<span class="keywd">loop</span>'</tt> example above reads characters from a file and
  concatenates them to a string until the character <tt><span class="stri">'\n'</span></tt> is read.
  The <tt><span class="stri">'\n'</span></tt> ends the loop. Hence it is not added to the string.
  An equivalent solution without the usage of the <a class="link" href="#syntax_The_syntax_of_a_statement">loop-statement</a>
  would be:
<p><pre class="indent">
<span class="keywd">repeat</span>
  ch := getc(inFile);
  <span class="keywd">if</span> ch &lt;> <span class="stri">'\n'</span> <span class="keywd">then</span>
    stri &amp;:= str(ch);
  <span class="keywd">end if</span>;
<span class="keywd">until</span> ch = <span class="stri">'\n'</span>;
</pre><p>
  The S7SSD of the <a class="link" href="#syntax_The_syntax_of_a_statement">loop-statement</a> is:
</p><pre class="indent">
$ <span class="keywd">syntax</span> <a class="type" href="#types_expr">expr</a>: .loop.().until.().do.().end.loop   <span class="keywd">is</span> -> 25;
</pre><p>
  The details of the S7SSD <tt>'<span class="keywd">syntax</span>'</tt> definition will be explained
  later. For now we concentrate at the heart of the S7SSD, the
  expression:
</p><pre class="indent">
.loop.().until.().do.().end.loop
</pre><p>
  For the purpose of the syntax description we can just remove the
  dots, which gives:
</p><pre class="indent">
 loop () until () do () end loop
</pre><p>
  This are the keywords used in a <a class="link" href="#syntax_The_syntax_of_a_statement">loop-statement</a>. The symbol <tt>()</tt>
  acts as placeholder for an expression.
  With EBNF the <a class="link" href="#syntax_The_syntax_of_a_statement">loop-statement</a> can be described as:
</p><dl><dd><tt><dl>
    <dt>loop_statement ::=</dt><dd>
      '<span class="keywd">loop</span>'<br />
      &nbsp;&nbsp;<a class="ebnf" href="#stats_ebnf_statement">statement</a><br />
      '<span class="keywd">until</span>' <a class="ebnf" href="#expr_ebnf_expression">expression</a> '<span class="keywd">do</span>'<br />
      &nbsp;&nbsp;<a class="ebnf" href="#stats_ebnf_statement">statement</a><br />
      '<span class="keywd">end</span>' '<span class="keywd">loop</span>' .</dd>
</dl></tt></dd></dl><p>
  An EBNF description may use many nonterminal symbols such as
  <tt>'<a class="ebnf" href="#stats_ebnf_statement">statement</a>'</tt> or <tt>'<a class="ebnf" href="#expr_ebnf_expression">expression</a>'</tt>. S7SSD does not distinguish
  between different nonterminal symbols. Instead S7SSD only
  knows one nonterminal symbol: <tt>()</tt>
</p><p>
  Therefore S7SSD cannot distinguish between <tt>'<a class="ebnf" href="#stats_ebnf_statement">statement</a>'</tt>,
  <tt>'<a class="ebnf" href="#expr_ebnf_expression">expression</a>'</tt> or something else. At the syntax level any kind of
  expression can by substituted for a S7SSD nonterminal symbol <tt>()</tt>.
  With EBNF it is possible to describe constraints such as the type
  of an expression. S7SSD relies on semantic checks to verify
  such constraints. Given the S7SSD of the <a class="link" href="#syntax_The_syntax_of_a_statement">loop-statement</a> an
  expression like
</p><pre class="indent">
<span class="keywd">loop</span>
  <span class="stri">"X"</span>
<span class="keywd">until</span> 1+2 <span class="keywd">do</span>
  <a class="type" href="#types_integer">integer</a>
<span class="keywd">end loop</span>
</pre><p>
  would be legal as it contains the required keywords
</p><pre class="indent">
<span class="keywd">loop</span>  <span class="keywd">until</span>  <span class="keywd">do</span>  <span class="keywd">end</span>  <span class="keywd">loop</span>
</pre><p>
  and the expressions
</p><pre class="indent">
<span class="stri">"X"</span>  1+2  <a class="type" href="#types_integer">integer</a>
</pre><p>
  at the places of the <tt>()</tt> symbols. This is exactly what the syntax
  definition specifies, but it would be not be considered correct
  given the description of the <a class="link" href="#syntax_The_syntax_of_a_statement">loop-statement</a> at the beginning of
  the chapter. To determine which types of expressions are allowed
  at the places of the <tt>()</tt> symbol, a semantic definition of the
  <a class="link" href="#syntax_The_syntax_of_a_statement">loop-statement</a> is necessary. A semantic definition is just a
  function definition which uses the keywords and parameters from
  the syntax definition. The definition of the <tt>'<span class="keywd">loop</span>'</tt> function
  (semantic definition of the <a class="link" href="#syntax_The_syntax_of_a_statement">loop-statement</a>) is:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: loop
              (<span class="keywd">in</span> <a class="type" href="#types_proc">proc</a>: statements1)
            until (<span class="keywd">ref</span> <a class="type" href="#types_func">func</a> <a class="type" href="#types_boolean">boolean</a>: condition) do
              (<span class="keywd">in</span> <a class="type" href="#types_proc">proc</a>: statements2)
            end loop <span class="keywd">is func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="#types_boolean">boolean</a>: exitLoop <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    <span class="keywd">repeat</span>
      statements1;
      <span class="keywd">if</span> <span class="op">not</span> condition <span class="keywd">then</span>
        statements2;
      <span class="keywd">else</span>
        exitLoop := TRUE;
      <span class="keywd">end if</span>;
    <span class="keywd">until</span> exitLoop;
  <span class="keywd">end func</span>;
</pre><p>
  This definition determines the types of the expressions accepted
  between the keywords. Besides that the semantic definition of the
  <a class="link" href="#syntax_The_syntax_of_a_statement">loop-statement</a> is just a normal function definition. Note that
  the sequence of keywords and parameters in the header of this
  function definition is determined by the corresponding syntax
  definition.
</p><p>
  The parameters <tt>'statements1'</tt>, <tt>'condition'</tt> and <tt>'statements2'</tt> are
  call-by-name parameters. A call-by-name parameter is a function
  without parameters. Function types such as <tt><a class="type" href="#types_proc">proc</a></tt> or <tt><a class="type" href="#types_func">func</a> <a class="type" href="#types_boolean">boolean</a></tt>
  are used as type of formal call-by-name parameters. An expression
  with the correct type is allowed as actual call-by-name parameter.
  This actual parameter expression is not evaluated when the
  function is called. Instead the expression is evaluated every time
  the formal call-by-name parameter is used. This way <tt>'statements1'</tt>,
  <tt>'condition'</tt> and <tt>'statements2'</tt> are not executed when the <tt>'<span class="keywd">loop</span>'</tt>
  function is called. Inside the body of the <tt>'<span class="keywd">loop</span>'</tt> function the
  call-by-name parameters are executed at some places.
</p><p>
  The <tt>'<span class="keywd">loop</span>'</tt> function uses a <a class="link" href="#stats_repeat-statement">repeat-</a> and an <a class="link" href="#stats_if-statement">if-statement</a> to
  implement the desired behavior. When necessary the call-by-name
  parameters are executed several times.
</p><p>
  For the <tt>'<span class="keywd">loop</span>'</tt> example with the semantic errors (see above) we
  would get an error message like:
</p><pre class="indent">
*** chkloop.sd7(35):51: Match for {loop "X" until {1 + 2 } do integer end loop } failed
</pre><p></p>

<a name="syntax_Priority_and_associativity"><h3>9.3 Priority and associativity</h3></a>
<p>
    When a syntax construct has parameters before the first symbol
  or after the last symbol the priority and the associativity of the
  construct are significant. Constructs with stronger priority bind
  their parameters earlier than constructs with weaker priority. The
  priority is described by a natural number (inclusive 0). The
  strongest priority is 0. Weaker priorities are described by larger
  numbers. What bind means is can be explained with an example:
</p><pre class="box">
                                      =
    A = B + C * D                    / \
                                    A   +
    * priority  6                      / \
    + priority  7                     B   *
    = priority 12                        / \
                                        C   D
</pre><p>
  The * operator has the strongest priority (6) of all operators
  involved. Therefore the <tt><span class="op">*</span></tt> takes its parameters first. Then
  the <tt><span class="op">+</span></tt> (with priority 7) and at last the <tt><span class="op">=</span></tt> (with priority 12)
  follows. This leads to the the following interpretation of
  the expression:
</p><pre class="indent">
A = (B + (C * D))
</pre><p>
  The associativity describes, in which order constructs with equal
  priority bind their parameters. For example
</p><pre class="indent">
A - B - C
</pre><p>
  can be interpreted in two ways:
</p><pre class="indent">
(A - B) - C    or   A - (B - C)
</pre><p>
  The first interpretation is usually preferred by mathematicians
  and is described with the associativity <tt><span class="op">-></span></tt> . Generally four
  associativities are possible:
</p><dl><dd><table border="1" cellspacing="0" cellpadding="5">
    
    <tr><th align="left"> Associativity                             </th><th> Symbol </th></tr>
    
    <tr><td> Binding from left to right                </td><td align="center">   <tt><span class="op">-></span></tt>   </td></tr>
    
    <tr><td> Binding from right to left                </td><td align="center">   <tt><span class="op">&lt;-</span></tt>   </td></tr>
    
    <tr><td> Neither the left nor the right parameter          
     are allowed to have the same priority     </td><td align="center">   <tt><span class="op">&lt;-></span></tt>  </td></tr>
    
    <tr><td> At the left side there is a binding from          
     left to right and at the right side there         
     is a binding from right to left           </td><td align="center">  <tt><span class="op">->&lt;-</span></tt>  </td></tr>
    
</table></dd></dl><p>
  The last two possibilities give no legal interpretation in the
  subtraction example. The third kind of associativity ( <tt><span class="op">&lt;-></span></tt> ) is
  used by the equal operator ( <tt><span class="op">=</span></tt> ) of Pascal because there an
  expression like
</p><pre class="indent">
A = B = C
</pre><p>
  is not legal.
</p><p>
  There is a second way to describe the associativity. The
  associativity describes, if an operand must have a stronger
  priority than the priority of the operator. For example:
</p><pre class="box">
                             -                     7
    A - B - C              /   \                 /   \
                          /     \           &lt;=7 /     \ &lt;7
    - priority 7 ->      /       \             /       \
                        -         C           7         0
                      /   \                 /   \
                     /     \           &lt;=7 /     \ &lt;7
                    /       \             /       \
                   A         B           0         0
</pre><p>
  The numbers in the nodes of the right tree show the priority of
  each sub expression (sub tree). With <tt><span class="op">&lt;</span></tt> and <tt><span class="op">&lt;=</span></tt> the required
  condition for the priority of an operand is described. An
  interpretation is legal if all this conditions are met. If there
  are more than one legal interpretations or no legal
  interpretation the expression is illegal.
</p><p>
  Table for the possibilities of associativity:
</p><dl><dd><table border="1" cellspacing="0" cellpadding="5">
    
    <tr><th rowspan="2"> associativity </th><th align="center" colspan="2">             The priority of the              </th></tr>
    
    <tr><th align="center"> left operand must be </th><th align="center"> right operand must be </th></tr>
    
    <tr><td align="center">      <tt><span class="op">-></span></tt>       </td><td align="center">          <tt><span class="op">&lt;=</span></tt>          </td><td align="center">          <tt><span class="op">&lt;</span></tt>            </td></tr>
    <tr><td align="center">      <tt><span class="op">&lt;-</span></tt>       </td><td align="center">          <tt><span class="op">&lt;</span></tt>           </td><td align="center">          <tt><span class="op">&lt;=</span></tt>           </td></tr>
    <tr><td align="center">      <tt><span class="op">&lt;-></span></tt>      </td><td align="center">          <tt><span class="op">&lt;</span></tt>           </td><td align="center">          <tt><span class="op">&lt;</span></tt>            </td></tr>
    <tr><td align="center">     <tt><span class="op">->&lt;-</span></tt>      </td><td align="center">          <tt><span class="op">&lt;=</span></tt>          </td><td align="center">          <tt><span class="op">&lt;=</span></tt>           </td></tr>
    
    <tr><td>&nbsp;              </td><td align="center" colspan="2">          than that of the operator           </td></tr>
    
</table></dd></dl><p>
  The parameter before the operator symbol is called left operand.
  The parameter after the last symbol of a construct is called
  right operand. In case of normal operators the last symbol of a
  construct and the operator symbol are identical. If this is not
  the case there is a third kind of operand. Between the operator
  symbol and the last symbol of a construct are the middle operands.
  Middle operands can have any priority.
</p>

<a name="syntax_The_syntax_of_operators"><h3>9.4 The syntax of operators</h3></a>
<p>
    A syntax definition specifies the way a usage of a statement
  or operator must be written. For example a call of the
  <tt><span class="keywd">not</span></tt> operator looks like:
</p><pre class="indent">
<span class="op">not</span> okay
</pre><p>
  To describe the syntax of the <tt><span class="keywd">not</span></tt> operator we write:
</p><pre class="indent">
$ <span class="keywd">syntax</span> <a class="type" href="#types_expr">expr</a>: .not.() <span class="keywd">is</span> &lt;- 13;
</pre><p>
  This means that a <tt><span class="keywd">not</span></tt> expression is constructed with the
  symbol <tt><span class="keywd">not</span></tt> followed by a parameter. The place of the
  parameter is marked with the () sign. The syntax description
  contains no information about the types of the parameters. At
  the syntax level a parameter may be anything. With <tt><span class="op">&lt;-</span></tt> the
  associativity of the <tt><span class="keywd">not</span></tt> operator is specified as right
  associative. This means that the right operand is allowed to
  have the same priority as the operator symbol. So the
  expression
</p><pre class="indent">
<span class="op">not</span> <span class="op">not</span> okay
</pre><p>
  is legal and means
</p><pre class="indent">
<span class="op">not</span> (<span class="op">not</span> okay)
</pre><p>
  When the associativity of the <tt><span class="keywd">not</span></tt> operator is specified with
  <tt><span class="op">-></span></tt> instead of <tt><span class="op">&lt;-</span></tt> the <tt>'<span class="op">not</span> <span class="op">not</span>'</tt> expression above is not legal.
  With 13 the priority of the whole <tt><span class="keywd">not</span></tt> operator is determined.
  As convention priorities from 1 to 20 are used by operators
  and priority 25 is used by statements. Arithmetic operators
  have priorities from 1 to 11 and comparisons have priority 12.
</p><p>
  To define the <tt><span class="keywd">not</span></tt> operator completely there must be also
  a semantic definition which is as follows:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_func">func</a> <a class="type" href="#types_boolean">boolean</a>: not (<span class="keywd">in</span> <a class="type" href="#types_boolean">boolean</a>: aBool) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="#types_boolean">boolean</a>: negation <span class="keywd">is</span> TRUE;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> aBool <span class="keywd">then</span>
      negation := FALSE;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre><p>
  In the declaration the <tt><span class="keywd">not</span></tt> operator is written exactly
  in the same way it is written when it is called. The syntax
  definition is used at both places: declaration and call.
  The syntax and semantic declarations define precisely how
  the <tt><span class="keywd">not</span></tt> operator works.
</p><p>
    As next example we try an infix operator like the <tt><span class="keywd">and</span></tt> operator.
  A call of the <tt><span class="keywd">and</span></tt> operator may look like:
</p><pre class="indent">
okay <span class="op">and</span> <span class="op">not</span> error
</pre><p>
  To describe the syntax of the <tt><span class="keywd">and</span></tt> operator we write:
</p><pre class="indent">
$ <span class="keywd">syntax</span> <a class="type" href="#types_expr">expr</a>: .().and.() <span class="keywd">is</span>    -> 14;
</pre><p>
  This means that an <tt><span class="keywd">and</span></tt> expression is constructed with the
  symbol <tt><span class="keywd">and</span></tt> surrounded by parameters. The <tt><span class="op">-></span></tt> defines the
  <tt><span class="keywd">and</span></tt> operator as left associative. This means that an expression
  like
</p><pre class="indent">
A <span class="op">and</span> B <span class="op">and</span> C
</pre><p>
  is interpreted as
</p><pre class="indent">
(A <span class="op">and</span> B) <span class="op">and</span> C
</pre><p>
  With 14 the priority of the whole <tt><span class="keywd">and</span></tt> operator is determined.
  Since priority 14 is weaker than the priority of the <tt><span class="keywd">not</span></tt> operator
  which is 13 the example expression is evaluated as:
</p><pre class="indent">
okay <span class="op">and</span> (<span class="op">not</span> error)
</pre><p>
  Note that the expression
</p><pre class="indent">
okay <span class="op">and</span> <span class="op">not</span> error
</pre><p>
  makes no sense when the <tt><span class="keywd">and</span></tt> operator has priority 12 instead of 14.
</p><p>
  S7SSD treats everything as operator description. Operators
  have priority and associativity. The priority and associativity
  determine in which succession S7SSD syntax rules get applied.
  To explain priority and associativity we use the basic arithmetic
  operations (+,-,*,/). To describe them with EBNF we can write:
</p><dl><dt></dt><dd><tt><dl>
    <dt>factor ::=</dt><dd>
      number | name .</dd>

    <dt>expression_5 ::=</dt><dd>
      factor |
      ( '+' expression_5 ) |<br />
      ( '-' expression_5 ) .</dd>

    <dt>expression_6 ::=</dt><dd>
      expression_5 |<br />
      ( expression_6 '*' expression_7 ) |<br />
      ( expression_6 '/' expression_7 ) .</dd>

    <dt>expression_7 ::=</dt><dd>
      expression_6 |<br />
      ( expression_7 '+' expression_6 ) |<br />
      ( expression_7 '-' expression_6 ) .</dd>
</dl></tt></dd></dl><p>
  This describes the following things:
</p><ul>
    <li>The operators have different priorities:<ul>
      <li>Plus and minus signs are executed first</li>
      <li>Multiplication and division are executed second.</li>
      <li>Addition and subtraction are executed last.</li></ul></li>

    <li>These priorities are exactly what we expect from an
      arithmetic expression.</li>

    <li>Additionally we see that ++2 is allowed and interpreted as
      +(+(2)) which means that the plus sign is a right-associative
      operator.</li>

    <li>We can also see that a*b*c is allowed and interpreted as
      (a*b)*c which means that the multiplication is a
      left-associative operator.</li>
</ul><p>
  All this things can also be described with S7SSD:
</p><pre class="indent">
$ <span class="keywd">syntax</span> <a class="type" href="#types_expr">expr</a>: . + .()      is &lt;-  5;
$ <span class="keywd">syntax</span> <a class="type" href="#types_expr">expr</a>: . - .()      is &lt;-  5;
$ <span class="keywd">syntax</span> <a class="type" href="#types_expr">expr</a>: .(). * .()   is  -> 6;
$ <span class="keywd">syntax</span> <a class="type" href="#types_expr">expr</a>: .(). / .()   is  -> 6;
$ <span class="keywd">syntax</span> <a class="type" href="#types_expr">expr</a>: .(). + .()   is  -> 7;
$ <span class="keywd">syntax</span> <a class="type" href="#types_expr">expr</a>: .(). - .()   is  -> 7;
</pre><p>
  As we can see S7SSD is shorter as the description with EBNF.
  A syntax statement is explained as follows:
</p><ul>
    <li>The $ is used to introduce all hard coded statements.</li>

    <li>The keyword <tt>'<span class="keywd">syntax</span>'</tt> introduces a structured syntax
      description.</li>

    <li>The result of the recognized expression will have
      the type <tt><a class="type" href="#types_expr">expr</a></tt>. The type <tt><a class="type" href="#types_expr">expr</a></tt> is used between the syntax
      and the semantic analysis. The type <tt><a class="type" href="#types_expr">expr</a></tt> describes
      expressions which are syntactically analyzed but not
      semantically analyzed. After the semantic analysis (and
      during the runtime) the type <tt><a class="type" href="#types_expr">expr</a></tt> is not used.</li>

    <li>The colon ':' is used as separator between type and syntax
      description.</li>

    <li>A dot expression like <tt>'.(). * .()'</tt> is introduced (as can
      probably be guessed by the name) with a dot. For the purpose
      of the syntax description we can just remove the dots in
      our mind: <tt>'() * ()'</tt></li>

    <li>The symbol <tt>'<span class="keywd">is</span>'</tt> is used in all Seed7 declarations as
      separator between the name and the value.</li>

    <li>The associativity is described with one of the symbols
      <tt>-></tt> (left-associative), <tt>&lt;-</tt> (right-associative),
      <tt>&lt;-></tt> (not associative) and <tt>->&lt;-</tt> (both associativities).
      When there are no left or right operands, as it is the case
      for the <a class="link" href="#syntax_The_syntax_of_a_statement">loop-statement</a>, the associativity is irrelevant.</li>

    <li>Finally the priority of the syntax construct is defined with
      a integer literal like <tt>'6'</tt>. The priority <tt>'6'</tt> is used for the
      operators <tt>'*'</tt>, <tt>'/'</tt>, <tt><span class="keywd">div</span></tt>, <tt><span class="keywd">rem</span></tt>, <tt><span class="keywd">mdiv</span></tt> and <tt><span class="keywd">mod</span></tt>.</li>
</ul><p></p>

<a name="syntax_Syntax_of_predefined_statements"><h3>9.5 Syntax of predefined statements</h3></a>
<p>
    Predefined statements can also be defined with S7SSD.
  E.g.: The <a class="link" href="#stats_while-statement">while-statement</a>. A use of the <a class="link" href="#stats_while-statement">while-statement</a> is:
</p><pre class="indent">
<span class="keywd">while</span> element_index > 0 <span class="op">and</span> okay <span class="keywd">do</span>
  processElement;
  write(<span class="stri">"."</span>);
<span class="keywd">end while</span>;
</pre><p>
  To describe the syntax of the <a class="link" href="#stats_while-statement">while-statement</a> we write:
</p><pre class="indent">
$ <span class="keywd">syntax</span> <a class="type" href="#types_expr">expr</a>: .while.().do.().end.while <span class="keywd">is</span> -> 25;
</pre><p>
  This means that the <a class="link" href="#stats_while-statement">while-statement</a> is an expression with the
  symbols <tt>'<span class="keywd">while</span>'</tt>, <tt>'<span class="keywd">do</span>'</tt>, <tt>'<span class="keywd">end</span>'</tt> and <tt>'<span class="keywd">while</span>'</tt>. With <tt><span class="op">-></span></tt> the
  associativity of the <a class="link" href="#stats_while-statement">while-statement</a> is specified as left
  associative. The associativity has no meaning for the
  <a class="link" href="#stats_while-statement">while-statement</a> since there is no parameter before the first
  symbol or after the last symbol. The priority of the whole
  <a class="link" href="#stats_while-statement">while-statement</a> is 25.
</p><p>
  The semantic definition of the <a class="link" href="#stats_while-statement">while-statement</a> is as follows:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: while (<span class="keywd">ref</span> func <a class="type" href="#types_boolean">boolean</a>: condition) do
    (<span class="keywd">ref</span> <a class="type" href="#types_proc">proc</a>: statement) end while <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> condition <span class="keywd">then</span>
      statement;
      <span class="keywd">while</span> condition <span class="keywd">do</span>
        statement;
      <span class="keywd">end while</span>;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre><p>
  The syntax definition is used for the declaration and for the call.
  This declaration defines precisely how the <a class="link" href="#stats_while-statement">while-statement</a>
  works. It is based on the <a class="link" href="#stats_if-statement">if-statement</a> and uses recursion
  to emulate the repetition of the loop body.
  Another example for a syntax description is the
  <a class="link" href="#stats_repeat-statement">repeat-statement</a>
</p><pre class="indent">
<span class="keywd">repeat</span>
  processElement;
  write(<span class="stri">"."</span>);
<span class="keywd">until</span> element_index = 0 <span class="op">or</span> <span class="op">not</span> okay;
</pre><p>
  which has the following syntax description:
</p><pre class="indent">
$ <span class="keywd">syntax</span> <a class="type" href="#types_expr">expr</a>: .repeat.().until.() <span class="keywd">is</span> -> 25;
</pre><p>
  This means that the <a class="link" href="#stats_repeat-statement">repeat-statement</a> is an expression with
  the symbols <tt>'<span class="keywd">repeat</span>'</tt> and <tt>'<span class="keywd">until</span>'</tt> and a parameter between
  <tt>'<span class="keywd">repeat</span>'</tt> and <tt>'<span class="keywd">until</span>'</tt> and after <tt>'<span class="keywd">until</span>'</tt>. With 25 the priority
  of the whole <a class="link" href="#stats_repeat-statement">repeat-statement</a> is determined. With <tt><span class="op">-></span></tt> the
  associativity of the <a class="link" href="#stats_repeat-statement">repeat-statement</a> is specified as left
  associative. This allows priorities from 0 to 24 for the
  parameter after <tt>'<span class="keywd">until</span>'</tt>. Since statements have priority 25
  it is not possible to write a statement direct behind <tt>'<span class="keywd">until</span>'</tt>.
</p><p>
  A simple <a class="link" href="#stats_if-statement">if-statement</a>, without
  <tt>'<span class="keywd">elsif</span>'</tt> part, is the next example.
  A usage of this <a class="link" href="#stats_if-statement">if-statement</a> might be:
</p><pre class="indent">
<span class="keywd">if</span> okay <span class="keywd">then</span>
  writeln(<span class="stri">"okay"</span>);
<span class="keywd">else</span>
  writeln(<span class="stri">"not okay"</span>);
<span class="keywd">end if</span>;
</pre><p>
  As syntax description we use
</p><pre class="indent">
$ <span class="keywd">syntax</span> <a class="type" href="#types_expr">expr</a>: .if.().then.().end.if <span class="keywd">is</span>            -> 25;
$ <span class="keywd">syntax</span> <a class="type" href="#types_expr">expr</a>: .if.().then.().else.().end.if <span class="keywd">is</span>    -> 25;
</pre><p>
  Note that this description allows <a class="link" href="#stats_if-statement">if-statements</a> with and
  without <tt>'<span class="keywd">else</span>'</tt> parts. As semantic description we use
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: if (<span class="keywd">in</span> <a class="type" href="#types_boolean">boolean</a>: condition) then
              (<span class="keywd">in</span> <a class="type" href="#types_proc">proc</a>: statement)
            end if <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    <span class="keywd">case</span> condition <span class="keywd">of</span>
      <span class="keywd">when</span> {TRUE}: statement;
    <span class="keywd">end case</span>;
  <span class="keywd">end func</span>;

<span class="keywd">const</span> proc: if (<span class="keywd">in</span> <a class="type" href="#types_boolean">boolean</a>: condition) then
              (<span class="keywd">in</span> <a class="type" href="#types_proc">proc</a>: statement1)
            else
              (<span class="keywd">in</span> <a class="type" href="#types_proc">proc</a>: statement2)
            end if <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    <span class="keywd">case</span> condition of
      <span class="keywd">when</span> {TRUE}:  statement1;
      <span class="keywd">when</span> {FALSE}: statement2;
    <span class="keywd">end case</span>;
  <span class="keywd">end func</span>;
</pre><p>
  The two forms of the <a class="link" href="#stats_if-statement">if-statement</a> are based on the
  <a class="link" href="#stats_case-statement">case-statement</a>. A more complex <a class="link" href="#stats_if-statement">if-statement</a> with <tt>'<span class="keywd">elsif</span>'</tt>
  parts can be:
</p><pre class="indent">
<span class="keywd">if</span> number &lt; 0 <span class="keywd">then</span>
  write(<span class="stri">"less"</span>);
<span class="keywd">elsif</span> number = 0 <span class="keywd">then</span>
  write(<span class="stri">"equal"</span>);
<span class="keywd">else</span>
  write(<span class="stri">"greater"</span>);
<span class="keywd">end if</span>;
</pre><p>
  How to define the syntax and the semantic for this statement
  is described in the next chapter.
</p>

<a name="syntax_Advanced_syntax_definitions"><h3>9.6 Advanced syntax definitions</h3></a>
<p>
  When we want to use some special syntax which should be only
  allowed at some place we do the following:
</p><ul>
    <li>Define the special syntax with S7SSD in a way that does not
      contradict with the rest of the syntax definitions.</li>

    <li>Use semantic definitions to make sure that this syntax
      construct can only be used at the place desired.</li>
</ul><p>
  The EBNF of the <a class="link" href="#stats_if-statement">if-statement</a> with <tt>'<span class="keywd">elsif</span>'</tt> parts is:
</p><dl><dd><tt><dl>
    <dt>if_statement ::=</dt><dd>
      '<span class="keywd">if</span>' <a class="ebnf" href="#expr_ebnf_expression">expression</a> '<span class="keywd">then</span>'<br />
      &nbsp;&nbsp;<a class="ebnf" href="#stats_ebnf_statement">statement</a><br />
      { '<span class="keywd">elsif</span>' <a class="ebnf" href="#expr_ebnf_expression">expression</a> '<span class="keywd">then</span>'<br />
      &nbsp;&nbsp;<a class="ebnf" href="#stats_ebnf_statement">statement</a> }<br />
      [ '<span class="keywd">else</span>'<br />
      &nbsp;&nbsp;<a class="ebnf" href="#stats_ebnf_statement">statement</a> ]<br />
      '<span class="keywd">end</span>' '<span class="keywd">if</span>' .</dd>
</dl></tt></dd></dl><p>
  The S7SSD of this <a class="link" href="#stats_if-statement">if-statement</a> is:
</p><pre class="indent">
$ <span class="keywd">syntax</span> <a class="type" href="#types_expr">expr</a> : .if.().then.().end.if           <span class="keywd">is</span> -> 25;
$ <span class="keywd">syntax</span> <a class="type" href="#types_expr">expr</a> : .if.().then.().().end.if        <span class="keywd">is</span> -> 25;

$ <span class="keywd">syntax</span> <a class="type" href="#types_expr">expr</a> : .elsif.().then.()               <span class="keywd">is</span> <- 60;
$ <span class="keywd">syntax</span> <a class="type" href="#types_expr">expr</a> : .elsif.().then.().()            <span class="keywd">is</span> <- 60;
$ <span class="keywd">syntax</span> <a class="type" href="#types_expr">expr</a> : .else.()                        <span class="keywd">is</span> <- 60;
</pre><p>
  Instead of one rule (as EBNF does) the rule is broken into several
  S7SSD rules. This is necessary because S7SSD does not support the
  [ ] and { } notations. They are not supported for good reasons:
  They complicate the parameter lists and they are also not so easy
  to implement. On the other hand, the BNF like rules of S7SSD
  lead to semantic constructs which are easy to parse and easy to
  compile. The broken down S7SSD rules of the <a class="link" href="#stats_if-statement">if-statement</a>
  corresponds to the following EBNF description:
</p><dl><dd><tt><dl>
    <dt>if_statement ::=</dt><dd>
      '<span class="keywd">if</span>' <a class="ebnf" href="#expr_ebnf_expression">expression</a> '<span class="keywd">then</span>'<br />
      &nbsp;&nbsp;<a class="ebnf" href="#stats_ebnf_statement">statement</a><br />
      '<span class="keywd">end</span>' '<span class="keywd">if</span>' .</dd>
<dt><br /></dt>
    <dt>if_statement ::=</dt><dd>
      '<span class="keywd">if</span>' <a class="ebnf" href="#expr_ebnf_expression">expression</a> '<span class="keywd">then</span>'<br />
      &nbsp;&nbsp;<a class="ebnf" href="#stats_ebnf_statement">statement</a><br />
      &nbsp;&nbsp;elseif_or_else_part<br />
      '<span class="keywd">end</span>' '<span class="keywd">if</span>' .</dd>
<dt><br /></dt>
    <dt>elseif_or_else_part ::=</dt><dd>
      '<span class="keywd">elsif</span>' <a class="ebnf" href="#expr_ebnf_expression">expression</a> '<span class="keywd">then</span>'<br />
      &nbsp;&nbsp;<a class="ebnf" href="#stats_ebnf_statement">statement</a> .</dd>
<dt><br /></dt>
    <dt>elseif_or_else_part ::=</dt><dd>
      '<span class="keywd">elsif</span>' <a class="ebnf" href="#expr_ebnf_expression">expression</a> '<span class="keywd">then</span>'<br />
      &nbsp;&nbsp;<a class="ebnf" href="#stats_ebnf_statement">statement</a><br />
      &nbsp;&nbsp;elseif_or_else_part .</dd>
<dt><br /></dt>
    <dt>elseif_or_else_part ::=</dt><dd>
      '<span class="keywd">else</span>'<br />
      &nbsp;&nbsp;<a class="ebnf" href="#stats_ebnf_statement">statement</a> .</dd>
</dl></tt></dd></dl><p>
  Since S7SSD uses only one nonterminal symbol <tt>'()'</tt> it is the job
  of the semantic level to make sure that only the right nonterminal
  symbol can be used. This is done by introducing the type
  <tt><span class="type">ELSIF_PROC</span></tt> (which corresponds to the nonterminal symbol
  <tt>'elseif_or_else_part'</tt> of the EBNF) and the type
  <tt><span class="type">ELSIF_RESULT</span></tt> (which is the result
  of the <tt><span class="type">ELSIF_PROC</span></tt>).
</p><p>
  Normally a syntax declaration can be used in many semantic
  declarations. E.g.: The syntax of the <tt>'+'</tt> operator is defined
  once and the semantic of the <tt>'+'</tt> operator is defined for the types
  <tt><a class="type" href="#types_integer">integer</a></tt>, <tt><a class="type" href="#types_bigInteger">bigInteger</a></tt>, <tt><a class="type" href="#types_float">float</a></tt>, <tt><a class="type" href="#types_integer">complex</a></tt>, ... This possibility
  is not needed for the <a class="link" href="#stats_if-statement">if-statement</a>. For each of the five
  S7SSD syntax rules of the <a class="link" href="#stats_if-statement">if-statement</a> just one
  corresponding semantic declaration is done:
</p><pre class="indent">
<span class="comment"># Semantic for the syntax: .if.().then.().end.if</span>
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: if (<span class="keywd">in</span> <a class="type" href="#types_boolean">boolean</a>: condition) then
              (<span class="keywd">in</span> <a class="type" href="#types_proc">proc</a>: statements)
            end if                                    <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    <span class="keywd">case</span> condition <span class="keywd">of</span>
      <span class="keywd">when</span> {TRUE}: statements;
    <span class="keywd">end case</span>;
  <span class="keywd">end func</span>;

<span class="comment"># Semantic for the syntax: .if.().then.().().end.if</span>
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: if (<span class="keywd">in</span> <a class="type" href="#types_boolean">boolean</a>: condition) then
              (<span class="keywd">in</span> <a class="type" href="#types_proc">proc</a>: statements)
            (<span class="keywd">in</span> <span class="type">ELSIF_PROC</span>: elsifPart)
            end if                                    <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    <span class="keywd">case</span> condition <span class="keywd">of</span>
      <span class="keywd">when</span> {TRUE}: statements;
      <span class="keywd">when</span> {FALSE}: elsifPart;
    <span class="keywd">end case</span>;
  <span class="keywd">end func</span>;

<span class="comment"># Semantic for the syntax: .elsif.().then.()</span>
<span class="keywd">const</span> <span class="type">ELSIF_PROC</span>: elsif (<span class="keywd">in</span> <a class="type" href="#types_boolean">boolean</a>: condition) then
                    (<span class="keywd">in</span> <a class="type" href="#types_proc">proc</a>: statements)             <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    <span class="keywd">case</span> condition <span class="keywd">of</span>
      <span class="keywd">when</span> {TRUE}: statements;
    <span class="keywd">end case</span>;
  <span class="keywd">end func</span>;

<span class="comment"># Semantic for the syntax: .elsif.().then.().()</span>
<span class="keywd">const</span> <span class="type">ELSIF_PROC</span>: elsif (<span class="keywd">in</span> <a class="type" href="#types_boolean">boolean</a>: condition) then
                    (<span class="keywd">in</span> <a class="type" href="#types_proc">proc</a>: statements)
                  (<span class="keywd">in</span> <span class="type">ELSIF_PROC</span>: elsifPart)          <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    <span class="keywd">case</span> condition <span class="keywd">of</span>
      <span class="keywd">when</span> {TRUE}: statements;
      <span class="keywd">when</span> {FALSE}: elsifPart;
    <span class="keywd">end case</span>;
  <span class="keywd">end func</span>;

<span class="comment"># Semantic for the syntax: .else.()</span>
<span class="keywd">const</span> <span class="type">ELSIF_PROC</span>: else
                    (<span class="keywd">ref</span> <a class="type" href="#types_void">void</a>: voidValue)        <span class="keywd">is</span> ELSIF_EMPTY;
</pre><p>
  Since no other functions of type <tt>'<span class="type">ELSIF_PROC</span>'</tt> are defined only
  legal <a class="link" href="#stats_if-statement">if-statements</a> can be written.
</p>

<a name="syntax_Comparison_of_EBNF_and_S7SSD"><h3>9.7 Comparison of EBNF and S7SSD</h3></a>
<p>
  In the S7SSD of the <a class="link" href="#syntax_The_syntax_of_a_statement">loop-statement</a>
</p><pre class="indent">
$ <span class="keywd">syntax</span> <a class="type" href="#types_expr">expr</a>: .loop.().until.().do.().end.loop <span class="keywd">is</span> -> 25;
</pre><p>
  are no nonterminal expressions <tt>'()'</tt> before the first keyword or
  after the last keyword. Therefore the associativity does not play
  any role. The nonterminal expressions <tt>'()'</tt> of the <a class="link" href="#syntax_The_syntax_of_a_statement">loop-statement</a>
  are all surrounded by keywords and therefore they can have any
  priority. As priority of the <tt>'<span class="keywd">loop</span>'</tt> 25 is chosen just because
  most other statements have also priority 25. The assignments
  (:= +:= *:= ...) have priority 20 and all operators used in
  arithmetic, boolean and string expressions have priorities less
  than 20. BTW: The semicolon operator (;) is defined with the
  priority 50. Operators with a priority of 0 get their parameters
  before operators with priority 1 and so on.
</p><p>
  The corresponding EBNF description of the <a class="link" href="#syntax_The_syntax_of_a_statement">loop-statement</a> would
  be:
</p><dl><dd><tt><dl>
    <dt>expression_25 ::=</dt><dd>
      '<span class="keywd">loop</span>'<br />
      &nbsp;&nbsp;expression_127<br />
      '<span class="keywd">until</span>' expression_127 '<span class="keywd">do</span>'<br />
      &nbsp;&nbsp;expression_127<br />
      '<span class="keywd">end</span>' '<span class="keywd">loop</span>' .</dd>
</dl></tt></dd></dl><p>
  We must keep in mind that alternative rules for expression_25 are
  also possible and that for every priority level a rule like
</p><dl><dd><tt><dl>
    <dt>expression_127 ::=</dt><dd>
      expression_126 .</dd>
</dl></tt></dd></dl><p>
  is defined. Additionally the following rules are defined:
</p><dl><dd><tt><dl>
    <dt>expression_0 ::=</dt><dd>
      token | parentheses_expression |<br />
      call_expression | dot_expression .</dd>
<dt><br /></dt>
    <dt>token ::=</dt><dd>
      identifier | literal .</dd>
<dt><br /></dt>
    <dt>parentheses_expression ::=</dt><dd>
      '(' expression_127 ')' .</dd>
<dt><br /></dt>
    <dt>call_expression ::=</dt><dd>
      expression_127 [ '('<br />
      [ expression_127 { ',' expression_127 } ]<br />
      ')' ] .</dd>
<dt><br /></dt>
    <dt>dot_expression ::=</dt><dd>
      [ '.' ] call_expression { '.' call_expression } .</dd>
</dl></tt></dd></dl><p>
  The EBNF description can become long, when many priority levels
  exist, as it is the case in Seed7.
</p><p>
  There are some things which are out of the scope of S7SSD.
  The syntax of <a class="link" href="#tokens_Comments">comments</a>, tokens (<a class="link" href="#tokens_Identifiers">identifiers</a> and <a class="link" href="#tokens_Literals">literals</a>) and
  expressions (parentheses, function calls and dot expressions)
  is hard coded. The hard coded constructs are described in
  <a class="link" href="#tokens_file_start">chapter 10 (Tokens)</a> and <a class="link" href="#expr_file_start">chapter 11 (Expressions)</a>.
</p><p>
  For the reasons mentioned above it is not possible to transform
  every EBNF syntax description into S7SSD. Transforming S7SSD
  descriptions to EBNF is always possible.
</p><p>
  The advantage of S7SSD lies in its simplicity and that a fast
  automated syntax recognition algorithm can be easily implemented.
  It is exactly the combination of hard coded syntax recognition and
  flexible syntax rules that make it successful.
</p>

<a name="tokens_file_start"></a><p></p>
<a name="tokens_TOKENS"><h2>10. TOKENS</h2></a>

<p>
    A program consists of a sequence of tokens which may be delimited
  by white space. There are two types of tokens:
</p><dl>
    <dd><a class="ebnf" href="#tokens_ebnf_identifier">identifier</a>s</dd>
    <dd><a class="ebnf" href="#tokens_ebnf_literal">literal</a>s</dd>
</dl><dl><dt>
  Syntax:
</dt><dd><tt><dl>
    <dt>program ::=</dt><dd>
      { <a class="ebnf" href="#tokens_ebnf_white_space">white_space</a> | <a class="ebnf" href="#tokens_ebnf_token">token</a> } .</dd>
<dt><br /></dt>
    <dt><a name="tokens_ebnf_token">token</a> ::=</dt><dd>
      <a class="ebnf" href="#tokens_ebnf_identifier">identifier</a> | <a class="ebnf" href="#tokens_ebnf_literal">literal</a> .</dd>
</dl></tt></dd></dl><p></p>

<a name="tokens_White_space"><h3>10.1 White space</h3></a>
<p>
    There are three types of white space
</p><dl>
    <dd><a class="ebnf" href="#tokens_ebnf_space">space</a>s</dd>
    <dd><a class="ebnf" href="#tokens_ebnf_comment">comment</a>s</dd>
    <dd><a class="ebnf" href="#tokens_ebnf_line_comment">line comment</a>s</dd>
</dl><p>
  White space always terminates a preceding <a class="link" href="#tokens_Identifiers">identifier</a>, <a class="link" href="#tokens_Integer_literals">integer</a>,
  <a class="link" href="#tokens_BigInteger_literals">bigInteger</a> or <a class="link" href="#tokens_Float_literals">float</a> literal. Some white space is required to
  separate otherwise adjacent tokens.
</p><dl><dt>
  Syntax:
</dt><dd><tt><dl>
    <dt><a name="tokens_ebnf_white_space">white_space</a> ::=</dt><dd>
      ( <a class="ebnf" href="#tokens_ebnf_space">space</a> | <a class="ebnf" href="#tokens_ebnf_comment">comment</a> | <a class="ebnf" href="#tokens_ebnf_line_comment">line_comment</a> )<br />
      { <a class="ebnf" href="#tokens_ebnf_space">space</a> | <a class="ebnf" href="#tokens_ebnf_comment">comment</a> | <a class="ebnf" href="#tokens_ebnf_line_comment">line_comment</a> } .</dd>
</dl></tt></dd></dl><p></p>

<a name="tokens_Spaces"><h4>10.1.1 Spaces</h4></a>
<p>
    There are several types of space characters which are ignored
  except as they separate tokens:
</p><dl><dd>
    blanks, horizontal tabs, carriage returns and new lines.
</dd></dl><dl><dt>
  Syntax:
</dt><dd><tt><dl>
    <dt><a name="tokens_ebnf_space">space</a> ::=</dt><dd>
      ' ' | TAB | CR | NL .</dd>
</dl></tt></dd></dl><p></p>

<a name="tokens_Comments"><h4>10.1.2 Comments</h4></a>
<p>
    Comments are introduced with the characters <span class="comment">(* and are
  terminated with the characters *)</span> . For example:
</p><pre class="indent">
<span class="comment">(* This is a comment *)</span>
</pre><p>
  Comment nesting is allowed so it is possible to comment out
  larger sections of the program which can also include comments.
  Comments cannot occur within <a class="link" href="#tokens_String_literals">string</a> or <a class="link" href="#tokens_Character_literals">character literals</a>.
</p><dl><dt>
  Syntax:
</dt><dd><tt><dl>
    <dt><a name="tokens_ebnf_comment">comment</a> ::=</dt><dd>
      '(*' { <a class="ebnf" href="#tokens_ebnf_any_character">any_character</a> } '*)' .</dd>
<dt><br /></dt>
    <dt><a name="tokens_ebnf_any_character">any_character</a> ::=</dt><dd>
      <a class="ebnf" href="#tokens_ebnf_simple_literal_character">simple_literal_character</a> | <a class="ebnf" href="#tokens_ebnf_apostrophe">apostrophe</a> | '"' | '\' |<br />
      <a class="ebnf" href="#tokens_ebnf_control_character">control_character</a>  .</dd>
<dt><br /></dt>
    <dt><a name="tokens_ebnf_control_character">control_character</a> ::=</dt><dd>
      NUL | SOH | STX | ETX | EOT | ENQ | ACK | BEL |<br />
      BS&nbsp; | TAB | LF&nbsp; | VT&nbsp; | FF&nbsp; | CR&nbsp; | SO&nbsp; | SI&nbsp; |<br />
      DLE | DC1 | DC2 | DC3 | DC4 | NAK | SYN | ETB |<br />
      CAN | EM&nbsp; | SUB | ESC | FS&nbsp; | GS&nbsp; | RS&nbsp; | US&nbsp; |<br />
      DEL .</dd>
</dl></tt></dd></dl><p></p>

<a name="tokens_Line_comments"><h4>10.1.3 Line comments</h4></a>
<p>
    Line comments are introduced with the character <span class="comment"># and are
  terminated with the end of the line.</span><br />
  For example:
</p><pre class="indent">
<span class="comment"># This is a comment</span>
</pre><p>
  Comments cannot occur within string, character or numerical
  literals.
</p><dl><dt>
  Syntax:
</dt><dd><tt><dl>
    <dt><a name="tokens_ebnf_line_comment">line_comment</a> ::=</dt><dd>
      '#' { <a class="ebnf" href="#tokens_ebnf_any_character">any_character</a> } NL .</dd>
</dl></tt></dd></dl><p></p>

<a name="tokens_Identifiers"><h3>10.2 Identifiers</h3></a>
<p>
    There are three types of identifiers
</p><dl>
    <dd><a class="ebnf" href="#tokens_ebnf_name_identifier">name identifier</a>s</dd>
    <dd><a class="ebnf" href="#tokens_ebnf_special_identifier">special identifier</a>s</dd>
    <dd><a class="ebnf" href="#tokens_ebnf_parenthesis">parenthesis</a></dd>
</dl><p>
  Identifiers can be written adjacent except that between two
  name identifiers and between two special identifiers white space
  must be used to separate them.
</p><dl><dt>
  Syntax:
</dt><dd><tt><dl>
    <dt><a name="tokens_ebnf_identifier">identifier</a> ::=</dt><dd>
      <a class="ebnf" href="#tokens_ebnf_name_identifier">name_identifier</a> | <a class="ebnf" href="#tokens_ebnf_special_identifier">special_identifier</a> | <a class="ebnf" href="#tokens_ebnf_parenthesis">parenthesis</a> .</dd>
</dl></tt></dd></dl><p></p>

<a name="tokens_Name_identifiers"><h4>10.2.1 Name identifiers</h4></a>
<p>
    A name identifier is a sequence of letters, digits and
  underscores ( _ ). The first character must be a letter or an
  underscore. Examples of name identifiers are:
</p><pre class="indent">
NUMBER  integer  const  if  UPPER_LIMIT  LowerLimit  x5  _end
</pre><p>
  Upper and lower case letters are different. Name identifiers
  may have any length and all characters are significant. The
  name identifier is terminated with a character which is
  neither a letter (or _ ) nor a digit. The terminating
  character is not part of the name identifier.
</p><dl><dt>
  Syntax:
</dt><dd><tt><dl>
    <dt><a name="tokens_ebnf_name_identifier">name_identifier</a> ::=</dt><dd>
      ( <a class="ebnf" href="#tokens_ebnf_letter">letter</a> | <a class="ebnf" href="#tokens_ebnf_underscore">underscore</a> ) { <a class="ebnf" href="#tokens_ebnf_letter">letter</a> | <a class="ebnf" href="#tokens_ebnf_digit">digit</a> | <a class="ebnf" href="#tokens_ebnf_underscore">underscore</a> } .</dd>
<dt><br /></dt>
    <dt><a name="tokens_ebnf_letter">letter</a> ::=</dt><dd>
      <a class="ebnf" href="#tokens_ebnf_upper_case_letter">upper_case_letter</a> | <a class="ebnf" href="#tokens_ebnf_lower_case_letter">lower_case_letter</a> .</dd>
<dt><br /></dt>
    <dt><a name="tokens_ebnf_upper_case_letter">upper_case_letter</a> ::=</dt><dd>
      'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' |<br />
      'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' |<br />
      'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' .</dd>
<dt><br /></dt>
    <dt><a name="tokens_ebnf_lower_case_letter">lower_case_letter</a> ::=</dt><dd>
      'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' |<br />
      'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' |<br />
      'u' | 'v' | 'w' | 'x' | 'y' | 'z' .</dd>
<dt><br /></dt>
    <dt><a name="tokens_ebnf_digit">digit</a> ::=</dt><dd>
      '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' .</dd>
<dt><br /></dt>
    <dt><a name="tokens_ebnf_underscore">underscore</a> ::=</dt><dd>
      '_' .</dd>
</dl></tt></dd></dl><p></p>

<a name="tokens_Special_identifiers"><h4>10.2.2 Special identifiers</h4></a>
<p>
    A special identifier is a sequence of special characters.
  Examples of special identifiers are:
</p><pre class="indent">
+  :=  &lt;=  *  ->  ,  &amp;
</pre><p>
  Here is a list of all special characters:
</p><pre class="indent">
! $ % &amp; * + , - . / : ; &lt; = > ? @ \ ^ ` | ~
</pre><p>
  Special identifiers may have any length and all characters are
  significant. The special identifier is terminated with a character
  which is not a special character. The terminating character is
  not part of the special identifier.
</p><dl><dt>
  Syntax:
</dt><dd><tt><dl>
    <dt><a name="tokens_ebnf_special_identifier">special_identifier</a> ::=</dt><dd>
      <a class="ebnf" href="#tokens_ebnf_special_character">special_character</a> { <a class="ebnf" href="#tokens_ebnf_special_character">special_character</a> } .</dd>
<dt><br /></dt>
    <dt><a name="tokens_ebnf_special_character">special_character</a> ::=</dt><dd>
      '!' | '$' | '%' | '&amp;' | '*' | '+' | ',' | '-' | '.' | '/' |<br />
      ':' | ';' | '&lt;' | '=' | '>' | '?' | '@' | '\' | '^' | '`' |<br />
      '|' | '~' .</dd>
</dl></tt></dd></dl><p></p>

<a name="tokens_Parentheses"><h4>10.2.3 Parentheses</h4></a>
<p>
    A parenthesis is one of the following characters:
</p><pre class="indent">
( ) [ ] { }
</pre><p>
  Note that a parenthesis consists of only one character. Except
  for the character sequence (* (which introduces a comment)
  a parenthesis is terminated with the next character.
</p><dl><dt>
  Syntax:
</dt><dd><tt><dl>
    <dt><a name="tokens_ebnf_parenthesis">parenthesis</a> ::=</dt><dd>
      '(' | ')' | '[' | ']' | '{' | '}' .</dd>
</dl></tt></dd></dl><p></p>

<a name="tokens_Literals"><h3>10.3 Literals</h3></a>
<p>
    There are several types of literals
</p><dl>
    <dd><a class="ebnf" href="#tokens_ebnf_integer_literal">integer literal</a>s</dd>
    <dd><a class="ebnf" href="#tokens_ebnf_biginteger_literal">biginteger literal</a>s</dd>
    <dd><a class="ebnf" href="#tokens_ebnf_float_literal">float literal</a>s</dd>
    <dd><a class="ebnf" href="#tokens_ebnf_character_literal">character literal</a>s</dd>
    <dd><a class="ebnf" href="#tokens_ebnf_string_literal">string literal</a>s</dd>
</dl><dl><dt>
  Syntax:
</dt><dd><tt><dl>
    <dt><a name="tokens_ebnf_literal">literal</a> ::=</dt><dd>
      <a class="ebnf" href="#tokens_ebnf_integer_literal">integer_literal</a> | <a class="ebnf" href="#tokens_ebnf_biginteger_literal">biginteger_literal</a> | <a class="ebnf" href="#tokens_ebnf_float_literal">float_literal</a> |<br />
      <a class="ebnf" href="#tokens_ebnf_character_literal">character_literal</a> | <a class="ebnf" href="#tokens_ebnf_string_literal">string_literal</a> .</dd>
</dl></tt></dd></dl><p></p>

<a name="tokens_Integer_literals"><h4>10.3.1 Integer literals</h4></a>
<p>
    An integer literal is a sequence of digits which is taken to
  be decimal. The sequence of digits may be followed by the letter
  E or e an optional + sign and a decimal exponent. Based numbers
  can be specified when the sequence of digits is followed by
  the # character and a sequence of extended digits. The decimal
  number in front of the # character specifies the base of the
  number which follows the # character. As base a number between
  2 and 36 is allowed. As extended digits the letters A or a can
  be used for 10, B or b can be used for 11 and so on to Z or z
  which can be used as 35.
</p><dl><dt>
  Syntax:
</dt><dd><tt><dl>
    <dt><a name="tokens_ebnf_integer_literal">integer_literal</a> ::=</dt><dd>
      <a class="ebnf" href="#tokens_ebnf_decimal_integer">decimal_integer</a> [ <a class="ebnf" href="#tokens_ebnf_exponent">exponent</a> | <a class="ebnf" href="#tokens_ebnf_based_integer">based_integer</a> ] .</dd>
<dt><br /></dt>
    <dt><a name="tokens_ebnf_decimal_integer">decimal_integer</a> ::=</dt><dd>
      <a class="ebnf" href="#tokens_ebnf_digit">digit</a> { <a class="ebnf" href="#tokens_ebnf_digit">digit</a> } .</dd>
<dt><br /></dt>
    <dt><a name="tokens_ebnf_exponent">exponent</a> ::=</dt><dd>
      ( 'E' | 'e' ) [ '+' ] <a class="ebnf" href="#tokens_ebnf_decimal_integer">decimal_integer</a> .</dd>
<dt><br /></dt>
    <dt><a name="tokens_ebnf_based_integer">based_integer</a> ::=</dt><dd>
      '#' <a class="ebnf" href="#tokens_ebnf_extended_digit">extended_digit</a> { <a class="ebnf" href="#tokens_ebnf_extended_digit">extended_digit</a> } .</dd>
<dt><br /></dt>
    <dt><a name="tokens_ebnf_extended_digit">extended_digit</a> ::=</dt><dd>
      <a class="ebnf" href="#tokens_ebnf_letter">letter</a> | <a class="ebnf" href="#tokens_ebnf_digit">digit</a> .</dd>
</dl></tt></dd></dl><p></p>

<a name="tokens_BigInteger_literals"><h4>10.3.2 BigInteger literals</h4></a>
<p>
    A bigInteger literal is a sequence of digits followed by the
  underline character. The sequence of digits is taken to be
  decimal. Based numbers can be specified when a sequence of
  digits is followed by the # character, a sequence of extended
  digits and the underline character. The decimal number in front
  of the # character specifies the base of the number which follows
  the # character. As base a number between 2 and 36 is allowed.
  As extended digits the letters A or a can be used for 10, B or b
  can be used for 11 and so on to Z or z which can be used as 35.
</p><dl><dt>
  Syntax:
</dt><dd><tt><dl>
    <dt><a name="tokens_ebnf_biginteger_literal">biginteger_literal</a> ::=</dt><dd>
      <a class="ebnf" href="#tokens_ebnf_decimal_integer">decimal_integer</a> [ <a class="ebnf" href="#tokens_ebnf_based_integer">based_integer</a> ] '_' .</dd>
</dl></tt></dd></dl><p></p>

<a name="tokens_Float_literals"><h4>10.3.3 Float literals</h4></a>
<p>
    A float literal consists of two decimal integer literals
  seperated by a decimal point. The basic float literal may be
  followed by the letter E or e an optional + or - sign and a
  decimal exponent.
</p><dl><dt>
  Syntax:
</dt><dd><tt><dl>
    <dt><a name="tokens_ebnf_float_literal">float_literal</a> ::=</dt><dd>
      <a class="ebnf" href="#tokens_ebnf_decimal_integer">decimal_integer</a> '.' <a class="ebnf" href="#tokens_ebnf_decimal_integer">decimal_integer</a> [ <a class="ebnf" href="#tokens_ebnf_float_exponent">float_exponent</a> ] .</dd>
<dt><br /></dt>
    <dt><a name="tokens_ebnf_float_exponent">float_exponent</a> ::=</dt><dd>
      ( 'E' | 'e' ) [ '+' | '-' ] <a class="ebnf" href="#tokens_ebnf_decimal_integer">decimal_integer</a> .</dd>
</dl></tt></dd></dl><p></p>

<a name="tokens_String_literals"><h4>10.3.4 String literals</h4></a>
<p>
    A string literal is a sequence of UTF-8 encoded Unicode
  characters surrounded by double quotes. For example:
</p><pre class="indent">
<span class="stri">""</span>   <span class="stri">" "</span>   <span class="stri">"\""</span>   <span class="stri">"'"</span>   <span class="stri">"\'"</span>   <span class="stri">"String"</span>   <span class="stri">"ch=\" "</span>   <span class="stri">"\n\n"</span>
</pre><p>
  In order to represent non-printable characters and certain
  printable characters the following escape sequences may be
  used.
</p><dl><dd><table border="0" cellspacing="0">
    <tr><td>audible alert   </td> <td width="20"></td><td>BEL     </td> <td width="20"></td><td><tt><span class="stri">\a</span></tt></td></tr>
    <tr><td>backspace       </td> <td width="20"></td><td>BS      </td> <td width="20"></td><td><tt><span class="stri">\b</span></tt></td></tr>
    <tr><td>escape          </td> <td width="20"></td><td>ESC     </td> <td width="20"></td><td><tt><span class="stri">\e</span></tt></td></tr>
    <tr><td>formfeed        </td> <td width="20"></td><td>FF      </td> <td width="20"></td><td><tt><span class="stri">\f</span></tt></td></tr>
    <tr><td>newline         </td> <td width="20"></td><td>NL (LF) </td> <td width="20"></td><td><tt><span class="stri">\n</span></tt></td></tr>
    <tr><td>carriage return </td> <td width="20"></td><td>CR      </td> <td width="20"></td><td><tt><span class="stri">\r</span></tt></td></tr>
    <tr><td>horizontal tab  </td> <td width="20"></td><td>HT      </td> <td width="20"></td><td><tt><span class="stri">\t</span></tt></td></tr>
    <tr><td>vertical tab    </td> <td width="20"></td><td>VT      </td> <td width="20"></td><td><tt><span class="stri">\v</span></tt></td></tr>
    <tr><td>backslash       </td> <td width="20"></td><td>(\)     </td> <td width="20"></td><td><tt><span class="stri">\\</span></tt></td></tr>
    <tr><td>apostrophe      </td> <td width="20"></td><td>(')     </td> <td width="20"></td><td><tt><span class="stri">\'</span></tt></td></tr>
    <tr><td>double quote    </td> <td width="20"></td><td>(")     </td> <td width="20"></td><td><tt><span class="stri">\"</span></tt></td></tr>
    <tr><td>control-A       </td> <td width="20"></td><td>        </td> <td width="20"></td><td><tt><span class="stri">\A</span></tt></td></tr>
    <tr><td>  ...</td></tr>
    <tr><td>control-Z       </td> <td width="20"></td><td>        </td> <td width="20"></td><td><tt><span class="stri">\Z</span></tt></td></tr>
</table></dd></dl><p>
  Additionally there are the following possibilities:
</p><ul>
    <li>Two backslashes with a sequence of blanks, horizontal tabs,
      carriage returns and new lines between them are completely
      ignored. The ignored characters are not part of the string.
      This can be used to continue a string in the following line.
      Note that in this case the leading spaces in the new line
      are not part of the string.</li>

    <li>Two backslashes with an integer literal between them is
      interpreted as character with the specified ordinal number.
      Note that the integer literal is interpreted decimal unless
      it is written as based integer.</li>
</ul><p>
  Strings are implemented with length field and UTF-32 encoding.
  Strings are not '\0\' terminated and therefore can also contain
  binary data.
</p><dl><dt>
  Syntax:
</dt><dd><tt><dl>
    <dt><a name="tokens_ebnf_string_literal">string_literal</a> ::=</dt><dd>
      '"' { <a class="ebnf" href="#tokens_ebnf_string_literal_element">string_literal_element</a> } '"' .</dd>
<dt><br /></dt>
    <dt><a name="tokens_ebnf_string_literal_element">string_literal_element</a> ::=</dt><dd>
      <a class="ebnf" href="#tokens_ebnf_simple_literal_character">simple_literal_character</a> | <a class="ebnf" href="#tokens_ebnf_escape_sequence">escape_sequence</a> | <a class="ebnf" href="#tokens_ebnf_apostrophe">apostrophe</a> .</dd>
<dt><br /></dt>
    <dt><a name="tokens_ebnf_simple_literal_character">simple_literal_character</a> ::=</dt><dd>
      <a class="ebnf" href="#tokens_ebnf_letter">letter</a> | <a class="ebnf" href="#tokens_ebnf_digit">digit</a> | <a class="ebnf" href="#tokens_ebnf_parenthesis">parenthesis</a> | <a class="ebnf" href="#tokens_ebnf_special_literal_character">special_literal_character</a> |<br />
      utf8_encoded_character .</dd>
<dt><br /></dt>
    <dt><a name="tokens_ebnf_special_literal_character">special_literal_character</a> ::=</dt><dd>
      '&nbsp;' | '!' | '#' | '$' | '%' | '&amp;' | '*' | '+' | ',' | '-' |<br />
      '.' | '/' | ':' | ';' | '&lt;' | '=' | '>' | '?' | '@' | '^' |<br />
      '_' | '`' | '|' | '~' .</dd>
<dt><br /></dt>
    <dt><a name="tokens_ebnf_escape_sequence">escape_sequence</a> ::=</dt><dd>
      '\a' | '\b' | '\e' | '\f' | '\n' | '\r' | '\t' | '\v' |<br />
      '\\' | '\''' | '\"' | '\' <a class="ebnf" href="#tokens_ebnf_upper_case_letter">upper_case_letter</a> |<br />
      '\' { <a class="ebnf" href="#tokens_ebnf_space">space</a> } '\' | '\' <a class="ebnf" href="#tokens_ebnf_integer_literal">integer_literal</a> '\' .</dd>
<dt><br /></dt>
    <dt><a name="tokens_ebnf_apostrophe">apostrophe</a> ::=</dt><dd>
      ''' .</dd>
</dl></tt></dd></dl><p></p>

<a name="tokens_Character_literals"><h4>10.3.5 Character literals</h4></a>
<p>
    A character literal is an UTF-8 encoded Unicode character
  enclosed in apostrophes. For example:
</p><pre class="indent">
<span class="stri">'a'</span>   <span class="stri">' '</span>   <span class="stri">'\n'</span>   <span class="stri">'!'</span>   <span class="stri">'\\'</span>   <span class="stri">'2'</span>   <span class="stri">'"' </span>  <span class="stri">'\"'</span>   <span class="stri">'\''</span>
</pre><p>
  To represent control characters and certain other characters in
  character literals the same escape sequences as for <a class="link" href="#tokens_String_literals">string
  literals</a> may be used.
</p><dl><dt>
  Syntax:
</dt><dd><tt><dl>
    <dt><a name="tokens_ebnf_character_literal">character_literal</a> ::=</dt><dd>
      <a class="ebnf" href="#tokens_ebnf_apostrophe">apostrophe</a> <a class="ebnf" href="#tokens_ebnf_char_literal_element">char_literal_element</a> <a class="ebnf" href="#tokens_ebnf_apostrophe">apostrophe</a> .</dd>
<dt><br /></dt>
    <dt><a name="tokens_ebnf_char_literal_element">char_literal_element</a> ::=</dt><dd>
      <a class="ebnf" href="#tokens_ebnf_simple_literal_character">simple_literal_character</a> | <a class="ebnf" href="#tokens_ebnf_escape_sequence">escape_sequence</a> | <a class="ebnf" href="#tokens_ebnf_apostrophe">apostrophe</a> | '"' .</dd>
</dl></tt></dd></dl><p></p>

<a name="expr_file_start"></a><p></p>
<a name="expr_EXPRESSIONS"><h2>11. EXPRESSIONS</h2></a>

<p>
    There are two types of expressions. On one side there so
  called simple expressions, which are constructed using fixed
  predefined syntax rules. On the other side there are expressions
  which are constructed according to syntax rules. Syntax rules
  are defined with syntax declarations. How syntax declarations
  work is described in <a class="link" href="#decls_Syntax_declarations">Chapter 3.2 (Syntax declarations)</a> and
  <a class="link" href="#syntax_file_start">chapter 9 (Structured syntax definition)</a>. The syntax
  declarations support the extensible syntax of Seed7. A
  simplified description of user defined expressions, which
  does not take priority levels into account, is:
</p><dl><dd><tt><dl>
    <dt><a name="expr_ebnf_expression">expression</a> ::=</dt><dd>
      <a class="ebnf" href="#expr_ebnf_prefix_expression">prefix_expression</a> | <a class="ebnf" href="#expr_infix_expression">infix_expression</a> | <a class="ebnf" href="#expr_ebnf_simple_expression">simple_expression</a> .</dd>
<dt><br /></dt>
    <dt><a name="expr_ebnf_prefix_expression">prefix_expression</a> ::=</dt><dd>
      <a class="ebnf" href="#tokens_ebnf_identifier">identifier</a> { <a class="ebnf" href="#tokens_ebnf_identifier">identifier</a> | <a class="ebnf" href="#expr_ebnf_expression">expression</a> } .</dd>
<dt><br /></dt>
    <dt><a name="expr_infix_expression">infix_expression</a> ::=</dt><dd>
      <a class="ebnf" href="#expr_ebnf_expression">expression</a> <a class="ebnf" href="#tokens_ebnf_identifier">identifier</a> { <a class="ebnf" href="#tokens_ebnf_identifier">identifier</a> | <a class="ebnf" href="#expr_ebnf_expression">expression</a> } .</dd>
<dt><br /></dt>
    <dt><a name="expr_ebnf_simple_expression">simple_expression</a> ::=</dt><dd>
      <a class="ebnf" href="#expr_ebnf_dot_expression">dot_expression</a> .</dd>
</dl></tt></dd></dl><p>
  The chapters below describe the predefined syntax rules
  of simple expressions.
</p>

<a name="expr_EXPRESSION_Parentheses"><h3>11.1 Parentheses</h3></a>
<p>
    Parentheses can be used to override any precedence
  rules of predefined and user defined syntax constructs.
  For example
</p><pre class="indent">
2 * (3 + 4)
</pre><p>
  specifies that the + operator gets his parameters first.
</p><dl><dt>
  Syntax:
</dt><dd><tt><dl>
    <dt><a name="expr_ebnf_parentheses_expression">parentheses_expression</a> ::=</dt><dd>
      '(' <a class="ebnf" href="#expr_ebnf_expression">expression</a> ')' .</dd>
</dl></tt></dd></dl><p></p>

<a name="expr_Call_expressions"><h3>11.2 Call expressions</h3></a>
<p>
    Call expressions can also be used to form a list.
  For example
</p><pre class="indent">
writeln(<span class="stri">"hello world"</span>)
</pre><p>
  forms a list expression with the elements
</p><dl>
    <dd><tt><span class="stri">"hello world"</span></tt></dd>
    <dd><tt>writeln</tt></dd>
</dl><p>
  The meta object of this list is specified with the system
  declaration <span class="stri">"system expr"</span> which is defined in the include
  file <span class="stri">"syntax.s7i"</span> included from <span class="stri">"seed7_05.s7i"</span> as
</p><pre class="indent">
$ <span class="keywd">system</span> <span class="stri">"expr"</span> is expr;
</pre><p>
  A call expression with two parameters as
</p><pre class="indent">
pos(<span class="stri">"Scotty! Beam me up."</span>, <span class="stri">"am"</span>)
</pre><p>
  forms a list expression with the elements
</p><dl>
    <dd><tt><span class="stri">"Scotty! Beam me up."</span></tt></dd>
    <dd><tt><span class="stri">"am"</span></tt></dd>
    <dd><tt>pos</tt></dd>
</dl><dl><dt>
  Syntax:
</dt><dd><tt><dl>
    <dt><a name="expr_ebnf_call_expression">call_expression</a> ::=</dt><dd>
      <a class="ebnf" href="#expr_ebnf_primary_expression">primary_expression</a> [ '(' <a class="ebnf" href="#expr_ebnf_parameter_list">parameter_list</a> ')' ] .</dd>
<dt><br /></dt>
    <dt><a name="expr_ebnf_primary_expression">primary_expression</a> ::=</dt><dd>
      <a class="ebnf" href="#expr_ebnf_parentheses_expression">parentheses_expression</a> | <a class="ebnf" href="#tokens_ebnf_token">token</a> .</dd>
<dt><br /></dt>
    <dt><a name="expr_ebnf_parameter_list">parameter_list</a> ::=</dt><dd>
      <a class="ebnf" href="#expr_ebnf_expression">expression</a> { ',' <a class="ebnf" href="#expr_ebnf_expression">expression</a> } .</dd>
</dl></tt></dd></dl><p></p>

<a name="expr_Dot_expressions"><h3>11.3 Dot expressions</h3></a>
<p>
    Dot expressions start with a dot and have dots as separator
  between the elements of the list. For example
</p><pre class="indent">
.<span class="op">not</span>.TRUE
</pre><p>
  and
</p><pre class="indent">
.OKAY.<span class="op">and</span>.GO_ON
</pre><p>
  form list expressions with the elements
</p><dl>
    <dd><tt><span class="op">not</span></tt></dd>
    <dd><tt>TRUE</tt></dd>
</dl><p>
  and
</p><dl>
    <dd><tt>OKAY</tt></dd>
    <dd><tt><span class="op">and</span></tt></dd>
    <dd><tt>GO_ON</tt></dd>
</dl><p>
  The meta object of this list is specified with the system
  declaration <span class="stri">"system expr"</span> which is defined in the include
  file <span class="stri">"syntax.s7i"</span> included from <span class="stri">"seed7_05.s7i"</span> as
</p><pre class="indent">
$ <span class="keywd">system</span> <span class="stri">"expr"</span> <span class="keywd">is</span> <a class="type" href="#types_expr">expr</a>;
</pre><p>
  Dot expressions override the priority of the elements.
  Dot expressions are used in <tt>'<span class="keywd">syntax</span>'</tt> declarations.
</p><dl><dt>
  Syntax:
</dt><dd><tt><dl>
    <dt><a name="expr_ebnf_dot_expression">dot_expression</a> ::=</dt><dd>
      [ '.' ] <a class="ebnf" href="#expr_ebnf_call_expression">call_expression</a> { '.' <a class="ebnf" href="#expr_ebnf_call_expression">call_expression</a> } .</dd>
</dl></tt></dd></dl><p></p>

<a name="os_file_start"></a><p></p>
<a name="os_OPERATING_SYSTEM_ACCESS"><h2>12. OPERATING SYSTEM ACCESS</h2></a>

<p>
    Seed7 provides a portable access to the services provided
  by an operating system. This interface is oriented towards
  Posix and Unix. The functions in this chapter are defined
  in the libraries <span class="stri">"<span class="lib">osfiles.s7i</span>"</span>, <span class="stri">"<span class="lib">dir.s7i</span>"</span> and <span class="stri">"<span class="lib">environment.s7i</span>"</span>.
</p>

<a name="os_Standard_path_representation"><h3>12.1 Standard path representation</h3></a>
<p>
    A path specifies the location of a file in a file system.
  Operating systems have different concepts how a path should
  look like. Seed7 compensates this differences with a standard
  path representation. Standard paths are used by all Seed7
  functions dealing with paths. The standard path representation
  uses <tt><a class="type" href="#types_string">string</a>s</tt> with the following properties to describe paths:
</p><ul>
    <li>The slash (<tt><span class="stri">'/'</span></tt>) is used as path delimiter.</li>
    <li>Drive letters are not allowed, but there is a solution
      to replace them.</li>
    <li>Except for the path <tt><span class="stri">"/"</span></tt> a standard path is not allowed
      to end with a slash.
</ul><p>
  When a function like <tt><span class="func">open</span></tt> is called with a path that is not
  <tt><span class="stri">"/"</span></tt>, but ends with a slash, the exception <tt><a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a></tt> is
  raised. Under Windows a standard path like <tt><span class="stri">"/c"</span></tt> is mapped to
  the drive <tt><span class="stri">"C:"</span></tt>. Reading the directory <tt><span class="stri">"/"</span></tt> under Windows
  returns a list of available drives. A path with a backslash
  or with a drive letter may raise the exception <tt><a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a></tt>,
  when a function like <tt><span class="func">open</span></tt> is called.
</p><p>
  An absolute path specifies an unique location in the file
  system. Absolute paths always start with a slash. A relative
  path specifies a location relative to the current working
  directory of the program. Although standard paths are defined
  in a portable way, an absolute path will usually not be portable.
</p>

<a name="os_readDir"><h3>12.2 readDir</h3></a>
<p>
    The function <tt><span class="func">readDir</span></tt> provides a portable access to the
  contents of directories in the file system. It reads the
  specified directory and the filenames are stored in the
  string-array result. The files <tt><span class="stri">"."</span></tt> and <tt><span class="stri">".."</span></tt> are left out from
  the result. Note that the strings contain only the filenames.
  Additional information must be obtained with other calls.
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_func">func</a> <a class="type" href="#types_array">array</a> <a class="type" href="#types_string">string</a>: readDir (<span class="keywd">in</span> <a class="type" href="#types_string">string</a>: dirPath) <span class="keywd">is</span> ...
</pre>
  <div><dl><dt><p>Returns:</p></dt><dd><p>
    An array of strings containing the names of all
    files in the specified directory, except <tt><span class="stri">"."</span></tt> and <tt><span class="stri">".."</span></tt>
</p></dd></dl></div>
  <div><dl><dt><p>Possible exceptions:</p></dt><dd><dl>
    <dt><a class="exception" href="#errors_MEMORY_ERROR">MEMORY_ERROR</a></dt>
        <dd>Not enough memory to convert <tt>'dirPath'</tt> to the system
        path type or not enough memory to represent the result
        <tt><a class="type" href="#types_array">array</a> <a class="type" href="#types_string">string</a></tt>.</dd>
    <dt><a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a></dt>
        <dd><tt>'dirPath'</tt> does not use the <a class="link" href="#os_Standard_path_representation">standard path representation</a>
        or it cannot be converted to the system path type.</dd>
    <dt><a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a></dt>
        <dd>A system function returns an error.</dd>
</dl></dd></dl></div>
  <div><dl><dt><p>Examples:</p></dt><dd><p>
    After the declaration
</p><pre class="indent">
<span class="keywd">var</span> <a class="type" href="#types_array">array</a> <a class="type" href="#types_string">string</a>: dir_array <span class="keywd">is</span> 0 <span class="op">times</span> <span class="stri">""</span>;
</pre><p>
    the statement
</p><pre class="indent">
dir_array := readDir(<span class="stri">"."</span>);
</pre><p>
    reads the current working directory and stores it into the
    string-array <tt>'dir_array'</tt>. The components of the directory
    can now be accessed via indexing:
</p><pre class="indent">
<span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> length(dir_array) <span class="keywd">do</span>
  writeln(dir_array[index]);
<span class="keywd">end for</span>;
</pre><p></p></dd></dl></div><p></p>

<a name="os_openDir"><h3>12.3 openDir</h3></a>
<p>
    The function <tt><span class="func">openDir</span></tt> opens the specified directory as file.
  Each line in this directory file contains the filename of a
  file present in the the directory. The files <tt><span class="stri">"."</span></tt> and <tt><span class="stri">".."</span></tt> are
  left out from the directory file. Note that only filenames can
  be read from the directory file. Additional information must be
  obtained with other calls.
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_func">func</a> <a class="type" href="#types_file">file</a>: openDir (<span class="keywd">in</span> <a class="type" href="#types_string">string</a>: dirPath) <span class="keywd">is</span> ...
</pre>
  <div><dl><dt><p>Returns:</p></dt><dd><p>
    The directory file of the specified directory.
</p></dd></dl></div>
  <div><dl><dt><p>Possible exceptions:</p></dt><dd><dl>
    <dt><a class="exception" href="#errors_MEMORY_ERROR">MEMORY_ERROR</a></dt>
        <dd>Not enough memory to convert <tt>'dirPath'</tt> to the system
        path type or not enough memory to represent the result
        <tt><a class="type" href="#types_array">array</a> <a class="type" href="#types_string">string</a></tt>.</dd>
    <dt><a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a></dt>
        <dd><tt>'dirPath'</tt> does not use the <a class="link" href="#os_Standard_path_representation">standard path representation</a>
        or it cannot be converted to the system path type.</dd>
    <dt><a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a></dt>
        <dd>A system function returns an error.</dd>
</dl></dd></dl></div>
  <div><dl><dt><p>Examples:</p></dt><dd><pre class="indent">
...

<span class="keywd">include</span> <span class="stri">"dir.s7i"</span>;

<span class="keywd">var</span> <a class="type" href="#types_file">file</a>: dir_file <span class="keywd">is</span> STD_NULL;
<span class="keywd">var</span> <a class="type" href="#types_string">string</a>: file_name <span class="keywd">is</span> <span class="stri">""</span>;

...

dir_file := openDir(<span class="stri">"."</span>);
file_name := getln(dir_file);
<span class="keywd">while</span> file_name &lt;> <span class="stri">""</span> <span class="keywd">do</span>
  writeln(file_name);
  file_name := getln(dir_file);
<span class="keywd">end while</span>;
</pre><p></p></dd></dl></div><p></p>

<a name="os_getcwd"><h3>12.4 getcwd</h3></a>
<p>
    The function <tt><span class="func">getcwd</span></tt> returns the current working directory
  of the calling process as absolute path.
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_func">func</a> <a class="type" href="#types_string">string</a>: getcwd <span class="keywd">is</span> ...
</pre>
  <div><dl><dt><p>Returns:</p></dt><dd><p>
    The absolute path of the current working directory.
</p></dd></dl></div>
  <div><dl><dt><p>Possible exceptions:</p></dt><dd><dl>
    <dt><a class="exception" href="#errors_MEMORY_ERROR">MEMORY_ERROR</a></dt>
        <dd>Not enough memory to represent the result <tt><a class="type" href="#types_string">string</a></tt>.</dd>
    <dt><a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a></dt>
        <dd>The system function returns an error.</dd>
</dl></dd></dl></div>
  <div><dl><dt><p>Examples:</p></dt><dd><p>
    The statement
</p><pre class="indent">
my_dir := getcwd;
</pre><p>
    assigns the full path of the current working directory to
    the <tt><a class="type" href="#types_string">string</a></tt> variable <tt>'my_dir'</tt>.
</p></dd></dl></div><p></p>

<a name="os_chdir"><h3>12.5 chdir</h3></a>
<p>
    The function <tt><span class="func">chdir</span></tt> changes the current working directory
  of the calling process to the specified directory.
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: chdir (<span class="keywd">in</span> <a class="type" href="#types_string">string</a>: name) <span class="keywd">is</span> ...
</pre>
  <div><dl><dt><p>Possible exceptions:</p></dt><dd><dl>
    <dt><a class="exception" href="#errors_MEMORY_ERROR">MEMORY_ERROR</a></dt>
        <dd>Not enough memory to convert <tt>'name'</tt> to the system path type.</dd>
    <dt><a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a></dt>
        <dd><tt>'name'</tt> does not use the <a class="link" href="#os_Standard_path_representation">standard path representation</a>
        or it cannot be converted to the system path type.</dd>
    <dt><a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a></dt>
        <dd>A system function returns an error.</dd>
</dl></dd></dl></div>
  <div><dl><dt><p>Examples:</p></dt><dd><p>
    The statement
</p><pre class="indent">
chdir(<span class="stri">"/usr/bin"</span>);
</pre><p>
    changes the current working directory to <tt><span class="stri">"/usr/bin"</span></tt>.
</p></dd></dl></div><p></p>

<a name="os_mkdir"><h3>12.6 mkdir</h3></a>
<p>
    The function <tt><span class="func">mkdir</span></tt> creates a new directory.
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: mkdir (<span class="keywd">in</span> <a class="type" href="#types_string">string</a>: name) <span class="keywd">is</span> ...
</pre>
  <div><dl><dt><p>Possible exceptions:</p></dt><dd><dl>
    <dt><a class="exception" href="#errors_MEMORY_ERROR">MEMORY_ERROR</a></dt>
        <dd>Not enough memory to convert <tt>'name'</tt> to the system path type.</dd>
    <dt><a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a></dt>
        <dd><tt>'name'</tt> does not use the <a class="link" href="#os_Standard_path_representation">standard path representation</a>
        or it cannot be converted to the system path type.</dd>
    <dt><a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a></dt>
        <dd>A system function returns an error.</dd>
</dl></dd></dl></div>
  <div><dl><dt><p>Examples:</p></dt><dd><p>
    The statement
</p><pre class="indent">
mkdir(<span class="stri">"my_dir"</span>);
</pre><p>
    creates the directory <tt><span class="stri">"my_dir"</span></tt>.
</p></dd></dl></div><p></p>

<a name="os_homeDir"><h3>12.7 homeDir</h3></a>
<p>
    The function <tt><span class="func">homeDir</span></tt> returns the home directory of the user
  as absolute path.
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_func">func</a> <a class="type" href="#types_string">string</a>: homeDir <span class="keywd">is</span> ...
</pre><p>
  This function should be preferred over the use of an environment
  variable such as <tt>$HOME</tt>. <tt>$HOME</tt> is not supported under all operating
  systems and it is not guaranteed, that it uses the <a class="link" href="#os_Standard_path_representation">standard path
  representation</a>.
</p>
  <div><dl><dt><p>Returns:</p></dt><dd><p>
    The absolute path of the home directory.
</p></dd></dl></div>
  <div><dl><dt><p>Possible exceptions:</p></dt><dd><dl>
    <dt><a class="exception" href="#errors_MEMORY_ERROR">MEMORY_ERROR</a></dt>
        <dd>Not enough memory to represent the result <tt><a class="type" href="#types_string">string</a></tt>.</dd>
    <dt><a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a></dt>
        <dd>Not able to determine the home directory.</dd>
</dl></dd></dl></div>
  <div><dl><dt><p>Examples:</p></dt><dd><p>
    The statement
</p><pre class="indent">
my_dir := homeDir;
</pre><p>
    assigns the full path of the home directory to the
    <tt><a class="type" href="#types_string">string</a></tt> variable <tt>'my_dir'</tt>.
</p></dd></dl></div><p></p>

<a name="os_fileType"><h3>12.8 fileType</h3></a>
<p>
    The type of a file can determined with <tt><span class="func">fileType</span></tt> or <tt><span class="func">fileTypeSL</span></tt>:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_func">func</a> <a class="type" href="#types_integer">integer</a>: fileType (<span class="keywd">in</span> <a class="type" href="#types_string">string</a>: filePath) <span class="keywd">is</span> ...
<span class="keywd">const</span> <a class="type" href="#types_func">func</a> <a class="type" href="#types_integer">integer</a>: fileTypeSL (<span class="keywd">in</span> <a class="type" href="#types_string">string</a>: filePath) <span class="keywd">is</span> ...
</pre><p>
  The function <tt><span class="func">fileType</span></tt> does follow symbolic links. Therefore
  <tt><span class="func">fileType</span></tt> never returns <tt>'FILE_SYMLINK'</tt>. The function <tt><span class="func">fileTypeSL</span></tt>
  can also return <tt>'FILE_SYMLINK'</tt>, because it does not follow symbolic
  links. All functions which use a file path, except <tt><span class="func">fileTypeSL</span></tt>
  and <tt><span class="func">readlink</span></tt> follow symbolic links.  A return value of
  <tt>'FILE_ABSENT'</tt> does not imply that a file with this name can be
  created, since missing directories and illegal file names cause
  also <tt>'FILE_ABSENT'</tt>.
</p>
  <div><dl><dt><p>Returns:</p></dt><dd><dl>
    <dt>FILE_ABSENT</dt>
        <dd>A component of path does not exist.</dd>
    <dt>FILE_UNKNOWN</dt>
        <dd>The file exists but has an unknown type.</dd>
    <dt>FILE_REGULAR</dt>
        <dd>The file is a regular file.</dd>
    <dt>FILE_DIR</dt>
        <dd>The file is a directory.</dd>
    <dt>FILE_CHAR</dt>
        <dd>The file is a character special file.</dd>
    <dt>FILE_BLOCK</dt>
        <dd>The file is a block special file.</dd>
    <dt>FILE_FIFO</dt>
        <dd>The file is a pipe or FIFO special file.</dd>
    <dt>FILE_SYMLINK</dt>
        <dd>The file is a symbolic link.</dd>
    <dt>FILE_SOCKET</dt>
        <dd>The file is a socket.</dd>
</dl></dd></dl></div>
  <div><dl><dt><p>Possible exceptions:</p></dt><dd><dl>
    <dt><a class="exception" href="#errors_MEMORY_ERROR">MEMORY_ERROR</a></dt>
        <dd>Not enough memory to convert <tt>'filePath'</tt> to the system path type.</dd>
    <dt><a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a></dt>
        <dd><tt>'filePath'</tt> does not use the <a class="link" href="#os_Standard_path_representation">standard path representation</a>.</dd>
    <dt><a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a></dt>
        <dd>The system function returns an error other than ENOENT,
        ENOTDIR or ENAMETOOLONG.</dd>
</dl></dd></dl></div><p></p>

<a name="os_fileMode"><h3>12.9 fileMode</h3></a>
<p>
    The permissions of a file can determined with <tt><span class="func">fileMode</span></tt>:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_func">func</a> <span class="type">fileMode</span>: fileMode (<span class="keywd">in</span> <a class="type" href="#types_string">string</a>: filePath) <span class="keywd">is</span> ...
</pre>
  <div><dl><dt><p>Returns:</p></dt><dd><p>
    The <tt><span class="type">fileMode</span></tt> which is defined as <tt><a class="type" href="#types_set">set</a> <span class="type">of</span> <span class="type">filePermission</span></tt>.
</p></dd></dl></div>
  <div><dl><dt><p>The literal values of <tt><span class="type">filePermission</span></tt> are:</p></dt><dd><dl>
    <dt>EXEC_OTHER</dt>
        <dd>others have execute permission</dd>
    <dt>WRITE_OTHER</dt>
        <dd>others have write permission</dd>
    <dt>READ_OTHER</dt>
        <dd>others have read permission</dd>
    <dt>EXEC_GROUP</dt>
        <dd>group has execute permission</dd>
    <dt>WRITE_GROUP</dt>
        <dd>group has write permission</dd>
    <dt>READ_GROUP</dt>
        <dd>group has read permission</dd>
    <dt>EXEC_USER</dt>
        <dd>owner has execute permission</dd>
    <dt>WRITE_USER</dt>
        <dd>owner has write permission</dd>
    <dt>READ_USER</dt>
        <dd>owner has read permission</dd>
</dl></dd></dl></div>
  <div><dl><dt><p>Possible exceptions:</p></dt><dd><dl>
    <dt><a class="exception" href="#errors_MEMORY_ERROR">MEMORY_ERROR</a></dt>
        <dd>Not enough memory to convert <tt>'filePath'</tt> to the system path type.</dd>
    <dt><a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a></dt>
        <dd><tt>'filePath'</tt> does not use the <a class="link" href="#os_Standard_path_representation">standard path representation</a>
        or it cannot be converted to the system path type.</dd>
    <dt><a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a></dt>
        <dd>A system function returns an error.</dd>
</dl></dd></dl></div><p></p>

<a name="os_setFileMode"><h3>12.10 setFileMode</h3></a>
<p>
    The permissions of a file can changed with <tt><span class="func">setFileMode</span></tt>:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: setFileMode (<span class="keywd">in</span> <a class="type" href="#types_string">string</a>: filePath, <span class="keywd">in</span> <span class="type">fileMode</span>: newFileMode) <span class="keywd">is</span> ...
</pre><p>
  The type <tt><span class="type">fileMode</span></tt> is defined as <tt>'<a class="type" href="#types_set">set</a> <span class="type">of</span> <span class="type">filePermission</span>'</tt>.
</p>
  <div><dl><dt><p>The literal values of <tt><span class="type">filePermission</span></tt> are:</p></dt><dd><dl>
    <dt>EXEC_OTHER</dt>
        <dd>others have execute permission</dd>
    <dt>WRITE_OTHER</dt>
        <dd>others have write permission</dd>
    <dt>READ_OTHER</dt>
        <dd>others have read permission</dd>
    <dt>EXEC_GROUP</dt>
        <dd>group has execute permission</dd>
    <dt>WRITE_GROUP</dt>
        <dd>group has write permission</dd>
    <dt>READ_GROUP</dt>
        <dd>group has read permission</dd>
    <dt>EXEC_USER</dt>
        <dd>owner has execute permission</dd>
    <dt>WRITE_USER</dt>
        <dd>owner has write permission</dd>
    <dt>READ_USER</dt>
        <dd>owner has read permission</dd>
</dl></dd></dl></div>
  <div><dl><dt><p>Possible exceptions:</p></dt><dd><dl>
    <dt><a class="exception" href="#errors_MEMORY_ERROR">MEMORY_ERROR</a></dt>
        <dd>Not enough memory to convert <tt>'filePath'</tt> to the system path type.</dd>
    <dt><a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a></dt>
        <dd><tt>'filePath'</tt> does not use the <a class="link" href="#os_Standard_path_representation">standard path representation</a>
        or it cannot be converted to the system path type.</dd>
    <dt><a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a></dt>
        <dd>A system function returns an error.</dd>
</dl></dd></dl></div><p></p>

<a name="os_fileSize"><h3>12.11 fileSize</h3></a>
<p>
    The size of a file can be determined with <tt><span class="func">fileSize</span></tt> and <tt><span class="func">bigFileSize</span></tt>:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_func">func</a> <a class="type" href="#types_integer">integer</a>: fileSize (<span class="keywd">in</span> <a class="type" href="#types_string">string</a>: filePath) <span class="keywd">is</span> ...
<span class="keywd">const</span> <a class="type" href="#types_func">func</a> <a class="type" href="#types_bigInteger">bigInteger</a>: bigFileSize (<span class="keywd">in</span> <a class="type" href="#types_string">string</a>: filePath) <span class="keywd">is</span> ...
</pre>
  <div><dl><dt><p>Returns:</p></dt><dd><p>
    For directories a size of 0 is returned. For other file types
    the operating system functions <tt>'stat()'</tt> and <tt>'seek()'</tt> are
    used to determine the size of a file. The functions <tt>'fileSize'</tt>
    and <tt>'bigFileSize'</tt> succeed when at least one strategy to determine
    the file size succeeds.
</p></dd></dl></div>
  <div><dl><dt><p>Possible exceptions:</p></dt><dd><dl>
    <dt><a class="exception" href="#errors_MEMORY_ERROR">MEMORY_ERROR</a></dt>
        <dd>Not enough memory to convert <tt>'filePath'</tt> to the system path type.</dd>
    <dt><a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a></dt>
        <dd><tt>'filePath'</tt> does not use the <a class="link" href="#os_Standard_path_representation">standard path representation</a>
        or it cannot be converted to the system path type.</dd>
    <dt><a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a></dt>
        <dd>The file size is not representable as <tt><a class="type" href="#types_integer">integer</a></tt>
        (this exception is not raised by <tt>'bigFileSize'</tt>).</dd>
    <dt><a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a></dt>
        <dd>It was not possible to determine the file size.</dd>
</dl></dd></dl></div><p></p>

<a name="os_getATime"><h3>12.12 getATime</h3></a>
<p>
    The access time of a file is returned by the function <tt><span class="func">getATime</span></tt>:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_func">func</a> <a class="type" href="#types_time">time</a>: getATime (<span class="keywd">in</span> <a class="type" href="#types_string">string</a>: filePath) <span class="keywd">is</span> ...
</pre>
  <div><dl><dt><p>Possible exceptions:</p></dt><dd><dl>
    <dt><a class="exception" href="#errors_MEMORY_ERROR">MEMORY_ERROR</a></dt>
        <dd>Not enough memory to convert <tt>'filePath'</tt> to the system path type.</dd>
    <dt><a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a></dt>
        <dd><tt>'filePath'</tt> does not use the <a class="link" href="#os_Standard_path_representation">standard path representation</a>
        or it cannot be converted to the system path type.</dd>
    <dt><a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a></dt>
        <dd>A system function returns an error.</dd>
</dl></dd></dl></div><p></p>

<a name="os_getCTime"><h3>12.13 getCTime</h3></a>
<p>
    The change time of a file is returned by the function <tt><span class="func">getCTime</span></tt>:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_func">func</a> <a class="type" href="#types_time">time</a>: getCTime (<span class="keywd">in</span> <a class="type" href="#types_string">string</a>: filePath) <span class="keywd">is</span> ...
</pre>
  <div><dl><dt><p>Possible exceptions:</p></dt><dd><dl>
    <dt><a class="exception" href="#errors_MEMORY_ERROR">MEMORY_ERROR</a></dt>
        <dd>Not enough memory to convert <tt>'filePath'</tt> to the system path type.</dd>
    <dt><a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a></dt>
        <dd><tt>'filePath'</tt> does not use the <a class="link" href="#os_Standard_path_representation">standard path representation</a>
        or it cannot be converted to the system path type.</dd>
    <dt><a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a></dt>
        <dd>A system function returns an error.</dd>
</dl></dd></dl></div><p></p>

<a name="os_getMTime"><h3>12.14 getMTime</h3></a>
<p>
    The modification time of a file is returned by the function <tt><span class="func">getMTime</span></tt>:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_func">func</a> <a class="type" href="#types_time">time</a>: getMTime (<span class="keywd">in</span> <a class="type" href="#types_string">string</a>: filePath) <span class="keywd">is</span> ...
</pre>
  <div><dl><dt><p>Possible exceptions:</p></dt><dd><dl>
    <dt><a class="exception" href="#errors_MEMORY_ERROR">MEMORY_ERROR</a></dt>
        <dd>Not enough memory to convert <tt>'filePath'</tt> to the system path type.</dd>
    <dt><a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a></dt>
        <dd><tt>'filePath'</tt> does not use the <a class="link" href="#os_Standard_path_representation">standard path representation</a>
        or it cannot be converted to the system path type.</dd>
    <dt><a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a></dt>
        <dd>A system function returns an error.</dd>
</dl></dd></dl></div><p></p>

<a name="os_setATime"><h3>12.15 setATime</h3></a>
<p>
    The function <tt><span class="func">setATime</span></tt> sets the access time of a file:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: setATime (<span class="keywd">in</span> <a class="type" href="#types_string">string</a>: filePath, <span class="keywd">in</span> <a class="type" href="#types_time">time</a>: aTime) <span class="keywd">is</span> ...
</pre>
  <div><dl><dt><p>Possible exceptions:</p></dt><dd><dl>
    <dt><a class="exception" href="#errors_MEMORY_ERROR">MEMORY_ERROR</a></dt>
        <dd>Not enough memory to convert <tt>'filePath'</tt> to the system path type.</dd>
    <dt><a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a></dt>
        <dd><tt>'filePath'</tt> does not use the <a class="link" href="#os_Standard_path_representation">standard path representation</a>
        or it cannot be converted to the system path type or <tt>'aTime'</tt>
        is invalid or cannot be converted to the system file time.</dd>
    <dt><a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a></dt>
        <dd>A system function returns an error.</dd>
</dl></dd></dl></div><p></p>

<a name="os_setMTime"><h3>12.16 setMTime</h3></a>
<p>
    The function <tt><span class="func">setMTime</span></tt> sets the modification time of a file:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: setMTime (<span class="keywd">in</span> <a class="type" href="#types_string">string</a>: filePath, <span class="keywd">in</span> <a class="type" href="#types_time">time</a>: aTime) <span class="keywd">is</span> ...
</pre>
  <div><dl><dt><p>Possible exceptions:</p></dt><dd><dl>
    <dt><a class="exception" href="#errors_MEMORY_ERROR">MEMORY_ERROR</a></dt>
        <dd>Not enough memory to convert <tt>'filePath'</tt> to the system path type.</dd>
    <dt><a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a></dt>
        <dd><tt>'filePath'</tt> does not use the <a class="link" href="#os_Standard_path_representation">standard path representation</a>
        or it cannot be converted to the system path type or <tt>'aTime'</tt>
        is invalid or cannot be converted to the system file time.</dd>
    <dt><a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a></dt>
        <dd>A system function returns an error.</dd>
</dl></dd></dl></div><p></p>

<a name="os_readlink"><h3>12.17 readlink</h3></a>
<p>
    The function <tt><span class="func">readlink</span></tt> reads the destination of a symbolic link:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_func">func</a> <a class="type" href="#types_string">string</a>: readlink (<span class="keywd">in</span> <a class="type" href="#types_string">string</a>: filePath) <span class="keywd">is</span> ...
</pre>
  <div><dl><dt><p>Returns:</p></dt><dd><p>
    The symbolic link refered by <tt>'filePath'</tt>.
</p></dd></dl></div>
  <div><dl><dt><p>Possible exceptions:</p></dt><dd><dl>
    <dt><a class="exception" href="#errors_MEMORY_ERROR">MEMORY_ERROR</a></dt>
        <dd>Not enough memory to convert <tt>'filePath'</tt> to the system path type or not
        enough memory to represent the result <tt><a class="type" href="#types_string">string</a></tt>.</dd>
    <dt><a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a></dt>
        <dd><tt>'filePath'</tt> does not use the <a class="link" href="#os_Standard_path_representation">standard path representation</a>
        or it cannot be converted to the system path type.</dd>
    <dt><a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a></dt>
        <dd>The file described with <tt>'filePath'</tt> does not exist or is not a symbolic link.</dd>
</dl></dd></dl></div><p></p>

<a name="os_symlink"><h3>12.18 symlink</h3></a>
<p>
    The function <tt><span class="func">symlink</span></tt> creates a symbolic link called <tt>'dest'</tt>
  that contains the string referred by <tt>'source'</tt>:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: symlink (<span class="keywd">in</span> <a class="type" href="#types_string">string</a>: source, <span class="keywd">in</span> <a class="type" href="#types_string">string</a>: dest) <span class="keywd">is</span> ...
</pre>
  <div><dl><dt><p>Parameters:</p></dt><dd><dl>
    <dt>source</dt>
        <dd>String to be contained in the symbolic link.</dd>
    <dt>dest</dt>
        <dd>Name of the symbolic link to be created.</dd>
</dl></dd></dl></div>
  <div><dl><dt><p>Possible exceptions:</p></dt><dd><dl>
    <dt><a class="exception" href="#errors_MEMORY_ERROR">MEMORY_ERROR</a></dt>
        <dd>Not enough memory to convert <tt>'source'</tt> or <tt>'dest'</tt>
        to the system path type.</dd>
    <dt><a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a></dt>
        <dd><tt>'source'</tt> or <tt>'dest'</tt> does not use the <a class="link" href="#os_Standard_path_representation">standard path
        representation</a> or one of them cannot be converted to the
        system path type.</dd>
    <dt><a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a></dt>
        <dd>A system function returns an error.</dd>
</dl></dd></dl></div><p></p>

<a name="os_removeFile"><h3>12.19 removeFile</h3></a>
<p>
    The function <tt><span class="func">removeFile</span></tt> removes a file or empty directory:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: removeFile (<span class="keywd">in</span> <a class="type" href="#types_string">string</a>: filePath) <span class="keywd">is</span> ...
</pre>
  <div><dl><dt><p>Possible exceptions:</p></dt><dd><dl>
    <dt><a class="exception" href="#errors_MEMORY_ERROR">MEMORY_ERROR</a></dt>
        <dd>Not enough memory to convert <tt>'filePath'</tt> to the system path type.</dd>
    <dt><a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a></dt>
        <dd><tt>'filePath'</tt> does not use the <a class="link" href="#os_Standard_path_representation">standard path representation</a>
        or it cannot be converted to the system path type.</dd>
    <dt><a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a></dt>
        <dd>The file does not exist or a system function returns an error.</dd>
</dl></dd></dl></div><p></p>

<a name="os_removeAnyFile"><h3>12.20 removeAnyFile</h3></a>
<p>
    The function <tt><span class="func">removeAnyFile</span></tt> removes a file independent of its
  file type:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: removeAnyFile (<span class="keywd">in</span> <a class="type" href="#types_string">string</a>: filePath) <span class="keywd">is</span> ...
</pre>
  <div><dl><dt><p>Possible exceptions:</p></dt><dd><dl>
    <dt><a class="exception" href="#errors_MEMORY_ERROR">MEMORY_ERROR</a></dt>
        <dd>Not enough memory to convert <tt>'filePath'</tt> to the system path type.</dd>
    <dt><a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a></dt>
        <dd><tt>'filePath'</tt> does not use the <a class="link" href="#os_Standard_path_representation">standard path representation</a>
        or it cannot be converted to the system path type.</dd>
    <dt><a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a></dt>
        <dd>The file does not exist or a system function returns an error.</dd>
</dl></dd></dl></div>

<a name="os_copyFile"><h3>12.21 copyFile</h3></a>
<p>
    The function <tt><span class="func">copyFile</span></tt> copies a file or directory tree:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: copyFile (<span class="keywd">in</span> <a class="type" href="#types_string">string</a>: sourcePath, <span class="keywd">in</span> <a class="type" href="#types_string">string</a>: destPath) <span class="keywd">is</span> ...
</pre><p>
  Permissions/mode, ownership and timestamps of the destination file
  are determined independent of the corresponding source properties.
  The destination file gets the permissions/mode defined by umask.
  The user executing the program is the owner of the destination file.
  The timestamps of the destination file are set to the current time.
  Symbolic links in sourcePath are always followed. Therefore
  <tt>'copyFile'</tt> will never create a symbolic link. Note that <tt>'copyFile'</tt>
  does not preserve hard links (they are resolved to distinct files).
</p>
  <div><dl><dt><p>Possible exceptions:</p></dt><dd><dl>
    <dt><a class="exception" href="#errors_MEMORY_ERROR">MEMORY_ERROR</a></dt>
        <dd>Not enough memory to convert <tt>'sourcePath'</tt> or <tt>'destPath'</tt>
        to the system path type.</dd>
    <dt><a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a></dt>
        <dd><tt>'sourcePath'</tt> or <tt>'destPath'</tt> does not use the <a class="link" href="#os_Standard_path_representation">standard path
        representation</a> or one of them cannot be converted to the
        system path type.</dd>
    <dt><a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a></dt>
        <dd>Source file does not exist, destination file already exists or
        a system function returns an error.</dd>
</dl></dd></dl></div><p></p>

<a name="os_cloneFile"><h3>12.22 cloneFile</h3></a>
<p>
    The function <tt><span class="func">cloneFile</span></tt> clones a file or directory tree:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: cloneFile (<span class="keywd">in</span> <a class="type" href="#types_string">string</a>: sourcePath, <span class="keywd">in</span> <a class="type" href="#types_string">string</a>: destPath) <span class="keywd">is</span> ...
</pre><p>
  Permissions/mode, ownership and timestamps of the original are
  preserved. Symlinks are not followed. Instead the symlink
  is copied. Note that <tt>'cloneFile'</tt> does not preserve hard
  links (they are resolved to distinct files).
</p>
  <div><dl><dt><p>Possible exceptions:</p></dt><dd><dl>
    <dt><a class="exception" href="#errors_MEMORY_ERROR">MEMORY_ERROR</a></dt>
        <dd>Not enough memory to convert <tt>'sourcePath'</tt> or <tt>'destPath'</tt>
        to the system path type.</dd>
    <dt><a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a></dt>
        <dd><tt>'sourcePath'</tt> or <tt>'destPath'</tt> does not use the <a class="link" href="#os_Standard_path_representation">standard path
        representation</a> or one of them cannot be converted to the
        system path type.</dd>
    <dt><a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a></dt>
        <dd>Source file does not exist, destination file already exists or
        a system function returns an error.</dd>
</dl></dd></dl></div><p></p>

<a name="os_moveFile"><h3>12.23 moveFile</h3></a>
<p>
    The function <tt><span class="func">moveFile</span></tt> moves and/or renames a file or
  directory tree:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: moveFile (<span class="keywd">in</span> <a class="type" href="#types_string">string</a>: sourcePath, <span class="keywd">in</span> <a class="type" href="#types_string">string</a>: destPath) <span class="keywd">is</span> ...
</pre><p>
  The function uses the C <tt>'rename()'</tt> function. When <tt>'rename()'</tt> fails
  the file (or directory tree) is cloned with <tt>'cloneFile'</tt> (which
  preserves permissions/mode, ownership and timestamps) to the new
  place and with the new name. When <tt>'cloneFile'</tt> succeeds the original
  file is deleted. When <tt>'cloneFile'</tt> fails (no space on device or
  other reason) all remains of the failed clone are removed. Note
  that <tt>'cloneFile'</tt> works for symbolic links but does not preserve
  hard links (they are resolved to distinct files).
</p>
  <div><dl><dt><p>Possible exceptions:</p></dt><dd><dl>
    <dt><a class="exception" href="#errors_MEMORY_ERROR">MEMORY_ERROR</a></dt>
        <dd>Not enough memory to convert <tt>'sourcePath'</tt> or <tt>'destPath'</tt>
        to the system path type.</dd>
    <dt><a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a></dt>
        <dd><tt>'sourcePath'</tt> or <tt>'destPath'</tt> does not use the <a class="link" href="#os_Standard_path_representation">standard path
        representation</a> or one of them cannot be converted to the
        system path type.</dd>
    <dt><a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a></dt>
        <dd>Source file does not exist, destination file already exists or
        a system function returns an error.</dd>
</dl></dd></dl></div><p></p>

<a name="os_argv_PROGRAM"><h3>12.24 argv(PROGRAM)</h3></a>
<p>
    The function <tt><span class="func">argv(PROGRAM)</span></tt> returns the argument vector of
  the program as array of strings. The name of the program is
  not part of the argument vector.
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_func">func</a> <a class="type" href="#types_array">array</a> <a class="type" href="#types_string">string</a>: argv (PROGRAM) <span class="keywd">is</span> ...
</pre>
  <div><dl><dt><p>Returns:</p></dt><dd><p>
    An array of strings containing the argument vector.
</p></dd></dl></div><p></p>

<a name="os_name_PROGRAM"><h3>12.25 name(PROGRAM)</h3></a>
<p>
    The function <tt><span class="func">name(PROGRAM)</span></tt> returns the name of the program
  without path and extension. The name returned by <tt><span class="func">name(PROGRAM)</span></tt>
  is the same for interpreted and compiled programs. The function
  <tt><span class="func">name(PROGRAM)</span></tt> does not follow symbolic links. It determines,
  with which name a program was called. When several symbolic
  links refer to one program <tt><span class="func">name(PROGRAM)</span></tt> returns the name
  of the symbolic link.
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_func">func</a> <a class="type" href="#types_string">string</a>: name (PROGRAM) <span class="keywd">is</span> ...
</pre>
  <div><dl><dt><p>Returns:</p></dt><dd><p>
    The name of the program.
</p></dd></dl></div><p></p>

<a name="os_path_PROGRAM"><h3>12.26 path(PROGRAM)</h3></a>
<p>
    The function <tt><span class="func">path(PROGRAM)</span></tt> returns the absolute path
  of the program. For an interpreted program this is the
  absolute path of the source file. For a compiled program
  this is the absolute path of the executable. The function
  <tt><span class="func">path(PROGRAM)</span></tt> does follow symbolic links.
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_func">func</a> <a class="type" href="#types_string">string</a>: path (PROGRAM) <span class="keywd">is</span> ...
</pre>
  <div><dl><dt><p>Returns:</p></dt><dd><p>
    The absolute path of the program.
</p></dd></dl></div><p></p>

<a name="os_dir_PROGRAM"><h3>12.27 dir(PROGRAM)</h3></a>
<p>
    The function <tt><span class="func">dir(PROGRAM)</span></tt> returns the absolute path of the
  directory containing the program. The function <tt><span class="func">dir(PROGRAM)</span></tt>
  allows placing configuration data in the directory of the program.
  <tt><span class="func">dir(PROGRAM)</span></tt> is based on <tt><span class="func">path(PROGRAM)</span></tt>.
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_func">func</a> <a class="type" href="#types_string">string</a>: dir (PROGRAM) <span class="keywd">is</span> ...
</pre>
  <div><dl><dt><p>Returns:</p></dt><dd><p>
    The absolute path of the directory containing the program.
</p></dd></dl></div><p></p>

<a name="os_file_PROGRAM"><h3>12.28 file(PROGRAM)</h3></a>
<p>
    The function <tt><span class="func">file(PROGRAM)</span></tt> returns the filename of the
  program without path. <tt><span class="func">file(PROGRAM)</span></tt> is based on <tt><span class="func">path(PROGRAM)</span></tt>.
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_func">func</a> <a class="type" href="#types_string">string</a>: file (PROGRAM) <span class="keywd">is</span> ...
</pre>
  <div><dl><dt><p>Returns:</p></dt><dd><p>
    The filename of the program.
</p></dd></dl></div><p></p>

<a name="os_getenv"><h3>12.29 getenv</h3></a>
<p>
    The function <tt><span class="func">getenv</span></tt> determines the value of an
  environment variable.
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_func">func</a> <a class="type" href="#types_string">string</a>: getenv (<span class="keywd">in</span> <a class="type" href="#types_string">string</a>: name) <span class="keywd">is</span> ...
</pre><p>
  The function <tt><span class="func">getenv</span></tt> searches the environment for an
  environment variable with the given <tt>'name'</tt>. When such
  an environment variable exists the corresponding <tt><a class="type" href="#types_string">string</a></tt>
  value is returned.
</p>
  <div><dl><dt><p>Returns:</p></dt><dd><p>
    The value of an environment variable or <span class="stri">""</span>
    when the requested environment variable does not exist.
</p></dd></dl></div>
  <div><dl><dt><p>Possible exceptions:</p></dt><dd><dl>
    <dt><a class="exception" href="#errors_MEMORY_ERROR">MEMORY_ERROR</a></dt>
        <dd>Not enough memory to convert <tt>'name'</tt> to the system string type or not
        enough memory to represent the result <tt><a class="type" href="#types_string">string</a></tt>.</dd>
</dl></dd></dl></div><p></p>

<a name="os_setenv"><h3>12.30 setenv</h3></a>
<p>
    The function <tt><span class="func">setenv</span></tt> adds or changes an environment
  variable.
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: setenv (<span class="keywd">in</span> <a class="type" href="#types_string">string</a>: name, <span class="keywd">in</span> <a class="type" href="#types_string">string</a>: value) <span class="keywd">is</span> ...
</pre><p>
  The function <tt><span class="func">setenv</span></tt> searches the environment for an
  environment variable with the given <tt>'name'</tt>. When such
  an environment variable exists the corresponding value is
  changed to <tt>'value'</tt>. When no environment variable with
  the given <tt>'name'</tt> exists a new environment variable
  <tt>'name'</tt> with the value <tt>'value'</tt> is created.
</p>
  <div><dl><dt><p>Possible exceptions:</p></dt><dd><dl>
    <dt><a class="exception" href="#errors_MEMORY_ERROR">MEMORY_ERROR</a></dt>
        <dd>Not enough memory to convert <tt>'name'</tt> or <tt>'value'</tt> to
        the system string type.</dd>
    <dt><a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a></dt>
        <dd>A system function returns an error.</dd>
</dl></dd></dl></div><p></p>

<a name="os_environment"><h3>12.31 environment</h3></a>
<p>
    The function <tt><span class="func">environment</span></tt> returns the list of
  environment variable names as array of strings.
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_func">func</a> <a class="type" href="#types_array">array</a> <a class="type" href="#types_string">string</a>: environment <span class="keywd">is</span> ...
</pre>
  <div><dl><dt><p>Returns:</p></dt><dd><p>
    The list of environment variable names.
</p></dd></dl></div>
  <div><dl><dt><p>Possible exceptions:</p></dt><dd><dl>
    <dt><a class="exception" href="#errors_MEMORY_ERROR">MEMORY_ERROR</a></dt>
        <dd>Not enough memory to create the result.</dd>
</dl></dd></dl></div><p></p>

<a name="actions_file_start"></a><p></p>
<a name="actions_PRIMITIVE_ACTIONS"><h2>13. PRIMITIVE ACTIONS</h2></a>

<p>
    Not all functions can be described by calling other
  functions of the same language. For this reason and for
  performance reasons several functions are defined using a
  mechanism called action. For example: It is easy to define
  the <a class="link" href="#stats_while-statement">while-statement</a> by using recursion. But this would
  hurt performance and it would also use a huge amount of
  memory for the runtime stack. In practice an implementation
  of the <a class="link" href="#stats_while-statement">while-statement</a> can use a conditional jump
  instead of a subroutine call. Since Seed7 has no <tt><span class="keywd">goto</span></tt>
  statement, this is not an option. Instead the primitive
  action PRC_WHILE can be used. The <a class="link" href="#stats_while-statement">while-statement</a> is
  defined in the basic Seed7 library <tt><span class="lib">"seed7_05.s7i"</span></tt> with:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: while (<span class="keywd">in</span> <a class="type" href="#types_func">func</a> <a class="type" href="#types_boolean">boolean</a> <span class="keywd">param</span>) do
    (<span class="keywd">in</span> <a class="type" href="#types_proc">proc</a> <span class="keywd">param</span>) end while <span class="keywd">is action</span> <span class="stri">"PRC_WHILE"</span>;
</pre><p>
  This declaration shows the types and the position of
  the parameters of a <a class="link" href="#stats_while-statement">while-statement</a>. Such an action
  declaration contains enough information to use the defined
  construct. The semantic of all primitive actions is
  hard coded in the interpreter and in the compiler. The
  parameters of the hard coded actions and the corresponding
  definitions in Seed7 must match. If you are interested in
  the Seed7 definitions of primitive actions just look into
  the file <tt><span class="lib">"seed7_05.s7i"</span></tt>.
</p><p>
    Currently there are several hundred primitive actions
  predefined in the interpreter. They all have names in upper
  case characters which have the form:
</p><pre class="indent">
TYPE_ACTION
</pre><p>
  Which means that for example all <tt><a class="type" href="#types_integer">integer</a></tt> actions start
  with INT_ and all assignment actions end with _CPY .
  The following list shows actions which are used with more
  than one type:
</p><dl><dd><table border="0" cellspacing="0">
    <tr><td>_ABS      <td width="20"></td><td>Absolute value</td></tr>
    <tr><td>_ADD      <td width="20"></td><td>Addition</td></tr>
    <tr><td>_CAT      <td width="20"></td><td>Concatenation</td></tr>
    <tr><td>_CMP      <td width="20"></td><td>Compare</td></tr>
    <tr><td>_CPY      <td width="20"></td><td>Copy (Assignment)</td></tr>
    <tr><td>_CREATE   <td width="20"></td><td>Initialize (Construct)</td></tr>
    <tr><td>_DESTR    <td width="20"></td><td>Destroy (Destruct)</td></tr>
    <tr><td>_DECR     <td width="20"></td><td>Decrement</td></tr>
    <tr><td>_DIV      <td width="20"></td><td>Division</td></tr>
    <tr><td>_EQ       <td width="20"></td><td>Equal</td></tr>
    <tr><td>_GE       <td width="20"></td><td>Greater equal</td></tr>
    <tr><td>_GETC     <td width="20"></td><td>Get one character from a <span class="type">file</span></td></tr>
    <tr><td>_GETS     <td width="20"></td><td>Get <tt><a class="type" href="#types_string">string</a></tt> with maximum length from a <span class="type">file</span></td></tr>
    <tr><td>_GT       <td width="20"></td><td>Greater than</td></tr>
    <tr><td>_HASHCODE <td width="20"></td><td>Compute a hashCode</td></tr>
    <tr><td>_HEAD     <td width="20"></td><td>Head of <tt><a class="type" href="#types_string">string</a></tt>, <tt><a class="type" href="#types_array">array</a></tt> or <tt><a class="type" href="#types_ref_list">ref_list</a></tt></td></tr>
    <tr><td>_ICONV    <td width="20"></td><td>Conversion of <tt><a class="type" href="#types_integer">integer</a></tt> to another type</td></tr>
    <tr><td>_IDX      <td width="20"></td><td>Index (Element) of <tt><a class="type" href="#types_string">string</a></tt>, <tt><a class="type" href="#types_array">array</a></tt> or <tt><a class="type" href="#types_ref_list">ref_list</a></tt></td></tr>
    <tr><td>_INCR     <td width="20"></td><td>Increment</td></tr>
    <tr><td>_IPOW     <td width="20"></td><td>Power with <tt><a class="type" href="#types_integer">integer</a></tt> exponent</td></tr>
    <tr><td>_LE       <td width="20"></td><td>Less equal</td></tr>
    <tr><td>_LNG      <td width="20"></td><td>Length</td></tr>
    <tr><td>_LOG2     <td width="20"></td><td>Base 2 logarithm</td></tr>
    <tr><td>_LOWER    <td width="20"></td><td>Convert to lower case</td></tr>
    <tr><td>_LSHIFT   <td width="20"></td><td>Shift left</td></tr>
    <tr><td>_LT       <td width="20"></td><td>Less than</td></tr>
    <tr><td>_MDIV     <td width="20"></td><td>Modulo division (Integer division truncated towards negative infinity)</td></tr>
    <tr><td>_MINUS    <td width="20"></td><td>Change sign</td></tr>
    <tr><td>_MOD      <td width="20"></td><td>Modulo (Reminder of _MDIV integer division)</td></tr>
    <tr><td>_MULT     <td width="20"></td><td>Multiply</td></tr>
    <tr><td>_NE       <td width="20"></td><td>Not equal</td></tr>
    <tr><td>_ODD      <td width="20"></td><td>Odd number</td></tr>
    <tr><td>_ORD      <td width="20"></td><td>Ordinal number</td></tr>
    <tr><td>_PARSE    <td width="20"></td><td>Conversion of <tt><a class="type" href="#types_string">string</a></tt> to another type</td></tr>
    <tr><td>_PLUS     <td width="20"></td><td>Positive sign (noop)</td></tr>
    <tr><td>_POW      <td width="20"></td><td>Power</td></tr>
    <tr><td>_PRED     <td width="20"></td><td>Predecessor</td></tr>
    <tr><td>_RAND     <td width="20"></td><td>Random value</td></tr>
    <tr><td>_RANGE    <td width="20"></td><td>Range of <tt><a class="type" href="#types_string">string</a></tt>, <tt><a class="type" href="#types_array">array</a></tt> or <tt><a class="type" href="#types_ref_list">ref_list</a></tt></td></tr>
    <tr><td>_REM      <td width="20"></td><td>Remainder (Reminder of _DIV integer division)</td></tr>
    <tr><td>_RSHIFT   <td width="20"></td><td>Arithmetic shift right</td></tr>
    <tr><td>_SBTR     <td width="20"></td><td>Subtract</td></tr>
    <tr><td>_SCAN     <td width="20"></td><td>Convert from <tt><a class="type" href="#types_string">string</a></tt> to another type</td></tr>
    <tr><td>_SEEK     <td width="20"></td><td>Set actual file position of a <span class="type">file</span></td></tr>
    <tr><td>_SQRT     <td width="20"></td><td>Square root</td></tr>
    <tr><td>_STR      <td width="20"></td><td>Convert to <tt><a class="type" href="#types_string">string</a></tt></td></tr>
    <tr><td>_SUCC     <td width="20"></td><td>Successor</td></tr>
    <tr><td>_TAIL     <td width="20"></td><td>Tail of <tt><a class="type" href="#types_string">string</a></tt>, <tt><a class="type" href="#types_array">array</a></tt> or <tt><a class="type" href="#types_ref_list">ref_list</a></tt></td></tr>
    <tr><td>_TELL     <td width="20"></td><td>Return the actual <span class="type">file</span> position</td></tr>
    <tr><td>_UPPER    <td width="20"></td><td>Convert to upper case</td></tr>
    <tr><td>_VALUE    <td width="20"></td><td>Dereference a <tt><a class="type" href="#types_reference">reference</a></tt></td></tr>
    <tr><td>_WRITE    <td width="20"></td><td>Write <tt><a class="type" href="#types_string">string</a></tt> to <span class="type">file</span></td></tr>
</table></dd></dl><p>
  Primitive actions are defined for many types. The functions
  which implement the primitive actions are grouped together
  in *lib.c files. The following list contains the action
  prefix, the file containing the functions and a description:
</p><dl><dd><table border="0" cellspacing="0">
    <tr><td>ACT_  <td width="20"></td><td>actlib.c  <td width="20"></td><td><tt><span class="type">ACTION</span></tt> operations</td></tr>
    <tr><td>ARR_  <td width="20"></td><td>arrlib.c  <td width="20"></td><td><tt><a class="type" href="#types_array">array</a></tt> operations</td></tr>
    <tr><td>BIG_  <td width="20"></td><td>biglib.c  <td width="20"></td><td><tt><a class="type" href="#types_bigInteger">bigInteger</a></tt> operations</td></tr>
    <tr><td>BLN_  <td width="20"></td><td>blnlib.c  <td width="20"></td><td><tt><a class="type" href="#types_boolean">boolean</a></tt> operations</td></tr>
    <tr><td>BST_  <td width="20"></td><td>bstlib.c  <td width="20"></td><td>Operations for byte strings</td></tr>
    <tr><td>CHR_  <td width="20"></td><td>chrlib.c  <td width="20"></td><td><tt><a class="type" href="#types_char">char</a></tt> operations</td></tr>
    <tr><td>CMD_  <td width="20"></td><td>cmdlib.c  <td width="20"></td><td>Various directory, file and other commands</td></tr>
    <tr><td>DCL_  <td width="20"></td><td>dcllib.c  <td width="20"></td><td>Declaration operations</td></tr>
    <tr><td>DRW_  <td width="20"></td><td>drwlib.c  <td width="20"></td><td>Drawing operations</td></tr>
    <tr><td>ENU_  <td width="20"></td><td>enulib.c  <td width="20"></td><td>Enumeration operations</td></tr>
    <tr><td>FIL_  <td width="20"></td><td>fillib.c  <td width="20"></td><td><tt><span class="type">clib_file</span></tt> operations</td></tr>
    <tr><td>FLT_  <td width="20"></td><td>fltlib.c  <td width="20"></td><td><tt><a class="type" href="#types_float">float</a></tt> operations</td></tr>
    <tr><td>HSH_  <td width="20"></td><td>hshlib.c  <td width="20"></td><td><tt><a class="type" href="#types_hash">hash</a></tt> operations</td></tr>
    <tr><td>INT_  <td width="20"></td><td>intlib.c  <td width="20"></td><td><tt><a class="type" href="#types_integer">integer</a></tt> operations</td></tr>
    <tr><td>ITF_  <td width="20"></td><td>itflib.c  <td width="20"></td><td>Operations for interface types</td></tr>
    <tr><td>KBD_  <td width="20"></td><td>kbdlib.c  <td width="20"></td><td>Keyboard operations</td></tr>
    <tr><td>LST_  <td width="20"></td><td>lstlib.c  <td width="20"></td><td>List operations</td></tr>
    <tr><td>PRC_  <td width="20"></td><td>prclib.c  <td width="20"></td><td><tt><a class="type" href="#types_proc">proc</a></tt> operations and statements</td></tr>
    <tr><td>PRG_  <td width="20"></td><td>prglib.c  <td width="20"></td><td>Program operations</td></tr>
    <tr><td>REF_  <td width="20"></td><td>reflib.c  <td width="20"></td><td><tt><a class="type" href="#types_reference">reference</a></tt> operations</td></tr>
    <tr><td>RFL_  <td width="20"></td><td>rfllib.c  <td width="20"></td><td><tt><a class="type" href="#types_ref_list">ref_list</a></tt> operations</td></tr>
    <tr><td>SCR_  <td width="20"></td><td>scrlib.c  <td width="20"></td><td>Screen operations</td></tr>
    <tr><td>SCT_  <td width="20"></td><td>sctlib.c  <td width="20"></td><td><tt><a class="type" href="#types_struct">struct</a></tt> operations</td></tr>
    <tr><td>SET_  <td width="20"></td><td>setlib.c  <td width="20"></td><td><tt><a class="type" href="#types_set">set</a></tt> operations</td></tr>
    <tr><td>SOC_  <td width="20"></td><td>soclib.c  <td width="20"></td><td><tt><span class="type">PRIMITIVE_SOCKET</span></tt> operations</td></tr>
    <tr><td>STR_  <td width="20"></td><td>strlib.c  <td width="20"></td><td><tt><a class="type" href="#types_string">string</a></tt> operations</td></tr>
    <tr><td>TIM_  <td width="20"></td><td>timlib.c  <td width="20"></td><td><tt><a class="type" href="#types_time">time</a></tt> and <tt><a class="type" href="#types_duration">duration</a></tt> operations</td></tr>
    <tr><td>TYP_  <td width="20"></td><td>typlib.c  <td width="20"></td><td><tt><a class="type" href="#types_type">type</a></tt> operations</td></tr>
    <tr><td>UT8_  <td width="20"></td><td>ut8lib.c  <td width="20"></td><td><tt><span class="type">utf8_file</span></tt> operations</td></tr>
</table></dd></dl><p>
  The C functions which implement primitive actions have
  lowercase names. E.g.: The action <tt>'PRC_WHILE'</tt> is implemented
  with the C function <tt>'prc_while()'</tt> in the file <tt><span class="lib">"prclib.c"</span></tt>.
  The parameter list for all C action functions is identical.
  Every *lib.c file has a corresponding *lib.h file which
  contains the prototypes for the action functions.
</p><p>
  In a Seed7 program the operator <tt><span class="op">+</span></tt> is used to add two <tt><a class="type" href="#types_integer">integer</a></tt>
  values. The primitive action, which describes the addition of
  two integers, is <tt>'INT_ADD'</tt>. The connection between <tt><span class="op">+</span></tt>
  and <tt>'INT_ADD'</tt> is done in the library <tt><span class="stri">"<span class="lib">integer.s7i</span>"</span></tt> with the definition:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_func">func</a> <a class="type" href="#types_integer">integer</a>: (<span class="keywd">in</span> <a class="type" href="#types_integer">integer</a>: summand1) + (<span class="keywd">in</span> <a class="type" href="#types_integer">integer</a>: summand2) <span class="keywd">is action</span> <span class="stri">"INT_ADD"</span>;
</pre><p>
  To execute an action a corresponding C function must
  be present in the s7 interpreter. The function for the
  action <tt>'INT_ADD'</tt> is <tt><a class="func" href="#actions_int_add">int_add</a>()</tt>. The function <tt><a class="func" href="#actions_int_add">int_add</a>()</tt>
  is defined in the file <tt><span class="lib">"intlib.c"</span></tt> with:
</p><pre class="indent">
<a class="type" href="#ffi_objecttype">objecttype</a> <a name="actions_int_add">int_add</a> (<a class="type" href="#ffi_listtype">listtype</a> arguments)

  { <span class="comment">/* int_add */</span>
    <a class="func" href="#ffi_isit_int">isit_int</a>(<a class="func" href="#ffi_arg_1">arg_1</a>(arguments));
    <a class="func" href="#ffi_isit_int">isit_int</a>(<a class="func" href="#ffi_arg_3">arg_3</a>(arguments));
    <span class="keywd">return</span> <a class="func" href="#ffi_bld_int_temp">bld_int_temp</a>(
        <a class="func" href="#ffi_take_int">take_int</a>(<a class="func" href="#ffi_arg_1">arg_1</a>(arguments)) +
        <a class="func" href="#ffi_take_int">take_int</a>(<a class="func" href="#ffi_arg_3">arg_3</a>(arguments)));
  } <span class="comment">/* int_add */</span>
</pre><p>
  The action functions use ANSI C prototypes and K&amp;R function headers.
  The function <tt><a class="func" href="#actions_int_add">int_add</a>()</tt> adds the first and the third argument (the
  second argument contains the + symbol. The file <tt><span class="lib">"objutl.h"</span></tt>
  contains several macros and functions which help to handle the
  arguments (parameter list) of a C primitive action function.
<ul>
    <li>The macros <tt><a class="func" href="#ffi_arg_1">arg_1</a></tt>, <tt><a class="func" href="#ffi_arg_2">arg_2</a></tt>,
      <tt><a class="func" href="#ffi_arg_3">arg_3</a></tt>, etc. can be used to get an individual argument
      (E.g.: <tt><a class="func" href="#ffi_arg_3">arg_3</a>(arguments)</tt> ).</li>

    <li>The macros <tt><a class="func" href="#ffi_isit_int">isit_int</a></tt>, <tt><a class="func" href="#ffi_isit_stri">isit_stri</a></tt>,
      <tt><a class="func" href="#ffi_isit_file">isit_file</a></tt>, etc. can be used to check for the correct
      <tt><a class="type" href="#types_category">category</a></tt> of an argument
      (E.g.: <tt><a class="func" href="#ffi_isit_int">isit_int</a>(<a class="func" href="#ffi_arg_1">arg_1</a>(arguments))</tt> ).</li>

    <li>The macros <tt><a class="func" href="#ffi_take_char">take_char</a></tt>, <tt><a class="func" href="#ffi_take_float">take_float</a></tt>,
      <tt><a class="func" href="#ffi_take_bigint">take_bigint</a></tt>, etc. can be used to get the corresponding
      value of an argument (E.g.: <tt><a class="func" href="#ffi_take_int">take_int</a>(<a class="func" href="#ffi_arg_1">arg_1</a>(arguments))</tt> ).</li>

    <li>The functions <tt><a class="func" href="#ffi_bld_int_temp">bld_int_temp</a></tt>, <tt><a class="func" href="#ffi_bld_array_temp">bld_array_temp</a></tt>,
      <tt><a class="func" href="#ffi_bld_win_temp">bld_win_temp</a></tt>, etc. can be used to create the (<tt><a class="type" href="#ffi_objecttype">objecttype</a></tt>)
      result of a primitive action (E.g.: <tt>return <a class="func" href="#ffi_bld_int_temp">bld_int_temp</a>(0);</tt> ).</li>
</ul><p>
  The file <tt><span class="lib">"intlib.h"</span></tt> contains the prototype for the <tt><a class="func" href="#actions_int_add">int_add</a>()</tt>
  function:
</p><pre class="indent">
<a class="type" href="#ffi_objecttype">objecttype</a> <a class="func" href="#actions_int_add">int_add</a> (<a class="type" href="#ffi_listtype">listtype</a> arguments);
</pre><p>
  and also a definition for the K&amp;R C language:
</p><pre class="indent">
<a class="type" href="#ffi_objecttype">objecttype</a> <a class="func" href="#actions_int_add">int_add</a> ();
</pre><p>
  Additionally every primitive action is registered in the file
  <tt><span class="lib">"primitive.c"</span></tt>. The line which incorporates <tt>'INT_ADD'</tt> is:
</p><pre class="indent">
{ <span class="stri">"INT_ADD"</span>,             <a class="func" href="#actions_int_add">int_add</a>,             },
</pre><p>
  The entries of the primitive action in the file <tt><span class="lib">"primitive.c"</span></tt> are
  sorted alphabetically. With this definitions the s7 interpreter
  understands a primitive action.
</p><p>
  To allow a primitive function in a compiled Seed7 program the
  Seed7 compiler (s7c) needs to know the action also. The
  compiler function which creates code for the <tt>'INT_ADD'</tt> action is:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: process_int_add (<span class="keywd">in</span> <a class="type" href="#types_ref_list">ref_list</a>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"("</span>;
    process_expr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">") + ("</span>;
    process_expr(params[3], c_expr);
    c_expr.expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end func</span>;
</pre><p>
  This function is called from the function <tt><span class="func">process_action</span></tt> with:
</p><pre class="indent">
<span class="keywd">elsif</span> action_name = <span class="stri">"INT_ADD"</span> <span class="keywd">then</span>
  process_int_add(params, c_expr);
</pre><p>
  Some primitive actions are more complicated and inline code would
  not be the best solution for it. In this case an additional helper
  function is used. The action <tt>'INT_LOG2'</tt> is such an action. The
  definition of the function <tt><span class="func">int_log2</span>()</tt> in the file <tt><span class="lib">"intlib.c"</span></tt> is:
</p><pre class="indent">
<a class="type" href="#ffi_objecttype">objecttype</a> <a name="actions_int_log2">int_log2</a> (<a class="type" href="#ffi_listtype">listtype</a> arguments)

  { <span class="comment">/* int_log2 */</span>
    <a class="func" href="#ffi_isit_int">isit_int</a>(<a class="func" href="#ffi_arg_1">arg_1</a>(arguments));
    <span class="keywd">return</span> <a class="func" href="#ffi_bld_int_temp">bld_int_temp</a>(
        <a class="func" href="#actions_intLog2">intLog2</a>(<a class="func" href="#ffi_take_int">take_int</a>(<a class="func" href="#ffi_arg_1">arg_1</a>(arguments))));
  } <span class="comment">/* int_log2 */</span>
</pre><p>
  The main work for the primitive action <tt>'INT_LOG2'</tt> is done in
  the helper function <tt><a class="func" href="#actions_intLog2">intLog2</a>()</tt>. The helper function <tt><a class="func" href="#actions_intLog2">intLog2</a>()</tt>
  can be found in the file <tt><span class="lib">"int_rtl.c"</span></tt>:
</p><pre class="indent">
<span class="comment">/**
 *  Compute the truncated base 2 logarithm of an integer number.
 *  @return the truncated base 2 logarithm.
 *  @exception NUMERIC_ERROR The number is negative.
 */</span>
<a class="type" href="#ffi_inttype">inttype</a> <a name="actions_intLog2">intLog2</a> (<a class="type" href="#ffi_inttype">inttype</a> number)

  {
    int result;

  <span class="comment">/* intLog2 */</span>
    <span class="keywd">if</span> (unlikely(number < 0)) {
      raise_error(NUMERIC_ERROR);
      result = 0;
    } <span class="keywd">else</span> {
      result = uintMostSignificantBit((<a class="type" href="#ffi_uinttype">uinttype</a>) number);
    } <span class="comment">/* if */</span>
    <span class="keywd">return</span> result;
  } <span class="comment">/* intLog2 */</span>
</pre><p>
  The file <tt><span class="lib">"int_rtl.h"</span></tt> contains a prototype definition for the
  <tt><a class="func" href="#actions_intLog2">intLog2</a>()</tt> helper function:
</p><pre class="indent">
<a class="type" href="#ffi_inttype">inttype</a> <a class="func" href="#actions_intLog2">intLog2</a> (<a class="type" href="#ffi_inttype">inttype</a> number);
</pre><p>
  and also a definition for the K&amp;R C language:
</p><pre class="indent">
<a class="type" href="#ffi_inttype">inttype</a> <a class="func" href="#actions_intLog2">intLog2</a> ();
</pre><p>
  The helper functions are also used in the code generated by
  the Seed7 compiler:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: process_int_log2 (<span class="keywd">in</span> <a class="type" href="#types_ref_list">ref_list</a>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"intLog2("</span>;
    process_expr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end func</span>;
</pre><p>
  The compiler writes a prototype of <tt><a class="func" href="#actions_intLog2">intLog2</a>()</tt> in the
  function <tt><span class="func">write_prototypes</span></tt>:
</p><pre class="indent">
declareExtern(<span class="stri">"inttype     intLog2 (inttype);"</span>);
</pre><p>
  All the *lib.c files containing primitive actions and various
  other files with their functions are grouped together in the
  <tt><span class="lib">"s7_comp.a"</span></tt> library (Licensed under GPL). Furthermore the C
  primitive action functions (E.g.: int_parse) of the *lib.c
  files may use corresponding functions (E.g.: intParse) which
  can be found in *_rtl.c files (E.g.: <tt><span class="lib">"int_rtl.c"</span></tt>). The *_rtl.c
  files are grouped together in the <tt><span class="lib">"seed7_05.a"</span></tt> library
  (Licensed under LGPL). When a Seed7 program is compiled with
  the Seed7 compiler (s7c) inline code is generated for many
  primitive actions. To implement the remaining primitive
  actions the functions of the <tt><span class="lib">"seed7_05.a"</span></tt> library are used.
</p>

<a name="actions_ACTION"><h3>13.1 Actions for the type ACTION</h3></a>
<p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>Action name</th>         <th>actlib.c function</th>   <th>act_comp.c function</th></tr>
    <tr><td>ACT_ILLEGAL</td>         <td>act_illegal</td>         <td>&nbsp;</td></tr>
    <tr><td>ACT_CPY</td>             <td>act_cpy</td>             <td>=</td></tr>
    <tr><td>ACT_CREATE</td>          <td>act_create</td>          <td>&nbsp;</td></tr>
    <tr><td>ACT_GEN</td>             <td>act_gen</td>             <td>&nbsp;</td></tr>
    <tr><td>ACT_STR</td>             <td>act_str</td>             <td>actStr</td></tr>
    <tr><td>ACT_VALUE</td>           <td>act_value</td>           <td>actValue</td></tr>
</table><p></p>

<a name="actions_array"><h3>13.2 Actions for array types</h3></a>
<p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>Action name</th>         <th>arrlib.c function</th>   <th>arr_rtl.c function</th></tr>
    <tr><td>ARR_APPEND</td>          <td>arr_append</td>          <td>arrAppend</td></tr>
    <tr><td>ARR_ARRLIT</td>          <td>arr_arrlit</td>          <td>arrArrlit</td></tr>
    <tr><td>ARR_ARRLIT2</td>         <td>arr_arrlit2</td>         <td>arrArrlit2</td></tr>
    <tr><td>ARR_BASELIT</td>         <td>arr_baselit</td>         <td>arrBaselit</td></tr>
    <tr><td>ARR_BASELIT2</td>        <td>arr_baselit2</td>        <td>arrBaselit2</td></tr>
    <tr><td>ARR_CAT</td>             <td>arr_cat</td>             <td>arrCat</td></tr>
    <tr><td>ARR_CONV</td>            <td>arr_conv</td>            <td>(noop)</td></tr>
    <tr><td>ARR_CPY</td>             <td>arr_cpy</td>             <td>cpy_ ...</td></tr>
    <tr><td>ARR_CREATE</td>          <td>arr_create</td>          <td>create_ ...</td></tr>
    <tr><td>ARR_DESTR</td>           <td>arr_destr</td>           <td>destr_ ...</td></tr>
    <tr><td>ARR_EMPTY</td>           <td>arr_empty</td>           <td>&nbsp;</td></tr>
    <tr><td>ARR_EXTEND</td>          <td>arr_extend</td>          <td>arrExtend</td></tr>
    <tr><td>ARR_GEN</td>             <td>arr_gen</td>             <td>arrGen</td></tr>
    <tr><td>ARR_HEAD</td>            <td>arr_head</td>            <td>arrHead</td></tr>
    <tr><td>ARR_IDX</td>             <td>arr_idx</td>             <td>a-&gt;arr[b-a-&gt;min_position]</td></tr>
    <tr><td>ARR_LNG</td>             <td>arr_lng</td>             <td>a->max_position-a->min_position + 1</td></tr>
    <tr><td>ARR_MAXIDX</td>          <td>arr_maxidx</td>          <td>a->max_position</td></tr>
    <tr><td>ARR_MINIDX</td>          <td>arr_minidx</td>          <td>a->min_position</td></tr>
    <tr><td>ARR_PUSH</td>            <td>arr_push</td>            <td>arrPush</td></tr>
    <tr><td>ARR_RANGE</td>           <td>arr_range</td>           <td>arrRange</td></tr>
    <tr><td>ARR_REMOVE</td>          <td>arr_remove</td>          <td>arrRemove</td></tr>
    <tr><td>ARR_SORT</td>            <td>arr_sort</td>            <td>arrSort</td></tr>
    <tr><td>ARR_TAIL</td>            <td>arr_tail</td>            <td>arrTail</td></tr>
    <tr><td>ARR_TIMES</td>           <td>arr_times</td>           <td>times_ ...</td></tr>
</table><p></p>

<a name="actions_bigInteger"><h3>13.3 Actions for the type bigInteger</h3></a>
<p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>Action name</th>         <th>biglib.c function</th>   <th>big_rtl.c function</th></tr>
    <tr><td>BIG_ABS</td>             <td>big_abs</td>             <td>bigAbs</td></tr>
    <tr><td>BIG_ADD</td>             <td>big_add</td>             <td>bigAdd, bigAddTemp</td></tr>
    <tr><td>BIG_BIT_LENGTH</td>      <td>big_bit_length</td>      <td>bigBitLength</td></tr>
    <tr><td>BIG_CLIT</td>            <td>big_clit</td>            <td>bigCLit</td></tr>
    <tr><td>BIG_CMP</td>             <td>big_cmp</td>             <td>bigCmp</td></tr>
    <tr><td>BIG_CPY</td>             <td>big_cpy</td>             <td>bigCpy</td></tr>
    <tr><td>BIG_CREATE</td>          <td>big_create</td>          <td>bigCreate</td></tr>
    <tr><td>BIG_DECR</td>            <td>big_decr</td>            <td>bigDecr</td></tr>
    <tr><td>BIG_DESTR</td>           <td>big_destr</td>           <td>bigDestr</td></tr>
    <tr><td>BIG_DIV</td>             <td>big_div</td>             <td>bigDiv</td></tr>
    <tr><td>BIG_EQ</td>              <td>big_eq</td>              <td>bigEq</td></tr>
    <tr><td>BIG_GCD</td>             <td>big_gcd</td>             <td>bigGcd</td></tr>
    <tr><td>BIG_GE</td>              <td>big_ge</td>              <td>bigCmp >= 0</td></tr>
    <tr><td>BIG_GROW</td>            <td>big_grow</td>            <td>bigGrow</td></tr>
    <tr><td>BIG_GT</td>              <td>big_gt</td>              <td>bigCmp > 0</td></tr>
    <tr><td>BIG_HASHCODE</td>        <td>big_hashcode</td>        <td>bigHashCode</td></tr>
    <tr><td>BIG_ICONV</td>           <td>big_iconv</td>           <td>bigIConv</td></tr>
    <tr><td>BIG_INCR</td>            <td>big_incr</td>            <td>bigIncr</td></tr>
    <tr><td>BIG_IPOW</td>            <td>big_ipow</td>            <td>bigIPow</td></tr>
    <tr><td>BIG_LE</td>              <td>big_le</td>              <td>bigCmp &lt;= 0</td></tr>
    <tr><td>BIG_LOG2</td>            <td>big_log2</td>            <td>bigLog2</td></tr>
    <tr><td>BIG_LOWEST_SET_BIT</td>  <td>big_lowest_set_bit</td>  <td>bigLowestSetBit</td></tr>
    <tr><td>BIG_LSHIFT</td>          <td>big_lshift</td>          <td>bigLShift</td></tr>
    <tr><td>BIG_LSHIFT_ASSIGN</td>   <td>big_lshift_assign</td>   <td>bigLShiftAssign</td></tr>
    <tr><td>BIG_LT</td>              <td>big_lt</td>              <td>bigCmp < 0</td></tr>
    <tr><td>BIG_MDIV</td>            <td>big_mdiv</td>            <td>bigMDiv</td></tr>
    <tr><td>BIG_MINUS</td>           <td>big_minus</td>           <td>bigMinus</td></tr>
    <tr><td>BIG_MOD</td>             <td>big_mod</td>             <td>bigMod</td></tr>
    <tr><td>BIG_MULT</td>            <td>big_mult</td>            <td>bigMult</td></tr>
    <tr><td>BIG_MULT_ASSIGN</td>     <td>big_mult_assign</td>     <td>bigMultAssign</td></tr>
    <tr><td>BIG_NE</td>              <td>big_ne</td>              <td>bigNe</td></tr>
    <tr><td>BIG_ODD</td>             <td>big_odd</td>             <td>bigOdd</td></tr>
    <tr><td>BIG_ORD</td>             <td>big_ord</td>             <td>bigOrd</td></tr>
    <tr><td>BIG_PARSE</td>           <td>big_parse</td>           <td>bigParse</td></tr>
    <tr><td>BIG_PLUS</td>            <td>big_plus</td>            <td>(noop)</td></tr>
    <tr><td>BIG_PRED</td>            <td>big_pred</td>            <td>bigPred</td></tr>
    <tr><td>BIG_RAND</td>            <td>big_rand</td>            <td>bigRand</td></tr>
    <tr><td>BIG_REM</td>             <td>big_rem</td>             <td>bigRem</td></tr>
    <tr><td>BIG_RSHIFT</td>          <td>big_rshift</td>          <td>bigRShift</td></tr>
    <tr><td>BIG_RSHIFT_ASSIGN</td>   <td>big_rshift_assign</td>   <td>bigRShiftAssign</td></tr>
    <tr><td>BIG_SBTR</td>            <td>big_sbtr</td>            <td>bigSbtr, bigSbtrTemp</td></tr>
    <tr><td>BIG_SHRINK</td>          <td>big_shrink</td>          <td>bigShrink</td></tr>
    <tr><td>BIG_STR</td>             <td>big_str</td>             <td>bigStr</td></tr>
    <tr><td>BIG_SUCC</td>            <td>big_succ</td>            <td>bigSucc</td></tr>
    <tr><td>BIG_VALUE</td>           <td>big_value</td>           <td>bigValue</td></tr>
</table><p></p>

<a name="actions_boolean"><h3>13.4 Actions for the type boolean</h3></a>
<p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>Action name</th>         <th>blnlib.c function</th>   <th>bln_rtl.c function</th></tr>
    <tr><td>BLN_AND</td>             <td>bln_and</td>             <td>&amp;&amp;</td></tr>
    <tr><td>BLN_CPY</td>             <td>bln_cpy</td>             <td>blnCpy</td></tr>
    <tr><td>BLN_CREATE</td>          <td>bln_create</td>          <td>blnCreate</td></tr>
    <tr><td>BLN_GE</td>              <td>bln_ge</td>              <td>&gt;=</td></tr>
    <tr><td>BLN_GT</td>              <td>bln_gt</td>              <td>&gt;</td></tr>
    <tr><td>BLN_ICONV</td>           <td>bln_iconv</td>           <td>&amp; 1</td></tr>
    <tr><td>BLN_LE</td>              <td>bln_le</td>              <td>&lt;=</td></tr>
    <tr><td>BLN_LT</td>              <td>bln_lt</td>              <td>&lt;</td></tr>
    <tr><td>BLN_NOT</td>             <td>bln_not</td>             <td>!</td></tr>
    <tr><td>BLN_OR</td>              <td>bln_or</td>              <td>||</td></tr>
    <tr><td>BLN_ORD</td>             <td>bln_ord</td>             <td>(inttype)</td></tr>
</table><p></p>

<a name="actions_bstring"><h3>13.5 Actions for byte strings</h3></a>
<p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>Action name</th>         <th>bstlib.c function</th>   <th>bst_rtl.c function</th></tr>
    <tr><td>BST_APPEND</td>          <td>bst_append</td>          <td>bstAppend</td></tr>
    <tr><td>BST_CAT</td>             <td>bst_cat</td>             <td>bstCat</td></tr>
    <tr><td>BST_CMP</td>             <td>bst_cmp</td>             <td>bstCmp</td></tr>
    <tr><td>BST_CPY</td>             <td>bst_cpy</td>             <td>bstCpy</td></tr>
    <tr><td>BST_CREATE</td>          <td>bst_create</td>          <td>bstCreate</td></tr>
    <tr><td>BST_DESTR</td>           <td>bst_destr</td>           <td>bstDestr</td></tr>
    <tr><td>BST_EMPTY</td>           <td>bst_empty</td>           <td>&nbsp;</td></tr>
    <tr><td>BST_EQ</td>              <td>bst_eq</td>              <td>a->size==b->size &amp;&amp; memcmp(a,b,a->size*sizeof(unsigned char))==0</td></tr>
    <tr><td>BST_HASHCODE</td>        <td>bst_hashcode</td>        <td>bstHashCode</td></tr>
    <tr><td>BST_IDX</td>             <td>bst_idx</td>             <td>a-&gt;mem[b-1]</td></tr>
    <tr><td>BST_LNG</td>             <td>bst_lng</td>             <td>a->size</td></tr>
    <tr><td>BST_NE</td>              <td>bst_ne</td>              <td>a->size!=b->size || memcmp(a,b,a->size*sizeof(unsigned char))!=0</td></tr>
    <tr><td>BST_PARSE</td>           <td>bst_parse</td>           <td>bstParse</td></tr>
    <tr><td>BST_STR</td>             <td>bst_str</td>             <td>bstStr</td></tr>
    <tr><td>BST_VALUE</td>           <td>bst_value</td>           <td>bstValue</td></tr>
</table><p></p>

<a name="actions_char"><h3>13.6 Actions for the type char</h3></a>
<p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>Action name</th>         <th>chrlib.c function</th>   <th>chr_rtl.c function</th></tr>
    <tr><td>CHR_CHR</td>             <td>chr_chr</td>             <td>(chartype)</td></tr>
    <tr><td>CHR_CLIT</td>            <td>chr_clit</td>            <td>chrCLit</td></tr>
    <tr><td>CHR_CMP</td>             <td>chr_cmp</td>             <td>chrCmp</td></tr>
    <tr><td>CHR_CONV</td>            <td>chr_conv</td>            <td>(noop)</td></tr>
    <tr><td>CHR_CPY</td>             <td>chr_cpy</td>             <td>chrCpy</td></tr>
    <tr><td>CHR_CREATE</td>          <td>chr_create</td>          <td>chrCreate</td></tr>
    <tr><td>CHR_DECR</td>            <td>chr_decr</td>            <td>--</td></tr>
    <tr><td>CHR_EQ</td>              <td>chr_eq</td>              <td>==</td></tr>
    <tr><td>CHR_GE</td>              <td>chr_ge</td>              <td>&gt;=</td></tr>
    <tr><td>CHR_GT</td>              <td>chr_gt</td>              <td>&gt;</td></tr>
    <tr><td>CHR_HASHCODE</td>        <td>chr_hashcode</td>        <td>(inttype)((schartype)a)</td></tr>
    <tr><td>CHR_ICONV</td>           <td>chr_iconv</td>           <td>(chartype)</td></tr>
    <tr><td>CHR_INCR</td>            <td>chr_incr</td>            <td>++</td></tr>
    <tr><td>CHR_LE</td>              <td>chr_le</td>              <td>&lt;=</td></tr>
    <tr><td>CHR_LOW</td>             <td>chr_low</td>             <td>chrLow</td></tr>
    <tr><td>CHR_LT</td>              <td>chr_lt</td>              <td>&lt;</td></tr>
    <tr><td>CHR_NE</td>              <td>chr_ne</td>              <td>!=</td></tr>
    <tr><td>CHR_ORD</td>             <td>chr_ord</td>             <td>(inttype)</td></tr>
    <tr><td>CHR_PRED</td>            <td>chr_pred</td>            <td>-1</td></tr>
    <tr><td>CHR_STR</td>             <td>chr_str</td>             <td>chrStr</td></tr>
    <tr><td>CHR_SUCC</td>            <td>chr_succ</td>            <td>+1</td></tr>
    <tr><td>CHR_UP</td>              <td>chr_up</td>              <td>chrUp</td></tr>
    <tr><td>CHR_VALUE</td>           <td>chr_value</td>           <td>chrValue</td></tr>
</table><p></p>

<a name="actions_commands"><h3>13.7 Actions for various directory, file and other commands</h3></a>
<p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>Action name</th>         <th>cmdlib.c function</th>   <th>cmd_rtl.c function</th></tr>
    <tr><td>CMD_BIG_FILESIZE</td>    <td>cmd_big_filesize</td>    <td>cmdBigFileSize</td></tr>
    <tr><td>CMD_CHDIR</td>           <td>cmd_chdir</td>           <td>cmdChdir</td></tr>
    <tr><td>CMD_CLONE_FILE</td>      <td>cmd_clone_file</td>      <td>cmdCloneFile</td></tr>
    <tr><td>CMD_CONFIG_VALUE</td>    <td>cmd_config_value</td>    <td>cmdConfigValue</td></tr>
    <tr><td>CMD_COPY_FILE</td>       <td>cmd_copy_file</td>       <td>cmdCopyFile</td></tr>
    <tr><td>CMD_ENVIRONMENT</td>     <td>cmd_environment</td>     <td>cmdEnvironment</td></tr>
    <tr><td>CMD_FILEMODE</td>        <td>cmd_filemode</td>        <td>cmdFileMode</td></tr>
    <tr><td>CMD_FILESIZE</td>        <td>cmd_filesize</td>        <td>cmdFileSize</td></tr>
    <tr><td>CMD_FILETYPE</td>        <td>cmd_filetype</td>        <td>cmdFileType</td></tr>
    <tr><td>CMD_FILETYPE_SL</td>     <td>cmd_filetype_sl</td>     <td>cmdFileTypeSL</td></tr>
    <tr><td>CMD_GETCWD</td>          <td>cmd_getcwd</td>          <td>cmdGetcwd</td></tr>
    <tr><td>CMD_GETENV</td>          <td>cmd_getenv</td>          <td>cmdGetenv</td></tr>
    <tr><td>CMD_GET_ATIME</td>       <td>cmd_get_atime</td>       <td>cmdGetATime</td></tr>
    <tr><td>CMD_GET_CTIME</td>       <td>cmd_get_ctime</td>       <td>cmdGetCTime</td></tr>
    <tr><td>CMD_GET_MTIME</td>       <td>cmd_get_mtime</td>       <td>cmdGetMTime</td></tr>
    <tr><td>CMD_GET_SEARCH_PATH</td> <td>cmd_getSearchPath</td>   <td>cmdGetSearchPath</td></tr>
    <tr><td>CMD_HOME_DIR</td>        <td>cmd_homeDir</td>         <td>cmdHomeDir</td></tr>
    <tr><td>CMD_LS</td>              <td>cmd_ls</td>              <td>cmdLs</td></tr>
    <tr><td>CMD_MKDIR</td>           <td>cmd_mkdir</td>           <td>cmdMkdir</td></tr>
    <tr><td>CMD_MOVE</td>            <td>cmd_move</td>            <td>cmdMove</td></tr>
    <tr><td>CMD_PIPE2</td>           <td>cmd_pipe2</td>           <td>cmdPipe2</td></tr>
    <tr><td>CMD_PTY</td>             <td>cmd_pty</td>             <td>cmdPty</td></tr>
    <tr><td>CMD_READLINK</td>        <td>cmd_readlink</td>        <td>cmdReadlink</td></tr>
    <tr><td>CMD_REMOVE</td>          <td>cmd_remove</td>          <td>cmdRemove</td></tr>
    <tr><td>CMD_REMOVE_ANY_FILE</td> <td>cmd_remove_any_file</td> <td>cmdRemoveAnyFile</td></tr>
    <tr><td>CMD_SETENV</td>          <td>cmd_setenv</td>          <td>cmdSetenv</td></tr>
    <tr><td>CMD_SET_ATIME</td>       <td>cmd_set_atime</td>       <td>cmdSetATime</td></tr>
    <tr><td>CMD_SET_FILEMODE</td>    <td>cmd_set_filemode</td>    <td>cmdSetFileMode</td></tr>
    <tr><td>CMD_SET_MTIME</td>       <td>cmd_set_mtime</td>       <td>cmdSetMTime</td></tr>
    <tr><td>CMD_SHELL</td>           <td>cmd_shell</td>           <td>cmdShell</td></tr>
    <tr><td>CMD_SHELL_ESCAPE</td>    <td>cmd_shell_escape</td>    <td>cmdShellEscape</td></tr>
    <tr><td>CMD_START_PROCESS</td>   <td>cmd_start_process</td>   <td>cmdStartProcess</td></tr>
    <tr><td>CMD_SYMLINK</td>         <td>cmd_symlink</td>         <td>cmdSymlink</td></tr>
    <tr><td>CMD_TO_OS_PATH</td>      <td>cmd_to_os_path</td>      <td>cmdToOsPath</td></tr>
</table><p></p>

<a name="actions_console_output"><h3>13.8 Actions for text (console) screen output</h3></a>
<p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>Action name</th>         <th>scrlib.c function</th>   <th>con_inf.c/con_rtl.c/con_win.c function</th></tr>
    <tr><td>CON_CLEAR</td>           <td>con_clear</td>           <td>conClear</td></tr>
    <tr><td>CON_CURSOR</td>          <td>con_cursor</td>          <td>conCursor</td></tr>
    <tr><td>CON_FLUSH</td>           <td>con_flush</td>           <td>conFlush</td></tr>
    <tr><td>CON_HEIGHT</td>          <td>con_height</td>          <td>conHeight</td></tr>
    <tr><td>CON_H_SCL</td>           <td>con_h_scl</td>           <td>conHScroll</td></tr>
    <tr><td>CON_OPEN</td>            <td>con_open</td>            <td>conOpen</td></tr>
    <tr><td>CON_SETPOS</td>          <td>con_setpos</td>          <td>conSetpos</td></tr>
    <tr><td>CON_V_SCL</td>           <td>con_v_scl</td>           <td>conVScroll</td></tr>
    <tr><td>CON_WIDTH</td>           <td>con_width</td>           <td>conWidth</td></tr>
    <tr><td>CON_WRITE</td>           <td>con_write</td>           <td>conWrite</td></tr>
</table><p></p>

<a name="actions_declarations"><h3>13.9 Actions for declarations</h3></a>
<p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>Action name</th>         <th>dcllib.c function</th></tr>
    <tr><td>DCL_ATTR</td>            <td>dcl_attr</td></tr>
    <tr><td>DCL_CONST</td>           <td>dcl_const</td></tr>
    <tr><td>DCL_ELEMENTS</td>        <td>dcl_elements</td></tr>
    <tr><td>DCL_FWD</td>             <td>dcl_fwd</td></tr>
    <tr><td>DCL_FWDVAR</td>          <td>dcl_fwdvar</td></tr>
    <tr><td>DCL_GETFUNC</td>         <td>dcl_getfunc</td></tr>
    <tr><td>DCL_GETOBJ</td>          <td>dcl_getobj</td></tr>
    <tr><td>DCL_GLOBAL</td>          <td>dcl_global</td></tr>
    <tr><td>DCL_IN1VAR</td>          <td>dcl_in1var</td></tr>
    <tr><td>DCL_IN2VAR</td>          <td>dcl_in2var</td></tr>
    <tr><td>DCL_INOUT1</td>          <td>dcl_inout1</td></tr>
    <tr><td>DCL_INOUT2</td>          <td>dcl_inout2</td></tr>
    <tr><td>DCL_PARAM_ATTR</td>      <td>dcl_param_attr</td></tr>
    <tr><td>DCL_REF1</td>            <td>dcl_ref1</td></tr>
    <tr><td>DCL_REF2</td>            <td>dcl_ref2</td></tr>
    <tr><td>DCL_SYMB</td>            <td>dcl_symb</td></tr>
    <tr><td>DCL_VAL1</td>            <td>dcl_val1</td></tr>
    <tr><td>DCL_VAL2</td>            <td>dcl_val2</td></tr>
    <tr><td>DCL_VAR</td>             <td>dcl_var</td></tr>
</table><p></p>

<a name="actions_graphic_output"><h3>13.10 Actions to do graphic output</h3></a>
<p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>Action name</th>         <th>drwlib.c function</th>   <th>drw_rtl.c/drw_x11.c/drw_win.c function</th></tr>
    <tr><td>DRW_ARC</td>             <td>drw_arc</td>             <td>drwArc</td></tr>
    <tr><td>DRW_ARC2</td>            <td>drw_arc2</td>            <td>drwArc2</td></tr>
    <tr><td>DRW_BACKGROUND</td>      <td>drw_background</td>      <td>drwBackground</td></tr>
    <tr><td>DRW_CIRCLE</td>          <td>drw_circle</td>          <td>drwCircle</td></tr>
    <tr><td>DRW_CLEAR</td>           <td>drw_clear</td>           <td>drwClear</td></tr>
    <tr><td>DRW_CMP</td>             <td>drw_cmp</td>             <td>uintCmpGeneric((generictype)(a))</td></tr>
    <tr><td>DRW_COLOR</td>           <td>drw_color</td>           <td>drwColor</td></tr>
    <tr><td>DRW_COPYAREA</td>        <td>drw_copyarea</td>        <td>drwCopyArea</td></tr>
    <tr><td>DRW_CPY</td>             <td>drw_cpy</td>             <td>drwCpy</td></tr>
    <tr><td>DRW_CREATE</td>          <td>drw_create</td>          <td>drwCreate</td></tr>
    <tr><td>DRW_DESTR</td>           <td>drw_destr</td>           <td>drwDestr</td></tr>
    <tr><td>DRW_EMPTY</td>           <td>drw_empty</td>           <td>&nbsp;</td></tr>
    <tr><td>DRW_EQ</td>              <td>drw_eq</td>              <td>==</td></tr>
    <tr><td>DRW_FARCCHORD</td>       <td>drw_farcchord</td>       <td>drwFArcChord</td></tr>
    <tr><td>DRW_FARCPIESLICE</td>    <td>drw_farcpieslice</td>    <td>drwFArcPieSlice</td></tr>
    <tr><td>DRW_FCIRCLE</td>         <td>drw_fcircle</td>         <td>drwFCircle</td></tr>
    <tr><td>DRW_FELLIPSE</td>        <td>drw_fellipse</td>        <td>drwFEllipse</td></tr>
    <tr><td>DRW_FLUSH</td>           <td>drw_flush</td>           <td>drwFlush</td></tr>
    <tr><td>DRW_FPOLYLINE</td>       <td>drw_fpolyLine</td>       <td>drwFPolyLine</td></tr>
    <tr><td>DRW_GENPOINTLIST</td>    <td>drw_genPointList</td>    <td>drwGenPointList</td></tr>
    <tr><td>DRW_GET</td>             <td>drw_get</td>             <td>drwGet</td></tr>
    <tr><td>DRW_GETPIXEL</td>        <td>drw_getPixel</td>        <td>drwGetPixel</td></tr>
    <tr><td>DRW_HASHCODE</td>        <td>drw_hashcode</td>        <td>(inttype)(((memsizetype)a)&gt;&gt;6)</td></tr>
    <tr><td>DRW_HEIGHT</td>          <td>drw_height</td>          <td>drwHeight</td></tr>
    <tr><td>DRW_IMAGE</td>           <td>drw_image</td>           <td>drwImage</td></tr>
    <tr><td>DRW_LINE</td>            <td>drw_line</td>            <td>drwLine</td></tr>
    <tr><td>DRW_NE</td>              <td>drw_ne</td>              <td>!=</td></tr>
    <tr><td>DRW_NEW_PIXMAP</td>      <td>drw_new_pixmap</td>      <td>drwNewPixmap</td></tr>
    <tr><td>DRW_OPEN</td>            <td>drw_open</td>            <td>drwOpen</td></tr>
    <tr><td>DRW_OPEN_SUB_WINDOW</td> <td>drw_open_sub_window</td> <td>drwOpenSubWindow</td></tr>
    <tr><td>DRW_PARC</td>            <td>drw_parc</td>            <td>drwPArc</td></tr>
    <tr><td>DRW_PCIRCLE</td>         <td>drw_pcircle</td>         <td>drwPCircle</td></tr>
    <tr><td>DRW_PFARCCHORD</td>      <td>drw_pfarcchord</td>      <td>drwPFArcChord</td></tr>
    <tr><td>DRW_PFARCPIESLICE</td>   <td>drw_pfarcpieslice</td>   <td>drwFArcPieSlice</td></tr>
    <tr><td>DRW_PFCIRCLE</td>        <td>drw_pfcircle</td>        <td>drwPFCircle</td></tr>
    <tr><td>DRW_PFELLIPSE</td>       <td>drw_pfellipse</td>       <td>drwPFEllipse</td></tr>
    <tr><td>DRW_PIXELTORGB</td>      <td>drw_pixelToRgb</td>      <td>drwPixelToRgb</td></tr>
    <tr><td>DRW_PLINE</td>           <td>drw_pline</td>           <td>drwPLine</td></tr>
    <tr><td>DRW_POINT</td>           <td>drw_point</td>           <td>drwPoint</td></tr>
    <tr><td>DRW_POINTER_XPOS</td>    <td>drw_pointer_xpos</td>    <td>drwPointerXpos</td></tr>
    <tr><td>DRW_POINTER_YPOS</td>    <td>drw_pointer_ypos</td>    <td>drwPointerYpos</td></tr>
    <tr><td>DRW_POLYLINE</td>        <td>drw_polyLine</td>        <td>drwPolyLine</td></tr>
    <tr><td>DRW_PPOINT</td>          <td>drw_ppoint</td>          <td>drwPPoint</td></tr>
    <tr><td>DRW_PRECT</td>           <td>drw_prect</td>           <td>drwPRect</td></tr>
    <tr><td>DRW_PUT</td>             <td>drw_put</td>             <td>drwPut</td></tr>
    <tr><td>DRW_RECT</td>            <td>drw_rect</td>            <td>drwRect</td></tr>
    <tr><td>DRW_RGBCOL</td>          <td>drw_rgbcol</td>          <td>drwRgbColor</td></tr>
    <tr><td>DRW_SETCONTENT</td>      <td>drw_setContent</td>      <td>drwSetContent</td></tr>
    <tr><td>DRW_SETPOS</td>          <td>drw_setPos</td>          <td>drwSetPos</td></tr>
    <tr><td>DRW_SETTRANSPARENTCOLOR</td> <td>drw_setTransparentColor</td> <td>drwSetTransparentColor</td></tr>
    <tr><td>DRW_TEXT</td>            <td>drw_text</td>            <td>drwText</td></tr>
    <tr><td>DRW_TOBOTTOM</td>        <td>drw_toBottom</td>        <td>drwToBottom</td></tr>
    <tr><td>DRW_TOTOP</td>           <td>drw_toTop</td>           <td>drwToTop</td></tr>
    <tr><td>DRW_WIDTH</td>           <td>drw_width</td>           <td>drwWidth</td></tr>
    <tr><td>DRW_XPOS</td>            <td>drw_xpos</td>            <td>drwXPos</td></tr>
    <tr><td>DRW_YPOS</td>            <td>drw_ypos</td>            <td>drwYPos</td></tr>
</table><p></p>

<a name="actions_enumeration"><h3>13.11 Actions for enumeration types</h3></a>
<p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>Action name</th>         <th>enulib.c function</th>   <th>&nbsp;</th></tr>
    <tr><td>ENU_CONV</td>            <td>enu_conv</td>            <td>(noop)</td></tr>
    <tr><td>ENU_CPY</td>             <td>enu_cpy</td>             <td>=</td></tr>
    <tr><td>ENU_CREATE</td>          <td>enu_create</td>          <td>&nbsp;</td></tr>
    <tr><td>ENU_EQ</td>              <td>enu_eq</td>              <td>==</td></tr>
    <tr><td>ENU_GENLIT</td>          <td>enu_genlit</td>          <td>&nbsp;</td></tr>
    <tr><td>ENU_ICONV2</td>          <td>enu_iconv2</td>          <td>(noop)</td></tr>
    <tr><td>ENU_NE</td>              <td>enu_ne</td>              <td>!=</td></tr>
    <tr><td>ENU_ORD2</td>            <td>enu_ord2</td>            <td>(noop)</td></tr>
    <tr><td>ENU_VALUE</td>           <td>enu_value</td>           <td>enuValue</td></tr>
</table><p></p>

<a name="actions_clib_file"><h3>13.12 Actions for the type clib_file</h3></a>
<p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>Action name</th>         <th>fillib.c function</th>   <th>fil_rtl.c function</th></tr>
    <tr><td>FIL_BIG_LNG</td>         <td>fil_big_lng</td>         <td>filBigLng</td></tr>
    <tr><td>FIL_BIG_SEEK</td>        <td>fil_big_seek</td>        <td>filBigSeek</td></tr>
    <tr><td>FIL_BIG_TELL</td>        <td>fil_big_tell</td>        <td>filBigTell</td></tr>
    <tr><td>FIL_CLOSE</td>           <td>fil_close</td>           <td>fclose</td></tr>
    <tr><td>FIL_CPY</td>             <td>fil_cpy</td>             <td>fltCpy</td></tr>
    <tr><td>FIL_CREATE</td>          <td>fil_create</td>          <td>fltCreate</td></tr>
    <tr><td>FIL_EMPTY</td>           <td>fil_empty</td>           <td>&nbsp;</td></tr>
    <tr><td>FIL_EOF</td>             <td>fil_eof</td>             <td>feof</td></tr>
    <tr><td>FIL_EQ</td>              <td>fil_eq</td>              <td>==</td></tr>
    <tr><td>FIL_ERR</td>             <td>fil_err</td>             <td>stderr</td></tr>
    <tr><td>FIL_FLUSH</td>           <td>fil_flush</td>           <td>fflush</td></tr>
    <tr><td>FIL_GETC</td>            <td>fil_getc</td>            <td>fgetc</td></tr>
    <tr><td>FIL_GETS</td>            <td>fil_gets</td>            <td>filGets</td></tr>
    <tr><td>FIL_HAS_NEXT</td>        <td>fil_has_next</td>        <td>filHasNext</td></tr>
    <tr><td>FIL_IN</td>              <td>fil_in</td>              <td>stdin</td></tr>
    <tr><td>FIL_INPUT_READY</td>     <td>fil_input_ready</td>     <td>filInputReady</td></tr>
    <tr><td>FIL_LINE_READ</td>       <td>fil_line_read</td>       <td>filLineRead</td></tr>
    <tr><td>FIL_LIT</td>             <td>fil_lit</td>             <td>filLit</td></tr>
    <tr><td>FIL_LNG</td>             <td>fil_lng</td>             <td>filLng</td></tr>
    <tr><td>FIL_NE</td>              <td>fil_ne</td>              <td>!=</td></tr>
    <tr><td>FIL_OPEN</td>            <td>fil_open</td>            <td>filOpen</td></tr>
    <tr><td>FIL_OUT</td>             <td>fil_out</td>             <td>stdout</td></tr>
    <tr><td>FIL_PCLOSE</td>          <td>fil_pclose</td>          <td>filPclose</td></tr>
    <tr><td>FIL_POPEN</td>           <td>fil_popen</td>           <td>filPopen</td></tr>
    <tr><td>FIL_PRINT</td>           <td>fil_print</td>           <td>filPrint</td></tr>
    <tr><td>FIL_SEEK</td>            <td>fil_seek</td>            <td>filSeek</td></tr>
    <tr><td>FIL_SETBUF</td>          <td>fil_setbuf</td>          <td>filSetbuf</td></tr>
    <tr><td>FIL_TELL</td>            <td>fil_tell</td>            <td>filTell</td></tr>
    <tr><td>FIL_VALUE</td>           <td>fil_value</td>           <td>filValue</td></tr>
    <tr><td>FIL_WORD_READ</td>       <td>fil_word_read</td>       <td>filWordRead</td></tr>
    <tr><td>FIL_WRITE</td>           <td>fil_write</td>           <td>filWrite</td></tr>
</table><p></p>

<a name="actions_float"><h3>13.13 Actions for the type float</h3></a>
<p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>Action name</th>         <th>fltlib.c function</th>   <th>flt_rtl.c function</th></tr>
    <tr><td>FLT_A2TAN</td>           <td>flt_a2tan</td>           <td>atan2</td></tr>
    <tr><td>FLT_ABS</td>             <td>flt_abs</td>             <td>fabs</td></tr>
    <tr><td>FLT_ACOS</td>            <td>flt_acos</td>            <td>acos</td></tr>
    <tr><td>FLT_ADD</td>             <td>flt_add</td>             <td>+</td></tr>
    <tr><td>FLT_ASIN</td>            <td>flt_asin</td>            <td>asin</td></tr>
    <tr><td>FLT_ATAN</td>            <td>flt_atan</td>            <td>atan</td></tr>
    <tr><td>FLT_CAST</td>            <td>flt_cast</td>            <td>(x.floatvalue=a, x.intvalue)</td></tr>
    <tr><td>FLT_CEIL</td>            <td>flt_ceil</td>            <td>ceil</td></tr>
    <tr><td>FLT_CMP</td>             <td>flt_cmp</td>             <td>fltCmp</td></tr>
    <tr><td>FLT_COS</td>             <td>flt_cos</td>             <td>cos</td></tr>
    <tr><td>FLT_COSH</td>            <td>flt_cosh</td>            <td>cosh</td></tr>
    <tr><td>FLT_CPY</td>             <td>flt_cpy</td>             <td>fltCpy</td></tr>
    <tr><td>FLT_CREATE</td>          <td>flt_create</td>          <td>fltCreate</td></tr>
    <tr><td>FLT_DGTS</td>            <td>flt_dgts</td>            <td>fltDgts</td></tr>
    <tr><td>FLT_DIV</td>             <td>flt_div</td>             <td>/</td></tr>
    <tr><td>FLT_DIV_ASSIGN</td>      <td>flt_div_assign</td>      <td>/=</td></tr>
    <tr><td>FLT_EQ</td>              <td>flt_eq</td>              <td>==</td></tr>
    <tr><td>FLT_EXP</td>             <td>flt_exp</td>             <td>exp</td></tr>
    <tr><td>FLT_FLOOR</td>           <td>flt_floor</td>           <td>floor</td></tr>
    <tr><td>FLT_GE</td>              <td>flt_ge</td>              <td>&gt;=</td></tr>
    <tr><td>FLT_GROW</td>            <td>flt_grow</td>            <td>+=</td></tr>
    <tr><td>FLT_GT</td>              <td>flt_gt</td>              <td>&gt;</td></tr>
    <tr><td>FLT_HASHCODE</td>        <td>flt_hashcode</td>        <td>(x.floatvalue=a, x.intvalue)</td></tr>
    <tr><td>FLT_ICAST</td>           <td>flt_icast</td>           <td>(x.intvalue=a, x.floatvalue)</td></tr>
    <tr><td>FLT_ICONV</td>           <td>flt_iconv</td>           <td>(float)</td></tr>
    <tr><td>FLT_IFLT</td>            <td>flt_iflt</td>            <td>(float)</td></tr>
    <tr><td>FLT_IPOW</td>            <td>flt_ipow</td>            <td>fltIPow</td></tr>
    <tr><td>FLT_ISNAN</td>           <td>flt_isnan</td>           <td>isnan</td></tr>
    <tr><td>FLT_ISNEGATIVEZERO</td>  <td>flt_isnegativezero</td>  <td>fltIsNegativeZero</td></tr>
    <tr><td>FLT_LE</td>              <td>flt_le</td>              <td>&lt;=</td></tr>
    <tr><td>FLT_LOG</td>             <td>flt_log</td>             <td>log</td></tr>
    <tr><td>FLT_LOG10</td>           <td>flt_log10</td>           <td>log10</td></tr>
    <tr><td>FLT_LT</td>              <td>flt_lt</td>              <td>&lt;</td></tr>
    <tr><td>FLT_MINUS</td>           <td>flt_minus</td>           <td>-</td></tr>
    <tr><td>FLT_MULT</td>            <td>flt_mult</td>            <td>*</td></tr>
    <tr><td>FLT_MULT_ASSIGN</td>     <td>flt_mult_assign</td>     <td>*=</td></tr>
    <tr><td>FLT_NE</td>              <td>flt_ne</td>              <td>!=</td></tr>
    <tr><td>FLT_PARSE</td>           <td>flt_parse</td>           <td>fltParse</td></tr>
    <tr><td>FLT_PLUS</td>            <td>flt_plus</td>            <td>(noop)</td></tr>
    <tr><td>FLT_POW</td>             <td>flt_pow</td>             <td>pow</td></tr>
    <tr><td>FLT_RAND</td>            <td>flt_rand</td>            <td>fltRand</td></tr>
    <tr><td>FLT_ROUND</td>           <td>flt_round</td>           <td>a&lt;0.0?-((inttype)(0.5-a)):(inttype)(0.5+a)</td></tr>
    <tr><td>FLT_SBTR</td>            <td>flt_sbtr</td>            <td>-</td></tr>
    <tr><td>FLT_SCI</td>             <td>flt_sci</td>             <td>fltSci</td></tr>
    <tr><td>FLT_SHRINK</td>          <td>flt_shrink</td>          <td>-=</td></tr>
    <tr><td>FLT_SIN</td>             <td>flt_sin</td>             <td>sin</td></tr>
    <tr><td>FLT_SINH</td>            <td>flt_sinh</td>            <td>sinh</td></tr>
    <tr><td>FLT_SQRT</td>            <td>flt_sqrt</td>            <td>sqrt</td></tr>
    <tr><td>FLT_STR</td>             <td>flt_str</td>             <td>fltStr</td></tr>
    <tr><td>FLT_TAN</td>             <td>flt_tan</td>             <td>tan</td></tr>
    <tr><td>FLT_TANH</td>            <td>flt_tanh</td>            <td>tanh</td></tr>
    <tr><td>FLT_TRUNC</td>           <td>flt_trunc</td>           <td>(inttype)</td></tr>
    <tr><td>FLT_VALUE</td>           <td>flt_value</td>           <td>fltValue</td></tr>
</table><p></p>

<a name="actions_graphic_keyboard"><h3>13.14 Actions to support the graphic keyboard</h3></a>
<p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>Action name</th>         <th>drwlib.c function</th>   <th>kbd_rtl.c/drw_x11.c/drw_win.c function</th></tr>
    <tr><td>GKB_BUSY_GETC</td>       <td>gkb_busy_getc</td>       <td>gkbKeyPressed() ? gkbGetc() : 512</td></tr>
    <tr><td>GKB_BUTTON_PRESSED</td>  <td>gkb_button_pressed</td>  <td>gkbButtonPressed</td></tr>
    <tr><td>GKB_BUTTON_XPOS</td>     <td>gkb_button_xpos</td>     <td>gkbButtonXpos</td></tr>
    <tr><td>GKB_BUTTON_YPOS</td>     <td>gkb_button_ypos</td>     <td>gkbButtonYpos</td></tr>
    <tr><td>GKB_GETC</td>            <td>gkb_getc</td>            <td>gkbGetc</td></tr>
    <tr><td>GKB_GETS</td>            <td>gkb_gets</td>            <td>gkbGets</td></tr>
    <tr><td>GKB_KEYPRESSED</td>      <td>gkb_keypressed</td>      <td>gkbKeyPressed</td></tr>
    <tr><td>GKB_LINE_READ</td>       <td>gkb_line_read</td>       <td>gkbLineRead</td></tr>
    <tr><td>GKB_RAW_GETC</td>        <td>gkb_raw_getc</td>        <td>gkbRawGetc</td></tr>
    <tr><td>GKB_WINDOW</td>          <td>gkb_window</td>          <td>gkbWindow</td></tr>
    <tr><td>GKB_WORD_READ</td>       <td>gkb_word_read</td>       <td>gkbWordRead</td></tr>
</table><p></p>

<a name="actions_hash"><h3>13.15 Actions for hash types</h3></a>
<p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>Action name</th>         <th>hshlib.c function</th>   <th>hsh_rtl.c function</th></tr>
    <tr><td>HSH_CONTAINS</td>        <td>hsh_contains</td>        <td>hshContains</td></tr>
    <tr><td>HSH_CPY</td>             <td>hsh_cpy</td>             <td>hshCpy</td></tr>
    <tr><td>HSH_CREATE</td>          <td>hsh_create</td>          <td>hshCreate</td></tr>
    <tr><td>HSH_DESTR</td>           <td>hsh_destr</td>           <td>hshDestr</td></tr>
    <tr><td>HSH_EMPTY</td>           <td>hsh_empty</td>           <td>hshEmpty</td></tr>
    <tr><td>HSH_EXCL</td>            <td>hsh_excl</td>            <td>hshExcl</td></tr>
    <tr><td>HSH_FOR</td>             <td>hsh_for</td>             <td>for</td></tr>
    <tr><td>HSH_FOR_DATA_KEY</td>    <td>hsh_for_data_key</td>    <td>for</td></tr>
    <tr><td>HSH_FOR_KEY</td>         <td>hsh_for_key</td>         <td>for</td></tr>
    <tr><td>HSH_IDX</td>             <td>hsh_idx</td>             <td>hshIdx, hshIdxAddr</td></tr>
    <tr><td>HSH_IDX2</td>            <td>hsh_idx2</td>            <td>&nbsp;</td></tr>
    <tr><td>HSH_INCL</td>            <td>hsh_incl</td>            <td>hshIncl</td></tr>
    <tr><td>HSH_KEYS</td>            <td>hsh_keys</td>            <td>hshKeys</td></tr>
    <tr><td>HSH_LNG</td>             <td>hsh_lng</td>             <td>a->size</td></tr>
    <tr><td>HSH_REFIDX</td>          <td>hsh_refidx</td>          <td>&nbsp;</td></tr>
    <tr><td>HSH_VALUES</td>          <td>hsh_values</td>          <td>hshValues</td></tr>
</table><p></p>

<a name="actions_integer"><h3>13.16 Actions for the type integer</h3></a>
<p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>Action name</th>         <th>intlib.c function</th>   <th>int_rtl.c function</th></tr>
    <tr><td>INT_ABS</td>             <td>int_abs</td>             <td>labs</td></tr>
    <tr><td>INT_ADD</td>             <td>int_add</td>             <td>+</td></tr>
    <tr><td>INT_BINOM</td>           <td>int_binom</td>           <td>intBinom</td></tr>
    <tr><td>INT_BIT_LENGTH</td>      <td>int_bit_length</td>      <td>intBitLength</td></tr>
    <tr><td>INT_CMP</td>             <td>int_cmp</td>             <td>intCmp</td></tr>
    <tr><td>INT_CONV</td>            <td>int_conv</td>            <td>(noop)</td></tr>
    <tr><td>INT_CPY</td>             <td>int_cpy</td>             <td>intCpy</td></tr>
    <tr><td>INT_CREATE</td>          <td>int_create</td>          <td>intCreate</td></tr>
    <tr><td>INT_DECR</td>            <td>int_decr</td>            <td>--</td></tr>
    <tr><td>INT_DIV</td>             <td>int_div</td>             <td>/</td></tr>
    <tr><td>INT_EQ</td>              <td>int_eq</td>              <td>==</td></tr>
    <tr><td>INT_FACT</td>            <td>int_fact</td>            <td>fact[a]</td></tr>
    <tr><td>INT_GE</td>              <td>int_ge</td>              <td>&gt;=</td></tr>
    <tr><td>INT_GROW</td>            <td>int_grow</td>            <td>+=</td></tr>
    <tr><td>INT_GT</td>              <td>int_gt</td>              <td>&gt;</td></tr>
    <tr><td>INT_HASHCODE</td>        <td>int_hashcode</td>        <td>(noop)</td></tr>
    <tr><td>INT_INCR</td>            <td>int_incr</td>            <td>++</td></tr>
    <tr><td>INT_LE</td>              <td>int_le</td>              <td>&lt;=</td></tr>
    <tr><td>INT_LOG2</td>            <td>int_log2</td>            <td>intLog2</td></tr>
    <tr><td>INT_LOWEST_SET_BIT</td>  <td>int_lowest_set_bit</td>  <td>intLowestSetBit</td></tr>
    <tr><td>INT_LPAD0</td>           <td>int_lpad0</td>           <td>intLpad0</td></tr>
    <tr><td>INT_LSHIFT</td>          <td>int_lshift</td>          <td>&lt;&lt;</td></tr>
    <tr><td>INT_LSHIFT_ASSIGN</td>   <td>int_lshift_assign</td>   <td>&lt;&lt;=</td></tr>
    <tr><td>INT_LT</td>              <td>int_lt</td>              <td>&lt;</td></tr>
    <tr><td>INT_MDIV</td>            <td>int_mdiv</td>            <td>a&gt;0&amp;&amp;b&lt;0 ? (a-1)/b-1 : a&lt;0&amp;&amp;b&gt;0 ? (a+1)/b-1 : a/b</td></tr>
    <tr><td>INT_MINUS</td>           <td>int_minus</td>           <td>-</td></tr>
    <tr><td>INT_MOD</td>             <td>int_mod</td>             <td>c=a%b, ((a&gt;0&amp;&amp;b&lt;0) || (a&lt;0&amp;&amp;b&gt;0)) &amp;&amp; c!=0 ? c+b : c</td></tr>
    <tr><td>INT_MULT</td>            <td>int_mult</td>            <td>*</td></tr>
    <tr><td>INT_MULT_ASSIGN</td>     <td>int_mult_assign</td>     <td>*=</td></tr>
    <tr><td>INT_NE</td>              <td>int_ne</td>              <td>!=</td></tr>
    <tr><td>INT_ODD</td>             <td>int_odd</td>             <td>&amp;1</td></tr>
    <tr><td>INT_ORD</td>             <td>int_ord</td>             <td>(noop)</td></tr>
    <tr><td>INT_PARSE</td>           <td>int_parse</td>           <td>intParse</td></tr>
    <tr><td>INT_PLUS</td>            <td>int_plus</td>            <td>(noop)</td></tr>
    <tr><td>INT_POW</td>             <td>int_pow</td>             <td>intPow</td></tr>
    <tr><td>INT_PRED</td>            <td>int_pred</td>            <td>--</td></tr>
    <tr><td>INT_RADIX</td>           <td>int_RADIX</td>           <td>intRadix</td></tr>
    <tr><td>INT_RAND</td>            <td>int_rand</td>            <td>intRand</td></tr>
    <tr><td>INT_REM</td>             <td>int_rem</td>             <td>%</td></tr>
    <tr><td>INT_RSHIFT</td>          <td>int_rshift</td>          <td>a&gt;&gt;b <span class="comment">/* C with arithmetic shift */</span><br />
                                            a&lt;0?~(~a&gt;&gt;b):a&gt;&gt;b <span class="comment">/* C with logical shift */</span></td></tr>
    <tr><td>INT_RSHIFT_ASSIGN</td>   <td>int_rshift_assign</td>   <td>a&gt;&gt;=b <span class="comment">/* C with arithmetic shift */</span><br />
                                            if (a<0) a= ~(~a&gt;&gt;b); else a&gt;&gt;=b; <span class="comment">/* C with logical shift */</span></td></tr>
    <tr><td>INT_SBTR</td>            <td>int_sbtr</td>            <td>-</td></tr>
    <tr><td>INT_SHRINK</td>          <td>int_shrink</td>          <td>-=</td></tr>
    <tr><td>INT_SQRT</td>            <td>int_sqrt</td>            <td>intSqrt</td></tr>
    <tr><td>INT_STR</td>             <td>int_str</td>             <td>intStr</td></tr>
    <tr><td>INT_SUCC</td>            <td>int_succ</td>            <td>+1</td></tr>
    <tr><td>INT_VALUE</td>           <td>int_value</td>           <td>intValue</td></tr>
    <tr><td>INT_radix</td>           <td>int_radix</td>           <td>intRadix</td></tr>
</table><p></p>

<a name="actions_interface"><h3>13.17 Actions for interface types</h3></a>
<p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>Action name</th>         <th>itflib.c function</th>   <th>&nbsp;</th></tr>
    <tr><td>ITF_CMP</td>             <td>itf_cmp</td>             <td>uintCmpGeneric</td></tr>
    <tr><td>ITF_CONV2</td>           <td>itf_conv2</td>           <td>(noop)</td></tr>
    <tr><td>ITF_CPY</td>             <td>itf_cpy</td>             <td>=</td></tr>
    <tr><td>ITF_CPY2</td>            <td>itf_cpy2</td>            <td>=</td></tr>
    <tr><td>ITF_CREATE</td>          <td>itf_create</td>          <td>&nbsp;</td></tr>
    <tr><td>ITF_CREATE2</td>         <td>itf_create2</td>         <td>&nbsp;</td></tr>
    <tr><td>ITF_DESTR</td>           <td>itf_destr</td>           <td>itfDestr</td></tr>
    <tr><td>ITF_EQ</td>              <td>itf_eq</td>              <td>==</td></tr>
    <tr><td>ITF_HASHCODE</td>        <td>itf_hashcode</td>        <td>(inttype)(((memsizetype)a)&gt;&gt;6)</td></tr>
    <tr><td>ITF_NE</td>              <td>itf_ne</td>              <td>!=</td></tr>
    <tr><td>ITF_TO_HEAP</td>         <td>itf_to_heap</td>         <td>&nbsp;</td></tr>
    <tr><td>ITF_TO_INTERFACE</td>    <td>itf_to_interface</td>    <td>&nbsp;</td></tr>
</table><p></p>

<a name="actions_console_keyboard"><h3>13.18 Actions to support the text (console) screen keyboard</h3></a>
<p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>Action name</th>         <th>kbdlib.c function</th>   <th>kbd_rtl.c/kbd_inf.c function</th></tr>
    <tr><td>KBD_BUSY_GETC</td>       <td>kbd_busy_getc</td>       <td>kbdKeyPressed() ? kbdGetc() : 512</td></tr>
    <tr><td>KBD_GETC</td>            <td>kbd_getc</td>            <td>kbdGetc</td></tr>
    <tr><td>KBD_GETS</td>            <td>kbd_gets</td>            <td>kbdGets</td></tr>
    <tr><td>KBD_KEYPRESSED</td>      <td>kbd_keypressed</td>      <td>kbdKeyPressed</td></tr>
    <tr><td>KBD_LINE_READ</td>       <td>kbd_line_read</td>       <td>kbdLineRead</td></tr>
    <tr><td>KBD_RAW_GETC</td>        <td>kbd_raw_getc</td>        <td>kbdRawGetc</td></tr>
    <tr><td>KBD_WORD_READ</td>       <td>kbd_word_read</td>       <td>kbdWordRead</td></tr>
</table><p></p>

<a name="actions_list"><h3>13.19 Actions for the list type</h3></a>
<p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>Action name</th>         <th>lstlib.c function</th></tr>
    <tr><td>LST_CAT</td>             <td>lst_cat</td></tr>
    <tr><td>LST_CPY</td>             <td>lst_cpy</td></tr>
    <tr><td>LST_CREATE</td>          <td>lst_create</td></tr>
    <tr><td>LST_DESTR</td>           <td>lst_destr</td></tr>
    <tr><td>LST_ELEM</td>            <td>lst_elem</td></tr>
    <tr><td>LST_EMPTY</td>           <td>lst_empty</td></tr>
    <tr><td>LST_EXCL</td>            <td>lst_excl</td></tr>
    <tr><td>LST_HEAD</td>            <td>lst_head</td></tr>
    <tr><td>LST_IDX</td>             <td>lst_idx</td></tr>
    <tr><td>LST_INCL</td>            <td>lst_incl</td></tr>
    <tr><td>LST_LNG</td>             <td>lst_lng</td></tr>
    <tr><td>LST_RANGE</td>           <td>lst_range</td></tr>
    <tr><td>LST_TAIL</td>            <td>lst_tail</td></tr>
</table><p></p>

<a name="actions_pollData"><h3>13.20 Actions for the type pollData</h3></a>
<p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>Action name</th>         <th>pollib.c function</th>   <th>pol_unx.c/pol_sel.c function</th></tr>
    <tr><td>POL_ADD_CHECK</td>       <td>pol_addCheck</td>        <td>polAddCheck</td></tr>
    <tr><td>POL_CLEAR</td>           <td>pol_clear</td>           <td>polClear</td></tr>
    <tr><td>POL_CPY</td>             <td>pol_cpy</td>             <td>polCpy</td></tr>
    <tr><td>POL_CREATE</td>          <td>pol_create</td>          <td>polCreate</td></tr>
    <tr><td>POL_DESTR</td>           <td>pol_destr</td>           <td>polDestr</td></tr>
    <tr><td>POL_EMPTY</td>           <td>pol_empty</td>           <td>polEmpty</td></tr>
    <tr><td>POL_GET_CHECK</td>       <td>pol_getCheck</td>        <td>polGetCheck</td></tr>
    <tr><td>POL_GET_FINDING</td>     <td>pol_getFinding</td>      <td>polGetFinding</td></tr>
    <tr><td>POL_HAS_NEXT</td>        <td>pol_hasNext</td>         <td>polHasNext</td></tr>
    <tr><td>POL_ITER_CHECKS</td>     <td>pol_iterChecks</td>      <td>polIterChecks</td></tr>
    <tr><td>POL_ITER_FINDINGS</td>   <td>pol_iterFindings</td>    <td>polIterFindings</td></tr>
    <tr><td>POL_NEXT_FILE</td>       <td>pol_nextFile</td>        <td>polNextFile</td></tr>
    <tr><td>POL_POLL</td>            <td>pol_poll</td>            <td>polPoll</td></tr>
    <tr><td>POL_REMOVE_CHECK</td>    <td>pol_removeCheck</td>     <td>polRemoveCheck</td></tr>
    <tr><td>POL_VALUE</td>           <td>pol_value</td>           <td>polValue</td></tr>
</table><p></p>

<a name="actions_proc"><h3>13.21 Actions for proc operations and statements</h3></a>
<p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>Action name</th>         <th>prclib.c function</th>   <th>&nbsp;</th></tr>
    <tr><td>PRC_ARGS</td>            <td>prc_args</td>            <td>&nbsp;</td></tr>
    <tr><td>PRC_BEGIN</td>           <td>prc_begin</td>           <td>&nbsp;</td></tr>
    <tr><td>PRC_BLOCK</td>           <td>prc_block</td>           <td>&nbsp;</td></tr>
    <tr><td>PRC_BLOCK_DEF</td>       <td>prc_block_def</td>       <td>&nbsp;</td></tr>
    <tr><td>PRC_CASE</td>            <td>prc_case</td>            <td>switch</td></tr>
    <tr><td>PRC_CASE_DEF</td>        <td>prc_case_def</td>        <td>switch</td></tr>
    <tr><td>PRC_CPY</td>             <td>prc_cpy</td>             <td>&nbsp;</td></tr>
    <tr><td>PRC_CREATE</td>          <td>prc_create</td>          <td>&nbsp;</td></tr>
    <tr><td>PRC_DECLS</td>           <td>prc_decls</td>           <td>&nbsp;</td></tr>
    <tr><td>PRC_DYNAMIC</td>         <td>prc_dynamic</td>         <td>&nbsp;</td></tr>
    <tr><td>PRC_EXIT</td>            <td>prc_exit</td>            <td>exit</td></tr>
    <tr><td>PRC_FOR_DOWNTO</td>      <td>prc_for_downto</td>      <td>for</td></tr>
    <tr><td>PRC_FOR_TO</td>          <td>prc_for_to</td>          <td>for</td></tr>
    <tr><td>PRC_HEAPSTAT</td>        <td>prc_heapstat</td>        <td>&nbsp;</td></tr>
    <tr><td>PRC_HSIZE</td>           <td>prc_hsize</td>           <td>heapsize</td></tr>
    <tr><td>PRC_IF</td>              <td>prc_if</td>              <td>if</td></tr>
    <tr><td>PRC_IF_ELSIF</td>        <td>prc_if_elsif</td>        <td>if</td></tr>
    <tr><td>PRC_INCLUDE</td>         <td>prc_include</td>         <td>&nbsp;</td></tr>
    <tr><td>PRC_LOCAL</td>           <td>prc_local</td>           <td>&nbsp;</td></tr>
    <tr><td>PRC_NOOP</td>            <td>prc_noop</td>            <td>prcNoop</td></tr>
    <tr><td>PRC_RAISE</td>           <td>prc_raise</td>           <td>raise_error</td></tr>
    <tr><td>PRC_REPEAT</td>          <td>prc_repeat</td>          <td>do</td></tr>
    <tr><td>PRC_RES_BEGIN</td>       <td>prc_res_begin</td>       <td>&nbsp;</td></tr>
    <tr><td>PRC_RES_LOCAL</td>       <td>prc_res_local</td>       <td>&nbsp;</td></tr>
    <tr><td>PRC_RETURN</td>          <td>prc_return</td>          <td>&nbsp;</td></tr>
    <tr><td>PRC_RETURN2</td>         <td>prc_return2</td>         <td>&nbsp;</td></tr>
    <tr><td>PRC_SETTRACE</td>        <td>prc_settrace</td>        <td>&nbsp;</td></tr>
    <tr><td>PRC_TRACE</td>           <td>prc_trace</td>           <td>&nbsp;</td></tr>
    <tr><td>PRC_VARFUNC</td>         <td>prc_varfunc</td>         <td>&nbsp;</td></tr>
    <tr><td>PRC_VARFUNC2</td>        <td>prc_varfunc2</td>        <td>&nbsp;</td></tr>
    <tr><td>PRC_WHILE</td>           <td>prc_while</td>           <td>while</td></tr>
</table><p></p>

<a name="actions_program"><h3>13.22 Actions for the type program</h3></a>
<p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>Action name</th>         <th>prglib.c function</th>   <th>prg_comp.c function</th></tr>
    <tr><td>PRG_CPY</td>             <td>prg_cpy</td>             <td>prgCpy</td></tr>
    <tr><td>PRG_CREATE</td>          <td>prg_create</td>          <td>&nbsp;</td></tr>
    <tr><td>PRG_DECL_OBJECTS</td>    <td>prg_decl_objects</td>    <td>prgDeclObjects</td></tr>
    <tr><td>PRG_DESTR</td>           <td>prg_destr</td>           <td>&nbsp;</td></tr>
    <tr><td>PRG_EMPTY</td>           <td>prg_empty</td>           <td>&nbsp;</td></tr>
    <tr><td>PRG_EQ</td>              <td>prg_eq</td>              <td>==</td></tr>
    <tr><td>PRG_ERROR_COUNT</td>     <td>prg_error_count</td>     <td>prgErrorCount</td></tr>
    <tr><td>PRG_EVAL</td>            <td>prg_eval</td>            <td>prgEval</td></tr>
    <tr><td>PRG_EXEC</td>            <td>prg_exec</td>            <td>prgExec</td></tr>
    <tr><td>PRG_FIL_PARSE</td>       <td>prg_fil_parse</td>       <td>prgFilParse</td></tr>
    <tr><td>PRG_FIND</td>            <td>prg_find</td>            <td>&nbsp;</td></tr>
    <tr><td>PRG_MATCH</td>           <td>prg_match</td>           <td>prgMatch</td></tr>
    <tr><td>PRG_MATCH_EXPR</td>      <td>prg_match_expr</td>      <td>prgMatchExpr</td></tr>
    <tr><td>PRG_NAME</td>            <td>prg_name</td>            <td>arg_0</td></tr>
    <tr><td>PRG_NE</td>              <td>prg_ne</td>              <td>!=</td></tr>
    <tr><td>PRG_PATH</td>            <td>prg_path</td>            <td>programPath</td></tr>
    <tr><td>PRG_PROG</td>            <td>prg_prog</td>            <td>&nbsp;</td></tr>
    <tr><td>PRG_STR_PARSE</td>       <td>prg_str_parse</td>       <td>prgStrParse</td></tr>
    <tr><td>PRG_SYOBJECT</td>        <td>prg_syobject</td>        <td>prgSyobject</td></tr>
    <tr><td>PRG_SYSVAR</td>          <td>prg_sysvar</td>          <td>prgSysvar</td></tr>
    <tr><td>PRG_VALUE</td>           <td>prg_value</td>           <td>prgValue</td></tr>
</table><p></p>

<a name="actions_reference"><h3>13.23 Actions for the type reference</h3></a>
<p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>Action name</th>         <th>reflib.c function</th>   <th>ref_data.c function</th></tr>
    <tr><td>REF_ADDR</td>            <td>ref_addr</td>            <td>&</td></tr>
    <tr><td>REF_ALLOC</td>           <td>ref_alloc</td>           <td>refAlloc</td></tr>
    <tr><td>REF_ARRMAXIDX</td>       <td>ref_arrmaxidx</td>       <td>refArrmaxidx</td></tr>
    <tr><td>REF_ARRMINIDX</td>       <td>ref_arrminidx</td>       <td>refArrminidx</td></tr>
    <tr><td>REF_ARRTOLIST</td>       <td>ref_arrtolist</td>       <td>refArrtolist</td></tr>
    <tr><td>REF_BODY</td>            <td>ref_body</td>            <td>refBody</td></tr>
    <tr><td>REF_BUILD</td>           <td>ref_build</td>           <td>&nbsp;</td></tr>
    <tr><td>REF_CAST</td>            <td>ref_cast</td>            <td>&nbsp;</td></tr>
    <tr><td>REF_CATEGORY</td>        <td>ref_category</td>        <td>refCategory</td></tr>
    <tr><td>REF_CAT_PARSE</td>       <td>ref_cat_parse</td>       <td>refCatParse</td></tr>
    <tr><td>REF_CAT_STR</td>         <td>ref_cat_str</td>         <td>refCatStr</td></tr>
    <tr><td>REF_CMP</td>             <td>ref_cmp</td>             <td>refCmp</td></tr>
    <tr><td>REF_CONTENT</td>         <td>ref_content</td>         <td>&nbsp;</td></tr>
    <tr><td>REF_CONV</td>            <td>ref_conv</td>            <td>(noop)</td></tr>
    <tr><td>REF_CPY</td>             <td>ref_cpy</td>             <td>refCpy</td></tr>
    <tr><td>REF_CREATE</td>          <td>ref_create</td>          <td>refCreate</td></tr>
    <tr><td>REF_DEREF</td>           <td>ref_deref</td>           <td>&nbsp;</td></tr>
    <tr><td>REF_EQ</td>              <td>ref_eq</td>              <td>==</td></tr>
    <tr><td>REF_FILE</td>            <td>ref_file</td>            <td>refFile</td></tr>
    <tr><td>REF_FIND</td>            <td>ref_find</td>            <td>&nbsp;</td></tr>
    <tr><td>REF_HASHCODE</td>        <td>ref_hashcode</td>        <td>(inttype)(((memsizetype)a)&gt;&gt;6)</td></tr>
    <tr><td>REF_HSHDATATOLIST</td>   <td>ref_hshdatatolist</td>   <td>refHshDataToList</td></tr>
    <tr><td>REF_HSHKEYTOLIST</td>    <td>ref_hshkeytolist</td>    <td>refHshKeyToList</td></tr>
    <tr><td>REF_ISSYMB</td>          <td>ref_issymb</td>          <td>&nbsp;</td></tr>
    <tr><td>REF_ISVAR</td>           <td>ref_isvar</td>           <td>refIsvar</td></tr>
    <tr><td>REF_ITFTOSCT</td>        <td>ref_itftosct</td>        <td>refItftosct</td></tr>
    <tr><td>REF_LINE</td>            <td>ref_line</td>            <td>refLine</td></tr>
    <tr><td>REF_LOCAL_CONSTS</td>    <td>ref_local_consts</td>    <td>refLocalConsts</td></tr>
    <tr><td>REF_LOCAL_VARS</td>      <td>ref_local_vars</td>      <td>refLocalVars</td></tr>
    <tr><td>REF_MKREF</td>           <td>ref_mkref</td>           <td>&nbsp;</td></tr>
    <tr><td>REF_NE</td>              <td>ref_ne</td>              <td>!=</td></tr>
    <tr><td>REF_NIL</td>             <td>ref_nil</td>             <td>&nbsp;</td></tr>
    <tr><td>REF_NUM</td>             <td>ref_num</td>             <td>refNum</td></tr>
    <tr><td>REF_PARAMS</td>          <td>ref_params</td>          <td>refParams</td></tr>
    <tr><td>REF_PROG</td>            <td>ref_prog</td>            <td>&nbsp;</td></tr>
    <tr><td>REF_RESINI</td>          <td>ref_resini</td>          <td>refResini</td></tr>
    <tr><td>REF_RESULT</td>          <td>ref_result</td>          <td>refResult</td></tr>
    <tr><td>REF_SCAN</td>            <td>ref_scan</td>            <td>&nbsp;</td></tr>
    <tr><td>REF_SCTTOLIST</td>       <td>ref_scttolist</td>       <td>refScttolist</td></tr>
    <tr><td>REF_SELECT</td>          <td>ref_select</td>          <td>a->stru[b]</td></tr>
    <tr><td>REF_SETCATEGORY</td>     <td>ref_setcategory</td>     <td>refSetCategory</td></tr>
    <tr><td>REF_SETPARAMS</td>       <td>ref_setparams</td>       <td>refSetParams</td></tr>
    <tr><td>REF_SETTYPE</td>         <td>ref_settype</td>         <td>refSetType</td></tr>
    <tr><td>REF_STR</td>             <td>ref_str</td>             <td>refStr</td></tr>
    <tr><td>REF_SYMB</td>            <td>ref_symb</td>            <td>&nbsp;</td></tr>
    <tr><td>REF_TRACE</td>           <td>ref_trace</td>           <td>printf</td></tr>
    <tr><td>REF_TYPE</td>            <td>ref_type</td>            <td>refType</td></tr>
    <tr><td>REF_VALUE</td>           <td>ref_value</td>           <td>refValue</td></tr>
</table><p></p>

<a name="actions_ref_list"><h3>13.24 Actions for the type ref_list</h3></a>
<p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>Action name</th>         <th>rfllib.c function</th>   <th>rfl_data.c function</th></tr>
    <tr><td>RFL_APPEND</td>          <td>rfl_append</td>          <td>rflAppend</td></tr>
    <tr><td>RFL_CAT</td>             <td>rfl_cat</td>             <td>rflCat</td></tr>
    <tr><td>RFL_CPY</td>             <td>rfl_cpy</td>             <td>rflCpy</td></tr>
    <tr><td>RFL_CREATE</td>          <td>rfl_create</td>          <td>rflCreate</td></tr>
    <tr><td>RFL_DESTR</td>           <td>rfl_destr</td>           <td>rflDestr</td></tr>
    <tr><td>RFL_ELEM</td>            <td>rfl_elem</td>            <td>rflElem</td></tr>
    <tr><td>RFL_ELEMCPY</td>         <td>rfl_elemcpy</td>         <td>rflElemcpy</td></tr>
    <tr><td>RFL_EMPTY</td>           <td>rfl_empty</td>           <td>&nbsp;</td></tr>
    <tr><td>RFL_EQ</td>              <td>rfl_eq</td>              <td>rflEq</td></tr>
    <tr><td>RFL_EXCL</td>            <td>rfl_excl</td>            <td>&nbsp;</td></tr>
    <tr><td>RFL_EXPR</td>            <td>rfl_expr</td>            <td>&nbsp;</td></tr>
    <tr><td>RFL_FOR</td>             <td>rfl_for</td>             <td>for</td></tr>
    <tr><td>RFL_FOR_UNTIL</td>       <td>rfl_for_until</td>       <td>for</td></tr>
    <tr><td>RFL_HEAD</td>            <td>rfl_head</td>            <td>rflHead</td></tr>
    <tr><td>RFL_IDX</td>             <td>rfl_idx</td>             <td>rflIdx</td></tr>
    <tr><td>RFL_INCL</td>            <td>rfl_incl</td>            <td>rflIncl</td></tr>
    <tr><td>RFL_IPOS</td>            <td>rfl_ipos</td>            <td>rflIpos</td></tr>
    <tr><td>RFL_LNG</td>             <td>rfl_lng</td>             <td>rflLng</td></tr>
    <tr><td>RFL_MKLIST</td>          <td>rfl_mklist</td>          <td>rflMklist</td></tr>
    <tr><td>RFL_NE</td>              <td>rfl_ne</td>              <td>rflNe</td></tr>
    <tr><td>RFL_NOT_ELEM</td>        <td>rfl_not_elem</td>        <td>!rflElem</td></tr>
    <tr><td>RFL_POS</td>             <td>rfl_pos</td>             <td>rflPos</td></tr>
    <tr><td>RFL_RANGE</td>           <td>rfl_range</td>           <td>rflRange</td></tr>
    <tr><td>RFL_SETVALUE</td>        <td>rfl_setvalue</td>        <td>rflSetvalue</td></tr>
    <tr><td>RFL_TAIL</td>            <td>rfl_tail</td>            <td>rflTail</td></tr>
    <tr><td>RFL_TRACE</td>           <td>rfl_trace</td>           <td>&nbsp;</td></tr>
    <tr><td>RFL_VALUE</td>           <td>rfl_value</td>           <td>rflValue</td></tr>
</table><p></p>

<a name="actions_struct"><h3>13.25 Actions for struct types</h3></a>
<p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>Action name</th>         <th>sctlib.c function</th>   <th>&nbsp;</th></tr>
    <tr><td>SCT_ALLOC</td>           <td>sct_alloc</td>           <td>&nbsp;</td></tr>
    <tr><td>SCT_CAT</td>             <td>sct_cat</td>             <td>&nbsp;</td></tr>
    <tr><td>SCT_CONV</td>            <td>sct_conv</td>            <td>&nbsp;</td></tr>
    <tr><td>SCT_CPY</td>             <td>sct_cpy</td>             <td>cpy_ ...</td></tr>
    <tr><td>SCT_CREATE</td>          <td>sct_create</td>          <td>create_ ...</td></tr>
    <tr><td>SCT_DESTR</td>           <td>sct_destr</td>           <td>destr_ ...</td></tr>
    <tr><td>SCT_ELEM</td>            <td>sct_elem</td>            <td>&nbsp;</td></tr>
    <tr><td>SCT_EMPTY</td>           <td>sct_empty</td>           <td>&nbsp;</td></tr>
    <tr><td>SCT_INCL</td>            <td>sct_incl</td>            <td>&nbsp;</td></tr>
    <tr><td>SCT_LNG</td>             <td>sct_lng</td>             <td>&nbsp;</td></tr>
    <tr><td>SCT_REFIDX</td>          <td>sct_refidx</td>          <td>&nbsp;</td></tr>
    <tr><td>SCT_SELECT</td>          <td>sct_select</td>          <td>a->stru[b]</td></tr>
</table><p></p>

<a name="actions_set"><h3>13.26 Actions for set types</h3></a>
<p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>Action name</th>         <th>setlib.c function</th>   <th>set_rtl.c function</th></tr>
    <tr><td>SET_ARRLIT</td>          <td>set_arrlit</td>          <td>setArrlit</td></tr>
    <tr><td>SET_BASELIT</td>         <td>set_baselit</td>         <td>setBaselit</td></tr>
    <tr><td>SET_CARD</td>            <td>set_card</td>            <td>setCard</td></tr>
    <tr><td>SET_CMP</td>             <td>set_cmp</td>             <td>setCmp</td></tr>
    <tr><td>SET_CONV</td>            <td>set_conv</td>            <td>(noop)</td></tr>
    <tr><td>SET_CPY</td>             <td>set_cpy</td>             <td>setCpy</td></tr>
    <tr><td>SET_CREATE</td>          <td>set_create</td>          <td>setCreate</td></tr>
    <tr><td>SET_DESTR</td>           <td>set_destr</td>           <td>setDestr</td></tr>
    <tr><td>SET_DIFF</td>            <td>set_diff</td>            <td>setDiff</td></tr>
    <tr><td>SET_ELEM</td>            <td>set_elem</td>            <td>setElem</td></tr>
    <tr><td>SET_EMPTY</td>           <td>set_empty</td>           <td>&nbsp;</td></tr>
    <tr><td>SET_EQ</td>              <td>set_eq</td>              <td>setEq</td></tr>
    <tr><td>SET_EXCL</td>            <td>set_excl</td>            <td>setExcl</td></tr>
    <tr><td>SET_GE</td>              <td>set_ge</td>              <td>setIsSubset(b, a)</td></tr>
    <tr><td>SET_GT</td>              <td>set_gt</td>              <td>setIsProperSubset(b, a)</td></tr>
    <tr><td>SET_HASHCODE</td>        <td>set_hashcode</td>        <td>setHashCode</td></tr>
    <tr><td>SET_ICONV</td>           <td>set_iconv</td>           <td>setIConv</td></tr>
    <tr><td>SET_INCL</td>            <td>set_incl</td>            <td>setIncl</td></tr>
    <tr><td>SET_INTERSECT</td>       <td>set_intersect</td>       <td>setIntersect</td></tr>
    <tr><td>SET_LE</td>              <td>set_le</td>              <td>setIsSubset</td></tr>
    <tr><td>SET_LT</td>              <td>set_lt</td>              <td>setIsProperSubset</td></tr>
    <tr><td>SET_MAX</td>             <td>set_max</td>             <td>setMax</td></tr>
    <tr><td>SET_MIN</td>             <td>set_min</td>             <td>setMin</td></tr>
    <tr><td>SET_NE</td>              <td>set_ne</td>              <td>setNe</td></tr>
    <tr><td>SET_NEXT</td>            <td>set_next</td>            <td>setNext</td></tr>
    <tr><td>SET_NOT_ELEM</td>        <td>set_not_elem</td>        <td>!setElem</td></tr>
    <tr><td>SET_RAND</td>            <td>set_rand</td>            <td>setRand</td></tr>
    <tr><td>SET_RANGELIT</td>        <td>set_rangelit</td>        <td>setRangelit</td></tr>
    <tr><td>SET_SCONV</td>           <td>set_sconv</td>           <td>setSConv</td></tr>
    <tr><td>SET_SYMDIFF</td>         <td>set_symdiff</td>         <td>setSymdiff</td></tr>
    <tr><td>SET_UNION</td>           <td>set_union</td>           <td>setUnion</td></tr>
    <tr><td>SET_VALUE</td>           <td>set_value</td>           <td>setValue</td></tr>
</table><p></p>

<a name="actions_PRIMITIVE_SOCKET"><h3>13.27 Actions for the type PRIMITIVE_SOCKET</h3></a>
<p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>Action name</th>         <th>strlib.c function</th>   <th>str_rtl.c function</th></tr>
    <tr><td>SOC_ACCEPT</td>          <td>soc_accept</td>          <td>socAccept</td></tr>
    <tr><td>SOC_ADDR_FAMILY</td>     <td>soc_addr_family</td>     <td>socAddrFamily</td></tr>
    <tr><td>SOC_ADDR_NUMERIC</td>    <td>soc_addr_numeric</td>    <td>socAddrNumeric</td></tr>
    <tr><td>SOC_ADDR_SERVICE</td>    <td>soc_addr_service</td>    <td>socAddrService</td></tr>
    <tr><td>SOC_BIND</td>            <td>soc_bind</td>            <td>socBind</td></tr>
    <tr><td>SOC_CLOSE</td>           <td>soc_close</td>           <td>socClose</td></tr>
    <tr><td>SOC_CONNECT</td>         <td>soc_connect</td>         <td>socConnect</td></tr>
    <tr><td>SOC_CPY</td>             <td>soc_cpy</td>             <td>=</td></tr>
    <tr><td>SOC_CREATE</td>          <td>soc_create</td>          <td>&nbsp;</td></tr>
    <tr><td>SOC_EMPTY</td>           <td>soc_empty</td>           <td>&nbsp;</td></tr>
    <tr><td>SOC_EQ</td>              <td>soc_eq</td>              <td>==</td></tr>
    <tr><td>SOC_GETC</td>            <td>soc_getc</td>            <td>socGetc</td></tr>
    <tr><td>SOC_GETS</td>            <td>soc_gets</td>            <td>socGets</td></tr>
    <tr><td>SOC_GET_ADDR</td>        <td>soc_get_addr</td>        <td>socGetAddr</td></tr>
    <tr><td>SOC_GET_HOSTNAME</td>    <td>soc_get_hostname</td>    <td>socGetHostname</td></tr>
    <tr><td>SOC_HAS_NEXT</td>        <td>soc_has_next</td>        <td>socHasNext</td></tr>
    <tr><td>SOC_INET_ADDR</td>       <td>soc_inet_addr</td>       <td>socInetAddr</td></tr>
    <tr><td>SOC_INET_LOCAL_ADDR</td> <td>soc_inet_local_addr</td> <td>socInetLocalAddr</td></tr>
    <tr><td>SOC_INET_SERV_ADDR</td>  <td>soc_inet_serv_addr</td>  <td>socInetServAddr</td></tr>
    <tr><td>SOC_INPUT_READY</td>     <td>soc_input_ready</td>     <td>socInputReady</td></tr>
    <tr><td>SOC_LINE_READ</td>       <td>soc_line_read</td>       <td>socLineRead</td></tr>
    <tr><td>SOC_LISTEN</td>          <td>soc_listen</td>          <td>socListen</td></tr>
    <tr><td>SOC_NE</td>              <td>soc_ne</td>              <td>!=</td></tr>
    <tr><td>SOC_RECV</td>            <td>soc_recv</td>            <td>socRecv</td></tr>
    <tr><td>SOC_RECVFROM</td>        <td>soc_recvfrom</td>        <td>socRecvfrom</td></tr>
    <tr><td>SOC_SEND</td>            <td>soc_send</td>            <td>socSend</td></tr>
    <tr><td>SOC_SENDTO</td>          <td>soc_sendto</td>          <td>socSendto</td></tr>
    <tr><td>SOC_SOCKET</td>          <td>soc_socket</td>          <td>socSocket</td></tr>
    <tr><td>SOC_WORD_READ</td>       <td>soc_word_read</td>       <td>socWordRead</td></tr>
    <tr><td>SOC_WRITE</td>           <td>soc_write</td>           <td>socWrite</td></tr>
</table><p></p>

<a name="actions_string"><h3>13.28 Actions for the type string</h3></a>
<p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>Action name</th>         <th>strlib.c function</th>   <th>str_rtl.c function</th></tr>
    <tr><td>STR_APPEND</td>          <td>str_append</td>          <td>strAppend</td></tr>
    <tr><td>STR_CAT</td>             <td>str_cat</td>             <td>strConcat, strConcatTemp</td></tr>
    <tr><td>STR_CHIPOS</td>          <td>str_chipos</td>          <td>strChIpos</td></tr>
    <tr><td>STR_CHPOS</td>           <td>str_chpos</td>           <td>strChPos</td></tr>
    <tr><td>STR_CHSPLIT</td>         <td>str_chsplit</td>         <td>strChSplit</td></tr>
    <tr><td>STR_CLIT</td>            <td>str_clit</td>            <td>strCLit</td></tr>
    <tr><td>STR_CMP</td>             <td>str_cmp</td>             <td>strCompare</td></tr>
    <tr><td>STR_CPY</td>             <td>str_cpy</td>             <td>strCopy</td></tr>
    <tr><td>STR_CREATE</td>          <td>str_create</td>          <td>strCreate</td></tr>
    <tr><td>STR_DESTR</td>           <td>str_destr</td>           <td>strDestr</td></tr>
    <tr><td>STR_ELEMCPY</td>         <td>str_elemcpy</td>         <td>a-&gt;mem[b-1]=c</td></tr>
    <tr><td>STR_EQ</td>              <td>str_eq</td>              <td>a->size==b->size &amp;&amp; memcmp(a,b,a->size*sizeof(strelemtype))==0</td></tr>
    <tr><td>STR_GE</td>              <td>str_ge</td>              <td>strGe</td></tr>
    <tr><td>STR_GT</td>              <td>str_gt</td>              <td>strGt</td></tr>
    <tr><td>STR_HASHCODE</td>        <td>str_hashcode</td>        <td>strHashCode</td></tr>
    <tr><td>STR_HEAD</td>            <td>str_head</td>            <td>strHead</td></tr>
    <tr><td>STR_IDX</td>             <td>str_idx</td>             <td>a-&gt;mem[b-1]</td></tr>
    <tr><td>STR_IPOS</td>            <td>str_ipos</td>            <td>strIpos</td></tr>
    <tr><td>STR_LE</td>              <td>str_le</td>              <td>strLe</td></tr>
    <tr><td>STR_LIT</td>             <td>str_lit</td>             <td>strLit</td></tr>
    <tr><td>STR_LNG</td>             <td>str_lng</td>             <td>a->size</td></tr>
    <tr><td>STR_LOW</td>             <td>str_low</td>             <td>strLow, strLowTemp</td></tr>
    <tr><td>STR_LPAD</td>            <td>str_lpad</td>            <td>strLpad</td></tr>
    <tr><td>STR_LPAD0</td>           <td>str_lpad0</td>           <td>strLpad0, strLpad0Temp</td></tr>
    <tr><td>STR_LT</td>              <td>str_lt</td>              <td>strLt</td></tr>
    <tr><td>STR_MULT</td>            <td>str_mult</td>            <td>strMult</td></tr>
    <tr><td>STR_NE</td>              <td>str_ne</td>              <td>a->size!=b->size || memcmp(a,b,a->size*sizeof(strelemtype))!=0</td></tr>
    <tr><td>STR_POS</td>             <td>str_pos</td>             <td>strPos</td></tr>
    <tr><td>STR_POSCPY</td>          <td>str_poscpy</td>          <td>memcpy</td></tr>
    <tr><td>STR_PUSH</td>            <td>str_push</td>            <td>strPush</td></tr>
    <tr><td>STR_RANGE</td>           <td>str_range</td>           <td>strRange</td></tr>
    <tr><td>STR_RCHIPOS</td>         <td>str_rchipos</td>         <td>strRChIpos</td></tr>
    <tr><td>STR_RCHPOS</td>          <td>str_rchpos</td>          <td>strRChPos</td></tr>
    <tr><td>STR_REPL</td>            <td>str_repl</td>            <td>strRepl</td></tr>
    <tr><td>STR_RIPOS</td>           <td>str_ripos</td>           <td>strRIPos</td></tr>
    <tr><td>STR_RPAD</td>            <td>str_rpad</td>            <td>strRpad</td></tr>
    <tr><td>STR_RPOS</td>            <td>str_rpos</td>            <td>strRpos</td></tr>
    <tr><td>STR_SPLIT</td>           <td>str_split</td>           <td>strSplit</td></tr>
    <tr><td>STR_STR</td>             <td>str_str</td>             <td>(noop)</td></tr>
    <tr><td>STR_SUBSTR</td>          <td>str_substr</td>          <td>strSubstr</td></tr>
    <tr><td>STR_TAIL</td>            <td>str_tail</td>            <td>strTail</td></tr>
    <tr><td>STR_TOUTF8</td>          <td>str_toutf8</td>          <td>strToUtf8</td></tr>
    <tr><td>STR_TRIM</td>            <td>str_trim</td>            <td>strTrim</td></tr>
    <tr><td>STR_UP</td>              <td>str_up</td>              <td>strUp, strUpTemp</td></tr>
    <tr><td>STR_UTF8TOSTRI</td>      <td>str_utf8tostri</td>      <td>strUtf8ToStri</td></tr>
    <tr><td>STR_VALUE</td>           <td>str_value</td>           <td>strValue</td></tr>
</table><p></p>

<a name="actions_time"><h3>13.29 Actions for the type time</h3></a>
<p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>Action name</th>         <th>timlib.c function</th>   <th>tim_unx.c/tim_win.c function</th></tr>
    <tr><td>TIM_AWAIT</td>           <td>tim_await</td>           <td>timAwait</td></tr>
    <tr><td>TIM_FROM_TIMESTAMP</td>  <td>tim_from_timestamp</td>  <td>timFromTimestamp</td></tr>
    <tr><td>TIM_NOW</td>             <td>tim_now</td>             <td>timNow</td></tr>
    <tr><td>TIM_SET_LOCAL_TZ</td>    <td>tim_set_local_tz</td>    <td>timSetLocalTZ</td></tr>
</table><p></p>

<a name="actions_type"><h3>13.30 Actions for the type type</h3></a>
<p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>Action name</th>         <th>typlib.c function</th>   <th>typ_data.c function</th></tr>
    <tr><td>TYP_ADDINTERFACE</td>    <td>typ_addinterface</td>    <td>&nbsp;</td></tr>
    <tr><td>TYP_CMP</td>             <td>typ_cmp</td>             <td>typCmp</td></tr>
    <tr><td>TYP_CPY</td>             <td>typ_cpy</td>             <td>typCpy</td></tr>
    <tr><td>TYP_CREATE</td>          <td>typ_create</td>          <td>typCreate</td></tr>
    <tr><td>TYP_DESTR</td>           <td>typ_destr</td>           <td>typDestr</td></tr>
    <tr><td>TYP_EQ</td>              <td>typ_eq</td>              <td>==</td></tr>
    <tr><td>TYP_FUNC</td>            <td>typ_func</td>            <td>typFunc</td></tr>
    <tr><td>TYP_GENSUB</td>          <td>typ_gensub</td>          <td>&nbsp;</td></tr>
    <tr><td>TYP_GENTYPE</td>         <td>typ_gentype</td>         <td>&nbsp;</td></tr>
    <tr><td>TYP_HASHCODE</td>        <td>typ_hashcode</td>        <td>(inttype)(((memsizetype)a)&gt;&gt;6)</td></tr>
    <tr><td>TYP_ISDECLARED</td>      <td>typ_isdeclared</td>      <td>&nbsp;</td></tr>
    <tr><td>TYP_ISDERIVED</td>       <td>typ_isderived</td>       <td>typIsDerived</td></tr>
    <tr><td>TYP_ISFORWARD</td>       <td>typ_isforward</td>       <td>&nbsp;</td></tr>
    <tr><td>TYP_ISFUNC</td>          <td>typ_isfunc</td>          <td>typIsFunc</td></tr>
    <tr><td>TYP_ISVARFUNC</td>       <td>typ_isvarfunc</td>       <td>typIsVarfunc</td></tr>
    <tr><td>TYP_MATCHOBJ</td>        <td>typ_matchobj</td>        <td>typMatchobj</td></tr>
    <tr><td>TYP_META</td>            <td>typ_meta</td>            <td>typMeta</td></tr>
    <tr><td>TYP_NE</td>              <td>typ_ne</td>              <td>!=</td></tr>
    <tr><td>TYP_NUM</td>             <td>typ_num</td>             <td>typNum</td></tr>
    <tr><td>TYP_RESULT</td>          <td>typ_result</td>          <td>typResult</td></tr>
    <tr><td>TYP_STR</td>             <td>typ_str</td>             <td>typStr</td></tr>
    <tr><td>TYP_VALUE</td>           <td>typ_value</td>           <td>typValue</td></tr>
    <tr><td>TYP_VARCONV</td>         <td>typ_varconv</td>         <td>&nbsp;</td></tr>
    <tr><td>TYP_VARFUNC</td>         <td>typ_varfunc</td>         <td>typVarfunc</td></tr>
</table><p></p>

<a name="actions_utf8_file"><h3>13.31 Actions for the type utf8_file</h3></a>
<p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>Action name</th>         <th>ut8lib.c function</th>   <th>ut8_rtl.c function</th></tr>
    <tr><td>UT8_GETC</td>            <td>ut8_getc</td>            <td>ut8Getc</td></tr>
    <tr><td>UT8_GETS</td>            <td>ut8_gets</td>            <td>ut8Gets</td></tr>
    <tr><td>UT8_LINE_READ</td>       <td>ut8_line_read</td>       <td>ut8LineRead</td></tr>
    <tr><td>UT8_SEEK</td>            <td>ut8_seek</td>            <td>ut8Seek</td></tr>
    <tr><td>UT8_WORD_READ</td>       <td>ut8_word_read</td>       <td>ut8WordRead</td></tr>
    <tr><td>UT8_WRITE</td>           <td>ut8_write</td>           <td>ut8Write</td></tr>
</table><p></p>

<a name="ffi_file_start"></a><p></p>
<a name="ffi_FOREIGN_FUNCTION_INTERFACE"><h2>14. FOREIGN FUNCTION INTERFACE</h2></a>

<p>
    Foreign functions cannot be called directly. It is necessary to
  write wrapper functions. Several things must be done to call a
  foreign function:
</p><ul>
    <li>The <a class="link" href="#ffi_C_types_used_by_the_implementation">C types used by Seed7</a> must be <a class="link" href="#ffi_String_and_path_conversions">converted to the C types</a> used
      by the foreign function (E.g.: <tt><a class="type" href="#types_string">string</a></tt> and <a class="link" href="#os_Standard_path_representation">path</a> conversions).
      The result of the foreign function and parameters, which return
      a value, must be converted back. This conversions are usually
      done in a wrapper function.</li>
    <li>A function with the <a class="link" href="#actions_file_start">action</a> prototype (a function with a
      <tt><a class="type" href="#ffi_listtype">listtype</a></tt> parameter and an <tt><a class="type" href="#ffi_objecttype">objecttype</a></tt> result) must be
      defined. Predefined macros help to <a class="link" href="#ffi_Macros_to_access_the_action_parameters">access the action arguments</a>
      and to <a class="link" href="#ffi_Functions_to_create_action_results">create result values</a>. The action function must be
      registered in the file <tt><span class="lib">"primitiv.c"</span></tt>.</li>
    <li>The new action must be introduced to Seed7. This is usually
      done in an <tt>*.s7i</tt> library file, which introduces an action
      definition.</li>
</ul><p>
  In general two functions are needed: A wrapper function and an
  action function. The corresponding function definitions can be
  placed in two <tt>*.c</tt> files. Corresponding <tt>*.h</tt> files contain prototypes.
  Assume, we have the library <tt><span class="lib">"superlib"</span></tt> and the function <tt><a class="func" href="#ffi_doWurx1">doWurx1</a></tt>
  from <tt><span class="lib">"superlib"</span></tt> should be called from a Seed7 program. The three
  letter abbreviation <tt><b>sup</b></tt> is used to determine the file and function
  names for wrapper and action. The following files and functions are
  used:
</p><dl><dd><table border="1" cellspacing="0" cellpadding="5">
  <tr><th>File         </th><th> Function    </th><th> Comment</th></tr>
  
  <tr><td>superlib.a   </td><td> <tt><a class="func" href="#ffi_doWurx1">doWurx1</a></tt>     </td><td> External library (the extension may vary)</td></tr>
  <tr><td>superlib.h   </td><td> <tt><a class="func" href="#ffi_doWurx1">doWurx1</a></tt>     </td><td> Prototype of the external C function</td></tr>
  <tr><td>sup_rtl.c    </td><td> <tt><a class="func" href="#ffi_supDoWurx1">supDoWurx1</a></tt>  </td><td> Wrapper function</td></tr>
  <tr><td>sup_rtl.h    </td><td> <tt><a class="func" href="#ffi_supDoWurx1">supDoWurx1</a></tt>  </td><td> Prototype of the wrapper function</td></tr>
  <tr><td>suplib.c     </td><td> <tt><a class="func" href="#ffi_sup_doWurx1">sup_doWurx1</a></tt> </td><td> Action function</td></tr>
  <tr><td>suplib.h     </td><td> <tt><a class="func" href="#ffi_sup_doWurx1">sup_doWurx1</a></tt> </td><td> Prototype of the action function</td></tr>
  <tr><td>primitiv.c   </td><td> &nbsp;           </td><td> Alphabetical list of all primitive actions</td></tr>
  <tr><td>makefile     </td><td> &nbsp;           </td><td> Makefile name depends on operating system and compiler</td></tr>
  <tr><td>superlib.s7i </td><td> <tt>doWurx1</tt>     </td><td> Introduces the external function to a Seed7 program</td></tr>
</table></dd></dl><p>
  The C prototype of <tt><a class="func" href="#ffi_doWurx1">doWurx1</a></tt> is defined in the file <tt><span class="lib">"superlib.h"</span></tt>:
</p><pre class="indent">
<span class="type">int</span> <a name="ffi_doWurx1">doWurx1</a> (<span class="type">char</span> *name);
</pre><p>
  This function accepts an UTF-8 <tt>'name'</tt> and it returns 0 on success.
  Every other return value indicates that the string is too long. In
  this case the exception <tt><a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a></tt> should be raised. The wrapper
  function is defined in the file <tt><span class="lib">"sup_rtl.c"</span></tt> with:
</p><pre class="indent">
#<span class="keywd">include</span> <span class="lib">"version.h"</span>
#<span class="keywd">include</span> <span class="lib">"stdio.h"</span>
#<span class="keywd">include</span> <span class="lib">"superlib.h"</span>
#<span class="keywd">include</span> <span class="lib">"common.h"</span>
#<span class="keywd">include</span> <span class="lib">"striutl.h"</span>
#<span class="keywd">include</span> <span class="lib">"rtl_err.h"</span>

void <a name="ffi_supDoWurx1">supDoWurx1</a> (const <a class="type" href="#ffi_stritype">stritype</a> name)
  {
    <a class="type" href="#ffi_cstritype">cstritype</a> cName;
    <span class="type">int</span> wurxResult;

    cName = <a class="func" href="#ffi_cp_to_cstri8">cp_to_cstri8</a>(name);
    <span class="keywd">if</span> (cName == NULL) {
      raise_error(MEMORY_ERROR);
    } <span class="keywd">else</span> {
      wurxResult = <a class="func" href="#ffi_doWurx1">doWurx1</a>(cName);
      free_cstri(cName);
      <span class="keywd">if</span> (wurxResult != 0) {
        raise_error(RANGE_ERROR);
      }
    }
  }
</pre><p>
  The prototype of <tt><a class="func" href="#ffi_supDoWurx1">supDoWurx1</a></tt> is defined in the file <tt><span class="lib">"sup_rtl.h"</span></tt> with:
</p><pre class="indent">
void <a class="func" href="#ffi_supDoWurx1">supDoWurx1</a> (const <a class="type" href="#ffi_stritype">stritype</a> name);
</pre><p>
  The action function for <tt><a class="func" href="#ffi_supDoWurx1">supDoWurx1</a></tt> is defined in the file
  <tt><span class="lib">"suplib.c"</span></tt> with:
</p><pre class="indent">
#<span class="keywd">include</span> <span class="lib">"version.h"</span>
#<span class="keywd">include</span> <span class="lib">"stdio.h"</span>
#<span class="keywd">include</span> <span class="lib">"common.h"</span>
#<span class="keywd">include</span> <span class="lib">"data.h"</span>
#<span class="keywd">include</span> <span class="lib">"syvarutl.h"</span>
#<span class="keywd">include</span> <span class="lib">"objutl.h"</span>
#<span class="keywd">include</span> <span class="lib">"sup_rtl.h"</span>

<a class="type" href="#ffi_objecttype">objecttype</a> <a name="ffi_sup_doWurx1">sup_doWurx1</a> (<a class="type" href="#ffi_listtype">listtype</a> arguments)
  {
    <a class="func" href="#ffi_isit_stri">isit_stri</a>(<a class="func" href="#ffi_arg_1">arg_1</a>(arguments));
    <a class="func" href="#ffi_supDoWurx1">supDoWurx1</a>(<a class="func" href="#ffi_take_stri">take_stri</a>(<a class="func" href="#ffi_arg_1">arg_1</a>(arguments)));
    <span class="keywd">return</span> SYS_EMPTY_OBJECT;
  }
</pre><p>
  The prototype of <tt><a class="func" href="#ffi_sup_doWurx1">sup_doWurx1</a></tt> is defined in the file <tt><span class="lib">"suplib.h"</span></tt> with:
</p><pre class="indent">
<a class="type" href="#ffi_objecttype">objecttype</a> <a class="func" href="#ffi_sup_doWurx1">sup_doWurx1</a> (<a class="type" href="#ffi_listtype">listtype</a> arguments);
</pre><p>
  The action is introduced to the interpreter, by changing the file
  <tt><span class="lib">"primitiv.c"</span></tt>. An include directive for <tt><span class="lib">"suplib.h"</span></tt> must be added:
</p><pre class="indent">
#<span class="keywd">include</span> <span class="lib">"strlib.h"</span>
<b>#<span class="keywd">include</span> <span class="lib">"suplib.h"</span></b>
#<span class="keywd">include</span> <span class="lib">"timlib.h"</span>
</pre><p>
  The file <tt><span class="lib">"primitiv.c"</span></tt> contains a list of alphabetically sorted primitive
  actions. Each action entry takes a line. It is important to add the new
  action <tt><span class="stri">"SUP_DO_WURX"</span></tt> at the correct place:
</p><pre class="indent">
{ <span class="stri">"STR_VALUE"</span>,               <span class="func">str_value</span>,               },

<b>{ <span class="stri">"SUP_DO_WURX"</span>,             <a class="func" href="#ffi_sup_doWurx1">sup_doWurx1</a>,             },</b>

{ <span class="stri">"TIM_AWAIT"</span>,               <span class="func">tim_await</span>,               },
</pre><p>
  The new files must be added to the makefile. Depending on C compiler and
  operating system Seed7 uses several makefiles. In the correct <tt>"makefile"</tt>
  <tt>suplib</tt> and <tt>sup_rtl</tt> must be added to lists of source
  and object files. Adding the <tt>suplib</tt> object file results in:
</p><pre class="indent">
LOBJ = actlib.o arrlib.o biglib.o blnlib.o bstlib.o chrlib.o cmdlib.o conlib.o dcllib.o drwlib.o \
       enulib.o fillib.o fltlib.o hshlib.o intlib.o itflib.o kbdlib.o lstlib.o pollib.o prclib.o \
       prglib.o reflib.o rfllib.o sctlib.o setlib.o soclib.o strlib.o <b>suplib.o</b> timlib.o typlib.o ut8lib.o
</pre><p>
  Adding the <tt>"suplib"</tt> source file results in:
</p><pre class="indent">
LSRC = actlib.c arrlib.c biglib.c blnlib.c bstlib.c chrlib.c cmdlib.c conlib.c dcllib.c drwlib.c \
       enulib.c fillib.c fltlib.c hshlib.c intlib.c itflib.c kbdlib.c lstlib.c pollib.c prclib.c \
       prglib.c reflib.c rfllib.c sctlib.c setlib.c soclib.c strlib.c <b>suplib.c</b> timlib.c typlib.c ut8lib.c
</pre><p>
  and object files. Adding the <tt>sup_rtl</tt> object file results in:
</p><pre class="indent">
ROBJ = arr_rtl.o bln_rtl.o bst_rtl.o chr_rtl.o cmd_rtl.o con_rtl.o dir_rtl.o drw_rtl.o fil_rtl.o \
       flt_rtl.o hsh_rtl.o int_rtl.o set_rtl.o soc_rtl.o str_rtl.o <b>sup_rtl.o</b> tim_rtl.o ut8_rtl.o \
       heaputl.o striutl.o
</pre><p>
  Adding the <tt>"sup_rtl"</tt> source file results in:
</p><pre class="indent">
RSRC = arr_rtl.c bln_rtl.c bst_rtl.c chr_rtl.c cmd_rtl.c con_rtl.c dir_rtl.c drw_rtl.c fil_rtl.c \
       flt_rtl.c hsh_rtl.c int_rtl.c set_rtl.c soc_rtl.c str_rtl.c <b>sup_rtl.c</b> tim_rtl.c ut8_rtl.c \
       heaputl.c striutl.c
</pre><p>
  The external library <tt>"superlib"</tt> itself is added with:
</p><pre class="indent">
SYSTEM_LIBS = -lm <b>superlib.a</b>
</pre><p>
  The interpreter must be compiled, so the changes can take effect.
  To actually call the new function it must be introduced in a Seed7
  library. This is done with the library <tt><span class="lib">"super.s7i"</span></tt>:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="#types_proc">proc</a>: doWurx1 (<span class="keywd">in</span> <a class="type" href="#types_string">string</a>: name) <span class="keywd">is</span> <span class="keywd">action</span> <span class="stri">"SUP_DO_WURX"</span>;
</pre><p></p>

<a name="ffi_C_types_used_by_the_implementation"><h3>14.1 C types used by the implementation</h3></a>
<p>
  Several Seed7 types correspond to simple C types, which are
  defined in <tt><span class="lib">"common.h"</span></tt>:
</p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>Seed7 type</th>       <th>C type</th>     <th>Comment</th></tr>
    <tr><td><tt><a class="type" href="#types_boolean">boolean</a></tt></td>          <td><a name="ffi_booltype">booltype</a></td>   <td>int</td></tr>
    <tr><td><tt><a class="type" href="#types_integer">integer</a></tt></td>          <td><a name="ffi_inttype">inttype</a></td>    <td>32- or 64-bit signed int</td></tr>
    <tr><td><tt><a class="type" href="#types_float">float</a></tt></td>            <td><a name="ffi_floattype">floattype</a></td>  <td>float (or double)</td></tr>
    <tr><td><tt><a class="type" href="#types_char">char</a></tt></td>             <td><a name="ffi_chartype">chartype</a></td>   <td>32-bit unsigned int</td></tr>
    <tr><td><tt><span class="type">clib_file</span></tt></td>        <td><a name="ffi_filetype">filetype</a></td>   <td>FILE *</td></tr>
    <tr><td><tt><span class="type">PRIMITIVE_SOCKET</span></tt></td> <td><a name="ffi_sockettype">sockettype</a></td> <td>int or unsigned int</td></tr>
</table><p>
  Other Seed7 types correspond to C pointers, which point to a struct.
  Some of this structs are used in all situations: In the interpreter
  and in the compiler and under different operation systems and with
  different runtime libraries. This invariant structs are defined
  in <tt><span class="lib">"common.h"</span></tt> and in <tt><span class="lib">"data.h"</span></tt>:
</p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>Seed7 type</th>   <th>C type</th>      <th>C struct</th>             <th>Comment</th></tr>
    <tr><td><tt><a class="type" href="#types_string">string</a></tt></td>       <td><a name="ffi_stritype">stritype</a></td>    <td>struct stristruct</td>    <td>UTF-32 encoded, can contain null chars</td></tr>
    <tr><td><tt><a class="type" href="#types_set">set</a></tt></td>          <td><a name="ffi_settype">settype</a></td>     <td>struct setstruct</td>     <td>&nbsp;</td></tr>
    <tr><td><tt><span class="type">bstring</span></tt></td>      <td><a name="ffi_bstritype">bstritype</a></td>   <td>struct bstristruct</td>   <td>Byte sequence, can contain null bytes</td></tr>
    <tr><td><tt><a class="type" href="#types_reference">reference</a></tt></td>    <td><a name="ffi_objecttype">objecttype</a></td>  <td>struct objectstruct</td>  <td>Interpreter type for Seed7 objects</td></tr>
    <tr><td><tt><a class="type" href="#types_ref_list">ref_list</a></tt></td>     <td><a name="ffi_listtype">listtype</a></td>    <td>struct liststruct</td>    <td>Interpreter type for Seed7 object lists</td></tr>
</table><p>
  Other Seed7 types also correspond to struct pointers, but the structs
  are different in interpreted and compiled Seed7 programs. The structs
  for interpreted programs are defined in <tt><span class="lib">"data.h"</span></tt> and the structs for
  compiled programs are defined in <tt><span class="lib">"data_rtl.h"</span></tt>:
</p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>Seed7 type</th>  <th>C type (interpreted)</th>  <th>C struct (interpreted)</th>  <th>C type (compiled)</th>  <th>C struct (compiled)</th></tr>
    <tr><td><tt><a class="type" href="#types_array">array</a></tt></td>       <td><a name="ffi_arraytype">arraytype</a></td>             <td>struct stristruct</td>       <td>rtlArraytype</td>       <td>struct rtlArraystruct</td></tr>
    <tr><td><tt><a class="type" href="#types_hash">hash</a></tt></td>        <td><a name="ffi_hashtype">hashtype</a></td>              <td>struct hashstruct</td>       <td>rtlHashtype</td>        <td>struct rtlHashstruct</td></tr>
    <tr><td><tt><a class="type" href="#types_struct">struct</a></tt></td>      <td><a name="ffi_structtype">structtype</a></td>            <td>struct structstruct</td>     <td>rtlStructtype</td>      <td>struct rtlStructstruct</td></tr>
</table><p>
  Because interpreter and compiler use different structs the
  functions from e.g. <tt><span class="lib">"arrlib.c"</span></tt> cannot use functions
  from <tt><span class="lib">"arr_rtl.c"</span></tt>.
</p><p>
  Some Seed7 types depend on the operating system or runtime
  library used:
</p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>Seed7 type</th>       <th>C type</th>      <th>Defined as</th>                        <th>Sourcefile</th>  <th>Comment</th></tr>
    <tr><td rowspan="2"><tt><a class="type" href="#types_bigInteger">bigInteger</a></tt></td>       <td><a name="ffi_biginttype">biginttype</a></td>  <td>struct bigintstruct *</td>             <td>big_rtl.c</td>   <td>The built-in bigInteger library</td></tr>
    <tr><td>biginttype</td>  <td>mpz_ptr</td>                           <td>big_gmp.c</td>   <td>The GNU Multiple Precision Arithmetic Library</td></tr>
    <tr><td rowspan="2"><tt><span class="type">pollData</span></tt></td>         <td><a name="ffi_polltype">polltype</a></td>    <td>struct select_based_pollstruct *</td>  <td>pol_sel.c</td>   <td>Functions cast it to implementation dependent struct</td></tr>
    <tr><td>polltype</td>    <td>struct poll_based_pollstruct *</td>    <td>pol_unx.c</td>   <td>Functions cast it to implementation dependent struct</td></tr>
    <tr><td rowspan="2"><tt><span class="type">PRIMITIVE_WINDOW</span></tt></td> <td><a name="ffi_wintype">wintype</a></td>     <td>struct x11_winstruct *</td>            <td>drw_x11.c</td>   <td>Functions cast from winstruct * to x11_winstruct *</td></tr>
    <tr><td>wintype</td>     <td>struct win_winstruct *</td>            <td>drw_win.c</td>   <td>Functions cast from winstruct * to win_winstruct *</td></tr>
</table><p>
  There are also C types without corresponding Seed7 type. They are
  defined in <tt><span class="lib">"common.h"</span></tt>:
</p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>C type</th>       <th>C definition</th>      <th>Comment</th></tr>
    <tr><td><tt><a class="type" name="ffi_cstritype">cstritype</a></tt></td>    <td>char *</td>            <td>String type of the C compiler</td></tr>
    <tr><td><tt><a class="type" name="ffi_ustritype">ustritype</a></tt></td>    <td>unsigned char *</td>   <td>Helpful for unsigned comparisons</td></tr>
    <tr><td rowspan="2"><tt><a class="type" name="ffi_os_stritype">os_stritype</a></tt></td>  <td>char *</td>            <td>When the OS uses UTF-8 chars</td></tr>
    <tr><td>wchar_t *</td>         <td>When the OS uses UTF-16 chars</td></tr>
    <tr><td><tt><a class="type" name="ffi_uinttype">uinttype</a></tt></td>     <td>unsigned inttype</td>  <td>Unsigned integer type with the size of <a class="type" href="#ffi_inttype">inttype</a></td></tr>
    <tr><td rowspan="2"><tt><a class="type" name="ffi_memsizetype">memsizetype</a></tt></td>  <td>uint32type</td>        <td>When C uses 32-bit pointers</td></tr>
    <tr><td>uint64type</td>        <td>When C uses 64-bit pointers</td></tr>
</table><p></p>

<a name="ffi_String_and_path_conversions"><h3>14.2 String and path conversions</h3></a>
<p>
  Seed7 strings are UTF-32 encoded and C strings are zero terminated
  byte sequences. To convert between the different representations,
  <tt><span class="lib">"striutl.h"</span></tt> defines conversion functions like <tt><a class="func" href="#ffi_cp_to_cstri8">cp_to_cstri8</a></tt>,
  <tt><a class="func" href="#ffi_stri_to_bstri">stri_to_bstri</a></tt>, <tt><a class="func" href="#ffi_stri_to_bstri8">stri_to_bstri8</a></tt>, <tt><a class="func" href="#ffi_cstri_to_stri">cstri_to_stri</a></tt>, <tt><a class="func" href="#ffi_cstri8_to_stri">cstri8_to_stri</a></tt>
  and <tt><a class="func" href="#ffi_cstri8_or_cstri_to_stri">cstri8_or_cstri_to_stri</a></tt>. Operating systems disagree in their
  Unicode encoding (UTF-8 or UTF-16). To cope with this, <tt><span class="lib">"striutl.h"</span></tt>
  defines the type <tt><a class="type" href="#ffi_os_stritype">os_stritype</a></tt> and the functions <tt><a class="func" href="#ffi_conv_from_os_stri">conv_from_os_stri</a></tt>,
  <tt><a class="func" href="#ffi_stri_to_os_stri">stri_to_os_stri</a></tt> and <tt><a class="func" href="#ffi_os_stri_to_stri">os_stri_to_stri</a></tt>. The different concepts to
  represent a file path (path delimiter and drive letter) are handled
  with <tt><a class="func" href="#ffi_cp_to_os_path">cp_to_os_path</a></tt> and <tt><a class="func" href="#ffi_cp_from_os_path">cp_from_os_path</a></tt>.
</p><div><table width="100%" border="1" cellspacing="0" cellpadding="3">
<tr><td style="font-size: 22px; font-weight: bold; background-color: #C0C0FF" colspan="2">
  Function Summary</td></tr>

    <tr><td align="right" valign="top"><a class="type" href="#ffi_cstritype">cstritype</a></td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a class="link" href="#ffi_cp_to_cstri8">cp_to_cstri8</a></b> (<a class="type" href="#ffi_stritype">const_stritype</a> stri)</td></tr>
      <tr><td width="30"></td><td>Create an UTF-8 encoded C string from a Seed7 UTF-32 string.</td></tr></table></td></tr>

    <tr><td align="right" valign="top"><a class="type" href="#ffi_bstritype">bstritype</a></td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a class="link" href="#ffi_stri_to_bstri">stri_to_bstri</a></b> (<a class="type" href="#ffi_stritype">const_stritype</a> stri)</td></tr>
      <tr><td width="30"></td><td>Create an ISO-8859-1 encoded bstring from a Seed7 UTF-32 string.</td></tr></table></td></tr>

    <tr><td align="right" valign="top"><a class="type" href="#ffi_bstritype">bstritype</a></td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a class="link" href="#ffi_stri_to_bstri8">stri_to_bstri8</a></b> (<a class="type" href="#ffi_stritype">const_stritype</a> stri)</td></tr>
      <tr><td width="30"></td><td>Create an UTF-8 encoded bstring from a Seed7 UTF-32 string.</td></tr></table></td></tr>

    <tr><td align="right" valign="top"><a class="type" href="#ffi_stritype">stritype</a></td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a class="link" href="#ffi_cstri_to_stri">cstri_to_stri</a></b> (<a class="type" href="#ffi_cstritype">const_cstritype</a> cstri)</td></tr>
      <tr><td width="30"></td><td>Copy an ISO-8859-1 (Latin-1) encoded C string to a Seed7 string.</td></tr></table></td></tr>

    <tr><td align="right" valign="top"><a class="type" href="#ffi_stritype">stritype</a></td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a class="link" href="#ffi_cstri8_to_stri">cstri8_to_stri</a></b> (<a class="type" href="#ffi_cstritype">const_cstritype</a> cstri)</td></tr>
      <tr><td width="30"></td><td>Copy an UTF-8 encoded C string to a Seed7 string.</td></tr></table></td></tr>

    <tr><td align="right" valign="top"><a class="type" href="#ffi_stritype">stritype</a></td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a class="link" href="#ffi_cstri8_or_cstri_to_stri">cstri8_or_cstri_to_stri</a></b> (<a class="type" href="#ffi_cstritype">const_cstritype</a> cstri)</td></tr>
      <tr><td width="30"></td><td>Copy an UTF-8 or ISO-8859-1 encoded C string to a Seed7 string.</td></tr></table></td></tr>

    <tr><td align="right" valign="top"><a class="type" href="#ffi_stritype">stritype</a></td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a class="link" href="#ffi_conv_from_os_stri">conv_from_os_stri</a></b> (const <a class="type" href="#ffi_os_stritype">const_os_stritype</a> os_stri, <a class="type" href="#ffi_memsizetype">memsizetype</a> length)</td></tr>
      <tr><td width="30"></td><td>Convert an os_stritype string with length to a Seed7 UTF-32 string.</td></tr></table></td></tr>

    <tr><td align="right" valign="top"><a class="type" href="#ffi_os_stritype">os_stritype</a></td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a class="link" href="#ffi_stri_to_os_stri">stri_to_os_stri</a></b> (<a class="type" href="#ffi_stritype">const_stritype</a> stri, <span class="type">errinfotype</span> *err_info)</td></tr>
      <tr><td width="30"></td><td>Convert a Seed7 UTF-32 string to a null terminated os_stritype string.</td></tr></table></td></tr>

    <tr><td align="right" valign="top"><a class="type" href="#ffi_stritype">stritype</a></td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a class="link" href="#ffi_os_stri_to_stri">os_stri_to_stri</a></b> (<a class="type" href="#ffi_os_stritype">const_os_stritype</a> os_stri, <span class="type">errinfotype</span> *err_info)</td></tr>
      <tr><td width="30"></td><td>Convert a null terminated os_stritype string to a Seed7 UTF-32 string.</td></tr></table></td></tr>

    <tr><td align="right" valign="top"><a class="type" href="#ffi_os_stritype">os_stritype</a></td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a class="link" href="#ffi_cp_to_os_path">cp_to_os_path</a></b> (<a class="type" href="#ffi_stritype">const_stritype</a> std_path, <span class="type">int</span> *path_info, <span class="type">errinfotype</span> *err_info)</td></tr>
      <tr><td width="30"></td><td>Convert a Seed7 standard path to a path used by system calls.</td></tr></table></td></tr>

    <tr><td align="right" valign="top"><a class="type" href="#ffi_stritype">stritype</a></td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a class="link" href="#ffi_cp_from_os_path">cp_from_os_path</a></b> (<a class="type" href="#ffi_os_stritype">const_os_stritype</a> os_path, <span class="type">errinfotype</span> *err_info)</td></tr>
      <tr><td width="30"></td><td>Convert a path returned by a system call to a Seed7 standard path.</td></tr></table></td></tr>
</table></div><br /><div><p><table width="100%" border="1" cellspacing="0" cellpadding="2"><tr>
<td style="font-size: 22px; font-weight: bold; background-color: #C0C0FF">
  Function Detail</td></tr></table></p>

  <div><a name="ffi_cp_to_cstri8"><h3>cp_to_cstri8</h3></a>
<p>
    <a class="type" href="#ffi_cstritype">cstritype</a> <b>cp_to_cstri8</b> (<a class="type" href="#ffi_stritype">const_stritype</a> stri)</p><dl><dd>
<p>
      Create an UTF-8 encoded C string from a Seed7 UTF-32 string.
      The memory for the zero byte terminated C string is allocated.
      The C string result must be freed with the macro free_cstri().
      This function is intended to create temporary strings, that
      are used as parameters. To get good performance the allocated
      memory for the C string is oversized. No special action is
      done, when the UTF-32 string contains a null character.
</p></dd>
      <dd><dl><dt><b>Parameters:</b></dt>
        <dd><tt>stri</tt> - Seed7 UTF-32 string to be converted.</dd>
</dl></dd>
      <dd><dl><dt><b>Returns:</b></dt>
        <dd>an UTF-8 encoded null terminated C string or NULL, when the memory allocation failed.</dd></dl></dd>
</dl></div>
<hr />
  <div><a name="ffi_stri_to_bstri"><h3>stri_to_bstri</h3></a>
<p>
    <a class="type" href="#ffi_bstritype">bstritype</a> <b>stri_to_bstri</b> (<a class="type" href="#ffi_stritype">const_stritype</a> stri)</p><dl><dd>
<p>
      Create an ISO-8859-1 encoded bstring from a Seed7 UTF-32 string.
      The memory for the bstring is allocated. No zero byte is added
      to the end of the bstring. No special action is done, when the
      UTF-32 string contains a null character. When the UTF-32 string
      contains a character beyond ISO-8859-1 the bstring will end with
      the last ISO-8859-1 character. When the first UTF-32 character
      is beyond ISO-8859-1 an empty bstring is returned. The conversion
      was successful, when the bstring has the same size as the UTF-32
      string.
</p></dd>
      <dd><dl><dt><b>Parameters:</b></dt>
        <dd><tt>stri</tt> - Seed7 UTF-32 string to be converted.</dd>
</dl></dd>
      <dd><dl><dt><b>Returns:</b></dt>
        <dd>an ISO-8859-1 encoded bstring or
        NULL, when the memory allocation failed.</dd></dl></dd>
</dl></div>
<hr />
  <div><a name="ffi_stri_to_bstri8"><h3>stri_to_bstri8</h3></a>
<p>
    <a class="type" href="#ffi_bstritype">bstritype</a> <b>stri_to_bstri8</b> (<a class="type" href="#ffi_stritype">const_stritype</a> stri)</p><dl><dd>
<p>
      Create an UTF-8 encoded bstring from a Seed7 UTF-32 string.
      The memory for the bstring is allocated. No zero byte is added
      to the end of the bstring. No special action is done, when
      the original string contains a null character.
</p></dd>
      <dd><dl><dt><b>Parameters:</b></dt>
        <dd><tt>stri</tt> - Seed7 UTF-32 string to be converted.</dd>
</dl></dd>
      <dd><dl><dt><b>Returns:</b></dt>
        <dd>an UTF-8 encoded bstring or
        NULL, when the memory allocation failed.</dd></dl></dd>
</dl></div>
<hr />
  <div><a name="ffi_cstri_to_stri"><h3>cstri_to_stri</h3></a>
<p>
    <a class="type" href="#ffi_stritype">stritype</a> <b>cstri_to_stri</b> (<a class="type" href="#ffi_cstritype">const_cstritype</a> cstri)</p><dl><dd>
<p>
      Copy an ISO-8859-1 (Latin-1) encoded C string to a Seed7 string.
      The memory for the UTF-32 encoded Seed7 string is allocated.
</p></dd>
      <dd><dl><dt><b>Parameters:</b></dt>
        <dd><tt>cstri</tt> - null terminated ISO-8859-1 encoded C string.</dd>
</dl></dd>
      <dd><dl><dt><b>Returns:</b></dt>
        <dd>an UTF-32 encoded Seed7 string or
        NULL, when the memory allocation failed.</dd></dl></dd>
</dl></div>
<hr />
  <div><a name="ffi_cstri8_to_stri"><h3>cstri8_to_stri</h3></a>
<p>
    <a class="type" href="#ffi_stritype">stritype</a> <b>cstri8_to_stri</b> (<a class="type" href="#ffi_cstritype">const_cstritype</a> cstri)</p><dl><dd>
<p>
      Copy an UTF-8 encoded C string to a Seed7 string.
      The memory for the UTF-32 encoded Seed7 string is allocated.
</p></dd>
      <dd><dl><dt><b>Parameters:</b></dt>
        <dd><tt>cstri</tt> - null terminated UTF-8 encoded C string.</dd>
</dl></dd>
      <dd><dl><dt><b>Returns:</b></dt>
        <dd>an UTF-32 encoded Seed7 string or
        NULL, when the memory allocation failed or when
        illegal UTF-8 encodings are used.</dd></dl></dd>
</dl></div>
<hr />
  <div><a name="ffi_cstri8_or_cstri_to_stri"><h3>cstri8_or_cstri_to_stri</h3></a>
<p>
    <a class="type" href="#ffi_stritype">stritype</a> <b>cstri8_or_cstri_to_stri</b> (<a class="type" href="#ffi_cstritype">const_cstritype</a> cstri)</p><dl><dd>
<p>
      Copy an UTF-8 or ISO-8859-1 encoded C string to a Seed7 string.
      The memory for the UTF-32 encoded Seed7 string is allocated.
</p></dd>
      <dd><dl><dt><b>Parameters:</b></dt>
        <dd><tt>cstri</tt> - null terminated UTF-8 or ISO-8859-1 encoded C string.</dd>
</dl></dd>
      <dd><dl><dt><b>Returns:</b></dt>
        <dd>an UTF-32 encoded Seed7 string or
        NULL, when the memory allocation failed.</dd></dl></dd>
</dl></div>
<hr />
  <div><a name="ffi_conv_from_os_stri"><h3>conv_from_os_stri</h3></a>
<p>
    <a class="type" href="#ffi_stritype">stritype</a> <b>conv_from_os_stri</b> (const <a class="type" href="#ffi_os_stritype">const_os_stritype</a> os_stri,
        <a class="type" href="#ffi_memsizetype">memsizetype</a> length)</p><dl><dd>
<p>
      Convert an os_stritype string with length to a Seed7 UTF-32 string.
      Many system calls return os_stritype data with length. System calls
      are defined in "version.h" and "os_decls.h". They are prefixed
      with os_ and use strings of the type os_stritype. Depending on the
      operating system os_stritype can describe byte or wide char strings.
      The encoding can be Latin-1, UTF-8, UTF-16 or it can use a code page.
</p></dd>
      <dd><dl><dt><b>Parameters:</b></dt>
        <dd><tt>os_stri</tt> - possibly binary string (may contain null characters).</dd>
        <dd><tt>length</tt> - length of os_stri.</dd>
</dl></dd>
      <dd><dl><dt><b>Returns:</b></dt>
        <dd>a Seed7 UTF-32 string or
        NULL, when an error occurred.</dd></dl></dd>
</dl></div>
<hr />
  <div><a name="ffi_stri_to_os_stri"><h3>stri_to_os_stri</h3></a>
<p>
    <a class="type" href="#ffi_os_stritype">os_stritype</a> <b>stri_to_os_stri</b> (<a class="type" href="#ffi_stritype">const_stritype</a> stri, <span class="type">errinfotype</span> *err_info)</p><dl><dd>
<p>
      Convert a Seed7 UTF-32 string to a null terminated os_stritype string.
      The memory for the null terminated os_stritype string is allocated.
      The os_stritype result must be freed with the macro os_stri_free().
      Many system calls have parameters with null terminated os_stritype
      strings. System calls are defined in "version.h" and "os_decls.h".
      They are prefixed with os_ and use strings of the type os_stritype.
      Depending on the operating system os_stritype can describe byte or
      wide char strings. The encoding can be Latin-1, UTF-8, UTF-16 or
      it can use a code page.
</p></dd>
      <dd><dl><dt><b>Parameters:</b></dt>
        <dd><tt>stri</tt> - Seed7 UTF-32 string to be converted.</dd>
        <dd><tt>err_info</tt> - unchanged when the function succceeds or
                   <a class="exception" href="#errors_MEMORY_ERROR">MEMORY_ERROR</a> when the memory allocation failed or
                   <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> when the conversion failed.</dd>
</dl></dd>
      <dd><dl><dt><b>Returns:</b></dt>
        <dd>a null terminated os_stritype value used by system calls or
        NULL, when an error occurred.</dd></dl></dd>
</dl></div>
<hr />
  <div><a name="ffi_os_stri_to_stri"><h3>os_stri_to_stri</h3></a>
<p>
    <a class="type" href="#ffi_stritype">stritype</a> <b>os_stri_to_stri</b> (<a class="type" href="#ffi_os_stritype">const_os_stritype</a> os_stri, <span class="type">errinfotype</span> *err_info)</p><dl><dd>
<p>
      Convert a null terminated os_stritype string to a Seed7 UTF-32 string.
      Many system calls return null terminated os_stritype strings. System
      calls are defined in "version.h" and "os_decls.h". They are prefixed
      with os_ and use strings of the type os_stritype. Depending on the
      operating system os_stritype can describe byte or wide char strings.
      The encoding can be Latin-1, UTF-8, UTF-16 or it can use a code page.
</p></dd>
      <dd><dl><dt><b>Parameters:</b></dt>
        <dd><tt>os_stri</tt> - null terminated os_stritype string to be converted.</dd>
        <dd><tt>err_info</tt> - unchanged when the function succceeds or
                   <a class="exception" href="#errors_MEMORY_ERROR">MEMORY_ERROR</a> when the memory allocation failed.</dd>
</dl></dd>
      <dd><dl><dt><b>Returns:</b></dt>
        <dd>a Seed7 UTF-32 string or
        NULL, when an error occurred.</dd></dl></dd>
</dl></div>
<hr />
  <div><a name="ffi_cp_to_os_path"><h3>cp_to_os_path</h3></a>
<p>
    <a class="type" href="#ffi_os_stritype">os_stritype</a> <b>cp_to_os_path</b> (<a class="type" href="#ffi_stritype">const_stritype</a> std_path, <span class="type">int</span> *path_info, <span class="type">errinfotype</span> *err_info)</p><dl><dd>
<p>
      Convert a Seed7 standard path to a path used by system calls.
      The memory for the null terminated os_stritype path is allocated.
      The os_stritype result must be freed with the macro os_stri_free().
      System calls are defined in "version.h" and "os_decls.h". They are
      prefixed with os_ and use system paths of the type os_stritype.
      Depending on the operating system os_stritype can describe byte or
      wide char strings. The encoding can be Latin-1, UTF-8, UTF-16 or
      it can use a code page. Beyond the conversion to os_stritype a
      mapping to drive letters might take place on some operating systems.
</p></dd>
    <dd><dl><dt><b>Parameters:</b></dt>
        <dd><tt>std_path</tt> - UTF-32 encoded Seed7 standard path to be converted.</dd>
        <dd><tt>path_info</tt> - unchanged when the function succceeds or
                    PATH_IS_EMULATED_ROOT when the path is "/".
                    PATH_NOT_MAPPED when the path cannot be mapped.</dd>
        <dd><tt>err_info</tt> - unchanged when the function succceeds or
                   <a class="exception" href="#errors_MEMORY_ERROR">MEMORY_ERROR</a> when the memory allocation failed or
                   <a class="exception" href="#errors_RANGE_ERROR">RANGE_ERROR</a> when the path is not a standard path.</dd>
</dl></dd>
      <dd><dl><dt><b>Returns:</b></dt>
        <dd>a null terminated os_stritype path used by system calls or
        NULL, when an error occurred.</dd></dl></dd>
</dl></div>
<hr />
  <div><a name="ffi_cp_from_os_path"><h3>cp_from_os_path</h3></a>
<p>
    <a class="type" href="#ffi_stritype">stritype</a> <b>cp_from_os_path</b> (<a class="type" href="#ffi_os_stritype">const_os_stritype</a> os_path, <span class="type">errinfotype</span> *err_info)</p><dl><dd>
<p>
      Convert a path returned by a system call to a Seed7 standard path.
      System calls are defined in "version.h" and "os_decls.h". They are
      prefixed with os_ and use system paths of the type os_stritype.
      Depending on the operating system os_stritype can describe byte or
      wide char strings. The encoding can be Latin-1, UTF-8, UTF-16 or
      it can use a code page. Beyond the conversion from os_stritype a
      mapping from drive letters might take place on some operating
      systems.
</p></dd>
      <dd><dl><dt><b>Parameters:</b></dt>
        <dd><tt>os_path</tt> - null terminated os_stritype path to be converted.</dd>
        <dd><tt>err_info</tt> - unchanged when the function succceeds or
                   <a class="exception" href="#errors_MEMORY_ERROR">MEMORY_ERROR</a> when the memory allocation failed.</dd>
</dl></dd>
      <dd><dl><dt><b>Returns:</b></dt>
        <dd>an UTF-32 encoded Seed7 standard path or
        NULL, when the memory allocation failed.</dd></dl></dd>
</dl></div>
</div>

<a name="ffi_Macros_to_access_the_action_parameters"><h3>14.3 Macros to access the action parameters</h3></a>
<p>
  A primitive action function has one parameter named <tt>'arguments'</tt>. The
  <tt>'arguments'</tt> parameter has the type <tt><a class="type" href="#ffi_listtype">listtype</a></tt> and contains a list of
  objects. Macros like <tt><a class="func" href="#ffi_arg_1">arg_1</a></tt>, <tt><a class="func" href="#ffi_arg_2">arg_2</a></tt>, <tt><a class="func" href="#ffi_arg_3">arg_3</a></tt>, etc. get a specific
  object from the <tt>'arguments'</tt>.
</p><div><table width="100%" border="1" cellspacing="0" cellpadding="3">
<tr><td style="font-size: 22px; font-weight: bold; background-color: #C0C0FF" colspan="2">
  Functions (macros) to get a Seed7 object from a list</td></tr>

    <tr><td align="right" valign="top"><a class="type" href="#ffi_objecttype">objecttype</a></td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_arg_1">arg_1</a></b> (<a class="type" href="#ffi_listtype">listtype</a> arguments)</td></tr>
      <tr><td width="30"></td><td>Take the first object from the list.</td></tr></table></td></tr>

    <tr><td align="right" valign="top"><a class="type" href="#ffi_objecttype">objecttype</a></td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_arg_2">arg_2</a></b> (<a class="type" href="#ffi_listtype">listtype</a> arguments)</td></tr>
      <tr><td width="30"></td><td>Take the second object from the list.</td></tr></table></td></tr>

    <tr><td align="right" valign="top"><a class="type" href="#ffi_objecttype">objecttype</a></td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_arg_3">arg_3</a></b> (<a class="type" href="#ffi_listtype">listtype</a> arguments)</td></tr>
      <tr><td width="30"></td><td>Take the third object from the list.</td></tr></table></td></tr>

    <tr><td align="right" valign="top"><b>. . .</b></td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b>. . .</b></td></tr>
      </table></td></tr>

    <tr><td align="right" valign="top"><a class="type" href="#ffi_objecttype">objecttype</a></td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_arg_12">arg_12</a></b> (<a class="type" href="#ffi_listtype">listtype</a> arguments)</td></tr>
      <tr><td width="30"></td><td>Take the twelveth object from the list.</td></tr></table></td></tr>
</table></div><p>
  An object value contains a specific C implementation type. Macros like
  <tt><a class="func" href="#ffi_isit_char">isit_char</a></tt> and <tt><a class="func" href="#ffi_isit_set">isit_set</a></tt> check if an object has the requested type.
  When the object has not the requested C implementation type and error
  message is written.
</p><div><table width="100%" border="1" cellspacing="0" cellpadding="3">
<tr><td style="font-size: 22px; font-weight: bold; background-color: #C0C0FF" colspan="2">
  Functions (macros) to check the C type of Seed7 objects</td></tr>

    <tr><td align="right" valign="top">void</td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_isit_array">isit_array</a></b> (<a class="type" href="#ffi_objecttype">objecttype</a> arg)</td></tr>
      <tr><td width="30"></td><td>Check if the object type is <a class="type" href="#ffi_arraytype">arraytype</a>.</td></tr></table></td></tr>

    <tr><td align="right" valign="top">void</td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_isit_bigint">isit_bigint</a></b> (<a class="type" href="#ffi_objecttype">objecttype</a> arg)</td></tr>
      <tr><td width="30"></td><td>Check if the object type is <a class="type" href="#ffi_biginttype">biginttype</a>.</td></tr></table></td></tr>

    <tr><td align="right" valign="top">void</td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_isit_bool">isit_bool</a></b> (<a class="type" href="#ffi_objecttype">objecttype</a> arg)</td></tr>
      <tr><td width="30"></td><td>Check if the object type is <a class="type" href="#ffi_booltype">booltype</a>.</td></tr></table></td></tr>

    <tr><td align="right" valign="top">void</td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_isit_bstri">isit_bstri</a></b> (<a class="type" href="#ffi_objecttype">objecttype</a> arg)</td></tr>
      <tr><td width="30"></td><td>Check if the object type is <a class="type" href="#ffi_bstritype">bstritype</a>.</td></tr></table></td></tr>

    <tr><td align="right" valign="top">void</td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_isit_char">isit_char</a></b> (<a class="type" href="#ffi_objecttype">objecttype</a> arg)</td></tr>
      <tr><td width="30"></td><td>Check if the object type is <a class="type" href="#ffi_chartype">chartype</a>.</td></tr></table></td></tr>

    <tr><td align="right" valign="top">void</td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_isit_file">isit_file</a></b> (<a class="type" href="#ffi_objecttype">objecttype</a> arg)</td></tr>
      <tr><td width="30"></td><td>Check if the object type is <a class="type" href="#ffi_filetype">filetype</a>.</td></tr></table></td></tr>

    <tr><td align="right" valign="top">void</td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_isit_float">isit_float</a></b> (<a class="type" href="#ffi_objecttype">objecttype</a> arg)</td></tr>
      <tr><td width="30"></td><td>Check if the object type is <a class="type" href="#ffi_floattype">floattype</a>.</td></tr></table></td></tr>

    <tr><td align="right" valign="top">void</td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_isit_hash">isit_hash</a></b> (<a class="type" href="#ffi_objecttype">objecttype</a> arg)</td></tr>
      <tr><td width="30"></td><td>Check if the object type is <a class="type" href="#ffi_hashtype">hashtype</a>.</td></tr></table></td></tr>

    <tr><td align="right" valign="top">void</td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_isit_int">isit_int</a></b> (<a class="type" href="#ffi_objecttype">objecttype</a> arg)</td></tr>
      <tr><td width="30"></td><td>Check if the object type is <a class="type" href="#ffi_inttype">inttype</a>.</td></tr></table></td></tr>

    <tr><td align="right" valign="top">void</td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_isit_poll">isit_poll</a></b> (<a class="type" href="#ffi_objecttype">objecttype</a> arg)</td></tr>
      <tr><td width="30"></td><td>Check if the object type is <a class="type" href="#ffi_polltype">polltype</a>.</td></tr></table></td></tr>

    <tr><td align="right" valign="top">void</td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_isit_set">isit_set</a></b> (<a class="type" href="#ffi_objecttype">objecttype</a> arg)</td></tr>
      <tr><td width="30"></td><td>Check if the object type is <a class="type" href="#ffi_settype">settype</a>.</td></tr></table></td></tr>

    <tr><td align="right" valign="top">void</td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_isit_socket">isit_socket</a></b> (<a class="type" href="#ffi_objecttype">objecttype</a> arg)</td></tr>
      <tr><td width="30"></td><td>Check if the object type is <a class="type" href="#ffi_sockettype">sockettype</a>.</td></tr></table></td></tr>

    <tr><td align="right" valign="top">void</td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_isit_stri">isit_stri</a></b> (<a class="type" href="#ffi_objecttype">objecttype</a> arg)</td></tr>
      <tr><td width="30"></td><td>Check if the object type is <a class="type" href="#ffi_stritype">stritype</a>.</td></tr></table></td></tr>

    <tr><td align="right" valign="top">void</td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_isit_struct">isit_struct</a></b> (<a class="type" href="#ffi_objecttype">objecttype</a> arg)</td></tr>
      <tr><td width="30"></td><td>Check if the object type is <a class="type" href="#ffi_structtype">structtype</a>.</td></tr></table></td></tr>

    <tr><td align="right" valign="top">void</td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_isit_win">isit_win</a></b> (<a class="type" href="#ffi_objecttype">objecttype</a> arg)</td></tr>
      <tr><td width="30"></td><td>Check if the object type is <a class="type" href="#ffi_wintype">wintype</a>.</td></tr></table></td></tr>
</table></div><p>
  Macros like <tt><a class="func" href="#ffi_take_bool">take_bool</a></tt> and <tt><a class="func" href="#ffi_take_file">take_file</a></tt> return a value with the requested
  C implementation type.
</p><div><table width="100%" border="1" cellspacing="0" cellpadding="3">
<tr><td style="font-size: 22px; font-weight: bold; background-color: #C0C0FF" colspan="2">
  Functions (macros) to get the C values of Seed7 objects</td></tr>

    <tr><td align="right" valign="top"><a class="type" href="#ffi_arraytype">arraytype</a></td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_take_array">take_array</a></b> (<a class="type" href="#ffi_objecttype">objecttype</a> arg)</td></tr>
      <tr><td width="30"></td><td>Take the array value from an object.</td></tr></table></td></tr>

    <tr><td align="right" valign="top"><a class="type" href="#ffi_biginttype">biginttype</a></td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_take_bigint">take_bigint</a></b> (<a class="type" href="#ffi_objecttype">objecttype</a> arg)</td></tr>
      <tr><td width="30"></td><td>Take the bigInteger value from an object.</td></tr></table></td></tr>

    <tr><td align="right" valign="top"><a class="type" href="#ffi_booltype">booltype</a></td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_take_bool">take_bool</a></b> (<a class="type" href="#ffi_objecttype">objecttype</a> arg)</td></tr>
      <tr><td width="30"></td><td>Take the boolean value from an object.</td></tr></table></td></tr>

    <tr><td align="right" valign="top"><a class="type" href="#ffi_bstritype">bstritype</a></td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_take_bstri">take_bstri</a></b> (<a class="type" href="#ffi_objecttype">objecttype</a> arg)</td></tr>
      <tr><td width="30"></td><td>Take the bstring value from an object.</td></tr></table></td></tr>

    <tr><td align="right" valign="top"><a class="type" href="#ffi_chartype">chartype</a></td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_take_char">take_char</a></b> (<a class="type" href="#ffi_objecttype">objecttype</a> arg)</td></tr>
      <tr><td width="30"></td><td>Take the char value from an object.</td></tr></table></td></tr>

    <tr><td align="right" valign="top"><a class="type" href="#ffi_filetype">filetype</a></td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_take_file">take_file</a></b> (<a class="type" href="#ffi_objecttype">objecttype</a> arg)</td></tr>
      <tr><td width="30"></td><td>Take the file value from an object.</td></tr></table></td></tr>

    <tr><td align="right" valign="top"><a class="type" href="#ffi_floattype">floattype</a></td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_take_float">take_float</a></b> (<a class="type" href="#ffi_objecttype">objecttype</a> arg)</td></tr>
      <tr><td width="30"></td><td>Take the float value from an object.</td></tr></table></td></tr>

    <tr><td align="right" valign="top"><a class="type" href="#ffi_hashtype">hashtype</a></td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_take_hash">take_hash</a></b> (<a class="type" href="#ffi_objecttype">objecttype</a> arg)</td></tr>
      <tr><td width="30"></td><td>Take the hash table value from an object.</td></tr></table></td></tr>

    <tr><td align="right" valign="top"><a class="type" href="#ffi_inttype">inttype</a></td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_take_int">take_int</a></b> (<a class="type" href="#ffi_objecttype">objecttype</a> arg)</td></tr>
      <tr><td width="30"></td><td>Take the integer value from an object.</td></tr></table></td></tr>

    <tr><td align="right" valign="top"><a class="type" href="#ffi_polltype">polltype</a></td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_take_poll">take_poll</a></b> (<a class="type" href="#ffi_objecttype">objecttype</a> arg)</td></tr>
      <tr><td width="30"></td><td>Take the poll data value from an object.</td></tr></table></td></tr>

    <tr><td align="right" valign="top"><a class="type" href="#ffi_settype">settype</a></td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_take_set">take_set</a></b> (<a class="type" href="#ffi_objecttype">objecttype</a> arg)</td></tr>
      <tr><td width="30"></td><td>Take the set value from an object.</td></tr></table></td></tr>

    <tr><td align="right" valign="top"><a class="type" href="#ffi_sockettype">sockettype</a></td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_take_socket">take_socket</a></b> (<a class="type" href="#ffi_objecttype">objecttype</a> arg)</td></tr>
      <tr><td width="30"></td><td>Take the socket value from an object.</td></tr></table></td></tr>

    <tr><td align="right" valign="top"><a class="type" href="#ffi_stritype">stritype</a></td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_take_stri">take_stri</a></b> (<a class="type" href="#ffi_objecttype">objecttype</a> arg)</td></tr>
      <tr><td width="30"></td><td>Take the string value from an object.</td></tr></table></td></tr>

    <tr><td align="right" valign="top"><a class="type" href="#ffi_structtype">structtype</a></td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_take_struct">take_struct</a></b> (<a class="type" href="#ffi_objecttype">objecttype</a> arg)</td></tr>
      <tr><td width="30"></td><td>Take the struct value from an object.</td></tr></table></td></tr>

    <tr><td align="right" valign="top"><a class="type" href="#ffi_wintype">wintype</a></td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_take_win">take_win</a></b> (<a class="type" href="#ffi_objecttype">objecttype</a> arg)</td></tr>
      <tr><td width="30"></td><td>Take the struct value from an object.</td></tr></table></td></tr>
</table></div>

<a name="ffi_Functions_to_create_action_results"><h3>14.4 Functions to create action results</h3></a>
<p>
  A primitive action function has a result of type <tt><a class="type" href="#ffi_objecttype">objecttype</a></tt>. Functions
  like <tt><a class="func" href="#ffi_bld_bigint_temp">bld_bigint_temp</a></tt> and <tt><a class="func" href="#ffi_bld_stri_temp">bld_stri_temp</a></tt> create an object with the
  specified type.
</p><div><table width="100%" border="1" cellspacing="0" cellpadding="3">
<tr><td style="font-size: 22px; font-weight: bold; background-color: #C0C0FF" colspan="2">
  Functions to create Seed7 objects with a C value</td></tr>

    <tr><td align="right" valign="top"><a class="type" href="#ffi_objecttype">objecttype</a></td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_bld_array_temp">bld_array_temp</a></b> (<a class="type" href="#ffi_arraytype">arraytype</a> temp_array)</td></tr>
      <tr><td width="30"></td><td>Create an object with an <a class="type" href="#ffi_arraytype">arraytype</a> value.</td></tr></table></td></tr>

    <tr><td align="right" valign="top"><a class="type" href="#ffi_objecttype">objecttype</a></td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_bld_bigint_temp">bld_bigint_temp</a></b> (<a class="type" href="#ffi_biginttype">biginttype</a> temp_bigint)</td></tr>
      <tr><td width="30"></td><td>Create an object with a <a class="type" href="#ffi_biginttype">biginttype</a> value.</td></tr></table></td></tr>

    <tr><td align="right" valign="top"><a class="type" href="#ffi_objecttype">objecttype</a></td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_bld_bstri_temp">bld_bstri_temp</a></b> (<a class="type" href="#ffi_bstritype">bstritype</a> temp_bstri)</td></tr>
      <tr><td width="30"></td><td>Create an object with a <a class="type" href="#ffi_bstritype">bstritype</a> value.</td></tr></table></td></tr>

    <tr><td align="right" valign="top"><a class="type" href="#ffi_objecttype">objecttype</a></td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_bld_char_temp">bld_char_temp</a></b> (<a class="type" href="#ffi_chartype">chartype</a> temp_char)</td></tr>
      <tr><td width="30"></td><td>Create an object with a <a class="type" href="#ffi_chartype">chartype</a> value.</td></tr></table></td></tr>

    <tr><td align="right" valign="top"><a class="type" href="#ffi_objecttype">objecttype</a></td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_bld_file_temp">bld_file_temp</a></b> (<a class="type" href="#ffi_filetype">filetype</a> temp_file)</td></tr>
      <tr><td width="30"></td><td>Create an object with a <a class="type" href="#ffi_filetype">filetype</a> value.</td></tr></table></td></tr>

    <tr><td align="right" valign="top"><a class="type" href="#ffi_objecttype">objecttype</a></td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_bld_float_temp">bld_float_temp</a></b> (<a class="type" href="#ffi_floattype">floattype</a> temp_float)</td></tr>
      <tr><td width="30"></td><td>Create an object with a <a class="type" href="#ffi_floattype">floattype</a> value.</td></tr></table></td></tr>

    <tr><td align="right" valign="top"><a class="type" href="#ffi_objecttype">objecttype</a></td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_bld_hash_temp">bld_hash_temp</a></b> (<a class="type" href="#ffi_hashtype">hashtype</a> temp_hash)</td></tr>
      <tr><td width="30"></td><td>Create an object with a <a class="type" href="#ffi_hashtype">hashtype</a> value.</td></tr></table></td></tr>

    <tr><td align="right" valign="top"><a class="type" href="#ffi_objecttype">objecttype</a></td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_bld_int_temp">bld_int_temp</a></b> (<a class="type" href="#ffi_inttype">inttype</a> temp_int)</td></tr>
      <tr><td width="30"></td><td>Create an object with an <a class="type" href="#ffi_inttype">inttype</a> value.</td></tr></table></td></tr>

    <tr><td align="right" valign="top"><a class="type" href="#ffi_objecttype">objecttype</a></td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_bld_poll_temp">bld_poll_temp</a></b> (<a class="type" href="#ffi_polltype">polltype</a> temp_poll)</td></tr>
      <tr><td width="30"></td><td>Create an object with a <a class="type" href="#ffi_polltype">polltype</a> value.</td></tr></table></td></tr>

    <tr><td align="right" valign="top"><a class="type" href="#ffi_objecttype">objecttype</a></td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_bld_set_temp">bld_set_temp</a></b> (<a class="type" href="#ffi_settype">settype</a> temp_set)</td></tr>
      <tr><td width="30"></td><td>Create an object with a <a class="type" href="#ffi_settype">settype</a> value.</td></tr></table></td></tr>

    <tr><td align="right" valign="top"><a class="type" href="#ffi_objecttype">objecttype</a></td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_bld_socket_temp">bld_socket_temp</a></b> (<a class="type" href="#ffi_sockettype">sockettype</a> temp_socket)</td></tr>
      <tr><td width="30"></td><td>Create an object with a <a class="type" href="#ffi_sockettype">sockettype</a> value.</td></tr></table></td></tr>

    <tr><td align="right" valign="top"><a class="type" href="#ffi_objecttype">objecttype</a></td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_bld_stri_temp">bld_stri_temp</a></b> (<a class="type" href="#ffi_stritype">stritype</a> temp_stri)</td></tr>
      <tr><td width="30"></td><td>Create an object with a <a class="type" href="#ffi_stritype">stritype</a> value.</td></tr></table></td></tr>

    <tr><td align="right" valign="top"><a class="type" href="#ffi_objecttype">objecttype</a></td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_bld_struct_temp">bld_struct_temp</a></b> (<a class="type" href="#ffi_structtype">structtype</a> temp_struct)</td></tr>
      <tr><td width="30"></td><td>Create an object with a <a class="type" href="#ffi_structtype">structtype</a> value.</td></tr></table></td></tr>

    <tr><td align="right" valign="top"><a class="type" href="#ffi_objecttype">objecttype</a></td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_bld_win_temp">bld_win_temp</a></b> (<a class="type" href="#ffi_wintype">wintype</a> temp_win)</td></tr>
      <tr><td width="30"></td><td>Create an object with a <a class="type" href="#ffi_wintype">wintype</a> value.</td></tr></table></td></tr>
</table></div><p></p>

<a name="errors_file_start"></a><p></p>
<a name="errors_ERRORS"><h2>15. ERRORS</h2></a>

<p></p>
<a name="errors_Compile_time_errors"><h3>15.1 Compile time errors</h3></a>
<p>
  The compile time errors are not fatal (the program can
  execute) except for the error 1 (Out of heap space) which
  terminates the compilation process and no execution occurs.
  The following compile time errors exist:
</p><dl><dd><table border="0" cellspacing="0">
    <tr><td align="right"> 1:</td> <td width="10"></td><td>Fatal Error: Out of heap space</td></tr>
    <tr><td align="right"> 2:</td> <td width="10"></td><td>File "%s" not found</td></tr>
    <tr><td align="right"> 3:</td> <td width="10"></td><td>Include file "%s" not found</td></tr>
    <tr><td align="right"> 4:</td> <td width="10"></td><td>"END OF FILE" encountered</td></tr>
    <tr><td align="right"> 5:</td> <td width="10"></td><td>Illegal character in text "%s"</td></tr>
    <tr><td align="right"> 6:</td> <td width="10"></td><td>Unclosed comment</td></tr>
    <tr><td align="right"> 7:</td> <td width="10"></td><td>Illegal pragma "%s"</td></tr>
    <tr><td align="right"> 8:</td> <td width="10"></td><td>Illegal action "%s"</td></tr>
    <tr><td align="right"> 9:</td> <td width="10"></td><td>Illegal system declaration "%s"</td></tr>
    <tr><td align="right">10:</td> <td width="10"></td><td>Integer "%s" too big</td></tr>
    <tr><td align="right">11:</td> <td width="10"></td><td>Negative exponent in integer literal</td></tr>
    <tr><td align="right">12:</td> <td width="10"></td><td>Digit expected found "%s"</td></tr>
    <tr><td align="right">13:</td> <td width="10"></td><td>Integer "%dE%s" too big</td></tr>
    <tr><td align="right">14:</td> <td width="10"></td><td>Integer base "%ld" not between 2 and 36</td></tr>
    <tr><td align="right">15:</td> <td width="10"></td><td>Extended digit expected found "%s"</td></tr>
    <tr><td align="right">16:</td> <td width="10"></td><td>Illegal digit "%c" in based integer "%d#%s"</td></tr>
    <tr><td align="right">17:</td> <td width="10"></td><td>Based integer "%d#%s" too big</td></tr>
    <tr><td align="right">18:</td> <td width="10"></td><td>"'" expected found "%s"</td></tr>
    <tr><td align="right">19:</td> <td width="10"></td><td>Character literal exceeds source line</td></tr>
    <tr><td align="right">20:</td> <td width="10"></td><td>Use \" instead of "" to represent " in a string</td></tr>
    <tr><td align="right">21:</td> <td width="10"></td><td>Use / instead of \\ as path delimiter</td></tr>
    <tr><td align="right">22:</td> <td width="10"></td><td>Illegal string escape "\%s"</td></tr>
    <tr><td align="right">23:</td> <td width="10"></td><td>Numerical escape sequences should end with "\" not "%s");</td></tr>
    <tr><td align="right">24:</td> <td width="10"></td><td>String continuations should end with "\" not "%s");</td></tr>
    <tr><td align="right">25:</td> <td width="10"></td><td>String literal exceeds source line</td></tr>
    <tr><td align="right">26:</td> <td width="10"></td><td>Name expected found "%s"</td></tr>
    <tr><td align="right">27:</td> <td width="10"></td><td>Integer literal expected found "%s"</td></tr>
    <tr><td align="right">28:</td> <td width="10"></td><td>String literal expected found "%s"</td></tr>
    <tr><td align="right">29:</td> <td width="10"></td><td>Identifier expected found "%s"</td></tr>
    <tr><td align="right">30:</td> <td width="10"></td><td>Expression expected found "%s"</td></tr>
    <tr><td align="right">31:</td> <td width="10"></td><td>Declaration of parameter %s failed</td></tr>
    <tr><td align="right">32:</td> <td width="10"></td><td>Declaration of "%s" failed</td></tr>
    <tr><td align="right">33:</td> <td width="10"></td><td>Exception "%s" raised</td></tr>
    <tr><td align="right">34:</td> <td width="10"></td><td>"%s" declared twice</td></tr>
    <tr><td align="right">35:</td> <td width="10"></td><td>"%s" not declared</td></tr>
    <tr><td align="right">36:</td> <td width="10"></td><td>Associativity expected found "%s"</td></tr>
    <tr><td align="right">37:</td> <td width="10"></td><td>Statement priority "%s" too big</td></tr>
    <tr><td align="right">38:</td> <td width="10"></td><td>Syntax with two parameters before operator is illegal</td></tr>
    <tr><td align="right">39:</td> <td width="10"></td><td>Empty syntax declaration</td></tr>
    <tr><td align="right">40:</td> <td width="10"></td><td>Dot expression requested as syntax description</td></tr>
    <tr><td align="right">41:</td> <td width="10"></td><td>"%s" redeclared with infix priority %d not %d</td></tr>
    <tr><td align="right">42:</td> <td width="10"></td><td>"%s" redeclared with prefix priority %d not %d</td></tr>
    <tr><td align="right">43:</td> <td width="10"></td><td>Priority %d required for parameter after "%s" not %d</td></tr>
    <tr><td align="right">44:</td> <td width="10"></td><td>Priority &lt;= %d expected found "%s" with priority %d</td></tr>
    <tr><td align="right">45:</td> <td width="10"></td><td>"%s" must have priority %d not %d for dot expression</td></tr>
    <tr><td align="right">46:</td> <td width="10"></td><td>"%s" expected found "%s"</td></tr>
    <tr><td align="right">47:</td> <td width="10"></td><td>"%s" expected found "%s"</td></tr>
    <tr><td align="right">48:</td> <td width="10"></td><td>Undefined type for literal "%s"</td></tr>
    <tr><td align="right">49:</td> <td width="10"></td><td>"newtype", "subtype", "func", "enumlit" or "action" expected found "%s"</td></tr>
    <tr><td align="right">50:</td> <td width="10"></td><td>"func" or "type" expected found "%s"</td></tr>
    <tr><td align="right">51:</td> <td width="10"></td><td>Match for %s failed</td></tr>
    <tr><td align="right">52:</td> <td width="10"></td><td>Variable expected in %s found %s</td></tr>
    <tr><td align="right">53:</td> <td width="10"></td><td>Type expected found %s</td></tr>
    <tr><td align="right">54:</td> <td width="10"></td><td>Procedure expected found %s expression</td></tr>
    <tr><td align="right">55:</td> <td width="10"></td><td>Parameter specifier expected found "%s"</td></tr>
    <tr><td align="right">56:</td> <td width="10"></td><td>Evaluate type expression %s failed</td></tr>
    <tr><td align="right">57:</td> <td width="10"></td><td>Overlong UTF-8 encoding used for character "%s" (U+%04x)</td></tr>
    <tr><td align="right">58:</td> <td width="10"></td><td>UTF-16 surrogate character found in UTF-8 encoding "%s" (U+%04x)</td></tr>
    <tr><td align="right">59:</td> <td width="10"></td><td>Non Unicode character found "%s" (U+%04x)</td></tr>
    <tr><td align="right">60:</td> <td width="10"></td><td>UTF-8 continuation byte expected found "%s" (U+%04x)</td></tr>
    <tr><td align="right">   </td> <td width="10"></td><td>Undefined error</td></tr>
</table></dd></dl><p></p>

<a name="errors_Exceptions"><h3>15.2 Exceptions</h3></a>
<p>
  There are various exceptions, which can be raised during
  program execution:
</p><dl><dt>
    <a name="errors_MEMORY_ERROR">MEMORY_ERROR</a>:</dt><dd><dl><dt>
      May be raised by various operations of the following types:</dt><dd>
          <tt><a class="type" href="#types_array">array</a></tt>, <tt><a class="type" href="#types_struct">struct</a></tt>, <tt><a class="type" href="#types_hash">hash</a></tt>, <tt><a class="type" href="#types_file">file</a></tt>, <tt><a class="type" href="#types_func">func</a></tt>, <tt><a class="type" href="#types_proc">proc</a></tt>, <tt><a class="type" href="#types_reference">reference</a></tt>, <tt><a class="type" href="#types_string">string</a></tt>.</dd><dt>
      Additionally the interpreter kernel may raise this exception also.</dt></dl></dd><dt>
    <a name="errors_NUMERIC_ERROR">NUMERIC_ERROR</a>:</dt><dd><dl><dt>
      May be raised from the following <tt><a class="type" href="#types_integer">integer</a></tt> operations:</dt><dd>
          <span class="op">!</span>, <span class="op">**</span>, <span class="op">div</span>, <span class="op">rem</span>, <span class="op">mdiv</span>, <span class="op">mod</span>, <span class="func">sqrt</span>, <span class="func">log2</span>.</dd><dt>
      May be raised from the following <tt><a class="type" href="#types_bigInteger">bigInteger</a></tt> operations:</dt><dd>
          <span class="op">!</span>, <span class="op">**</span>, <span class="op">div</span>, <span class="op">rem</span>, <span class="op">mdiv</span>, <span class="op">mod</span>, <span class="func">sqrt</span>, <span class="func">log2</span>.</dd><dt></dl></dd><dt>
    <a name="errors_RANGE_ERROR">RANGE_ERROR</a>:</dt><dd><dl><dt>
      May be raised from the following <tt><a class="type" href="#types_boolean">boolean</a></tt> operations:</dt><dd>
          <span class="op">parse</span>, <span class="func">rand</span>.</dd><dt>
      May be raised from the following <tt><a class="type" href="#types_integer">integer</a></tt> operations:</dt><dd>
          <span class="op">parse</span>, <span class="op">radix</span>, <span class="op">RADIX</span>, <span class="func">rand</span>.</dd><dt>
      May be raised from the following <tt><a class="type" href="#types_bigInteger">bigInteger</a></tt> operations:</dt><dd>
          <span class="op">parse</span>, <span class="op">radix</span>, <span class="op">RADIX</span>, <span class="func">rand</span>, <span class="func">ord</span>, <span class="func">bitLength</span>, <span class="func">modInverse</span>.</dd><dt>
      May be raised from the following <tt><a class="type" href="#types_rational">rational</a></tt> operations:</dt><dd>
          <span class="op">parse</span>.</dd><dt>
      May be raised from the following <tt><a class="type" href="#types_bigRational">bigRational</a></tt> operations:</dt><dd>
          <span class="op">parse</span>.</dd><dt>
      May be raised from the following <tt><a class="type" href="#types_float">float</a></tt> operations:</dt><dd>
          <span class="op">parse</span>, <span class="func">rand</span>.</dd><dt>
      May be raised from the following <tt><a class="type" href="#types_char">char</a></tt> operations:</dt><dd>
          <span class="func">chr</span>, <span class="func">rand</span>.</dd><dt>
      May be raised from the following <tt><a class="type" href="#types_string">string</a></tt> operations:</dt><dd>
          <span class="op">[</span>, <span class="op">@:=</span>, <span class="op">mult</span>, <span class="func">pos</span>, <span class="func">rpos</span>.</dd><dt>
      May be raised from the following <tt><a class="type" href="#types_set">bitset</a></tt> operations:</dt><dd>
          <span class="op">conv</span>, <span class="op">parse</span>, <span class="func">min</span>, <span class="func">max</span>, <span class="func">rand</span>.</dd><dt>
      May be raised from the following <tt><a class="type" href="#types_array">array</a></tt> operations:</dt><dd>
          <span class="op">[</span>, <span class="op">times</span>, <span class="func">remove</span>, <span class="func">rand</span>.</dd><dt>
      May be raised from the following <tt><a class="type" href="#types_hash">hash</a></tt> operations:</dt><dd>
          <span class="op">[</span>.</dd><dt>
      May be raised from the following <tt><a class="type" href="#types_category">category</a></tt> operations:</dt><dd>
          <span class="op">parse</span>.</dd><dt>
      May be raised from the following <tt><a class="type" href="#types_ref_list">ref_list</a></tt> operations:</dt><dd>
          <span class="op">[</span>, <span class="op">@:=</span>, <span class="func">pos</span>.</dd><dt>
      May be raised from the following <tt><a class="type" href="#types_file">file</a></tt> operations:</dt><dd>
          <span class="func">open</span>, <span class="func">write</span>, <span class="func">gets</span>, <span class="func">length</span>, <span class="func">seek</span>, <span class="func">tell</span>.</dd><dt></dl></dd><dt>
    <a name="errors_FILE_ERROR">FILE_ERROR</a>:</dt><dd><dl><dt>
      May be raised by the following functions:</dt><dd>
          <a class="func" href="#os_fileSize">fileSize</a>, <a class="func" href="#os_fileSize">bigFileSize</a>, <a class="func" href="#os_fileType">fileType</a>, <a class="func" href="#os_fileType">fileTypeSL</a>, <a class="func" href="#os_fileMode">fileMode</a>, <a class="func" href="#os_setFileMode">setFileMode</a>,
          <a class="func" href="#os_readDir">readDir</a>, <a class="func" href="#os_removeFile">removeFile</a>, <a class="func" href="#os_removeAnyFile">removeAnyFile</a>, <a class="func" href="#os_moveFile">moveFile</a>, <a class="func" href="#os_cloneFile">cloneFile</a>, <a class="func" href="#os_copyFile">copyFile</a>,
          <a class="func" href="#os_readlink">readlink</a>, <a class="func" href="#os_symlink">symlink</a>, hasNext, seek, tell, bigTell, setbuf, write,
          <span class="func">inetSocketAddress</span>, <span class="func">inetListenerAddress</span>, <span class="func">openInetSocket</span>, <span class="func">openInetListener</span>.</dd><dt></dl></dd><dt>
    <a name="errors_ILLEGAL_ACTION">ILLEGAL_ACTION</a>:</dt><dd>
      May be raised by the interpreter kernel when a primitive action
      does not point to any legal action. This check is only done when
      the s7 interpreter is compiled with <tt>'#define WITH_ACTION_CHECK'</tt>.
      The ILLEGAL_ACTION exception is also raised when the primitive
      action ACT_ILLEGAL is executed.</dd><dt>
</dl><p>
  A program can raise an exception with the <tt><span class="keywd">raise</span></tt> statement. For example:
</p><pre class="indent">
<span class="keywd">raise</span> RANGE_ERROR;
</pre><p></p>

<a name="errors_Handlers"><h3>15.3 Handlers</h3></a>
<p>
  To catch an EXCEPTION the following handler construct can be used:
</p><pre class="indent">
<span class="keywd">block</span>
  number := 1 <span class="op">div</span> 0;
<span class="keywd">exception</span>
  <span class="keywd">catch</span> NUMERIC_ERROR:
    number := 1;
<span class="keywd">end block</span>;
</pre><p>
  It is also possible to catch several EXCEPTIONS:
</p><pre class="indent">
<span class="keywd">block</span>
  doSomething(someValue);
<span class="keywd">exception</span>
  <span class="keywd">catch</span> MEMORY_ERROR:  writeln(<span class="stri">"MEMORY_ERROR"</span>);
  <span class="keywd">catch</span> NUMERIC_ERROR: writeln(<span class="stri">"NUMERIC_ERROR"</span>);
<span class="keywd">end block</span>;
</pre><p></p>

<a name="errors_Stack_trace"><h3>15.4 Stack trace</h3></a>
<p>
  When an EXCEPTION is not caught the program is terminated and the s7
  interpreter writes a stack trace:
</p><pre class="indent">
*** Uncaught EXCEPTION NUMERIC_ERROR raised with
{integer: &lt;SYMBOLOBJECT> *NULL_ENTITY_OBJECT* div fuel_max }

Stack:
in (val integer: dividend) div (val integer: divisor) at integer.s7i(95)
in init_display at lander.sd7(840)
in setup at lander.sd7(909)
in main at lander.sd7(1541)
</pre><p>
  The stack trace shows that a <tt>'NUMERIC_ERROR'</tt> was raised by the <tt><span class="keywd">div</span></tt> operation.
  This operation is defined in line 95 of <tt><span class="lib">integer.s7i</span></tt>. More interesting is that
  <tt><span class="keywd">div</span></tt> was called from the function <tt>'init_display'</tt> in
  line 840 of <tt><span class="prog">lander.sd7</span></tt>. A <tt>'NUMERIC_ERROR'</tt> with <tt><span class="keywd">div</span></tt> is
  probably caused by a zero division. A short examination in <tt><span class="prog">lander.sd7</span></tt> shows that an assignment to
  <tt>'fuel_max'</tt> was commented out to show how stack traces work.
</p><p>
  A compiled program creates a much shorter crash message:
</p><pre class="indent">
*** Uncaught EXCEPTION NUMERIC_ERROR raised at tmp_lander.c(764)
</pre><p>
  To get more information there are two possibilities:
</p><ul>
    <li>Start the program in the interpreter instead.</li>
    <li>Compile the program with the options <tt><b>-g</b></tt> <tt><b>-e</b></tt> and start it
       from a debugger.</li>
</ul><p>
  When <span class="link">s7c</span> is called with the option <tt><b>-g</b></tt> it instructs the
  C compiler to generate debugging information. This way a debugger
  like gdb can run the program and provide information. The option
  <tt><b>-e</b></tt> tells the compiler to generate code which sends a signal,
  when an uncaught exception occurs. This option allows debuggers
  to handle uncaught Seed7 exceptions. Note that <tt><b>-e</b></tt> sends the
  signal SIGFPE. This is done even when the exception is not
  related to floating point operations.
</p><pre class="indent">
./s7 s7c -g -e lander
gdb ./lander
</pre><p>
  Then the debugger should be able to run the program and to
  write a backtrace when a crash occurs:
</p><pre class="indent">
(gdb) run
Starting program: /home/tm/seed7_5/prg/lander

Program received signal SIGFPE, Arithmetic exception.
0x08068518 in o_2541_init_display () at lander.sd7:840
840         fuel_gauge := 40 * rocket.fuel div fuel_max;
(gdb) bt
#0  0x08068518 in o_2541_init_display () at lander.sd7:840
#1  0x08068c21 in o_2546_setup () at lander.sd7:909
#2  0x0806c304 in main (argc=1, argv=0xbffff324) at lander.sd7:1541
</pre><p>
  Sometimes it is helpful to debug the generated C program instead of
  the Seed7 source. The option <tt><b>-g-debug_c</b></tt> creates debug
  information, which refers to the C program generated by the Seed7 compiler:
</p><pre class="indent">
./s7 s7c -g-debug_c -e lander
gdb ./lander
</pre><p>
  Now the debugger refers to the temporary file <tt><span class="stri">tmp_lander.c</span></tt>:
</p><pre class="indent">
(gdb) run
Starting program: /home/tm/seed7_5/prg/lander

Program received signal SIGFPE, Arithmetic exception.
0x08068518 in o_2541_init_display () at tmp_lander.c:19727
19727   o_2428_fuel_gauge=((40) * (((structtype)(o_2338_rocket))->stru[10].value.intvalue/*->o_2336_fuel*/)) / (o_2431_fuel_max);
(gdb) bt
#0  0x08068518 in o_2541_init_display () at tmp_lander.c:19727
#1  0x08068c21 in o_2546_setup () at tmp_lander.c:19864
#2  0x0806c304 in main (argc=1, argv=0xbffff324) at tmp_lander.c:21188
</pre><p>
  Some Seed7 exceptions do not send signals. This hinders the debugger
  to recognize that an uncaught exception occurred. The compiler option <tt><b>-e</b></tt>
  can help in this situation. It instructs the compiler to generate
  code which sends a signal when an uncaught exception occurs. This
  allows the debugger to show a backtrace for uncaught Seed7 exceptions.
</p>

<a name="errors_Other_errors_and_warnings"><h3>15.5 Other errors and warnings</h3></a>
<p><dl><dt>
  No more memory. Program terminated.</dt><dd>
    This error message is displayed after the compile time error 1
    (Out of heap space) . The file name and line number of the
    analyzer source code where this happens is displayed together
    with internal heap information.</dd><dt>

  System declaration for main missing</dt><dd>
    Each program must contain a system declaration that describes
    which procedure to start as first one.</dd><dt>

  EXCEPTION %s raised with</dt><dd>
    If your trace level specifies exception tracing exceptions
    and handlers are displayed with this messages and the user
    must type the ENTER-key to accept.</dd><dt>

  ACTION $%s REQUIRES %s NOT %s</dt><dd>
    This error can happen when an action tries to do something
    with the wrong primitive value. For example adding an
    integer to a string with INT_ADD. Since the analyze phase
    checks for the right types this error can only happen when the
    basic libraries are defined wrong.</dd><dt>

  ACTION $%s REQUIRES VARIABLE %s NOT %s</dt><dd>
    This error can happen with actions which assign a value to
    a constant. Since the analyze phase checks for variable objects
    this error can only happen when the basic libraries are defined
    wrong. Principally this error is possible with the following
    operations: :=, incr, decr, wrd_rd, lin_rd</dd><dt>
</dl><p></p>
</body>
</html>
