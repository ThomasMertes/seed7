
(********************************************************************)
(*                                                                  *)
(*  chkfil.sd7    Checks file operations                            *)
(*  Copyright (C) 1991 - 1994, 2020, 2021  Thomas Mertes            *)
(*                                                                  *)
(*  This program is free software; you can redistribute it and/or   *)
(*  modify it under the terms of the GNU General Public License as  *)
(*  published by the Free Software Foundation; either version 2 of  *)
(*  the License, or (at your option) any later version.             *)
(*                                                                  *)
(*  This program is distributed in the hope that it will be useful, *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of  *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *)
(*  GNU General Public License for more details.                    *)
(*                                                                  *)
(*  You should have received a copy of the GNU General Public       *)
(*  License along with this program; if not, write to the           *)
(*  Free Software Foundation, Inc., 51 Franklin Street,             *)
(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)
(*                                                                  *)
(********************************************************************)


$ include "seed7_05.s7i";
  include "bigint.s7i";
  include "bigfile.s7i";
  include "osfiles.s7i";
  include "console.s7i";
  include "keybd.s7i";
  include "utf8.s7i";

# The file size for the seek test has been reduced, such that not
# so much disk space is needed. This was necessary because some
# operating systems really request the disk space for the seek test.
# Originally the value was 9876543210.
const integer: SEEK_TEST_FILE_SIZE is 12345678;
const string: SEEK_TEST_END_MARKER is "this is the end";
const integer: END_MARKER_POS is SEEK_TEST_FILE_SIZE - length(SEEK_TEST_END_MARKER);

const string: testString is "\0;\A\B\C\D\E\F\G\H^I^J\K\L\M\N\O\
                            \\P\Q\R\S\T\U\V\W\X\Y\Z\e\28;\29;\30;\31;\
                            \(space)!\"#$%&'()*+,-./0123456789:;<=>?\
                            \@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\
                            \`abcdefghijklmnopqrstuvwxyz{|}~\127;\
                            \\128;\129;\130;\131;\132;\133;\134;\135;\
                            \\136;\137;\138;\139;\140;\141;\142;\143;\
                            \\144;\145;\146;\147;\148;\149;\150;\151;\
                            \\152;\153;\154;\155;\156;\157;\158;\159;\
                            \\160;¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿\
                            \ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞß\
                            \àáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ\0;";


const func boolean: raisesRangeError (in func file: expression) is func
  result
    var boolean: raisesRangeError is FALSE;
  local
    var file: exprResult is STD_NULL;
  begin
    block
      exprResult := expression;
    exception
      catch RANGE_ERROR:
        raisesRangeError := TRUE;
    end block;
  end func;


const func boolean: raisesRangeError (in func string: expression) is func
  result
    var boolean: raisesRangeError is FALSE;
  local
    var string: exprResult is "";
  begin
    block
      exprResult := expression;
    exception
      catch RANGE_ERROR:
        raisesRangeError := TRUE;
    end block;
  end func;


const func boolean: raisesRangeError (in proc: expression) is func
  result
    var boolean: raisesRangeError is FALSE;
  begin
    block
      expression;
    exception
      catch RANGE_ERROR: raisesRangeError := TRUE;
    end block;
  end func;


const proc: DECLARE_RAISES_FILE_ERROR (in type: aType) is func
  begin

    const func boolean: raisesFileError (in func aType: expression) is func
      result
        var boolean: raisesFileError is FALSE;
      local
        var aType: exprResult is aType.value;
      begin
        block
          exprResult := expression;
        exception
          catch FILE_ERROR:
            raisesFileError := TRUE;
        end block;
      end func;

  end func;


DECLARE_RAISES_FILE_ERROR(void);
DECLARE_RAISES_FILE_ERROR(boolean);
DECLARE_RAISES_FILE_ERROR(integer);
DECLARE_RAISES_FILE_ERROR(bigInteger);
DECLARE_RAISES_FILE_ERROR(char);
DECLARE_RAISES_FILE_ERROR(string);


const proc: check_clib_file is func
  local
    var boolean: okay is TRUE;
    var clib_file: aFile is clib_file.value;
    var array clib_file: fileArr is 1 times clib_file.value;
  begin
    if clib_file.value <> CLIB_NULL_FILE then
      writeln(" ***** Default value of clib_file is not CLIB_NULL_FILE.");
      okay := FALSE;
    end if;
    if not raisesFileError(close(CLIB_NULL_FILE)) then
      writeln(" ***** Closing CLIB_NULL_FILE does not raise FILE_ERROR.");
      okay := FALSE;
    end if;
    if raisesRangeError(aFile := openClibFile("asdf", "r+")) then
      writeln("Cannot open clib_file with mode \"r+\". (1)");
      okay := FALSE;
    end if;
    if aFile <> CLIB_NULL_FILE then
      close(aFile);
    end if;
    if raisesRangeError(fileArr[1] := openClibFile("asdf", "r+")) then
      writeln("Cannot open clib_file with mode \"r+\". (2)");
      okay := FALSE;
    end if;
    if fileArr[1] <> CLIB_NULL_FILE then
      close(fileArr[1]);
    end if;
    if  literal(CLIB_INPUT)  <> "stdin" or
        literal(CLIB_OUTPUT) <> "stdout" or
        literal(CLIB_ERROR)  <> "stderr" then
      writeln("Literal of clib_file does not work correctly.");
      okay := FALSE;
    end if;
  end func;


(*
 *  Test the case where a function changes its parameter.
 *  Assume the function is called with:
 *   aFile := changeParameter(aFile, testFileName);
 *  This triggers two changes of 'aFile'. One change is in
 *  changeParameter() and another change is done by the assignment.
 *  In this case the change of 'aFile' in changeParameter() is
 *  overwritten by the assignment. The variable 'aFile' obtains
 *  its new value from the result of changeParameter().
 *)
const func clib_file: changeParameter (inout clib_file: aFile,
    in string: testFileName) is func
  result
    var clib_file: fileResult is clib_file.value;
  begin
    fileResult := openClibFile(testFileName, "r+");
    # To check the implementation this must change the address of 'aFile':
    aFile := openClibFile(testFileName, "r+");
  end func;


const proc: check_clib_file_assign is func
  local
    var boolean: okay is TRUE;
    var string: testFileName is "";
    var clib_file: aFile is clib_file.value;
    var array clib_file: fileArr is 1 times clib_file.value;
  begin
    repeat
      testFileName := homeDir <& "/tmp_test_file_" <& rand(0, 999) lpad0 3;
    until fileType(testFileName) = FILE_ABSENT;
    aFile := openClibFile(testFileName, "w");
    write(aFile, testFileName);
    close(aFile);

    aFile := openClibFile(testFileName, "r+");
    aFile := changeParameter(aFile, testFileName);
    aFile := aFile;
    close(aFile);
    fileArr[1] := openClibFile(testFileName, "r+");
    fileArr[1] := changeParameter(fileArr[1], testFileName);
    fileArr[1] := fileArr[1];
    close(fileArr[1]);
    aFile := clib_file.value;
    fileArr[1] := clib_file.value;
    removeFile(testFileName);
  end func;


(*
 *  Test the case where a function changes its parameter.
 *  Assume the function is called with:
 *   aFile := changeParameter(aFile, testFileName);
 *  This triggers two changes of 'aFile'. One change is in
 *  changeParameter() and another change is done by the assignment.
 *  In this case the change of 'aFile' in changeParameter() is
 *  overwritten by the assignment. The variable 'aFile' obtains
 *  its new value from the result of changeParameter().
 *)
const func file: changeParameter (inout file: aFile,
    in string: testFileName) is func
  result
    var file: fileResult is STD_NULL;
  begin
    fileResult := open(testFileName, "r+");
    # To check the implementation this must change the address of 'aFile':
    aFile := open(testFileName, "r+");
  end func;


const proc: check_file_assign is func
  local
    var boolean: okay is TRUE;
    var string: testFileName is "";
    var file: aFile is STD_NULL;
    var array file: fileArr is 1 times STD_NULL;
  begin
    repeat
      testFileName := homeDir <& "/tmp_test_file_" <& rand(0, 999) lpad0 3;
    until fileType(testFileName) = FILE_ABSENT;
    aFile := open(testFileName, "w");
    write(aFile, testFileName);
    close(aFile);

    aFile := open(testFileName, "r+");
    aFile := changeParameter(aFile, testFileName);
    aFile := aFile;
    close(aFile);
    fileArr[1] := open(testFileName, "r+");
    fileArr[1] := changeParameter(fileArr[1], testFileName);
    fileArr[1] := fileArr[1];
    close(fileArr[1]);
    aFile := STD_NULL;
    fileArr[1] := STD_NULL;
    removeFile(testFileName);
  end func;


const proc: check_file_open is func
  local
    var boolean: okay is TRUE;
    var file: aFile is STD_NULL;
  begin
    if not raisesRangeError(open("asdf\0;asdf", "r")) then
      writeln("Open file with null byte in file name succeeds.");
      okay := FALSE;
    end if;
    if  not raisesRangeError(open("asdf", "r-")) or
        not raisesRangeError(open("asdf", "z")) then
      writeln("Open file with illegal mode.");
      okay := FALSE;
    end if;
    if raisesRangeError(aFile := open("asdf", "r+")) then
      writeln("Cannot open file with mode \"r+\".");
      okay := FALSE;
    else
      close(aFile);
    end if;
    if raisesRangeError(aFile := open("asdf", "rt")) then
      writeln("Cannot open file with mode \"rt\".");
      okay := FALSE;
    else
      close(aFile);
    end if;
    if raisesRangeError(aFile := open("asdf", "rt+")) then
      writeln("Cannot open file with mode \"rt+\".");
      okay := FALSE;
    else
      close(aFile);
    end if;
    if raisesRangeError(open("asdfasdf\16#10FFFF;asdfasdf", "r")) then
      writeln("Open file with Unicode character in file name fails.");
      okay := FALSE;
    end if;
    if not raisesRangeError(open("asdfasdf\16#110000;asdfasdf", "r")) then
      writeln("Open file with non-Unicode character in file name succeeds.");
      okay := FALSE;
    end if;

    if okay then
      writeln("Open a file does work correctly.");
    else
      writeln(" ***** Open a file does not work correctly");
      writeln;
    end if;
  end func;


const func boolean: check_file_io_1 is func
  result
    var boolean: okay is TRUE;
  local
    var file: aFile is STD_NULL;
    var string: stri is "";
  begin
    aFile := open("qwerty", "w");
    if aFile = STD_NULL then
      writeln(" ***** Could not open file \"qwerty\" for writing. (1)");
      okay := FALSE;
    else
      writeln(aFile, "qwertyuiop");
      if length(aFile) <> 11 then
        writeln("length(aFile) returns " <& length(aFile) <& " instead of 11. (1)");
        okay := FALSE;
      end if;
      if bigLength(aFile) <> 11_ then
        writeln("bigLength(aFile) returns " <& bigLength(aFile) <& " instead of 11. (1)");
        okay := FALSE;
      end if;
      close(aFile);
      aFile := open("qwerty", "r");
      if aFile = STD_NULL then
        writeln(" ***** Could not open file \"qwerty\" for reading. (1)");
        okay := FALSE;
      else
        read(aFile, stri);
        if stri <> "qwertyuiop" then
          writeln("read(file, string) does not work correctly. (1)");
          okay := FALSE;
        end if;
        seek(aFile, 1);
        stri := getTerminatedString(aFile, 'y');
        if stri <> "qwert" or aFile.bufferChar <> 'y' then
          writeln("getTerminatedString(file, terminator) does not work correctly. (1)");
          okay := FALSE;
        end if;
        seek(aFile, 1);
        stri := getln(aFile);
        if stri <> "qwertyuiop" or aFile.bufferChar <> '\n' then
          writeln("getln(file) does not work correctly. (1)");
          okay := FALSE;
        end if;
        seek(aFile, 1);
        stri := getwd(aFile);
        if stri <> "qwertyuiop" or aFile.bufferChar <> '\n' then
          writeln("getwd(file) does not work correctly. (1)");
          okay := FALSE;
        end if;
        stri := "";
        if hasNext(aFile) then
          writeln("hasNext(file) does return TRUE after reading the last character of the file. (1)");
          okay := FALSE;
        end if;
        if eof(aFile) then
          writeln("eof(file) does return TRUE after reading the last character of the file. (1)");
          okay := FALSE;
        end if;
        if getc(aFile) <> EOF then
          writeln("getc(file) does not return EOF when reading beyond the last character of the file. (1)");
          okay := FALSE;
        end if;
        if hasNext(aFile) then
          writeln("hasNext(file) does return TRUE after reading the last character of the file. (2)");
          okay := FALSE;
        end if;
        if not eof(aFile) then
          writeln("eof(file) does return FALSE after reading the EOF marker of the file. (1)");
          okay := FALSE;
        end if;
        seek(aFile, 1);
        if eof(aFile) then
          writeln("Seek does not clear the EOF flag of a file (eof(file) returns TRUE). (1)");
          okay := FALSE;
        end if;
        if not hasNext(aFile) then
          writeln("hasNext(file) does not return TRUE at the beginning of an non-empty file. (1)");
          okay := FALSE;
        end if;
        if  not raisesRangeError(gets(aFile, integer.first)) or
            not raisesRangeError(gets(aFile, -1)) then
          writeln("gets with negative number does not raise RANGE_ERROR. (1)");
          okay := FALSE;
        end if;
        if gets(aFile, 0) <> ""  then
          writeln("gets(file, 0) does not work correctly. (1)");
          okay := FALSE;
        end if;
        stri := gets(aFile, 10);
        if stri <> "qwertyuiop" then
          writeln("gets(file, 10) does not work correctly. (1)");
          okay := FALSE;
        end if;
        seek(aFile, 1);
        stri := gets(aFile, 999999999);
        if stri <> "qwertyuiop\n" then
          writeln("gets(file, 999999999) does not work correctly. (1)");
          okay := FALSE;
        end if;
        if length(aFile) <> 11 then
          writeln("length(aFile) returns " <& length(aFile) <& " instead of 11. (2)");
          okay := FALSE;
        end if;
        if bigLength(aFile) <> 11_ then
          writeln("bigLength(aFile) returns " <& bigLength(aFile) <& " instead of 11. (2)");
          okay := FALSE;
        end if;
        close(aFile);
      end if;
      removeFile("qwerty");
    end if;
  end func;


const func boolean: check_file_io_2 is func
  result
    var boolean: okay is TRUE;
  local
    var file: aFile is STD_NULL;
    var string: stri is "";
  begin
    aFile := open("qwerty", "w");
    if aFile = STD_NULL then
      writeln(" ***** Could not open file \"qwerty\" for writing. (2)");
      okay := FALSE;
    else
      writeln(aFile, "qwertyuiop\r");
      if length(aFile) <> 12 then
        writeln("length(aFile) returns " <& length(aFile) <& " instead of 12. (1)");
        okay := FALSE;
      end if;
      if bigLength(aFile) <> 12_ then
        writeln("bigLength(aFile) returns " <& bigLength(aFile) <& " instead of 12. (1)");
        okay := FALSE;
      end if;
      close(aFile);
      aFile := open("qwerty", "r");
      if aFile = STD_NULL then
        writeln(" ***** Could not open file \"qwerty\" for reading. (2)");
        okay := FALSE;
      else
        read(aFile, stri);
        if stri <> "qwertyuiop" then
          writeln("read(file, string) does not work correctly. (2)");
          okay := FALSE;
        end if;
        seek(aFile, 1);
        stri := getTerminatedString(aFile, 'y');
        if stri <> "qwert" or aFile.bufferChar <> 'y' then
          writeln("getTerminatedString(file, terminator) does not work correctly. (2)");
          okay := FALSE;
        end if;
        seek(aFile, 1);
        stri := getln(aFile);
        if stri <> "qwertyuiop" or aFile.bufferChar <> '\n' then
          writeln("getln(file) does not work correctly. (2)");
          okay := FALSE;
        end if;
        seek(aFile, 1);
        stri := getwd(aFile);
        if stri <> "qwertyuiop" or aFile.bufferChar <> '\n' then
          writeln("getwd(file) does not work correctly. (2)");
          okay := FALSE;
        end if;
        stri := "";
        if hasNext(aFile) then
          writeln("hasNext(file) does return TRUE after reading the last character of the file. (3)");
          okay := FALSE;
        end if;
        if eof(aFile) then
          writeln("eof(file) does return TRUE after reading the last character of the file. (2)");
          okay := FALSE;
        end if;
        if getc(aFile) <> EOF then
          writeln("getc(file) does not return EOF when reading beyond the last character of the file. (2)");
          okay := FALSE;
        end if;
        if hasNext(aFile) then
          writeln("hasNext(file) does return TRUE after reading the last character of the file. (4)");
          okay := FALSE;
        end if;
        if not eof(aFile) then
          writeln("eof(file) does return FALSE after reading the EOF marker of the file. (2)");
          okay := FALSE;
        end if;
        seek(aFile, 1);
        if eof(aFile) then
          writeln("Seek does not clear the EOF flag of a file (eof(file) returns TRUE). (2)");
          okay := FALSE;
        end if;
        if not hasNext(aFile) then
          writeln("hasNext(file) does not return TRUE at the beginning of an non-empty file. (2)");
          okay := FALSE;
        end if;
        if  not raisesRangeError(gets(aFile, integer.first)) or
            not raisesRangeError(gets(aFile, -1)) then
          writeln("gets with negative number does not raise RANGE_ERROR. (2)");
          okay := FALSE;
        end if;
        if gets(aFile, 0) <> ""  then
          writeln("gets(file, 0) does not work correctly. (2)");
          okay := FALSE;
        end if;
        stri := gets(aFile, 10);
        if stri <> "qwertyuiop" then
          writeln("gets(file, 10) does not work correctly. (2)");
          okay := FALSE;
        end if;
        seek(aFile, 1);
        stri := gets(aFile, 999999999);
        if stri <> "qwertyuiop\r\n" then
          writeln("gets(file, 999999999) does not work correctly. (2)");
          okay := FALSE;
        end if;
        if length(aFile) <> 12 then
          writeln("length(aFile) returns " <& length(aFile) <& " instead of 12. (2)");
          okay := FALSE;
        end if;
        if bigLength(aFile) <> 12_ then
          writeln("bigLength(aFile) returns " <& bigLength(aFile) <& " instead of 12. (2)");
          okay := FALSE;
        end if;
        close(aFile);
      end if;
      removeFile("qwerty");
    end if;
  end func;


const func boolean: check_file_io_3 is func
  result
    var boolean: okay is TRUE;
  local
    var file: aFile is STD_NULL;
    var string: stri is "";
  begin
    aFile := open("qwerty", "w");
    if aFile = STD_NULL then
      writeln(" ***** Could not open file \"qwerty\" for writing. (3)");
      okay := FALSE;
    else
      writeln(aFile, testString);
      if length(aFile) <> succ(length(testString)) then
        writeln("length(aFile) returns " <& length(aFile) <& " instead of " <&
                succ(length(testString)) <& ". (1)");
        okay := FALSE;
      end if;
      if bigLength(aFile) <> bigInteger(succ(length(testString))) then
        writeln("bigLength(aFile) returns " <& bigLength(aFile) <& " instead of " <&
                succ(length(testString)) <& ". (1)");
        okay := FALSE;
      end if;
      close(aFile);
      aFile := open("qwerty", "r");
      if aFile = STD_NULL then
        writeln(" ***** Could not open file \"qwerty\" for reading. (3)");
        okay := FALSE;
      else
        read(aFile, stri);
        if stri <> testString then
          writeln("read(file, string) does not work correctly. (3)");
          okay := FALSE;
        end if;
        seek(aFile, 1);
        stri := getTerminatedString(aFile, '^');
        if stri <> "\0;\A\B\C\D\E\F\G\H" or aFile.bufferChar <> '^' then
          writeln("getTerminatedString(file, terminator) does not work correctly. (3)");
          okay := FALSE;
        end if;
        seek(aFile, 1);
        stri := getln(aFile);
        if stri <> testString or aFile.bufferChar <> '\n' then
          writeln("getln(file) does not work correctly. (3)");
          okay := FALSE;
        end if;
        seek(aFile, 1);
        stri := getwd(aFile);
        if stri <> testString or aFile.bufferChar <> '\n' then
          writeln("getwd(file) does not work correctly. (3)");
          okay := FALSE;
        end if;
        stri := "";
        if hasNext(aFile) then
          writeln("hasNext(file) does return TRUE after reading the last character of the file. (5)");
          okay := FALSE;
        end if;
        if eof(aFile) then
          writeln("eof(file) does return TRUE after reading the last character of the file. (3)");
          okay := FALSE;
        end if;
        if getc(aFile) <> EOF then
          writeln("getc(file) does not return EOF when reading beyond the last character of the file. (3)");
          okay := FALSE;
        end if;
        if hasNext(aFile) then
          writeln("hasNext(file) does return TRUE after reading the last character of the file. (6)");
          okay := FALSE;
        end if;
        if not eof(aFile) then
          writeln("eof(file) does return FALSE after reading the EOF marker of the file. (3)");
          okay := FALSE;
        end if;
        seek(aFile, 1);
        if eof(aFile) then
          writeln("Seek does not clear the EOF flag of a file (eof(file) returns TRUE). (3)");
          okay := FALSE;
        end if;
        if not hasNext(aFile) then
          writeln("hasNext(file) does not return TRUE at the beginning of an non-empty file. (3)");
          okay := FALSE;
        end if;
        if  not raisesRangeError(gets(aFile, integer.first)) or
            not raisesRangeError(gets(aFile, -1)) then
          writeln("gets with negative number does not raise RANGE_ERROR. (3)");
          okay := FALSE;
        end if;
        if gets(aFile, 0) <> ""  then
          writeln("gets(file, 0) does not work correctly. (3)");
          okay := FALSE;
        end if;
        stri := gets(aFile, length(testString));
        if stri <> testString then
          writeln("gets(file, 10) does not work correctly. (3)");
          okay := FALSE;
        end if;
        seek(aFile, 1);
        stri := gets(aFile, 999999999);
        if stri <> testString & "\n" then
          writeln("gets(file, 999999999) does not work correctly. (3)");
          okay := FALSE;
        end if;
        if length(aFile) <> succ(length(testString)) then
          writeln("length(aFile) returns " <& length(aFile) <& " instead of " <&
                  succ(length(testString)) <& ". (2)");
          okay := FALSE;
        end if;
        if bigLength(aFile) <> bigInteger(succ(length(testString))) then
          writeln("bigLength(aFile) returns " <& bigLength(aFile) <& " instead of " <&
                  succ(length(testString)) <& ". (2)");
          okay := FALSE;
        end if;
        close(aFile);
      end if;
      removeFile("qwerty");
    end if;
  end func;


const proc: check_file_io is func
  local
    var boolean: okay is TRUE;
    var file: aFile is STD_NULL;
  begin
    okay := TRUE;
    aFile := open("qwerty", "r");
    if aFile <> STD_NULL then
      close(aFile);
      # Make sure that a leftover from a previous test is removed.
      removeFile("qwerty");
    end if;

    if not check_file_io_1 then
      okay := FALSE;
    end if;

    if not check_file_io_2 then
      okay := FALSE;
    end if;

    if not check_file_io_3 then
      okay := FALSE;
    end if;

    if okay then
      writeln("File I/O does work correctly.");
    else
      writeln(" ***** File I/O does not work correctly");
      writeln;
    end if;
  end func;


const proc: check_file_seek is func
  local
    var boolean: okay is TRUE;
    var file: aFile is STD_NULL;
    var string: stri is "";
    var integer: num is 0;
  begin
    okay := TRUE;
    aFile := open("qwerty", "r");
    if aFile = STD_NULL then
      aFile := open("qwerty", "w");
      if aFile <> STD_NULL then
        writeln(aFile, "qwertyuiop");
        if not seekable(aFile) then
          writeln("A regular file is not seekable. (1)");
          okay := FALSE;
        end if;
        seek(aFile, END_MARKER_POS);
        writeln(aFile, SEEK_TEST_END_MARKER);
        close(aFile);
        aFile := open("qwerty", "r");
        if aFile <> STD_NULL then
          # stri := gets(aFile, 10);
          # stri := gets(aFile, 67076095); # okay           with bcc32
          # stri := gets(aFile, 67076096); # errno = EINVAL with bcc32
            stri := gets(aFile, 100000000);
          # stri := gets(aFile, 268435456);
          # stri := gets(aFile, 378000000);
          # stri := gets(aFile, 536870912);
          # for num range 1 to 26843545 do
          #   stri := gets(aFile, 10);
          # end for;
          if stri[.. 6] <> "qwerty" then
            writeln("gets(file, 536870912) does not work correctly.");
            TRACE_OBJ(stri);
            writeln;
            okay := FALSE;
          end if;
          stri := "";
          if not seekable(aFile) then
            writeln("A regular file is not seekable. (2)");
            okay := FALSE;
          end if;
          seek(aFile, END_MARKER_POS);
          read(aFile, stri);
          if stri <> "this" then
            writeln("read(file, string) after seek does not work correctly.");
            okay := FALSE;
          end if;
          seek(aFile, END_MARKER_POS);
          stri := getTerminatedString(aFile, 'e');
          if stri <> "this is th" or aFile.bufferChar <> 'e' then
            writeln("getTerminatedString(file, terminator) after seek does not work correctly.");
            okay := FALSE;
          end if;
          seek(aFile, END_MARKER_POS);
          stri := getln(aFile);
          if stri <> SEEK_TEST_END_MARKER or aFile.bufferChar <> '\n' then
            writeln("getln(file) after seek does not work correctly.");
            okay := FALSE;
          end if;
          seek(aFile, END_MARKER_POS);
          stri := getwd(aFile);
          if stri <> "this" or aFile.bufferChar <> ' ' then
            writeln("getwd(file) after seek does not work correctly.");
            okay := FALSE;
          end if;
          seek(aFile, END_MARKER_POS);
          stri := gets(aFile, 15);
          if stri <> SEEK_TEST_END_MARKER then
            writeln("gets(file, 15) after seek does not work correctly.");
            okay := FALSE;
          end if;
          seek(aFile, END_MARKER_POS);
          stri := gets(aFile, 999999999);
          if stri <> SEEK_TEST_END_MARKER & "\n" then
            writeln("gets(file, 999999999) does not work correctly. (4)");
            okay := FALSE;
          end if;
          seek(aFile, END_MARKER_POS);
          if tell(aFile) <> END_MARKER_POS then
            writeln("tell(aFile) does not return the position set by seek. (1)");
            okay := FALSE;
          end if;
          if bigTell(aFile) <> bigInteger(END_MARKER_POS) then
            writeln("tell(aFile) does not return the position set by seek. (2)");
            okay := FALSE;
          end if;
          if length(aFile) <> SEEK_TEST_FILE_SIZE then
            writeln("length(aFile) returns " <& length(aFile) <&
                    " instead of " <& SEEK_TEST_FILE_SIZE <& ". (1)");
            okay := FALSE;
          end if;
          if bigLength(aFile) <> bigInteger(SEEK_TEST_FILE_SIZE) then
            writeln("bigLength(aFile) returns " <& bigLength(aFile) <&
                    " instead of " <& SEEK_TEST_FILE_SIZE <& ". (1)");
            okay := FALSE;
          end if;
          if  not raisesRangeError(seek(aFile, integer.first)) or
              not raisesRangeError(seek(aFile,   -2147483648)) or
              not raisesRangeError(seek(aFile,             0)) then
            writeln("seek with negative number does not raise RANGE_ERROR. (1)");
            okay := FALSE;
          end if;
          if  not raisesRangeError(seek(aFile, -18446744073709551616_)) or
              not raisesRangeError(seek(aFile,  -9223372036854775808_)) or
              not raisesRangeError(seek(aFile,           -2147483648_)) or
              not raisesRangeError(seek(aFile,                     0_)) then
            writeln("seek with negative number does not raise RANGE_ERROR. (2)");
            okay := FALSE;
          end if;
          close(aFile);
        else
          writeln(" ***** Could not open file \"qwerty\" for reading");
        end if;
        removeFile("qwerty");

        if okay then
          writeln("File seek does work correctly.");
        else
          writeln(" ***** File seek does not work correctly");
          writeln;
        end if;

      else
        writeln(" ***** Could not open file \"qwerty\" for writing. (4)");
      end if;
    else
      writeln(" ***** File \"qwerty\" already exists");
      close(aFile);
    end if;
  end func;


const proc: check_automatic_close is func
  local
    var boolean: okay is TRUE;
    var string: test_file_name is "";
    var file: aFile is STD_NULL;
    var integer: number is 0;
    var char: ch is ' ';
    var string: expected is "";
    var string: test is "";
  begin
    repeat
      test_file_name := homeDir <& "/tmp_test_file_" <& rand(0, 999) lpad0 3;
    until fileType(test_file_name) = FILE_ABSENT;

    aFile := open(test_file_name, "w");
    for number range 0 to 5000 do
      ch := char(32 + number mod 96);
      # The assignment of the new file should close the old file automatically.
      # If automatic closing fails the upper limit of open files is reached.
      # In this case open() returns STD_NULL and test <> expected will fail.
      aFile := open(test_file_name, "a");
      write(aFile, ch);
      expected &:= ch;
    end for;

    aFile := open(test_file_name, "r");
    test := gets(aFile, integer.last);
    if test <> expected then
      writeln("The file does not contain the expected string.");
      writeln("Expected: " <& literal(expected));
      writeln("Found:    " <& literal(test));
      okay := FALSE;
    end if;

    close(aFile);
    removeFile(test_file_name);

    if okay then
      writeln("Automatic closing of files works.");
    else
      writeln(" ***** Automatic closing of files does not work.");
      writeln;
    end if;
  end func;


const func boolean: check_use_after_close1 (inout file: aFile) is func
  result
    var boolean: okay is TRUE;
  begin
    if not raisesFileError(writeln(aFile, "yxcvjhkjh")) then
      writeln("Write to a closed file succeeds.");
      okay := FALSE;
    end if;
    if not raisesFileError(length(aFile)) then
      writeln("Length of a closed file succeeds.");
      okay := FALSE;
    end if;
    if not raisesFileError(bigLength(aFile)) then
      writeln("BigLength of a closed file succeeds.");
      okay := FALSE;
    end if;
    if not raisesFileError(seekable(aFile)) then
      writeln("Seekable of a closed file succeeds.");
      okay := FALSE;
    end if;
    if not raisesFileError(tell(aFile)) then
      writeln("Tell of a closed file succeeds.");
      okay := FALSE;
    end if;
    if not raisesFileError(bigTell(aFile)) then
      writeln("BigTell of a closed file succeeds.");
      okay := FALSE;
    end if;
    if not raisesFileError(seek(aFile, 10)) then
      writeln("Seek of a closed file succeeds.");
      okay := FALSE;
    end if;
    if not raisesFileError(seek(aFile, 10_)) then
      writeln("Seek of a closed file succeeds.");
      okay := FALSE;
    end if;
    if not raisesFileError(truncate(aFile, 5)) then
      writeln("Truncate of a closed file succeeds.");
      okay := FALSE;
    end if;
    if not raisesFileError(flush(aFile)) then
      writeln("Flush of a closed file succeeds.");
      okay := FALSE;
    end if;
  end func;


const func boolean: check_use_after_close2 (inout file: aFile) is func
  result
    var boolean: okay is TRUE;
  begin
    if not raisesFileError(length(aFile)) then
      writeln("Length of a closed file succeeds.");
      okay := FALSE;
    end if;
    if not raisesFileError(bigLength(aFile)) then
      writeln("BigLength of a closed file succeeds.");
      okay := FALSE;
    end if;
    if not raisesFileError(seekable(aFile)) then
      writeln("Seekable of a closed file succeeds.");
      okay := FALSE;
    end if;
    if not raisesFileError(tell(aFile)) then
      writeln("Tell of a closed file succeeds.");
      okay := FALSE;
    end if;
    if not raisesFileError(bigTell(aFile)) then
      writeln("BigTell of a closed file succeeds.");
      okay := FALSE;
    end if;
    if not raisesFileError(seek(aFile, 7)) then
      writeln("Seek of a closed file succeeds.");
      okay := FALSE;
    end if;
    if not raisesFileError(seek(aFile, 7_)) then
      writeln("Seek of a closed file succeeds.");
      okay := FALSE;
    end if;
    if not raisesFileError(truncate(aFile, 5)) then
      writeln("Truncate of a closed file succeeds.");
      okay := FALSE;
    end if;
    if not raisesFileError(hasNext(aFile)) then
      writeln("HasNext of a closed file succeeds.");
      okay := FALSE;
    end if;
    if not raisesFileError(inputReady(aFile)) then
      writeln("InputReady of a closed file succeeds.");
      okay := FALSE;
    end if;
    if not raisesFileError(eof(aFile)) then
      writeln("Eof of a closed file succeeds.");
      okay := FALSE;
    end if;
    if not raisesFileError(getc(aFile)) then
      writeln("Getc from a closed file succeeds.");
      okay := FALSE;
    end if;
    if not raisesFileError(gets(aFile, 2)) then
      writeln("Gets from a closed file succeeds.");
      okay := FALSE;
    end if;
    if not raisesFileError(getwd(aFile)) then
      writeln("Getwd from a closed file succeeds.");
      okay := FALSE;
    end if;
    if not raisesFileError(getln(aFile)) then
      writeln("Getln from a closed file succeeds.");
      okay := FALSE;
    end if;
  end func;


const proc: check_use_after_close is func
  local
    var boolean: okay is TRUE;
    var string: test_file_name is "";
    var file: aFile is STD_NULL;
  begin
    repeat
      test_file_name := homeDir <& "/tmp_test_file_" <& rand(0, 999) lpad0 3;
    until fileType(test_file_name) = FILE_ABSENT;

    aFile := open(test_file_name, "w");
    writeln(aFile, "asdfasdfsdf");

    close(aFile);
    if not check_use_after_close1(aFile) then
      okay := FALSE;
    end if;

    aFile := open(test_file_name, "r");
    if gets(aFile, 6) <> "asdfas" then
      writeln("Reading from the test file failed.");
      okay := FALSE;
    end if;

    close(aFile);
    if not check_use_after_close2(aFile) then
      okay := FALSE;
    end if;

    removeFile(test_file_name);

    if okay then
      writeln("File operations with a closed file fail as they should.");
    else
      writeln(" ***** File operations with a closed file do not fail.");
      writeln;
    end if;
  end func;


const proc: check_utf8_file_open is func
  local
    var boolean: okay is TRUE;
    var file: aFile is STD_NULL;
  begin
    if not raisesRangeError(openUtf8("asdf\0;asdf", "r")) then
      writeln("Open UTF-8 file with null byte in file name succeeds.");
      okay := FALSE;
    end if;
    if  not raisesRangeError(openUtf8("asdf", "r-")) or
        not raisesRangeError(openUtf8("asdf", "z")) then
      writeln("Open UTF-8 file with illegal mode.");
      okay := FALSE;
    end if;
    if raisesRangeError(aFile := openUtf8("asdf", "r+")) then
      writeln("Cannot open UTF-8 file with mode \"r+\".");
      okay := FALSE;
    else
      close(aFile);
    end if;
    if raisesRangeError(aFile := openUtf8("asdf", "rt")) then
      writeln("Cannot open UTF-8 file with mode \"rt\".");
      okay := FALSE;
    else
      close(aFile);
    end if;
    if raisesRangeError(aFile := openUtf8("asdf", "rt+")) then
      writeln("Cannot open UTF-8 file with mode \"rt+\".");
      okay := FALSE;
    else
      close(aFile);
    end if;
    if raisesRangeError(openUtf8("asdfasdf\16#10FFFF;asdfasdf", "r")) then
      writeln("Open UTF-8 file with Unicode character in file name fails.");
      okay := FALSE;
    end if;
    if not raisesRangeError(openUtf8("asdfasdf\16#110000;asdfasdf", "r")) then
      writeln("Open UTF-8 file with non-Unicode character in file name succeeds.");
      okay := FALSE;
    end if;

    if okay then
      writeln("Open an UTF-8 file does work correctly.");
    else
      writeln(" ***** Open an UTF-8 file does not work correctly");
      writeln;
    end if;
  end func;


const proc: check_utf8_io is func
  local
    var boolean: okay is TRUE;
    var file: aFile is STD_NULL;
    var string: stri is "";
  begin
    okay := TRUE;
    aFile := openUtf8("qwerty", "r");
    if aFile = STD_NULL then
      aFile := openUtf8("qwerty", "w");
      if aFile <> STD_NULL then
        writeln(aFile, "qwertyuiop");
        close(aFile);
        aFile := openUtf8("qwerty", "r");
        if aFile <> STD_NULL then
          read(aFile, stri);
          if stri <> "qwertyuiop" then
            writeln("read(file, string) does not work correctly. (4)");
            okay := FALSE;
          end if;
          seek(aFile, 1);
          stri := getTerminatedString(aFile, 'y');
          if stri <> "qwert" or aFile.bufferChar <> 'y' then
            writeln("getTerminatedString(file, terminator) does not work correctly. (4)");
            okay := FALSE;
          end if;
          seek(aFile, 1);
          stri := getln(aFile);
          if stri <> "qwertyuiop" or aFile.bufferChar <> '\n' then
            writeln("getln(file) does not work correctly. (4)");
            okay := FALSE;
          end if;
          seek(aFile, 1);
          stri := getwd(aFile);
          if stri <> "qwertyuiop" or aFile.bufferChar <> '\n' then
            writeln("getwd(file) does not work correctly. (4)");
            okay := FALSE;
          end if;
          seek(aFile, 1);
          stri := gets(aFile, 10);
          if stri <> "qwertyuiop" then
            writeln("gets(file, 10) does not work correctly. (4)");
            okay := FALSE;
          end if;
          seek(aFile, 1);
          stri := gets(aFile, 999999999);
          if stri <> "qwertyuiop\n" then
            writeln("gets(file, 999999999) does not work correctly. (5)");
            okay := FALSE;
          end if;
          if length(aFile) <> 11 then
            writeln("length(aFile) returns " <& length(aFile) <& " instead of 11. (3)");
            okay := FALSE;
          end if;
          if bigLength(aFile) <> 11_ then
            writeln("bigLength(aFile) returns " <& bigLength(aFile) <& " instead of 11. (3)");
            okay := FALSE;
          end if;
          close(aFile);
        else
          writeln(" ***** Could not openUtf8 file \"qwerty\" for reading");
        end if;
        removeFile("qwerty");

        if okay then
          writeln("Utf-8 file I/O does work correctly.");
        else
          writeln(" ***** File I/O does not work correctly");
          writeln;
        end if;

      else
        writeln(" ***** Could not openUtf8 file \"qwerty\" for writing");
      end if;
    else
      writeln(" ***** File \"qwerty\" already exists");
      close(aFile);
    end if;
  end func;


const proc: check_utf8_seek is func
  local
    var boolean: okay is TRUE;
    var file: aFile is STD_NULL;
    var string: stri is "";
  begin
    okay := TRUE;
    aFile := openUtf8("qwerty", "r");
    if aFile = STD_NULL then
      aFile := openUtf8("qwerty", "w");
      if aFile <> STD_NULL then
        writeln(aFile, "qwertyuiop");
        seek(aFile, END_MARKER_POS);
        writeln(aFile, SEEK_TEST_END_MARKER);
        close(aFile);
        aFile := openUtf8("qwerty", "r");
        if aFile <> STD_NULL then
          # stri := gets(aFile, 10);
          # stri := gets(aFile, 67076095); # okay           with bcc32
          # stri := gets(aFile, 67076096); # errno = EINVAL with bcc32
            stri := gets(aFile, 100000000);
          # stri := gets(aFile, 268435456);
          # stri := gets(aFile, 378000000);
          # stri := gets(aFile, 536870912);
          # for num range 1 to 26843545 do
          #   stri := gets(aFile, 10);
          # end for;
          if stri[.. 6] <> "qwerty" then
            writeln("gets(file, 536870912) does not work correctly.");
            TRACE_OBJ(stri);
            writeln;
            okay := FALSE;
          end if;
          stri := "";
          seek(aFile, END_MARKER_POS);
          read(aFile, stri);
          if stri <> "this" then
            writeln("read(file, string) after seek does not work correctly.");
            okay := FALSE;
          end if;
          seek(aFile, END_MARKER_POS);
          stri := getTerminatedString(aFile, 'e');
          if stri <> "this is th" or aFile.bufferChar <> 'e' then
            writeln("getTerminatedString(file, terminator) after seek does not work correctly.");
            okay := FALSE;
          end if;
          seek(aFile, END_MARKER_POS);
          stri := getln(aFile);
          if stri <> SEEK_TEST_END_MARKER or aFile.bufferChar <> '\n' then
            writeln("getln(file) after seek does not work correctly.");
            okay := FALSE;
          end if;
          seek(aFile, END_MARKER_POS);
          stri := getwd(aFile);
          if stri <> "this" or aFile.bufferChar <> ' ' then
            writeln("getwd(file) after seek does not work correctly.");
            okay := FALSE;
          end if;
          seek(aFile, END_MARKER_POS);
          stri := gets(aFile, 15);
          if stri <> SEEK_TEST_END_MARKER then
            writeln("gets(file, 15) after seek does not work correctly.");
            okay := FALSE;
          end if;
          seek(aFile, END_MARKER_POS);
          stri := gets(aFile, 999999999);
          if stri <> SEEK_TEST_END_MARKER & "\n" then
            writeln("gets(file, 999999999) does not work correctly. (6)");
            okay := FALSE;
          end if;
          if length(aFile) <> SEEK_TEST_FILE_SIZE then
            writeln("length(aFile) returns " <& length(aFile) <&
                    " instead of " <& SEEK_TEST_FILE_SIZE <& ". (2)");
            okay := FALSE;
          end if;
          if bigLength(aFile) <> bigInteger(SEEK_TEST_FILE_SIZE) then
            writeln("bigLength(aFile) returns " <& bigLength(aFile) <&
                    " instead of " <& SEEK_TEST_FILE_SIZE <& ". (2)");
            okay := FALSE;
          end if;
          close(aFile);
        else
          writeln(" ***** Could not openUtf8 file \"qwerty\" for reading");
        end if;
        removeFile("qwerty");

        if okay then
          writeln("Utf-8 file seek does work correctly.");
        else
          writeln(" ***** File seek does not work correctly");
          writeln;
        end if;

      else
        writeln(" ***** Could not openUtf8 file \"qwerty\" for writing");
      end if;
    else
      writeln(" ***** File \"qwerty\" already exists");
      close(aFile);
    end if;
  end func;


const proc: check_automatic_close_utf8 is func
  local
    var boolean: okay is TRUE;
    var string: test_file_name is "";
    var file: aFile is STD_NULL;
    var integer: number is 0;
    var char: ch is ' ';
    var string: expected is "";
    var string: test is "";
  begin
    repeat
      test_file_name := homeDir <& "/tmp_test_file_" <& rand(0, 999) lpad0 3;
    until fileType(test_file_name) = FILE_ABSENT;

    aFile := openUtf8(test_file_name, "w");
    for number range 0 to 5000 do
      if number mod 192 < 96 then
        ch := char(32 + number mod 192);
      else
        ch := char(64 + number mod 192);
      end if;
      # The assignment of the new file should close the old file automatically.
      # If automatic closing fails the upper limit of open files is reached.
      # In this case openUtf8() returns STD_NULL and test <> expected will fail.
      aFile := openUtf8(test_file_name, "a");
      write(aFile, ch);
      expected &:= ch;
    end for;

    aFile := openUtf8(test_file_name, "r");
    test := gets(aFile, integer.last);
    if test <> expected then
      writeln("The file does not contain the expected string.");
      writeln("Expected: " <& literal(expected));
      writeln("Found:    " <& literal(test));
      okay := FALSE;
    end if;

    close(aFile);
    removeFile(test_file_name);

    if okay then
      writeln("Automatic closing of UTF-8 files works.");
    else
      writeln(" ***** Automatic closing of UTF-8 files does not work.");
      writeln;
    end if;
  end func;


const proc: check_use_after_close_utf8 is func
  local
    var boolean: okay is TRUE;
    var string: test_file_name is "";
    var file: aFile is STD_NULL;
  begin
    repeat
      test_file_name := homeDir <& "/tmp_test_file_" <& rand(0, 999) lpad0 3;
    until fileType(test_file_name) = FILE_ABSENT;

    aFile := openUtf8(test_file_name, "w");
    writeln(aFile, "asdfasdfsdf");

    close(aFile);
    if not check_use_after_close1(aFile) then
      okay := FALSE;
    end if;

    aFile := openUtf8(test_file_name, "r");
    if gets(aFile, 6) <> "asdfas" then
      writeln("Reading from the test file failed.");
      okay := FALSE;
    end if;

    close(aFile);
    if not check_use_after_close2(aFile) then
      okay := FALSE;
    end if;

    removeFile(test_file_name);

    if okay then
      writeln("File operations with a closed UTF-8 file fail as they should.");
    else
      writeln(" ***** File operations with a closed UTF-8 file do not fail.");
      writeln;
    end if;
  end func;


const type: myFile is sub null_file struct
    var string: line is "";
  end struct;


const func file: openMyFile is func
  result
    var file: newFile is STD_NULL;
  local
    var myFile: new_myFile is myFile.value;
  begin
    newFile := toInterface(new_myFile);
  end func;


const proc: write (inout myFile: outFile, in string: stri) is func
  begin
    outFile.line &:= stri;
  end func;


const proc: check_my_file is func
  local
    var file: aFile is STD_NULL;
  begin
    aFile := openMyFile;
    write(aFile, "test");
  end func;


const proc: check_null_file is func
  local
    var boolean: okay is TRUE;
    var file: aFile is STD_NULL;
  begin
    writeln(aFile, "test");
    if getc(aFile) <> EOF then
      writeln("getc(aFile) does not work correctly, if aFile = STD_NULL holds.");
      okay := FALSE;
    end if;
    if getc(STD_NULL) <> EOF then
      writeln("getc(STD_NULL) does not work correctly.");
      okay := FALSE;
    end if;
    if gets(aFile, 10) <> "" then
      writeln("gets(aFile) does not work correctly, if aFile = STD_NULL holds.");
      okay := FALSE;
    end if;
    if gets(STD_NULL, 10) <> "" then
      writeln("gets(STD_NULL) does not work correctly.");
      okay := FALSE;
    end if;
    writeln(aFile, "hello");
    writeln(STD_NULL, "hello");

    STD_NULL := STD_IN;

    aFile := STD_NULL;
    if getc(aFile) <> EOF then
      writeln("getc(aFile) does not work correctly, if aFile = STD_NULL holds.");
      okay := FALSE;
    end if;
    if getc(STD_NULL) <> EOF then
      writeln("getc(STD_NULL) does not work correctly.");
      okay := FALSE;
    end if;
    if gets(aFile, 10) <> "" then
      writeln("gets(aFile) does not work correctly, if aFile = STD_NULL holds.");
      okay := FALSE;
    end if;
    if gets(STD_NULL, 10) <> "" then
      writeln("gets(STD_NULL) does not work correctly.");
      okay := FALSE;
    end if;
    writeln(aFile, "hello");
    writeln(STD_NULL, "hello");

    STD_NULL := STD_OUT;

    aFile := STD_NULL;
    if getc(aFile) <> EOF then
      writeln("getc(aFile) does not work correctly, if aFile = STD_NULL holds.");
      okay := FALSE;
    end if;
    if getc(STD_NULL) <> EOF then
      writeln("getc(STD_NULL) does not work correctly.");
      okay := FALSE;
    end if;
    if gets(aFile, 10) <> "" then
      writeln("gets(aFile) does not work correctly, if aFile = STD_NULL holds.");
      okay := FALSE;
    end if;
    if gets(STD_NULL, 10) <> "" then
      writeln("gets(STD_NULL) does not work correctly.");
      okay := FALSE;
    end if;
    writeln(aFile, "hello");
    writeln(STD_NULL, "hello");

    if okay then
      writeln("STD_NULL does work correctly.");
    else
      writeln(" ***** STD_NULL does not work correctly");
      writeln;
    end if;
  end func;


const proc: check_keybd_and_console is func
  local
    var file: stdIn is STD_IN;
    var file: stdOut is STD_OUT;
    var file: stdErr is STD_ERR;
    var file: utf8In is STD_UTF8_IN;
    var file: utf8Out is STD_UTF8_OUT;
    var file: utf8Err is STD_UTF8_ERR;
    var text: consoleFile is STD_CONSOLE;
    var keyboard_file: consoleKeyboard is CONSOLE_KEYBOARD;
    var keyboard_file: graphKeyboard is GRAPH_KEYBOARD;
    var keyboard_file: keyboard is KEYBOARD;
  begin
    noop;
  end func;


const proc: main is func

  begin
    writeln;
    check_clib_file;
    check_clib_file_assign;
    check_file_assign;
    check_file_open;
    check_file_io;
    check_file_seek;
    check_automatic_close;
    check_use_after_close;
    check_utf8_file_open;
    check_utf8_io;
    check_utf8_seek;
    check_automatic_close_utf8;
    check_use_after_close_utf8;
    check_my_file;
    check_null_file;
    check_keybd_and_console;
  end func;
