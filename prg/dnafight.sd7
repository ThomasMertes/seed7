
(********************************************************************)
(*                                                                  *)
(*  dnafight.sd7  Bacterial dna fight programming game              *)
(*  Copyright (C) 1985, 1986, 2005  Thomas Mertes                   *)
(*  Copyright (C) 1985, 1986,       Markus Stumptner                *)
(*  Copyright (C) 1985, 1986, 1991  Johannes Gritsch                *)
(*                                                                  *)
(*  This program is free software; you can redistribute it and/or   *)
(*  modify it under the terms of the GNU General Public License as  *)
(*  published by the Free Software Foundation; either version 2 of  *)
(*  the License, or (at your option) any later version.             *)
(*                                                                  *)
(*  This program is distributed in the hope that it will be useful, *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of  *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *)
(*  GNU General Public License for more details.                    *)
(*                                                                  *)
(*  You should have received a copy of the GNU General Public       *)
(*  License along with this program; if not, write to the Free      *)
(*  Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,  *)
(*  MA 02111-1307 USA                                               *)
(*                                                                  *)
(********************************************************************)


$ include "seed7_05.s7i";
  include "window.s7i";
  include "keybd.s7i";
  include "float.s7i";
  include "graph.s7i";
  include "draw.s7i";
  include "field.s7i";
  include "dna_base.s7i";

  include "white.dna";
  include "violet.dna";
  include "indigo.dna";
  include "blue.dna";
  include "green.dna";
  include "orange.dna";
  include "red.dna";
  include "tan.dna";


const string:   Version     is   "5.3";

var text: scr is STD_NULL;
var text: field is STD_NULL;
var text: INFO is STD_NULL;
var text: STAT is STD_NULL;
var text: FSTAT is STD_NULL;

const integer:  MAX_LINE    is      21;
const integer:  MAX_COLUMN  is      21;
const integer:  XMAX        is      21;
const integer:  YMAX        is      21;

const type: xcoordinate is subtype integer; (* 0 .. XMAX *)
const type: ycoordinate is subtype integer; (* 0 .. YMAX *)

const type: bacterium is new struct
    var xcoordinate: xpos is 0;
    var ycoordinate: ypos is 0;
    var lifeSpan:    hungry is 0;
    var power:       mass is 0;
  end struct;

const type: microbe is varptr bacterium;

const type: position is new struct
    var COLOUR:  content is CLEAR;
    var power:   meal is 0;
    var microbe: possessor is microbe.NIL;
  end struct;

var array array position: area is XMAX + 2 times YMAX + 2 times position.value;
var array microbe: animates is 0 times microbe.NIL;
var array microbe: children is 0 times microbe.NIL;
var xcoordinate: x is 0;
var ycoordinate: y is 0;
var boolean: done is FALSE;

const type: killReason is new enum
    KNoReason, KEdge, KHunger, KWhite, KViolet, KIndigo, KBlue, KCyan,
    KGreen, KYellow, KAmber, KOrange, KRed, KScarlet, KTan, KLilac, KPink,
    KWrMove, KBigMouth, KSuicide, KFnotEmpty
  end enum;

const string: str (KEdge) is      "Edge";
const string: str (KHunger) is    "Hunger";
const string: str (KWrMove) is    "WrMove";
const string: str (KBigMouth) is  "Big M.";
const string: str (KSuicide) is   "Suic";
const string: str (KFnotEmpty) is "F.n.e";
const string: str (KWhite) is     str(WHITE);
const string: str (KViolet) is    str(VIOLET);
const string: str (KIndigo) is    str(INDIGO);
const string: str (KBlue) is      str(BLUE);
const string: str (KCyan) is      str(CYAN);
const string: str (KGreen) is     str(GREEN);
const string: str (KYellow) is    str(YELLOW);
const string: str (KAmber) is     str(AMBER);
const string: str (KOrange) is    str(ORANGE);
const string: str (KRed) is       str(RED);
const string: str (KScarlet) is   str(SCARLET);
const string: str (KTan) is       str(TAN);
const string: str (KLilac) is     str(LILIAC);
const string: str (KPink) is      str(PINK);

const func string: str (in killReason param) is DYNAMIC;

enable_output(killReason);

const type: statRecord is new struct
    var integer: accno is 0;
    var integer: accmass is 0;
    var integer: deathtime is 0;
    var integer: totalno is 0;
    var integer: totalmass is 0;
  end struct;

var array [COLOUR] array [boolean] statRecord: statValues is
    COLOUR times boolean times statRecord.value;

var array [COLOUR] array [killReason] integer: killarray is
    COLOUR times killReason times 0;

const array [COLOUR] killReason: REASON is [COLOUR] (
    KNoReason, KNoReason, KWhite, KViolet, KIndigo, KBlue, KCyan,
    KGreen, KYellow, KAmber, KOrange, KRed, KScarlet, KTan,
    KLilac, KPink
  );

const integer: STATTIME is 1;     (* Interval of Statistics *)

const integer: STRETCH_FACTOR is 2;

var integer: genNr is 0;

const color: statCol is white;   (* Colour for statistics *)

const color: display_color (EDGE) is    white;
const color: display_color (CLEAR) is   white;

const color: display_color (WHITE) is   white;
const color: display_color (VIOLET) is  dark_magenta;
const color: display_color (INDIGO) is  white;
const color: display_color (BLUE) is    light_blue;
const color: display_color (CYAN) is    dark_cyan;
const color: display_color (GREEN) is   light_green;
const color: display_color (YELLOW) is  yellow;
const color: display_color (AMBER) is   amber;
const color: display_color (ORANGE) is  orange;
const color: display_color (RED) is     light_red;
const color: display_color (SCARLET) is dark_red;
const color: display_color (TAN) is     brown;
const color: display_color (LILIAC) is  light_magenta;
const color: display_color (PINK) is    pink;

const func color: display_color (in COLOUR param) is DYNAMIC;

const func char: upper_char (in COLOUR: aColour) is
  return [] (
    ' ', ' ', 'W', 'V', 'I', 'B', 'C',
    'G', 'Y', 'A', 'O', 'R', 'S', 'T',
    'L', 'P'
  )[succ(ord(aColour))];

const func char: lower_char (in COLOUR: aColour) is
  return [] (
    ' ', ' ', 'w', 'v', 'i', 'b', 'c',
    'g', 'y', 'a', 'o', 'r', 's', 't',
    'l', 'p'
  )[succ(ord(aColour))];

const color: stdTextCol   is white;     (* Colour of Text *)
const color: stdBackGrCol is dark_blue; (* Colour of BackGround *)
const char: emptyarea     is '.';       (* indicating Clear area with food *)

var array file: fieldWin is 3 times STD_NULL;


const array [direction] integer: diffx is [direction] (
    0, -1,  1,  0,  0, -1, -1,  1,  1);
const array [direction] integer: diffy is [direction] (
    0,  0,  0, -1,  1, -1,  1, -1,  1);


var COLOURSET: playerSet is COLOURSET.EMPTY_SET;


const proc: resetStat (in COLOUR: species) is func

  begin (* resetStat *)
(*! statValues[species][FALSE].accno:= 0;
    statValues[species][FALSE].accmass:= 0; *)
    noop;
  end func; (* resetStat *)


const proc: incrKillStat (in COLOUR: content, in killReason: Killer) is func

  begin (* incrKillStat *)
    incr(killarray[content][Killer]);
  end func; (* incrKillStat *)


const func boolean: continue (GAME) is func
  result
    var boolean: result is FALSE;

  local
    var char: c is ' ';

  begin (* continue (GAME) *)
    setPos(STAT, 34, 1);
    color(STAT, statCol);
    write(STAT, " Once more (y/n) ?                 ");
    setPos(STAT, 34, 21);
    repeat
      c := upper(getc(KEYBOARD));
    until c = 'Y' or c = 'N';
    setPos(STAT, 34, 1);
    result := c = 'Y';
  end func; (* continue (GAME) *)


const proc: setclass (in xcoordinate: sx, in ycoordinate: sy,
    in COLOUR: sclass, in boolean: small) is func

  begin (* setclass *)
    color(field, display_color(sclass));
    setPos(field, sx - 1, 2 * sy - 2);
    if sclass = CLEAR then
      if area[sx][sy].meal = 0 then
        field << ' ';
      else
        field << emptyarea;
      end if;
    else
      if small then
        field << lower_char(sclass);
      else
        field << upper_char(sclass);
      end if;
    end if;
  end func; (* setclass *)


const proc: writeParameters (in integer: initSize,
    in integer: foodReserve, in integer: shrinkage) is func

  begin (* writeParameters *)
    setPos(INFO, 1, 1);
    writeln(INFO, "Isize "     <& initSize    lpad 5);
    writeln(INFO, "Foodr "     <& foodReserve lpad 5);
    writeln(INFO, "Shrinkage " <& shrinkage   lpad 3 <& "%");
  end func; (* writeParameters *)


const proc: writeInfo (in integer: line, in integer: column) is func

  local
    var COLOUR: species is CLEAR;

  begin (* writeInfo *)
    color(INFO, white, dark_blue);
    clear(INFO);
    writeParameters(initSize, foodReserve, shrinkage);
    writeln(INFO, "Position " <& line lpad 2 <& " " <& column lpad 2);
    species := area[succ(line)][succ(column)].content;
    write(INFO, species);
    if species <> EDGE and species <> CLEAR then
      if area[succ(line)][succ(column)].possessor <> microbe.NIL then
        write(INFO, " of size ");
        write(INFO, area[succ(line)][succ(column)].possessor->mass);
      end if;
    end if;
    writeln(INFO);
    write(INFO, "Meal ");
    write(INFO, area[succ(line)][succ(column)].meal);
  end func; (* writeInfo *)


const proc: initScreen is func

  local
    var integer: line is 0;
    const string: DOT_LINE is " ." mult YMAX & " ";

  begin (* initScreen *)
    field := open_window(scr, 3, 2, XMAX, 2 * YMAX + 1);
    INFO := open_window(scr, 2, 48, 34, 58);
    STAT := INFO;
    FSTAT := INFO;
    color(scr, white, dark_blue);
    box(field);
    box(INFO);
    writeInfo(1, 1);
    for line range 1 to pred(XMAX) do
      writeln(field, DOT_LINE);
    end for;
    write(field, DOT_LINE);
    setPos(scr, 25, 1);
    color(scr, black, dark_cyan);
    write(scr, " F1 ");
    color(scr, white, black);
    write(scr, " brings bacteria to life ");

    setPos(scr, 27, 2);
    color(scr, white, stdBackGrCol);
    write(scr, " W White   ");
    color(scr, dark_magenta, stdBackGrCol);
    write(scr, " V Violet  ");
    color(scr, white, stdBackGrCol);
    write(scr, " I Indigo  ");
    color(scr, light_blue, stdBackGrCol);
    write(scr, " B Blue   ");
    setPos(scr, 28, 2);
    color(scr, dark_cyan, stdBackGrCol);
    write(scr, " C Cyan    ");
    color(scr, light_green, stdBackGrCol);
    write(scr, " G Green   ");
    color(scr, yellow, stdBackGrCol);
    write(scr, " Y Yellow  ");
    color(scr, amber, stdBackGrCol);
    write(scr, " Y Amber  ");
    setPos(scr, 29, 2);
    color(scr, orange, stdBackGrCol);
    write(scr, " O Orange  ");
    color(scr, light_red, stdBackGrCol);
    write(scr, " R Red     ");
    color(scr, dark_red, stdBackGrCol);
    write(scr, " S Scarlet ");
    color(scr, brown, stdBackGrCol);
    write(scr, " T Tan    ");
    setPos(scr, 30, 2);
    color(scr, light_magenta, stdBackGrCol);
    write(scr, " L Lilac   ");
    color(scr, pink, stdBackGrCol);
    write(scr, " P Pink    ");
    write(scr, "           ");
    write(scr, "          ");

    setPos(scr, 1, 1);
    color(scr, stdTextCol, stdBackGrCol)
  end func; (* initScreen *)


const proc: readLimits is func

  local
    var integer: currWin is 1;
    var array integer: intValue is 3 times 10;
    var boolean: leave is FALSE;

  begin (* readLimits *)
    intValue[1] := initSize;
    intValue[2] := foodReserve;
    intValue[3] := shrinkage;
    leave := FALSE;
    currWin:= 1;
    repeat
      read(fieldWin[currWin], intValue[currWin]);
      case fieldWin[currWin].bufferChar of
        when {KEY_TAB, KEY_DOWN}:
          writeParameters(intValue[1], intValue[2], intValue[3]);
          incr(currWin);
          if currWin = 4 then
            currWin := 1;
          end if;
        when {KEY_BACKTAB, KEY_UP}:
          writeParameters(intValue[1], intValue[2], intValue[3]);
          decr(currWin);
          if currWin = 0 then
            currWin := 3;
          end if;
        when {KEY_NL}:
          initSize    := intValue[1];
          foodReserve := intValue[2];
          shrinkage   := intValue[3];
          leave := TRUE;
        when {KEY_ESC}:
          leave := TRUE;
      end case;
(*
      write(intValue[1]); write(" "); write(intValue[2]); write(" "); write(intValue[3]); write("  ");
      write(initSize); write(" "); write(foodReserve); write(" "); writeln(shrinkage);
*)
    until leave;
  end func; (* readLimits *)


const func COLOUR: charCol (in char: ch) is func
  result
    var COLOUR: result is CLEAR;

  begin (* charCol *)
    case upper(ch) of
      when {' '}: result:= CLEAR;
      when {'.'}: result:= CLEAR;
      when {'W'}: result:= WHITE;
      when {'V'}: result:= VIOLET;
      when {'I'}: result:= INDIGO;
      when {'B'}: result:= BLUE;
      when {'C'}: result:= CYAN;
      when {'G'}: result:= GREEN;
      when {'Y'}: result:= YELLOW;
      when {'A'}: result:= AMBER;
      when {'O'}: result:= ORANGE;
      when {'R'}: result:= RED;
      when {'S'}: result:= SCARLET;
      when {'T'}: result:= TAN;
      when {'L'}: result:= LILIAC;
      when {'P'}: result:= PINK
      otherwise: result := EDGE;
    end case;
  end func; (* charCol *)


const func char: readCommand (in integer: line, in integer: column) is func
  result
    var char: command is ' ';

  begin
    writeInfo(line, column);
    setPos(field, line, STRETCH_FACTOR * pred(column) + 3);
    field << ">";
    setPos(field, line, STRETCH_FACTOR * pred(column) + 1);
    field << "<";
    command := getc(KEYBOARD);
    setPos(field, line, STRETCH_FACTOR * pred(column) + 3);
    field << " ";
    setPos(field, line, STRETCH_FACTOR * pred(column) + 1);
    field << " ";
  end func;


const proc: InitAnimates is func

  local
    var integer: ix is 0;
    var integer: iy is 0;
    var integer: line is 1;
    var integer: column is 1;
    var char: command is ' ';
    var COLOUR: species is CLEAR;

  begin (* InitAnimates *)
    color(field, statCol);
    playerSet:= COLOURSET.EMPTY_SET;
    animates:= 0 times microbe.value;
    setPos(field, 3, 4);
    command := readCommand(line, column);
    while command <> 'q' and command <> KEY_F1 do
      case command of
        when {'2', KEY_DOWN}:
          if line < MAX_LINE then
            incr(line);
          else
            line := 1;
          end if;
        when {'8', KEY_UP}:
          if line > 1 then
            decr(line);
          else
            line := MAX_LINE;
          end if;
        when {'6', KEY_RIGHT}:
          if column < MAX_COLUMN then
            incr(column);
          else
            column := 1;
          end if;
        when {'4', KEY_LEFT}:
          if column > 1 then
            decr(column);
          else
            column := MAX_COLUMN;
          end if;
        when {'7', KEY_HOME}:
          line := 1;
          column := 1;
        when {'1', KEY_END}:
          line := MAX_LINE;
          column := MAX_COLUMN;
        when {KEY_TAB}:
          column := MAX_COLUMN;
        when {KEY_NL}:
          if line = MAX_LINE then
            column := 1;
          else
            incr(line);
            column := 1;
          end if;
        when {KEY_ESC}:
          readLimits;
        otherwise:
          species := charCol(command);
          if species <> EDGE then
            area[succ(line)][succ(column)].content := species;
            if command = '.' then
              field << emptyarea;
            else
              field << upper(command);
            end if;
          end if;
      end case;
      command := readCommand(line, column);
    end while;
  end func; (* InitAnimates *)


const proc: initDisplay is func

  begin (* initDisplay *)
    fieldWin[1] := open_field(KEYBOARD, INFO, 1,  7, 5, "   10");
    fieldWin[2] := open_field(KEYBOARD, INFO, 2,  7, 5, "   10");
    fieldWin[3] := open_field(KEYBOARD, INFO, 3, 11, 3, " 10");
(*
    color(scr, stdTextCol, stdBackGrCol);
    clear(scr);
*)
  end func; (* initDisplay *)


const func integer: min (in integer: a, in integer: b) is func
  result
    var integer: result is 0;

  begin (* min *)
    if a < b then
      result := a;
    else
      result := b;
    end if;
  end func; (* min *)


const func integer: max (in integer: a, in integer: b) is func
  result
    var integer: result is 0;

  begin (* max *)
    if a > b then
      result := a;
    else
      result := b;
    end if;
  end func; (* max *)


const func direction: ranDir (in directSet: dirset) is func
  result
    var direction: result is HERE;

  local
    var integer: number is 0;
    var direction: direct is HERE;

  begin (* ranDir *)
    if dirset <> directSet.EMPTY_SET then
      number := rand(1, card(dirset));
      for direct range HERE to SE do
        if direct in dirset then
          decr(number);
          if number = 0 then
            result := direct;
          end if;
        end if;
      end for;
    end if;
  end func; (* ranDir *)


const func power: shrinkSize (in power: size) is func
  result
    var power: result is 0;

  begin (* shrinkSize *)
    if size <> 0 then
      result := succ((pred(size) * shrinkage) div 100);
    end if;
  end func; (* shrinkSize *)


const func power: nextSize (in power: ownSize, in power: foodMass,
    in lifeSpan: ownHunger) is func
  result
    var power: result is 0;

  local
    var power: shrinkext is 0;

  begin (* nextSize *)
    shrinkext := shrinkSize(ownSize);
    if foodMass >= shrinkext or ownHunger <> 0 then
      result := ownSize - shrinkext + foodMass;
    end if;
  end func; (* nextSize *)


const proc: initBacterium (inout bacterium: bact,
    in xcoordinate: cx, in ycoordinate: cy,
    in lifeSpan: ownHunger, in power: strength) is func

  begin (* initBacterium *)
    bact.xpos := cx;
    bact.ypos := cy;
    bact.hungry := ownHunger;
    bact.mass := strength;
  end func; (* initBacterium *)


const proc: create (in xcoordinate: cx, in ycoordinate: cy,
    inout array microbe: animates, in COLOUR: species,
    in lifeSpan: ownHunger, in power: strength) is func

  local
    var bacterium: bact is bacterium.value;

  begin (* create *)
    area[cx][cy].content := species;
    initBacterium(bact, cx, cy, ownHunger, strength);
    area[cx][cy].possessor := varalloc(bact);
    children &:= [] (area[cx][cy].possessor);
  end func; (* create *)


const proc: setBact (in xcoordinate: ix, in ycoordinate: iy, in COLOUR: species) is func

  begin (* setBact *)
    create(ix, iy, animates, species, MAXLIFESPAN, initSize);
    incl(playerSet, species);
    resetStat(species);
  end func; (* setBact *)


const proc: die (in xcoordinate: x, in ycoordinate: y, in killReason: killer) is func

  begin (* die *)
    if area[x][y].content <> CLEAR then
      area[x][y].meal +:= area[x][y].possessor->mass;
      area[x][y].possessor->mass := 0;
      area[x][y].possessor := microbe.NIL;
      incrKillStat(area[x][y].content, killer);
      area[x][y].content := CLEAR;
      setclass(x, y, CLEAR, FALSE);
    end if;
  end func; (* die *)


const proc: move (inout xcoordinate: old_x_pos, inout ycoordinate: old_y_pos,
    in direction: direct) is func

  local
    var xcoordinate: new_x_pos is 0;
    var ycoordinate: new_y_pos is 0;

  begin (* move *)
    new_x_pos := old_x_pos + diffx[direct];
    new_y_pos := old_y_pos + diffy[direct];
    if area[new_x_pos][new_y_pos].content = CLEAR then
      area[new_x_pos][new_y_pos].content :=
          area[old_x_pos][old_y_pos].content;
      area[new_x_pos][new_y_pos].possessor :=
          area[old_x_pos][old_y_pos].possessor;
      area[new_x_pos][new_y_pos].possessor->xpos := new_x_pos;
      area[new_x_pos][new_y_pos].possessor->ypos := new_y_pos;
      area[old_x_pos][old_y_pos].content := CLEAR;
      area[old_x_pos][old_y_pos].possessor := microbe.NIL;
      setclass(old_x_pos, old_y_pos, CLEAR, FALSE);
      setclass(new_x_pos, new_y_pos,
          area[new_x_pos][new_y_pos].content, FALSE);
      old_x_pos := new_x_pos;
      old_y_pos := new_y_pos;
    end if;
  end func; (* move *)


const proc: digest (in xcoordinate: x, in ycoordinate: y, in power: quantity) is func

  local
    var microbe: bact_1 is microbe.NIL;
    var power: shrinkext is 0;

  begin (* digest *)
    bact_1 := area[x][y].possessor;
    shrinkext := shrinkSize(bact_1->mass);
    if quantity < shrinkext then
      if bact_1->hungry = 0 or
          bact_1->mass - shrinkext + quantity <= 0 then
        die(x, y, KHunger);
      else
        bact_1->mass +:= quantity - shrinkext;
        area[x][y].meal -:= quantity;
        bact_1->hungry := min(pred(bact_1->mass), pred(bact_1->hungry));
      end if;
    else
      bact_1->mass +:= quantity - shrinkext;
      area[x][y].meal -:= quantity;
      bact_1->hungry := min(MAXLIFESPAN, pred(bact_1->mass));
    end if;
  end func; (* digest *)


const proc: eatat (in xcoordinate: x, in ycoordinate: y, in var power: quantity) is func

  begin (* eatat *)
    quantity := min(quantity, area[x][y].meal);
    if area[x][y].possessor->mass < quantity then
      die(x, y, KBigMouth)
    else
      digest(x, y, quantity)
    end if;
  end func; (* eatat *)


const func power: strength (in direction: direct) is func
  result
    var power: result is 0;
  local
    var microbe: possessor is microbe.NIL;

  begin (* strength *)
    possessor := area[x + diffx[direct]][y + diffy[direct]].possessor;
    if possessor <> microbe.NIL then
      result := possessor->mass;
    else
      result := 0;
    end if;
  end func; (* strength *)


const func COLOUR: view (in direction: direct) is func
  result
    var COLOUR: result is CLEAR;

  begin (* view *)
    result := area[x + diffx[direct]][y + diffy[direct]].content;
  end func; (* view *)


const func power: food (in direction: direct) is func
  result
    var power: result is 0;

  begin (* food *)
    result := area[x + diffx[direct]][y + diffy[direct]].meal;
  end func; (* food *)


const func lifeSpan: hunger is func
  result
    var lifeSpan: result is 0;

  begin (* hunger *)
    result := area[x][y].possessor->hungry;
  end func; (* hunger *)


const proc: doWait is func

  local
    var power: quantity is 0;

  begin (* doWait *)
    if not done then
      digest(x, y, quantity);
      done := TRUE;
    end if;
  end func; (* doWait *)


const proc: eat (in direction: direct, in power: quantity) is func

  begin (* eat *)
    if not done then
(*    write("eat("); write(direct); write(", "); write(quantity); writeln(");"); *)
      if area[x + diffx[direct]][y + diffy[direct]].content <> CLEAR and
          direct <> HERE then
        die(x, y, KFnotEmpty);
      elsif direct in {NW, NE, SW, SE} then
        die(x, y, KWrMove);
      else
        if direct = HERE then
          setclass(x, y, area[x][y].content, FALSE);
        else
          move(x, y, direct);
        end if;
        eatat(x, y, quantity);
      end if;
      done := TRUE;
    end if;
  end func; (* eat *)


const proc: kill (in direction: direct) is func

  local
    var xcoordinate: new_x is 0;
    var ycoordinate: new_y is 0;
    var power: quantity is 0;

  begin (* kill *)
    if not done then
(*    write("kill("); write(direct); write(", "); write(quantity); writeln(");"); *)
      if direct = HERE then
        die(x, y, KSuicide);
      elsif direct in {NW, NE, SW, SE} then
        die(x, y, KWrMove);
      elsif strength(direct) > strength(HERE) then
        die(x, y, KBigMouth);
      else
        new_x := x + diffx[direct];
        new_y := y + diffy[direct];
        case area[new_x][new_y].content of
          when {EDGE}:
            die(x, y, KEdge);
          when {CLEAR}:
            move(x, y, direct);
          otherwise:
            quantity := strength(direct);
            die(new_x, new_y, REASON[area[x][y].content]);
            move(x, y, direct);
            digest(x, y, quantity);
        end case;
      end if;
      done := TRUE;
    end if;
  end func; (* kill *)


const proc: split (in direction: direct, in power: quantity1, in power: quantity2) is func

  local
    var microbe: bact_1 is microbe.NIL;
    var xcoordinate: new_x is 0;
    var ycoordinate: new_y is 0;
    var COLOUR: species is CLEAR;
    var lifeSpan: hungry is 0;
    var power: strength is 0;

  begin (* split *)
    if not done then
(*    write("split("); write(direct); write(", "); write(quantity1); write(", "); write(quantity2); writeln(");"); *)
      bact_1 := area[x][y].possessor;
      new_x := x + diffx[direct];
      new_y := y + diffy[direct];
      if area[new_x][new_y].content = EDGE then
        die(x, y, KEdge);
      elsif direct in {HERE, NW, NE, SW, SE} then
        die(x, y, KWrMove);
      elsif area[new_x][new_y].content <> CLEAR then
        die(x, y, KFnotEmpty);
      elsif bact_1->mass <= 1 then
        die(x, y, KHunger);
      else
        species := view(HERE);
        setclass(x, y, species, TRUE);
        setclass(new_x, new_y, species, TRUE);
        hungry := min(bact_1->hungry, pred(bact_1->mass div 2));
        strength := bact_1->mass div 2;
        create(new_x, new_y, animates, species, hungry, strength);
        bact_1->hungry := min(bact_1->hungry, pred(bact_1->mass));
        bact_1->mass -:= strength;
        eatat(x, y, quantity1);
        eatat(new_x, new_y, quantity2);
      end if;
      done := TRUE
    end if;
  end func; (* split *)


const proc: initArea is func

  local
    var xcoordinate: x is 0;
    var ycoordinate: y is 0;
    var position: edgePosition is position.value;

  begin (* initArea *)
    edgePosition.content := EDGE;
    edgePosition.meal := 0;
    edgePosition.possessor := microbe.NIL;
    for x range 1 to XMAX + 2 do
      area[x][1] := edgePosition;
      area[x][YMAX + 2] := edgePosition;
    end for;
    for y range 2 to succ(YMAX) do
      area[1][y] := edgePosition;
      area[XMAX + 2][y] := edgePosition;
    end for;
    for x range 2 to succ(XMAX) do
      for y range 2 to succ(YMAX) do
        area[x][y].content := CLEAR;
        area[x][y].meal := foodReserve;
        area[x][y].possessor := microbe.NIL;
      end for;
    end for;

    InitAnimates;

    children := 0 times microbe.NIL;
    for x range 2 to succ(XMAX) do
      for y range 2 to succ(YMAX) do
        (* write(STD_ERR, x lpad 2);
        write(STD_ERR, y lpad 3);
        write(STD_ERR, " ");
        writeln(STD_ERR, area[x][y].content); *)
        area[x][y].meal := foodReserve;
        if area[x][y].content <> CLEAR then
          setBact(x, y, area[x][y].content);
        end if;
      end for;
    end for;
    animates := children;

  end func; (* initArea *)


const proc: statistics (in integer: genNr) is func

  local
    var integer: playanz is 0;
    var integer: sumAccno is 0;
    var integer: sumAccmass is 0;
    var integer: sumFoodno is 0;
    var integer: sumFoodmass is 0;
    var xcoordinate: x is 0;
    var ycoordinate: y is 0;
    var hue: species is CLEAR;
    var boolean: anychange is FALSE;
    var microbe: p is microbe.NIL;

  begin (* statistics *)
    sumAccno := 0;
    sumAccmass := 0;
    anychange := FALSE;
    for species range FIRSTCOL to LASTCOL do
      statValues[species][TRUE].accno := 0;
      statValues[species][TRUE].accmass := 0;
    end for;
    setPos(STAT, 1, 12);
    color(STAT, statCol);
    writeln(STAT, genNr lpad 1);
    for p range animates do
      if p->mass > 0 then
        incr(statValues[area[p->xpos][p->ypos].content][TRUE].accno);
        statValues[area[p->xpos][p->ypos].content][TRUE].accmass +:= p->mass;
      end if;
    end for;
    playanz := 1;
    for species range FIRSTCOL to LASTCOL do
      if species in playerSet then
        if statValues[species][TRUE].deathtime = 0 then
          if statValues[species][TRUE].accno = 0 then
            statValues[species][TRUE].deathtime := genNr;
            setPos(STAT, 2 + playanz, 9);
            write(STAT, "(");
            write(STAT, statValues[species][TRUE].totalno lpad 5);
            write(STAT, " ");
            write(STAT, statValues[species][TRUE].totalmass lpad 9);
            write(STAT, flt(statValues[species][TRUE].totalmass) /
                flt(succ(statValues[species][TRUE].totalno)) digits 1 lpad 8);
            write(STAT, ") d");
            writeln(STAT, genNr lpad 5);
            anychange := TRUE;
          else
            sumAccno +:= statValues[species][TRUE].accno;
            sumAccmass +:= statValues[species][TRUE].accmass;
            statValues[species][TRUE].totalno +:=
                statValues[species][TRUE].accno;
            statValues[species][TRUE].totalmass +:=
                statValues[species][TRUE].accmass;
            if statValues[species][TRUE].accno <>
                statValues[species][FALSE].accno or
                statValues[species][TRUE].accmass <>
                statValues[species][FALSE].accmass then
              setPos(STAT, 2 + playanz, 9);
              write(STAT, statValues[species][TRUE].accno lpad 6);
              write(STAT, " ");
              write(STAT, statValues[species][TRUE].accmass lpad 9);
              writeln(STAT, flt(statValues[species][TRUE].accmass) /
                  flt(statValues[species][TRUE].accno) digits 1 lpad 8);
              statValues[species][FALSE] := statValues[species][TRUE];
              anychange := TRUE;
            end if;
          end if;
        end if;
        incr(playanz);
      end if;
    end for;
    if anychange then
      setPos(STAT, 3 + playanz, 9);
      write(STAT, sumAccno lpad 6);
      write(STAT, " ");
      write(STAT, sumAccmass lpad 9);
      if sumAccno <> 0 then
        writeln(STAT, flt(sumAccmass) / flt(sumAccno) digits 1 lpad 8);
      else
        writeln(STAT, " " lpad 8);
      end if;
    end if;
    sumFoodno := 0;
    sumFoodmass := 0;
    for x range 2 to succ(XMAX) do
      for y range 2 to succ(YMAX) do
        if area[x][y].meal <> 0 then
          incr(sumFoodno);
        end if;
        sumFoodmass +:= area[x][y].meal;
      end for;
    end for;
    setPos(STAT, 4 + playanz, 9);
    write(STAT, sumFoodno lpad 6);
    write(STAT, " ");
    write(STAT, sumFoodmass lpad 9);
    if sumFoodno <> 0 then
      writeln(STAT, flt(sumFoodmass) / flt(sumFoodno) digits 1 lpad 8);
    else
      writeln(STAT, " " lpad 8);
    end if;
    setPos(STAT, 6 + playanz, 9);
    write(STAT, sumAccno + sumFoodno lpad 6);
    write(STAT, " ");
    write(STAT, sumAccmass + sumFoodmass lpad 9);
    if sumAccno + sumFoodno <> 0 then
      writeln(STAT, flt(sumAccmass + sumFoodmass) / flt(sumAccno + sumFoodno) digits 1 lpad 8);
    else
      writeln(STAT, " " lpad 8);
    end if;
  end func; (* statistics *)


const proc: finalStatistics is func

  local
    var integer: i is 0;
    var integer: cardPlayerSet is 0;
    var hue: col1 is CLEAR;
    var hue: col2 is CLEAR;
    var COLOUR: col3 is CLEAR;
    var killReason: reason is KHunger;
    var array [hue] hue: colField is hue times hue.value;
    var array [hue] float: valueField is hue times 0.0;

  begin (* finalStatistics *)
    cardPlayerSet:= 0;
    color(STAT, statCol);
    for col1 range FIRSTCOL to LASTCOL do
      if col1 in playerSet then
        incr(cardPlayerSet);
        valueField[col1] := log(flt(abs(statValues[col1][TRUE].totalno) + 1)) +
            log(flt(abs(statValues[col1][TRUE].totalmass) + 1)) +
            log(flt(abs(statValues[col1][TRUE].deathtime) + 1));
      else
        valueField[col1] := 0.0;
      end if;
      colField[col1] := col1;
    end for;

    if cardPlayerSet <> 0 then
      for col1 range FIRSTCOL to pred(LASTCOL) do
        for col2 range succ(col1) to LASTCOL do
          if valueField[colField[col1]] < valueField[colField[col2]] then
            col3 := colField[col2];
            colField[col2] := colField[col1];
            colField[col1] := col3;
          end if;
        end for;
      end for;

      for col1 range FIRSTCOL to LASTCOL do
        if colField[col1] in playerSet then
          i:= 0;
          for col3 range FIRSTCOL to colField[col1] do
            if col3 in playerSet then
              incr(i);
            end if;
          end for;
          setPos(STAT, 2 + i, 42);
          writeln(STAT, ord(col1) - ord(FIRSTCOL) + 1 lpad 1);
        end if;
      end for;

      setPos(FSTAT, cardPlayerSet + 10, 1);
      write(FSTAT, "Victims:");
      for col1 range FIRSTCOL to LASTCOL do
        if col1 in playerSet then
          write(FSTAT, col1 lpad 7);
        end if;
      end for;
      writeln(FSTAT);
      for reason range KEdge to KFnotEmpty do
        if reason <= KHunger or reason >= KWrMove or
            hue conv (ord(reason) - ord(KWhite) + ord(WHITE)) in playerSet then
          write(FSTAT, reason rpad 8);
          for col1 range FIRSTCOL to LASTCOL do
            if col1 in playerSet | {CLEAR} then
              write(FSTAT, killarray[col1][reason] lpad 7);
            end if;
          end for;
          writeln(FSTAT);
        end if;
      end for;
    end if;
  end func; (* finalStatistics *)


const proc: initStatistics is func

  local
    var COLOUR: col1 is CLEAR;
    var killReason: reason is KHunger;
    var integer: playanz is 0;

  begin (* initStatistics *)
    playanz:= 0;
    clear(STAT);
    setPos(STAT, 1, 1);
    color(STAT, statCol);
    writeln(STAT, "Generation");
    for col1 range ALL_COLOURS do
      if col1 in playerSet then
        setPos(STAT, 3 + playanz, 1);
        writeln(STAT, col1);
        incr(playanz);
        statValues[col1][TRUE].deathtime:= 0;
        statValues[col1][TRUE].totalno:= 0;
        statValues[col1][TRUE].totalmass:= 0;
        for reason range KEdge to KFnotEmpty do
          killarray[col1][reason] := 0;
        end for;
      end if;
    end for;
    setPos(STAT, 4 + playanz, 1);
    writeln(STAT, "Sum");
    setPos(STAT, 5 + playanz, 1);
    writeln(STAT, "Food");
    setPos(STAT, 7 + playanz, 1);
    writeln(STAT, "Total");
  end func; (* initStatistics *)


const proc: execute (ref microbe: individuum) is func
  local
    var COLOUR: species is CLEAR;

  begin
    x := individuum->xpos;
    y := individuum->ypos;
    done:= FALSE;
    species := area[x][y].content;
    case species of
      when {WHITE}:   dna(WHITE);
      when {VIOLET}:  dna(VIOLET);
      when {INDIGO}:  dna(INDIGO);
      when {BLUE}:    dna(BLUE);
      when {GREEN}:   dna(GREEN);
      when {ORANGE}:  dna(ORANGE);
      when {RED}:     dna(RED);
      when {TAN}:     dna(TAN);
(*
      when {CYAN}:    dna(CYAN);
      when {YELLOW}:  dna(YELLOW);
      when {AMBER}:   dna(AMBER);
      when {SCARLET}: dna(SCARLET);
      when {LILIAC}:  dna(LILIAC);
      when {PINK}:    dna(PINK);
*)
    end case;
    flush(field);
    if not done then
      doWait;
    end if;
  end func; (* execute *)


const proc: generation is func

  local
    var microbe: individuum is microbe.NIL;
    var integer: index is 1;

  begin (* generation *)
    children := 0 times microbe.NIL;
    index := 1;
    while index <= length(animates) do
      if animates[index]->mass = 0 then
        ignore(remove(animates, index));
      else
        execute(animates[index]);
        incr(index);
      end if;
    end while;
    animates := children & animates;
  end func; (* generation *)


const proc: main is func
  begin (* main *)
(*
    scr := open(SCREEN);
*)
    screen(640, 480);
    clear(curr_win, white);
    color(black, white);
    KEYBOARD := GRAPH_KEYBOARD;
    scr := open(curr_win);
    color(scr, black, white);
    setPos(scr, 4, 47);
    writeln(scr, "D N A F I G H T");
    setPos(scr, 6, 31);
    writeln(scr, "Copyright (C) 1985, 1986, 2005  Thomas Mertes");
    setPos(scr, 7, 31);
    writeln(scr, "Copyright (C) 1985, 1986,       Markus Stumptner");
    setPos(scr, 8, 31);
    writeln(scr, "Copyright (C) 1985, 1986, 1991  Johannes Gritsch");
    setPos(scr, 10, 35);
    writeln(scr, "This program is free software under the");
    setPos(scr, 11, 35);
    writeln(scr, "terms of the GNU General Public License");
    setPos(scr, 13, 30);
    writeln(scr, "Dnafight is written in the Seed7 programming language");
    setPos(scr, 14, 32);
    writeln(scr, "Homepage:    http://seed7.sourceforge.net");
    setPos(scr, 15, 32);
    writeln(scr, "Wikipedia:   http://en.wikipedia.org/wiki/Seed7");
    setPos(scr, 19, 1);
    writeln(scr, " DNAFIGHT is a programming game in which bacterials fight \
         \aggainst each other. Each bacterium is");
    writeln(scr, " controlled by a DNA program written in Seed7. The different \
         \types of bacteria are named with colors");
    writeln(scr, " and have corresponding DNA programs for each color. There \
         \are two ways to play this game:");
    writeln(scr);
    writeln(scr, "  1. Place some bacterials on the plate and let them fight \
         \aggainst each other.");
    writeln(scr, "  2. Write an DNA for a new bacterium and measure your \
         \programming skills.");
    if upper(getc(KEYBOARD)) <> 'Q' then
      clear(curr_win, white);
      setPos(scr, 1, 1);
      write(scr, "DNAFIGHT V");
      writeln(scr, Version);
      repeat
        initScreen;
        initDisplay;
        initArea;
        initStatistics;
        genNr := 0;

        while length(animates) <> 0 and busy_getc(KEYBOARD) = KEY_NONE do
          generation;
          incr(genNr);
          if genNr mod STATTIME = 0 then
            statistics(genNr);
          end if;
          (* readln(KEYBOARD); *)
        end while;

        finalStatistics;
      until not continue(GAME);
    end if;
  end func; (* main *)
