
(********************************************************************)
(*                                                                  *)
(*  chkhsh.sd7    Checks hash table operations                      *)
(*  Copyright (C) 2009  Thomas Mertes                               *)
(*                                                                  *)
(*  This program is free software; you can redistribute it and/or   *)
(*  modify it under the terms of the GNU General Public License as  *)
(*  published by the Free Software Foundation; either version 2 of  *)
(*  the License, or (at your option) any later version.             *)
(*                                                                  *)
(*  This program is distributed in the hope that it will be useful, *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of  *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *)
(*  GNU General Public License for more details.                    *)
(*                                                                  *)
(*  You should have received a copy of the GNU General Public       *)
(*  License along with this program; if not, write to the           *)
(*  Free Software Foundation, Inc., 51 Franklin Street,             *)
(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)
(*                                                                  *)
(********************************************************************)


$ include "seed7_05.s7i";
  include "stdio.s7i";
  include "bigint.s7i";
  include "rational.s7i";
  include "bigrat.s7i";
  include "float.s7i";
  include "complex.s7i";
  include "bstring.s7i";
  include "time.s7i";
  include "graph.s7i";

enable_output(type);

const type: enumerationType is new enum
    RED, YELLOW, GREEN
  end enum;

const type: booleanBooleanHash     is hash [boolean] boolean;
const type: booleanIntegerHash     is hash [boolean] integer;
const type: booleanBigIntegerHash  is hash [boolean] bigInteger;
const type: booleanBigRationalHash is hash [boolean] bigRational;
const type: booleanFloatHash       is hash [boolean] float;
const type: booleanComplexHash     is hash [boolean] complex;
const type: booleanCharHash        is hash [boolean] char;
const type: booleanStringHash      is hash [boolean] string;
const type: booleanBstringHash     is hash [boolean] bstring;
const type: booleanBitsetHash      is hash [boolean] bitset;
const type: booleanTimeHash        is hash [boolean] time;
const type: booleanEnumTypeHash    is hash [boolean] enumerationType;
const type: booleanTypeHash        is hash [boolean] type;
const type: booleanReferenceHash   is hash [boolean] reference;
const type: booleanHashHash        is hash [boolean] booleanBooleanHash;

const type: integerBooleanHash     is hash [integer] boolean;
const type: integerIntegerHash     is hash [integer] integer;
const type: integerBigIntegerHash  is hash [integer] bigInteger;
const type: integerBigRationalHash is hash [integer] bigRational;
const type: integerFloatHash       is hash [integer] float;
const type: integerComplexHash     is hash [integer] complex;
const type: integerCharHash        is hash [integer] char;
const type: integerStringHash      is hash [integer] string;
const type: integerBstringHash     is hash [integer] bstring;
const type: integerBitsetHash      is hash [integer] bitset;
const type: integerTimeHash        is hash [integer] time;
const type: integerEnumTypeHash    is hash [integer] enumerationType;
const type: integerTypeHash        is hash [integer] type;
const type: integerReferenceHash   is hash [integer] reference;
const type: integerHashHash        is hash [integer] integerBooleanHash;

const type: bigIntegerBooleanHash     is hash [bigInteger] boolean;
const type: bigIntegerIntegerHash     is hash [bigInteger] integer;
const type: bigIntegerBigIntegerHash  is hash [bigInteger] bigInteger;
const type: bigIntegerBigRationalHash is hash [bigInteger] bigRational;
const type: bigIntegerFloatHash       is hash [bigInteger] float;
const type: bigIntegerComplexHash     is hash [bigInteger] complex;
const type: bigIntegerCharHash        is hash [bigInteger] char;
const type: bigIntegerStringHash      is hash [bigInteger] string;
const type: bigIntegerBstringHash     is hash [bigInteger] bstring;
const type: bigIntegerBitsetHash      is hash [bigInteger] bitset;
const type: bigIntegerTimeHash        is hash [bigInteger] time;
const type: bigIntegerEnumTypeHash    is hash [bigInteger] enumerationType;
const type: bigIntegerTypeHash        is hash [bigInteger] type;
const type: bigIntegerReferenceHash   is hash [bigInteger] reference;
const type: bigIntegerHashHash        is hash [bigInteger] bigIntegerBooleanHash;

const type: rationalBooleanHash     is hash [rational] boolean;
const type: rationalIntegerHash     is hash [rational] integer;
const type: rationalBigIntegerHash  is hash [rational] bigInteger;
const type: rationalBigRationalHash is hash [rational] bigRational;
const type: rationalFloatHash       is hash [rational] float;
const type: rationalComplexHash     is hash [rational] complex;
const type: rationalCharHash        is hash [rational] char;
const type: rationalStringHash      is hash [rational] string;
const type: rationalBstringHash     is hash [rational] bstring;
const type: rationalBitsetHash      is hash [rational] bitset;
const type: rationalTimeHash        is hash [rational] time;
const type: rationalEnumTypeHash    is hash [rational] enumerationType;
const type: rationalTypeHash        is hash [rational] type;
const type: rationalReferenceHash   is hash [rational] reference;
const type: rationalHashHash        is hash [rational] rationalBooleanHash;

const type: bigRationalBooleanHash     is hash [bigRational] boolean;
const type: bigRationalIntegerHash     is hash [bigRational] integer;
const type: bigRationalBigIntegerHash  is hash [bigRational] bigInteger;
const type: bigRationalBigRationalHash is hash [bigRational] bigRational;
const type: bigRationalFloatHash       is hash [bigRational] float;
const type: bigRationalComplexHash     is hash [bigRational] complex;
const type: bigRationalCharHash        is hash [bigRational] char;
const type: bigRationalStringHash      is hash [bigRational] string;
const type: bigRationalBstringHash     is hash [bigRational] bstring;
const type: bigRationalBitsetHash      is hash [bigRational] bitset;
const type: bigRationalTimeHash        is hash [bigRational] time;
const type: bigRationalEnumTypeHash    is hash [bigRational] enumerationType;
const type: bigRationalTypeHash        is hash [bigRational] type;
const type: bigRationalReferenceHash   is hash [bigRational] reference;
const type: bigRationalHashHash        is hash [bigRational] bigRationalBooleanHash;

const type: floatBooleanHash     is hash [float] boolean;
const type: floatIntegerHash     is hash [float] integer;
const type: floatBigIntegerHash  is hash [float] bigInteger;
const type: floatBigRationalHash is hash [float] bigRational;
const type: floatFloatHash       is hash [float] float;
const type: floatComplexHash     is hash [float] complex;
const type: floatCharHash        is hash [float] char;
const type: floatStringHash      is hash [float] string;
const type: floatBstringHash     is hash [float] bstring;
const type: floatBitsetHash      is hash [float] bitset;
const type: floatTimeHash        is hash [float] time;
const type: floatEnumTypeHash    is hash [float] enumerationType;
const type: floatTypeHash        is hash [float] type;
const type: floatReferenceHash   is hash [float] reference;
const type: floatHashHash        is hash [float] floatBooleanHash;

const type: complexBooleanHash     is hash [complex] boolean;
const type: complexIntegerHash     is hash [complex] integer;
const type: complexBigIntegerHash  is hash [complex] bigInteger;
const type: complexBigRationalHash is hash [complex] bigRational;
const type: complexFloatHash       is hash [complex] float;
const type: complexComplexHash     is hash [complex] complex;
const type: complexCharHash        is hash [complex] char;
const type: complexStringHash      is hash [complex] string;
const type: complexBstringHash     is hash [complex] bstring;
const type: complexBitsetHash      is hash [complex] bitset;
const type: complexTimeHash        is hash [complex] time;
const type: complexEnumTypeHash    is hash [complex] enumerationType;
const type: complexTypeHash        is hash [complex] type;
const type: complexReferenceHash   is hash [complex] reference;
const type: complexHashHash        is hash [complex] complexBooleanHash;

const type: charBooleanHash     is hash [char] boolean;
const type: charIntegerHash     is hash [char] integer;
const type: charBigIntegerHash  is hash [char] bigInteger;
const type: charBigRationalHash is hash [char] bigRational;
const type: charFloatHash       is hash [char] float;
const type: charComplexHash     is hash [char] complex;
const type: charCharHash        is hash [char] char;
const type: charStringHash      is hash [char] string;
const type: charBstringHash     is hash [char] bstring;
const type: charBitsetHash      is hash [char] bitset;
const type: charTimeHash        is hash [char] time;
const type: charEnumTypeHash    is hash [char] enumerationType;
const type: charTypeHash        is hash [char] type;
const type: charReferenceHash   is hash [char] reference;
const type: charHashHash        is hash [char] charBooleanHash;

const type: stringBooleanHash     is hash [string] boolean;
const type: stringIntegerHash     is hash [string] integer;
const type: stringBigIntegerHash  is hash [string] bigInteger;
const type: stringBigRationalHash is hash [string] bigRational;
const type: stringFloatHash       is hash [string] float;
const type: stringComplexHash     is hash [string] complex;
const type: stringCharHash        is hash [string] char;
const type: stringStringHash      is hash [string] string;
const type: stringBstringHash     is hash [string] bstring;
const type: stringBitsetHash      is hash [string] bitset;
const type: stringTimeHash        is hash [string] time;
const type: stringEnumTypeHash    is hash [string] enumerationType;
const type: stringTypeHash        is hash [string] type;
const type: stringReferenceHash   is hash [string] reference;
const type: stringHashHash        is hash [string] stringBooleanHash;

const type: bstringBooleanHash     is hash [bstring] boolean;
const type: bstringIntegerHash     is hash [bstring] integer;
const type: bstringBigIntegerHash  is hash [bstring] bigInteger;
const type: bstringBigRationalHash is hash [bstring] bigRational;
const type: bstringFloatHash       is hash [bstring] float;
const type: bstringComplexHash     is hash [bstring] complex;
const type: bstringCharHash        is hash [bstring] char;
const type: bstringStringHash      is hash [bstring] string;
const type: bstringBstringHash     is hash [bstring] bstring;
const type: bstringBitsetHash      is hash [bstring] bitset;
const type: bstringTimeHash        is hash [bstring] time;
const type: bstringEnumTypeHash    is hash [bstring] enumerationType;
const type: bstringTypeHash        is hash [bstring] type;
const type: bstringReferenceHash   is hash [bstring] reference;
const type: bstringHashHash        is hash [bstring] bstringBooleanHash;

const type: bitsetBooleanHash     is hash [bitset] boolean;
const type: bitsetIntegerHash     is hash [bitset] integer;
const type: bitsetBigIntegerHash  is hash [bitset] bigInteger;
const type: bitsetBigRationalHash is hash [bitset] bigRational;
const type: bitsetFloatHash       is hash [bitset] float;
const type: bitsetComplexHash     is hash [bitset] complex;
const type: bitsetCharHash        is hash [bitset] char;
const type: bitsetStringHash      is hash [bitset] string;
const type: bitsetBstringHash     is hash [bitset] bstring;
const type: bitsetBitsetHash      is hash [bitset] bitset;
const type: bitsetTimeHash        is hash [bitset] time;
const type: bitsetEnumTypeHash    is hash [bitset] enumerationType;
const type: bitsetTypeHash        is hash [bitset] type;
const type: bitsetReferenceHash   is hash [bitset] reference;
const type: bitsetHashHash        is hash [bitset] bitsetBooleanHash;

const type: timeBooleanHash     is hash [time] boolean;
const type: timeIntegerHash     is hash [time] integer;
const type: timeBigIntegerHash  is hash [time] bigInteger;
const type: timeBigRationalHash is hash [time] bigRational;
const type: timeFloatHash       is hash [time] float;
const type: timeComplexHash     is hash [time] complex;
const type: timeCharHash        is hash [time] char;
const type: timeStringHash      is hash [time] string;
const type: timeBstringHash     is hash [time] bstring;
const type: timeBitsetHash      is hash [time] bitset;
const type: timeTimeHash        is hash [time] time;
const type: timeEnumTypeHash    is hash [time] enumerationType;
const type: timeTypeHash        is hash [time] type;
const type: timeReferenceHash   is hash [time] reference;
const type: timeHashHash        is hash [time] timeBooleanHash;

const type: enumTypeBooleanHash     is hash [enumerationType] boolean;
const type: enumTypeIntegerHash     is hash [enumerationType] integer;
const type: enumTypeBigIntegerHash  is hash [enumerationType] bigInteger;
const type: enumTypeBigRationalHash is hash [enumerationType] bigRational;
const type: enumTypeFloatHash       is hash [enumerationType] float;
const type: enumTypeComplexHash     is hash [enumerationType] complex;
const type: enumTypeCharHash        is hash [enumerationType] char;
const type: enumTypeStringHash      is hash [enumerationType] string;
const type: enumTypeBstringHash     is hash [enumerationType] bstring;
const type: enumTypeBitsetHash      is hash [enumerationType] bitset;
const type: enumTypeTimeHash        is hash [enumerationType] time;
const type: enumTypeEnumTypeHash    is hash [enumerationType] enumerationType;
const type: enumTypeTypeHash        is hash [enumerationType] type;
const type: enumTypeReferenceHash   is hash [enumerationType] reference;
const type: enumTypeHashHash        is hash [enumerationType] enumTypeBooleanHash;


const proc: DECLARE_RAISES_INDEX_ERROR (in type: aType) is func
  begin

    const func boolean: raisesIndexError (in varfunc aType: expression) is func
      result
        var boolean: raisesIndexError is FALSE;
      local
        var aType: exprResult is aType.value;
      begin
        block
          exprResult := expression;
        exception
          catch INDEX_ERROR:
            raisesIndexError := TRUE;
        end block;
      end func;

  end func;


DECLARE_RAISES_INDEX_ERROR(boolean);
DECLARE_RAISES_INDEX_ERROR(integer);
DECLARE_RAISES_INDEX_ERROR(bigInteger);
DECLARE_RAISES_INDEX_ERROR(rational);
DECLARE_RAISES_INDEX_ERROR(bigRational);
DECLARE_RAISES_INDEX_ERROR(float);
DECLARE_RAISES_INDEX_ERROR(complex);
DECLARE_RAISES_INDEX_ERROR(char);
DECLARE_RAISES_INDEX_ERROR(string);
DECLARE_RAISES_INDEX_ERROR(bstring);
DECLARE_RAISES_INDEX_ERROR(bitset);
DECLARE_RAISES_INDEX_ERROR(time);
DECLARE_RAISES_INDEX_ERROR(enumerationType);
DECLARE_RAISES_INDEX_ERROR(type);
DECLARE_RAISES_INDEX_ERROR(reference);


const proc: DECLARE_RAISES_RANGE_ERROR (in type: aType) is func
  begin

    const func boolean: raisesRangeError (in func aType: expression) is func
      result
        var boolean: raisesRangeError is FALSE;
      local
        var aType: exprResult is aType.value;
      begin
        block
          exprResult := expression;
        exception
          catch RANGE_ERROR:
            raisesRangeError := TRUE;
        end block;
      end func;

  end func;


DECLARE_RAISES_RANGE_ERROR(stringIntegerHash);


const proc: chkBooleanHash is func
  local
    var boolean: okay is TRUE;
    var booleanBooleanHash:     booleanBooleanHashVar     is booleanBooleanHash    .EMPTY_HASH;
    var booleanIntegerHash:     booleanIntegerHashVar     is booleanIntegerHash    .EMPTY_HASH;
    var booleanBigIntegerHash:  booleanBigIntegerHashVar  is booleanBigIntegerHash .EMPTY_HASH;
    var booleanBigRationalHash: booleanBigRationalHashVar is booleanBigRationalHash.EMPTY_HASH;
    var booleanFloatHash:       booleanFloatHashVar       is booleanFloatHash      .EMPTY_HASH;
    var booleanComplexHash:     booleanComplexHashVar     is booleanComplexHash    .EMPTY_HASH;
    var booleanCharHash:        booleanCharHashVar        is booleanCharHash       .EMPTY_HASH;
    var booleanStringHash:      booleanStringHashVar      is booleanStringHash     .EMPTY_HASH;
    var booleanBstringHash:     booleanBstringHashVar     is booleanBstringHash    .EMPTY_HASH;
    var booleanBitsetHash:      booleanBitsetHashVar      is booleanBitsetHash     .EMPTY_HASH;
    var booleanTimeHash:        booleanTimeHashVar        is booleanTimeHash       .EMPTY_HASH;
    var booleanEnumTypeHash:    booleanEnumTypeHashVar    is booleanEnumTypeHash   .EMPTY_HASH;
    var booleanTypeHash:        booleanTypeHashVar        is booleanTypeHash       .EMPTY_HASH;
    var booleanReferenceHash:   booleanReferenceHashVar   is booleanReferenceHash  .EMPTY_HASH;
    var booleanHashHash:        booleanHashHashVar        is booleanHashHash       .EMPTY_HASH;
  begin
    if  length(booleanBooleanHashVar)     <> 0 or
        length(booleanIntegerHashVar)     <> 0 or
        length(booleanBigIntegerHashVar)  <> 0 or
        length(booleanBigRationalHashVar) <> 0 or
        length(booleanFloatHashVar)       <> 0 or
        length(booleanComplexHashVar)     <> 0 or
        length(booleanCharHashVar)        <> 0 or
        length(booleanStringHashVar)      <> 0 or
        length(booleanBstringHashVar)     <> 0 or
        length(booleanBitsetHashVar)      <> 0 or
        length(booleanTimeHashVar)        <> 0 or
        length(booleanEnumTypeHashVar)    <> 0 or
        length(booleanTypeHashVar)        <> 0 or
        length(booleanReferenceHashVar)   <> 0 or
        length(booleanHashHashVar)        <> 0 then
      writeln(" ***** Number of elements in empty hash[boolean] table not 0");
      okay := FALSE;
    end if;
    if  TRUE in booleanBooleanHashVar     or
        TRUE in booleanIntegerHashVar     or
        TRUE in booleanBigIntegerHashVar  or
        TRUE in booleanBigRationalHashVar or
        TRUE in booleanFloatHashVar       or
        TRUE in booleanComplexHashVar     or
        TRUE in booleanCharHashVar        or
        TRUE in booleanStringHashVar      or
        TRUE in booleanBstringHashVar     or
        TRUE in booleanBitsetHashVar      or
        TRUE in booleanTimeHashVar        or
        TRUE in booleanEnumTypeHashVar    or
        TRUE in booleanTypeHashVar        or
        TRUE in booleanReferenceHashVar   or
        TRUE in booleanHashHashVar        then
      writeln(" ***** Elements found in empty hash table");
      okay := FALSE;
    end if;
    if  keys(booleanBooleanHashVar)     <> 0 times FALSE or
        keys(booleanIntegerHashVar)     <> 0 times FALSE or
        keys(booleanBigIntegerHashVar)  <> 0 times FALSE or
        keys(booleanBigRationalHashVar) <> 0 times FALSE or
        keys(booleanFloatHashVar)       <> 0 times FALSE or
        keys(booleanComplexHashVar)     <> 0 times FALSE or
        keys(booleanCharHashVar)        <> 0 times FALSE or
        keys(booleanStringHashVar)      <> 0 times FALSE or
        keys(booleanBstringHashVar)     <> 0 times FALSE or
        keys(booleanBitsetHashVar)      <> 0 times FALSE or
        keys(booleanTimeHashVar)        <> 0 times FALSE or
        keys(booleanEnumTypeHashVar)    <> 0 times FALSE or
        keys(booleanTypeHashVar)        <> 0 times FALSE or
        keys(booleanReferenceHashVar)   <> 0 times FALSE or
        keys(booleanHashHashVar)        <> 0 times FALSE then
      writeln(" ***** Number of keys in empty hash[boolean] table is not 0");
      okay := FALSE;
    end if;
    if  values(booleanBooleanHashVar)     <> 0 times FALSE or
        values(booleanIntegerHashVar)     <> 0 times 0 or
        values(booleanBigIntegerHashVar)  <> 0 times 0_ or
        values(booleanBigRationalHashVar) <> 0 times 0_ / 1_ or
        values(booleanFloatHashVar)       <> 0 times 0.0 or
        values(booleanComplexHashVar)     <> 0 times complex(0.0, 0.0) or
        values(booleanCharHashVar)        <> 0 times ' ' or
        values(booleanStringHashVar)      <> 0 times "" or
        values(booleanBstringHashVar)     <> 0 times bstring("") or
        values(booleanBitsetHashVar)      <> 0 times {} or
        values(booleanTimeHashVar)        <> 0 times time.value or
        values(booleanEnumTypeHashVar)    <> 0 times RED or
        values(booleanTypeHashVar)        <> 0 times boolean or
        values(booleanReferenceHashVar)   <> 0 times NIL then
      writeln(" ***** Number of values in empty hash[boolean] table is not 0");
      okay := FALSE;
    end if;
    if  not raisesIndexError(booleanBooleanHashVar     [TRUE]) or
        not raisesIndexError(booleanIntegerHashVar     [TRUE]) or
        not raisesIndexError(booleanBigIntegerHashVar  [TRUE]) or
        not raisesIndexError(booleanBigRationalHashVar [TRUE]) or
        not raisesIndexError(booleanFloatHashVar       [TRUE]) or
        not raisesIndexError(booleanComplexHashVar     [TRUE]) or
        not raisesIndexError(booleanCharHashVar        [TRUE]) or
        not raisesIndexError(booleanStringHashVar      [TRUE]) or
        not raisesIndexError(booleanBstringHashVar     [TRUE]) or
        not raisesIndexError(booleanBitsetHashVar      [TRUE]) or
        not raisesIndexError(booleanTimeHashVar        [TRUE]) or
        not raisesIndexError(booleanEnumTypeHashVar    [TRUE]) or
        not raisesIndexError(booleanTypeHashVar        [TRUE]) or
        not raisesIndexError(booleanReferenceHashVar   [TRUE]) then
      writeln(" ***** Indexing into an empty hash[boolean] does not raise INDEX_ERROR");
      okay := FALSE;
    end if;
    booleanBooleanHashVar     @:= [TRUE] TRUE;
    booleanIntegerHashVar     @:= [TRUE] 1234;
    booleanBigIntegerHashVar  @:= [TRUE] 9999999999_;
    booleanBigRationalHashVar @:= [TRUE] 9999999999_ / 12345678_;
    booleanFloatHashVar       @:= [TRUE] 3.1415926535;
    booleanComplexHashVar     @:= [TRUE] complex(1.2, 3.4);
    booleanCharHashVar        @:= [TRUE] 'Q';
    booleanStringHashVar      @:= [TRUE] "success";
    booleanBstringHashVar     @:= [TRUE] bstring("okay");
    booleanBitsetHashVar      @:= [TRUE] {123};
    booleanTimeHashVar        @:= [TRUE] time("2011-12-13 14:15");
    booleanEnumTypeHashVar    @:= [TRUE] GREEN;
    booleanTypeHashVar        @:= [TRUE] char;
    booleanReferenceHashVar   @:= [TRUE] NIL;
    booleanHashHashVar        @:= [TRUE] booleanBooleanHashVar;
    if  length(booleanBooleanHashVar)     <> 1 or
        length(booleanIntegerHashVar)     <> 1 or
        length(booleanBigIntegerHashVar)  <> 1 or
        length(booleanBigRationalHashVar) <> 1 or
        length(booleanFloatHashVar)       <> 1 or
        length(booleanComplexHashVar)     <> 1 or
        length(booleanCharHashVar)        <> 1 or
        length(booleanStringHashVar)      <> 1 or
        length(booleanBstringHashVar)     <> 1 or
        length(booleanBitsetHashVar)      <> 1 or
        length(booleanTimeHashVar)        <> 1 or
        length(booleanEnumTypeHashVar)    <> 1 or
        length(booleanTypeHashVar)        <> 1 or
        length(booleanReferenceHashVar)   <> 1 or
        length(booleanHashHashVar)        <> 1 then
      writeln(" ***** Number of elements in hash[boolean] table not 1");
      okay := FALSE;
    end if;
    if  TRUE in booleanBooleanHashVar     and
        TRUE in booleanIntegerHashVar     and
        TRUE in booleanBigIntegerHashVar  and
        TRUE in booleanBigRationalHashVar and
        TRUE in booleanFloatHashVar       and
        TRUE in booleanComplexHashVar     and
        TRUE in booleanCharHashVar        and
        TRUE in booleanStringHashVar      and
        TRUE in booleanBstringHashVar     and
        TRUE in booleanBitsetHashVar      and
        TRUE in booleanTimeHashVar        and
        TRUE in booleanEnumTypeHashVar    and
        TRUE in booleanTypeHashVar        and
        TRUE in booleanReferenceHashVar   and
        TRUE in booleanHashHashVar        then
      noop;
    else
      writeln(" ***** Elements missing in hash[boolean] table");
      okay := FALSE;
    end if;
    if  keys(booleanBooleanHashVar)     <> [] (TRUE) or
        keys(booleanIntegerHashVar)     <> [] (TRUE) or
        keys(booleanBigIntegerHashVar)  <> [] (TRUE) or
        keys(booleanBigRationalHashVar) <> [] (TRUE) or
        keys(booleanFloatHashVar)       <> [] (TRUE) or
        keys(booleanComplexHashVar)     <> [] (TRUE) or
        keys(booleanCharHashVar)        <> [] (TRUE) or
        keys(booleanStringHashVar)      <> [] (TRUE) or
        keys(booleanBstringHashVar)     <> [] (TRUE) or
        keys(booleanBitsetHashVar)      <> [] (TRUE) or
        keys(booleanTimeHashVar)        <> [] (TRUE) or
        keys(booleanEnumTypeHashVar)    <> [] (TRUE) or
        keys(booleanTypeHashVar)        <> [] (TRUE) or
        keys(booleanReferenceHashVar)   <> [] (TRUE) or
        keys(booleanHashHashVar)        <> [] (TRUE) then
      writeln(" ***** keys(hash[boolean]) does not work correctly");
      okay := FALSE;
    end if;
    if  values(booleanBooleanHashVar)     <> [] (TRUE) or
        values(booleanIntegerHashVar)     <> [] (1234) or
        values(booleanBigIntegerHashVar)  <> [] (9999999999_) or
        values(booleanBigRationalHashVar) <> [] (9999999999_ / 12345678_) or
        values(booleanFloatHashVar)       <> [] (3.1415926535) or
        values(booleanComplexHashVar)     <> [] (complex(1.2, 3.4)) or
        values(booleanCharHashVar)        <> [] ('Q') or
        values(booleanStringHashVar)      <> [] ("success") or
        values(booleanBstringHashVar)     <> [] (bstring("okay")) or
        values(booleanBitsetHashVar)      <> [] ({123}) or
        values(booleanTimeHashVar)        <> [] (time("2011-12-13 14:15")) or
        values(booleanEnumTypeHashVar)    <> [] (GREEN) or
        values(booleanTypeHashVar)        <> [] (char) or
        values(booleanReferenceHashVar)   <> [] (NIL) then
      writeln(" ***** values(hash[boolean]) does not work correctly");
      okay := FALSE;
    end if;
    booleanBooleanHashVar     @:= [TRUE] TRUE;
    booleanIntegerHashVar     @:= [TRUE] 1234;
    booleanBigIntegerHashVar  @:= [TRUE] 9999999999_;
    booleanBigRationalHashVar @:= [TRUE] 9999999999_ / 12345678_;
    booleanFloatHashVar       @:= [TRUE] 3.1415926535;
    booleanComplexHashVar     @:= [TRUE] complex(1.2, 3.4);
    booleanCharHashVar        @:= [TRUE] 'Q';
    booleanStringHashVar      @:= [TRUE] "success";
    booleanBstringHashVar     @:= [TRUE] bstring("okay");
    booleanBitsetHashVar      @:= [TRUE] {123};
    booleanTimeHashVar        @:= [TRUE] time("2011-12-13 14:15");
    booleanEnumTypeHashVar    @:= [TRUE] GREEN;
    booleanTypeHashVar        @:= [TRUE] char;
    booleanReferenceHashVar   @:= [TRUE] NIL;
    booleanHashHashVar        @:= [TRUE] booleanBooleanHashVar;
    if  TRUE not in booleanBooleanHashVar     or
        TRUE not in booleanIntegerHashVar     or
        TRUE not in booleanBigIntegerHashVar  or
        TRUE not in booleanBigRationalHashVar or
        TRUE not in booleanFloatHashVar       or
        TRUE not in booleanComplexHashVar     or
        TRUE not in booleanCharHashVar        or
        TRUE not in booleanStringHashVar      or
        TRUE not in booleanBstringHashVar     or
        TRUE not in booleanBitsetHashVar      or
        TRUE not in booleanTimeHashVar        or
        TRUE not in booleanEnumTypeHashVar    or
        TRUE not in booleanTypeHashVar        or
        TRUE not in booleanReferenceHashVar   or
        TRUE not in booleanHashHashVar        then
      writeln(" ***** Elements missing in hash[boolean] table");
      okay := FALSE;
    end if;
    if  booleanBooleanHashVar     [TRUE] <> TRUE                     or
        booleanIntegerHashVar     [TRUE] <> 1234                     or
        booleanBigIntegerHashVar  [TRUE] <> 9999999999_              or
        booleanBigRationalHashVar [TRUE] <> 9999999999_ / 12345678_  or
        booleanFloatHashVar       [TRUE] <> 3.1415926535             or
        booleanComplexHashVar     [TRUE] <> complex(1.2, 3.4)        or
        booleanCharHashVar        [TRUE] <> 'Q'                      or
        booleanStringHashVar      [TRUE] <> "success"                or
        booleanBstringHashVar     [TRUE] <> bstring("okay")          or
        booleanBitsetHashVar      [TRUE] <> {123}                    or
        booleanTimeHashVar        [TRUE] <> time("2011-12-13 14:15") or
        booleanEnumTypeHashVar    [TRUE] <> GREEN                    or
        booleanTypeHashVar        [TRUE] <> char                     or
        booleanReferenceHashVar   [TRUE] <> NIL                      then
      writeln(" ***** Elements with wrong value in hash[boolean] table");
      okay := FALSE;
    end if;
    if okay then
      writeln("Hash tables with boolean keys work correctly.");
    else
      writeln(" ***** Hash tables with boolean keys do not work correctly");
      writeln;
    end if;
  end func;

const proc: chkIntegerHash is func
  local
    var boolean: okay is TRUE;
    var integerBooleanHash:     integerBooleanHashVar     is integerBooleanHash    .EMPTY_HASH;
    var integerIntegerHash:     integerIntegerHashVar     is integerIntegerHash    .EMPTY_HASH;
    var integerBigIntegerHash:  integerBigIntegerHashVar  is integerBigIntegerHash .EMPTY_HASH;
    var integerBigRationalHash: integerBigRationalHashVar is integerBigRationalHash.EMPTY_HASH;
    var integerFloatHash:       integerFloatHashVar       is integerFloatHash      .EMPTY_HASH;
    var integerComplexHash:     integerComplexHashVar     is integerComplexHash    .EMPTY_HASH;
    var integerCharHash:        integerCharHashVar        is integerCharHash       .EMPTY_HASH;
    var integerStringHash:      integerStringHashVar      is integerStringHash     .EMPTY_HASH;
    var integerBstringHash:     integerBstringHashVar     is integerBstringHash    .EMPTY_HASH;
    var integerBitsetHash:      integerBitsetHashVar      is integerBitsetHash     .EMPTY_HASH;
    var integerTimeHash:        integerTimeHashVar        is integerTimeHash       .EMPTY_HASH;
    var integerEnumTypeHash:    integerEnumTypeHashVar    is integerEnumTypeHash   .EMPTY_HASH;
    var integerTypeHash:        integerTypeHashVar        is integerTypeHash       .EMPTY_HASH;
    var integerReferenceHash:   integerReferenceHashVar   is integerReferenceHash  .EMPTY_HASH;
    var integerHashHash:        integerHashHashVar        is integerHashHash       .EMPTY_HASH;
  begin
    if  length(integerBooleanHashVar)     <> 0 or
        length(integerIntegerHashVar)     <> 0 or
        length(integerBigIntegerHashVar)  <> 0 or
        length(integerBigRationalHashVar) <> 0 or
        length(integerFloatHashVar)       <> 0 or
        length(integerComplexHashVar)     <> 0 or
        length(integerCharHashVar)        <> 0 or
        length(integerStringHashVar)      <> 0 or
        length(integerBstringHashVar)     <> 0 or
        length(integerBitsetHashVar)      <> 0 or
        length(integerTimeHashVar)        <> 0 or
        length(integerEnumTypeHashVar)    <> 0 or
        length(integerTypeHashVar)        <> 0 or
        length(integerReferenceHashVar)   <> 0 or
        length(integerHashHashVar)        <> 0 then
      writeln(" ***** Number of elements in empty hash[integer] table not 0");
      okay := FALSE;
    end if;
    if  87654321 in integerBooleanHashVar     or
        87654321 in integerIntegerHashVar     or
        87654321 in integerBigIntegerHashVar  or
        87654321 in integerBigRationalHashVar or
        87654321 in integerFloatHashVar       or
        87654321 in integerComplexHashVar     or
        87654321 in integerCharHashVar        or
        87654321 in integerStringHashVar      or
        87654321 in integerBstringHashVar     or
        87654321 in integerBitsetHashVar      or
        87654321 in integerTimeHashVar        or
        87654321 in integerEnumTypeHashVar    or
        87654321 in integerTypeHashVar        or
        87654321 in integerReferenceHashVar   or
        87654321 in integerHashHashVar        then
      writeln(" ***** Elements found in empty hash table");
      okay := FALSE;
    end if;
    if  keys(integerBooleanHashVar)     <> 0 times 0 or
        keys(integerIntegerHashVar)     <> 0 times 0 or
        keys(integerBigIntegerHashVar)  <> 0 times 0 or
        keys(integerBigRationalHashVar) <> 0 times 0 or
        keys(integerFloatHashVar)       <> 0 times 0 or
        keys(integerComplexHashVar)     <> 0 times 0 or
        keys(integerCharHashVar)        <> 0 times 0 or
        keys(integerStringHashVar)      <> 0 times 0 or
        keys(integerBstringHashVar)     <> 0 times 0 or
        keys(integerBitsetHashVar)      <> 0 times 0 or
        keys(integerTimeHashVar)        <> 0 times 0 or
        keys(integerEnumTypeHashVar)    <> 0 times 0 or
        keys(integerTypeHashVar)        <> 0 times 0 or
        keys(integerReferenceHashVar)   <> 0 times 0 or
        keys(integerHashHashVar)        <> 0 times 0 then
      writeln(" ***** Number of keys in empty hash[integer] table is not 0");
      okay := FALSE;
    end if;
    if  values(integerBooleanHashVar)     <> 0 times FALSE or
        values(integerIntegerHashVar)     <> 0 times 0 or
        values(integerBigIntegerHashVar)  <> 0 times 0_ or
        values(integerBigRationalHashVar) <> 0 times 0_ / 1_ or
        values(integerFloatHashVar)       <> 0 times 0.0 or
        values(integerComplexHashVar)     <> 0 times complex(0.0, 0.0) or
        values(integerCharHashVar)        <> 0 times ' ' or
        values(integerStringHashVar)      <> 0 times "" or
        values(integerBstringHashVar)     <> 0 times bstring("") or
        values(integerBitsetHashVar)      <> 0 times {} or
        values(integerTimeHashVar)        <> 0 times time.value or
        values(integerEnumTypeHashVar)    <> 0 times RED or
        values(integerTypeHashVar)        <> 0 times boolean or
        values(integerReferenceHashVar)   <> 0 times NIL then
      writeln(" ***** Number of values in empty hash[integer] table is not 0");
      okay := FALSE;
    end if;
    if  not raisesIndexError(integerBooleanHashVar     [87654321]) or
        not raisesIndexError(integerIntegerHashVar     [87654321]) or
        not raisesIndexError(integerBigIntegerHashVar  [87654321]) or
        not raisesIndexError(integerBigRationalHashVar [87654321]) or
        not raisesIndexError(integerFloatHashVar       [87654321]) or
        not raisesIndexError(integerComplexHashVar     [87654321]) or
        not raisesIndexError(integerCharHashVar        [87654321]) or
        not raisesIndexError(integerStringHashVar      [87654321]) or
        not raisesIndexError(integerBstringHashVar     [87654321]) or
        not raisesIndexError(integerBitsetHashVar      [87654321]) or
        not raisesIndexError(integerTimeHashVar        [87654321]) or
        not raisesIndexError(integerEnumTypeHashVar    [87654321]) or
        not raisesIndexError(integerTypeHashVar        [87654321]) or
        not raisesIndexError(integerReferenceHashVar   [87654321]) then
      writeln(" ***** Indexing into an empty hash[integer] does not raise INDEX_ERROR");
      okay := FALSE;
    end if;
    integerBooleanHashVar     @:= [87654321] TRUE;
    integerIntegerHashVar     @:= [87654321] 1234;
    integerBigIntegerHashVar  @:= [87654321] 9999999999_;
    integerBigRationalHashVar @:= [87654321] 9999999999_ / 12345678_;
    integerFloatHashVar       @:= [87654321] 3.1415926535;
    integerComplexHashVar     @:= [87654321] complex(1.2, 3.4);
    integerCharHashVar        @:= [87654321] 'Q';
    integerStringHashVar      @:= [87654321] "success";
    integerBstringHashVar     @:= [87654321] bstring("okay");
    integerBitsetHashVar      @:= [87654321] {123};
    integerTimeHashVar        @:= [87654321] time("2011-12-13 14:15");
    integerEnumTypeHashVar    @:= [87654321] GREEN;
    integerTypeHashVar        @:= [87654321] char;
    integerReferenceHashVar   @:= [87654321] NIL;
    integerHashHashVar        @:= [87654321] integerBooleanHashVar;
    if  length(integerBooleanHashVar)     <> 1 or
        length(integerIntegerHashVar)     <> 1 or
        length(integerBigIntegerHashVar)  <> 1 or
        length(integerBigRationalHashVar) <> 1 or
        length(integerFloatHashVar)       <> 1 or
        length(integerComplexHashVar)     <> 1 or
        length(integerCharHashVar)        <> 1 or
        length(integerStringHashVar)      <> 1 or
        length(integerBstringHashVar)     <> 1 or
        length(integerBitsetHashVar)      <> 1 or
        length(integerTimeHashVar)        <> 1 or
        length(integerEnumTypeHashVar)    <> 1 or
        length(integerTypeHashVar)        <> 1 or
        length(integerReferenceHashVar)   <> 1 or
        length(integerHashHashVar)        <> 1 then
      writeln(" ***** Number of elements in hash[integer] table not 1");
      okay := FALSE;
    end if;
    if  87654321 in integerBooleanHashVar     and
        87654321 in integerIntegerHashVar     and
        87654321 in integerBigIntegerHashVar  and
        87654321 in integerBigRationalHashVar and
        87654321 in integerFloatHashVar       and
        87654321 in integerComplexHashVar     and
        87654321 in integerCharHashVar        and
        87654321 in integerStringHashVar      and
        87654321 in integerBstringHashVar     and
        87654321 in integerBitsetHashVar      and
        87654321 in integerTimeHashVar        and
        87654321 in integerEnumTypeHashVar    and
        87654321 in integerTypeHashVar        and
        87654321 in integerReferenceHashVar   and
        87654321 in integerHashHashVar        then
      noop;
    else
      writeln(" ***** Elements missing in hash[integer] table");
      okay := FALSE;
    end if;
    if  keys(integerBooleanHashVar)     <> [] (87654321) or
        keys(integerIntegerHashVar)     <> [] (87654321) or
        keys(integerBigIntegerHashVar)  <> [] (87654321) or
        keys(integerBigRationalHashVar) <> [] (87654321) or
        keys(integerFloatHashVar)       <> [] (87654321) or
        keys(integerComplexHashVar)     <> [] (87654321) or
        keys(integerCharHashVar)        <> [] (87654321) or
        keys(integerStringHashVar)      <> [] (87654321) or
        keys(integerBstringHashVar)     <> [] (87654321) or
        keys(integerBitsetHashVar)      <> [] (87654321) or
        keys(integerTimeHashVar)        <> [] (87654321) or
        keys(integerEnumTypeHashVar)    <> [] (87654321) or
        keys(integerTypeHashVar)        <> [] (87654321) or
        keys(integerReferenceHashVar)   <> [] (87654321) or
        keys(integerHashHashVar)        <> [] (87654321) then
      writeln(" ***** keys(hash[integer]) does not work correctly");
      okay := FALSE;
    end if;
    if  values(integerBooleanHashVar)     <> [] (TRUE) or
        values(integerIntegerHashVar)     <> [] (1234) or
        values(integerBigIntegerHashVar)  <> [] (9999999999_) or
        values(integerBigRationalHashVar) <> [] (9999999999_ / 12345678_) or
        values(integerFloatHashVar)       <> [] (3.1415926535) or
        values(integerComplexHashVar)     <> [] (complex(1.2, 3.4)) or
        values(integerCharHashVar)        <> [] ('Q') or
        values(integerStringHashVar)      <> [] ("success") or
        values(integerBstringHashVar)     <> [] (bstring("okay")) or
        values(integerBitsetHashVar)      <> [] ({123}) or
        values(integerTimeHashVar)        <> [] (time("2011-12-13 14:15")) or
        values(integerEnumTypeHashVar)    <> [] (GREEN) or
        values(integerTypeHashVar)        <> [] (char) or
        values(integerReferenceHashVar)   <> [] (NIL) then
      writeln(" ***** values(hash[integer]) does not work correctly");
      okay := FALSE;
    end if;
    integerBooleanHashVar     @:= [87654321] TRUE;
    integerIntegerHashVar     @:= [87654321] 1234;
    integerBigIntegerHashVar  @:= [87654321] 9999999999_;
    integerBigRationalHashVar @:= [87654321] 9999999999_ / 12345678_;
    integerFloatHashVar       @:= [87654321] 3.1415926535;
    integerComplexHashVar     @:= [87654321] complex(1.2, 3.4);
    integerCharHashVar        @:= [87654321] 'Q';
    integerStringHashVar      @:= [87654321] "success";
    integerBstringHashVar     @:= [87654321] bstring("okay");
    integerBitsetHashVar      @:= [87654321] {123};
    integerTimeHashVar        @:= [87654321] time("2011-12-13 14:15");
    integerEnumTypeHashVar    @:= [87654321] GREEN;
    integerTypeHashVar        @:= [87654321] char;
    integerReferenceHashVar   @:= [87654321] NIL;
    integerHashHashVar        @:= [87654321] integerBooleanHashVar;
    if  87654321 not in integerBooleanHashVar     or
        87654321 not in integerIntegerHashVar     or
        87654321 not in integerBigIntegerHashVar  or
        87654321 not in integerBigRationalHashVar or
        87654321 not in integerFloatHashVar       or
        87654321 not in integerComplexHashVar     or
        87654321 not in integerCharHashVar        or
        87654321 not in integerStringHashVar      or
        87654321 not in integerBstringHashVar     or
        87654321 not in integerBitsetHashVar      or
        87654321 not in integerTimeHashVar        or
        87654321 not in integerEnumTypeHashVar    or
        87654321 not in integerTypeHashVar        or
        87654321 not in integerReferenceHashVar   or
        87654321 not in integerHashHashVar        then
      writeln(" ***** Elements missing in hash[integer] table");
      okay := FALSE;
    end if;
    if  integerBooleanHashVar     [87654321] <> TRUE                     or
        integerIntegerHashVar     [87654321] <> 1234                     or
        integerBigIntegerHashVar  [87654321] <> 9999999999_              or
        integerBigRationalHashVar [87654321] <> 9999999999_ / 12345678_  or
        integerFloatHashVar       [87654321] <> 3.1415926535             or
        integerComplexHashVar     [87654321] <> complex(1.2, 3.4)        or
        integerCharHashVar        [87654321] <> 'Q'                      or
        integerStringHashVar      [87654321] <> "success"                or
        integerBstringHashVar     [87654321] <> bstring("okay")          or
        integerBitsetHashVar      [87654321] <> {123}                    or
        integerTimeHashVar        [87654321] <> time("2011-12-13 14:15") or
        integerEnumTypeHashVar    [87654321] <> GREEN                    or
        integerTypeHashVar        [87654321] <> char                     or
        integerReferenceHashVar   [87654321] <> NIL                      then
      writeln(" ***** Elements with wrong value in hash[integer] table");
      okay := FALSE;
    end if;
    if okay then
      writeln("Hash tables with integer keys work correctly.");
    else
      writeln(" ***** Hash tables with integer keys do not work correctly");
      writeln;
    end if;
  end func;


const proc: chkBigIntegerHash is func
  local
    var boolean: okay is TRUE;
    var bigIntegerBooleanHash:     bigIntegerBooleanHashVar     is bigIntegerBooleanHash    .EMPTY_HASH;
    var bigIntegerIntegerHash:     bigIntegerIntegerHashVar     is bigIntegerIntegerHash    .EMPTY_HASH;
    var bigIntegerBigIntegerHash:  bigIntegerBigIntegerHashVar  is bigIntegerBigIntegerHash .EMPTY_HASH;
    var bigIntegerBigRationalHash: bigIntegerBigRationalHashVar is bigIntegerBigRationalHash.EMPTY_HASH;
    var bigIntegerFloatHash:       bigIntegerFloatHashVar       is bigIntegerFloatHash      .EMPTY_HASH;
    var bigIntegerComplexHash:     bigIntegerComplexHashVar     is bigIntegerComplexHash    .EMPTY_HASH;
    var bigIntegerCharHash:        bigIntegerCharHashVar        is bigIntegerCharHash       .EMPTY_HASH;
    var bigIntegerStringHash:      bigIntegerStringHashVar      is bigIntegerStringHash     .EMPTY_HASH;
    var bigIntegerBstringHash:     bigIntegerBstringHashVar     is bigIntegerBstringHash    .EMPTY_HASH;
    var bigIntegerBitsetHash:      bigIntegerBitsetHashVar      is bigIntegerBitsetHash     .EMPTY_HASH;
    var bigIntegerTimeHash:        bigIntegerTimeHashVar        is bigIntegerTimeHash       .EMPTY_HASH;
    var bigIntegerEnumTypeHash:    bigIntegerEnumTypeHashVar    is bigIntegerEnumTypeHash   .EMPTY_HASH;
    var bigIntegerTypeHash:        bigIntegerTypeHashVar        is bigIntegerTypeHash       .EMPTY_HASH;
    var bigIntegerReferenceHash:   bigIntegerReferenceHashVar   is bigIntegerReferenceHash  .EMPTY_HASH;
    var bigIntegerHashHash:        bigIntegerHashHashVar        is bigIntegerHashHash       .EMPTY_HASH;
  begin
    if  length(bigIntegerBooleanHashVar)     <> 0 or
        length(bigIntegerIntegerHashVar)     <> 0 or
        length(bigIntegerBigIntegerHashVar)  <> 0 or
        length(bigIntegerBigRationalHashVar) <> 0 or
        length(bigIntegerFloatHashVar)       <> 0 or
        length(bigIntegerComplexHashVar)     <> 0 or
        length(bigIntegerCharHashVar)        <> 0 or
        length(bigIntegerStringHashVar)      <> 0 or
        length(bigIntegerBstringHashVar)     <> 0 or
        length(bigIntegerBitsetHashVar)      <> 0 or
        length(bigIntegerTimeHashVar)        <> 0 or
        length(bigIntegerEnumTypeHashVar)    <> 0 or
        length(bigIntegerTypeHashVar)        <> 0 or
        length(bigIntegerReferenceHashVar)   <> 0 or
        length(bigIntegerHashHashVar)        <> 0 then
      writeln(" ***** Number of elements in empty hash[bigInteger] table not 0");
      okay := FALSE;
    end if;
    if  9223372036854775808_ in bigIntegerBooleanHashVar     or
        9223372036854775808_ in bigIntegerIntegerHashVar     or
        9223372036854775808_ in bigIntegerBigIntegerHashVar  or
        9223372036854775808_ in bigIntegerBigRationalHashVar or
        9223372036854775808_ in bigIntegerFloatHashVar       or
        9223372036854775808_ in bigIntegerComplexHashVar     or
        9223372036854775808_ in bigIntegerCharHashVar        or
        9223372036854775808_ in bigIntegerStringHashVar      or
        9223372036854775808_ in bigIntegerBstringHashVar     or
        9223372036854775808_ in bigIntegerBitsetHashVar      or
        9223372036854775808_ in bigIntegerTimeHashVar        or
        9223372036854775808_ in bigIntegerEnumTypeHashVar    or
        9223372036854775808_ in bigIntegerTypeHashVar        or
        9223372036854775808_ in bigIntegerReferenceHashVar   or
        9223372036854775808_ in bigIntegerHashHashVar        then
      writeln(" ***** Elements found in empty hash table");
      okay := FALSE;
    end if;
    if  keys(bigIntegerBooleanHashVar)     <> 0 times 0_ or
        keys(bigIntegerIntegerHashVar)     <> 0 times 0_ or
        keys(bigIntegerBigIntegerHashVar)  <> 0 times 0_ or
        keys(bigIntegerBigRationalHashVar) <> 0 times 0_ or
        keys(bigIntegerFloatHashVar)       <> 0 times 0_ or
        keys(bigIntegerComplexHashVar)     <> 0 times 0_ or
        keys(bigIntegerCharHashVar)        <> 0 times 0_ or
        keys(bigIntegerStringHashVar)      <> 0 times 0_ or
        keys(bigIntegerBstringHashVar)     <> 0 times 0_ or
        keys(bigIntegerBitsetHashVar)      <> 0 times 0_ or
        keys(bigIntegerTimeHashVar)        <> 0 times 0_ or
        keys(bigIntegerEnumTypeHashVar)    <> 0 times 0_ or
        keys(bigIntegerTypeHashVar)        <> 0 times 0_ or
        keys(bigIntegerReferenceHashVar)   <> 0 times 0_ or
        keys(bigIntegerHashHashVar)        <> 0 times 0_ then
      writeln(" ***** Number of keys in empty hash[bigInteger] table is not 0");
      okay := FALSE;
    end if;
    if  values(bigIntegerBooleanHashVar)     <> 0 times FALSE or
        values(bigIntegerIntegerHashVar)     <> 0 times 0 or
        values(bigIntegerBigIntegerHashVar)  <> 0 times 0_ or
        values(bigIntegerBigRationalHashVar) <> 0 times 0_ / 1_ or
        values(bigIntegerFloatHashVar)       <> 0 times 0.0 or
        values(bigIntegerComplexHashVar)     <> 0 times complex(0.0, 0.0) or
        values(bigIntegerCharHashVar)        <> 0 times ' ' or
        values(bigIntegerStringHashVar)      <> 0 times "" or
        values(bigIntegerBstringHashVar)     <> 0 times bstring("") or
        values(bigIntegerBitsetHashVar)      <> 0 times {} or
        values(bigIntegerTimeHashVar)        <> 0 times time.value or
        values(bigIntegerEnumTypeHashVar)    <> 0 times RED or
        values(bigIntegerTypeHashVar)        <> 0 times boolean or
        values(bigIntegerReferenceHashVar)   <> 0 times NIL then
      writeln(" ***** Number of values in empty hash[bigInteger] table is not 0");
      okay := FALSE;
    end if;
    if  not raisesIndexError(bigIntegerBooleanHashVar     [9223372036854775808_]) or
        not raisesIndexError(bigIntegerIntegerHashVar     [9223372036854775808_]) or
        not raisesIndexError(bigIntegerBigIntegerHashVar  [9223372036854775808_]) or
        not raisesIndexError(bigIntegerBigRationalHashVar [9223372036854775808_]) or
        not raisesIndexError(bigIntegerFloatHashVar       [9223372036854775808_]) or
        not raisesIndexError(bigIntegerComplexHashVar     [9223372036854775808_]) or
        not raisesIndexError(bigIntegerCharHashVar        [9223372036854775808_]) or
        not raisesIndexError(bigIntegerStringHashVar      [9223372036854775808_]) or
        not raisesIndexError(bigIntegerBstringHashVar     [9223372036854775808_]) or
        not raisesIndexError(bigIntegerBitsetHashVar      [9223372036854775808_]) or
        not raisesIndexError(bigIntegerTimeHashVar        [9223372036854775808_]) or
        not raisesIndexError(bigIntegerEnumTypeHashVar    [9223372036854775808_]) or
        not raisesIndexError(bigIntegerTypeHashVar        [9223372036854775808_]) or
        not raisesIndexError(bigIntegerReferenceHashVar   [9223372036854775808_]) then
      writeln(" ***** Indexing into an empty hash[bigInteger] does not raise INDEX_ERROR");
      okay := FALSE;
    end if;
    bigIntegerBooleanHashVar     @:= [9223372036854775808_] TRUE;
    bigIntegerIntegerHashVar     @:= [9223372036854775808_] 1234;
    bigIntegerBigIntegerHashVar  @:= [9223372036854775808_] 9999999999_;
    bigIntegerBigRationalHashVar @:= [9223372036854775808_] 9999999999_ / 12345678_;
    bigIntegerFloatHashVar       @:= [9223372036854775808_] 3.1415926535;
    bigIntegerComplexHashVar     @:= [9223372036854775808_] complex(1.2, 3.4);
    bigIntegerCharHashVar        @:= [9223372036854775808_] 'Q';
    bigIntegerStringHashVar      @:= [9223372036854775808_] "success";
    bigIntegerBstringHashVar     @:= [9223372036854775808_] bstring("okay");
    bigIntegerBitsetHashVar      @:= [9223372036854775808_] {123};
    bigIntegerTimeHashVar        @:= [9223372036854775808_] time("2011-12-13 14:15");
    bigIntegerEnumTypeHashVar    @:= [9223372036854775808_] GREEN;
    bigIntegerTypeHashVar        @:= [9223372036854775808_] char;
    bigIntegerReferenceHashVar   @:= [9223372036854775808_] NIL;
    bigIntegerHashHashVar        @:= [9223372036854775808_] bigIntegerBooleanHashVar;
    if  length(bigIntegerBooleanHashVar)     <> 1 or
        length(bigIntegerIntegerHashVar)     <> 1 or
        length(bigIntegerBigIntegerHashVar)  <> 1 or
        length(bigIntegerBigRationalHashVar) <> 1 or
        length(bigIntegerFloatHashVar)       <> 1 or
        length(bigIntegerComplexHashVar)     <> 1 or
        length(bigIntegerCharHashVar)        <> 1 or
        length(bigIntegerStringHashVar)      <> 1 or
        length(bigIntegerBstringHashVar)     <> 1 or
        length(bigIntegerBitsetHashVar)      <> 1 or
        length(bigIntegerTimeHashVar)        <> 1 or
        length(bigIntegerEnumTypeHashVar)    <> 1 or
        length(bigIntegerTypeHashVar)        <> 1 or
        length(bigIntegerReferenceHashVar)   <> 1 or
        length(bigIntegerHashHashVar)        <> 1 then
      writeln(" ***** Number of elements in hash[bigInteger] table not 1");
      okay := FALSE;
    end if;
    if  9223372036854775808_ in bigIntegerBooleanHashVar     and
        9223372036854775808_ in bigIntegerIntegerHashVar     and
        9223372036854775808_ in bigIntegerBigIntegerHashVar  and
        9223372036854775808_ in bigIntegerBigRationalHashVar and
        9223372036854775808_ in bigIntegerFloatHashVar       and
        9223372036854775808_ in bigIntegerComplexHashVar     and
        9223372036854775808_ in bigIntegerCharHashVar        and
        9223372036854775808_ in bigIntegerStringHashVar      and
        9223372036854775808_ in bigIntegerBstringHashVar     and
        9223372036854775808_ in bigIntegerBitsetHashVar      and
        9223372036854775808_ in bigIntegerTimeHashVar        and
        9223372036854775808_ in bigIntegerEnumTypeHashVar    and
        9223372036854775808_ in bigIntegerTypeHashVar        and
        9223372036854775808_ in bigIntegerReferenceHashVar   and
        9223372036854775808_ in bigIntegerHashHashVar        then
      noop;
    else
      writeln(" ***** Elements missing in hash[bigInteger] table");
      okay := FALSE;
    end if;
    if  keys(bigIntegerBooleanHashVar)     <> [] (9223372036854775808_) or
        keys(bigIntegerIntegerHashVar)     <> [] (9223372036854775808_) or
        keys(bigIntegerBigIntegerHashVar)  <> [] (9223372036854775808_) or
        keys(bigIntegerBigRationalHashVar) <> [] (9223372036854775808_) or
        keys(bigIntegerFloatHashVar)       <> [] (9223372036854775808_) or
        keys(bigIntegerComplexHashVar)     <> [] (9223372036854775808_) or
        keys(bigIntegerCharHashVar)        <> [] (9223372036854775808_) or
        keys(bigIntegerStringHashVar)      <> [] (9223372036854775808_) or
        keys(bigIntegerBstringHashVar)     <> [] (9223372036854775808_) or
        keys(bigIntegerBitsetHashVar)      <> [] (9223372036854775808_) or
        keys(bigIntegerTimeHashVar)        <> [] (9223372036854775808_) or
        keys(bigIntegerEnumTypeHashVar)    <> [] (9223372036854775808_) or
        keys(bigIntegerTypeHashVar)        <> [] (9223372036854775808_) or
        keys(bigIntegerReferenceHashVar)   <> [] (9223372036854775808_) or
        keys(bigIntegerHashHashVar)        <> [] (9223372036854775808_) then
      writeln(" ***** keys(hash[bigInteger]) does not work correctly");
      okay := FALSE;
    end if;
    if  values(bigIntegerBooleanHashVar)     <> [] (TRUE) or
        values(bigIntegerIntegerHashVar)     <> [] (1234) or
        values(bigIntegerBigIntegerHashVar)  <> [] (9999999999_) or
        values(bigIntegerBigRationalHashVar) <> [] (9999999999_ / 12345678_) or
        values(bigIntegerFloatHashVar)       <> [] (3.1415926535) or
        values(bigIntegerComplexHashVar)     <> [] (complex(1.2, 3.4)) or
        values(bigIntegerCharHashVar)        <> [] ('Q') or
        values(bigIntegerStringHashVar)      <> [] ("success") or
        values(bigIntegerBstringHashVar)     <> [] (bstring("okay")) or
        values(bigIntegerBitsetHashVar)      <> [] ({123}) or
        values(bigIntegerTimeHashVar)        <> [] (time("2011-12-13 14:15")) or
        values(bigIntegerEnumTypeHashVar)    <> [] (GREEN) or
        values(bigIntegerTypeHashVar)        <> [] (char) or
        values(bigIntegerReferenceHashVar)   <> [] (NIL) then
      writeln(" ***** values(hash[bigInteger]) does not work correctly");
      okay := FALSE;
    end if;
    bigIntegerBooleanHashVar     @:= [9223372036854775808_] TRUE;
    bigIntegerIntegerHashVar     @:= [9223372036854775808_] 1234;
    bigIntegerBigIntegerHashVar  @:= [9223372036854775808_] 9999999999_;
    bigIntegerBigRationalHashVar @:= [9223372036854775808_] 9999999999_ / 12345678_;
    bigIntegerFloatHashVar       @:= [9223372036854775808_] 3.1415926535;
    bigIntegerComplexHashVar     @:= [9223372036854775808_] complex(1.2, 3.4);
    bigIntegerCharHashVar        @:= [9223372036854775808_] 'Q';
    bigIntegerStringHashVar      @:= [9223372036854775808_] "success";
    bigIntegerBstringHashVar     @:= [9223372036854775808_] bstring("okay");
    bigIntegerBitsetHashVar      @:= [9223372036854775808_] {123};
    bigIntegerTimeHashVar        @:= [9223372036854775808_] time("2011-12-13 14:15");
    bigIntegerEnumTypeHashVar    @:= [9223372036854775808_] GREEN;
    bigIntegerTypeHashVar        @:= [9223372036854775808_] char;
    bigIntegerReferenceHashVar   @:= [9223372036854775808_] NIL;
    bigIntegerHashHashVar        @:= [9223372036854775808_] bigIntegerBooleanHashVar;
    if  9223372036854775808_ not in bigIntegerBooleanHashVar     or
        9223372036854775808_ not in bigIntegerIntegerHashVar     or
        9223372036854775808_ not in bigIntegerBigIntegerHashVar  or
        9223372036854775808_ not in bigIntegerBigRationalHashVar or
        9223372036854775808_ not in bigIntegerFloatHashVar       or
        9223372036854775808_ not in bigIntegerComplexHashVar     or
        9223372036854775808_ not in bigIntegerCharHashVar        or
        9223372036854775808_ not in bigIntegerStringHashVar      or
        9223372036854775808_ not in bigIntegerBstringHashVar     or
        9223372036854775808_ not in bigIntegerBitsetHashVar      or
        9223372036854775808_ not in bigIntegerTimeHashVar        or
        9223372036854775808_ not in bigIntegerEnumTypeHashVar    or
        9223372036854775808_ not in bigIntegerTypeHashVar        or
        9223372036854775808_ not in bigIntegerReferenceHashVar   or
        9223372036854775808_ not in bigIntegerHashHashVar        then
      writeln(" ***** Elements missing in hash[bigInteger] table");
      okay := FALSE;
    end if;
    if  bigIntegerBooleanHashVar     [9223372036854775808_] <> TRUE                     or
        bigIntegerIntegerHashVar     [9223372036854775808_] <> 1234                     or
        bigIntegerBigIntegerHashVar  [9223372036854775808_] <> 9999999999_              or
        bigIntegerBigRationalHashVar [9223372036854775808_] <> 9999999999_ / 12345678_  or
        bigIntegerFloatHashVar       [9223372036854775808_] <> 3.1415926535             or
        bigIntegerComplexHashVar     [9223372036854775808_] <> complex(1.2, 3.4)        or
        bigIntegerCharHashVar        [9223372036854775808_] <> 'Q'                      or
        bigIntegerStringHashVar      [9223372036854775808_] <> "success"                or
        bigIntegerBstringHashVar     [9223372036854775808_] <> bstring("okay")          or
        bigIntegerBitsetHashVar      [9223372036854775808_] <> {123}                    or
        bigIntegerTimeHashVar        [9223372036854775808_] <> time("2011-12-13 14:15") or
        bigIntegerEnumTypeHashVar    [9223372036854775808_] <> GREEN                    or
        bigIntegerTypeHashVar        [9223372036854775808_] <> char                     or
        bigIntegerReferenceHashVar   [9223372036854775808_] <> NIL                      then
      writeln(" ***** Elements with wrong value in hash[bigInteger] table");
      okay := FALSE;
    end if;
    if okay then
      writeln("Hash tables with bigInteger keys work correctly.");
    else
      writeln(" ***** Hash tables with bigInteger keys do not work correctly");
      writeln;
    end if;
  end func;


const proc: chkRationalHash is func
  local
    var boolean: okay is TRUE;
    var rationalBooleanHash:     rationalBooleanHashVar     is rationalBooleanHash    .EMPTY_HASH;
    var rationalIntegerHash:     rationalIntegerHashVar     is rationalIntegerHash    .EMPTY_HASH;
    var rationalBigIntegerHash:  rationalBigIntegerHashVar  is rationalBigIntegerHash .EMPTY_HASH;
    var rationalBigRationalHash: rationalBigRationalHashVar is rationalBigRationalHash.EMPTY_HASH;
    var rationalFloatHash:       rationalFloatHashVar       is rationalFloatHash      .EMPTY_HASH;
    var rationalComplexHash:     rationalComplexHashVar     is rationalComplexHash    .EMPTY_HASH;
    var rationalCharHash:        rationalCharHashVar        is rationalCharHash       .EMPTY_HASH;
    var rationalStringHash:      rationalStringHashVar      is rationalStringHash     .EMPTY_HASH;
    var rationalBstringHash:     rationalBstringHashVar     is rationalBstringHash    .EMPTY_HASH;
    var rationalBitsetHash:      rationalBitsetHashVar      is rationalBitsetHash     .EMPTY_HASH;
    var rationalTimeHash:        rationalTimeHashVar        is rationalTimeHash       .EMPTY_HASH;
    var rationalEnumTypeHash:    rationalEnumTypeHashVar    is rationalEnumTypeHash   .EMPTY_HASH;
    var rationalTypeHash:        rationalTypeHashVar        is rationalTypeHash       .EMPTY_HASH;
    var rationalReferenceHash:   rationalReferenceHashVar   is rationalReferenceHash  .EMPTY_HASH;
    var rationalHashHash:        rationalHashHashVar        is rationalHashHash       .EMPTY_HASH;
  begin
    if  length(rationalBooleanHashVar)     <> 0 or
        length(rationalIntegerHashVar)     <> 0 or
        length(rationalBigIntegerHashVar)  <> 0 or
        length(rationalBigRationalHashVar) <> 0 or
        length(rationalFloatHashVar)       <> 0 or
        length(rationalComplexHashVar)     <> 0 or
        length(rationalCharHashVar)        <> 0 or
        length(rationalStringHashVar)      <> 0 or
        length(rationalBstringHashVar)     <> 0 or
        length(rationalBitsetHashVar)      <> 0 or
        length(rationalTimeHashVar)        <> 0 or
        length(rationalEnumTypeHashVar)    <> 0 or
        length(rationalTypeHashVar)        <> 0 or
        length(rationalReferenceHashVar)   <> 0 or
        length(rationalHashHashVar)        <> 0 then
      writeln(" ***** Number of elements in empty hash[rational] table not 0");
      okay := FALSE;
    end if;
    if  9876543212 / 1234567890 in rationalBooleanHashVar     or
        9876543212 / 1234567890 in rationalIntegerHashVar     or
        9876543212 / 1234567890 in rationalBigIntegerHashVar  or
        9876543212 / 1234567890 in rationalBigRationalHashVar or
        9876543212 / 1234567890 in rationalFloatHashVar       or
        9876543212 / 1234567890 in rationalComplexHashVar     or
        9876543212 / 1234567890 in rationalCharHashVar        or
        9876543212 / 1234567890 in rationalStringHashVar      or
        9876543212 / 1234567890 in rationalBstringHashVar     or
        9876543212 / 1234567890 in rationalBitsetHashVar      or
        9876543212 / 1234567890 in rationalTimeHashVar        or
        9876543212 / 1234567890 in rationalEnumTypeHashVar    or
        9876543212 / 1234567890 in rationalTypeHashVar        or
        9876543212 / 1234567890 in rationalReferenceHashVar   or
        9876543212 / 1234567890 in rationalHashHashVar        then
      writeln(" ***** Elements found in empty hash table");
      okay := FALSE;
    end if;
    if  keys(rationalBooleanHashVar)     <> 0 times 0 / 1 or
        keys(rationalIntegerHashVar)     <> 0 times 0 / 1 or
        keys(rationalBigIntegerHashVar)  <> 0 times 0 / 1 or
        keys(rationalBigRationalHashVar) <> 0 times 0 / 1 or
        keys(rationalFloatHashVar)       <> 0 times 0 / 1 or
        keys(rationalComplexHashVar)     <> 0 times 0 / 1 or
        keys(rationalCharHashVar)        <> 0 times 0 / 1 or
        keys(rationalStringHashVar)      <> 0 times 0 / 1 or
        keys(rationalBstringHashVar)     <> 0 times 0 / 1 or
        keys(rationalBitsetHashVar)      <> 0 times 0 / 1 or
        keys(rationalTimeHashVar)        <> 0 times 0 / 1 or
        keys(rationalEnumTypeHashVar)    <> 0 times 0 / 1 or
        keys(rationalTypeHashVar)        <> 0 times 0 / 1 or
        keys(rationalReferenceHashVar)   <> 0 times 0 / 1 or
        keys(rationalHashHashVar)        <> 0 times 0 / 1 then
      writeln(" ***** Number of keys in empty hash[rational] table is not 0");
      okay := FALSE;
    end if;
    if  values(rationalBooleanHashVar)     <> 0 times FALSE or
        values(rationalIntegerHashVar)     <> 0 times 0 or
        values(rationalBigIntegerHashVar)  <> 0 times 0_ or
        values(rationalBigRationalHashVar) <> 0 times 0_ / 1_ or
        values(rationalFloatHashVar)       <> 0 times 0.0 or
        values(rationalComplexHashVar)     <> 0 times complex(0.0, 0.0) or
        values(rationalCharHashVar)        <> 0 times ' ' or
        values(rationalStringHashVar)      <> 0 times "" or
        values(rationalBstringHashVar)     <> 0 times bstring("") or
        values(rationalBitsetHashVar)      <> 0 times {} or
        values(rationalTimeHashVar)        <> 0 times time.value or
        values(rationalEnumTypeHashVar)    <> 0 times RED or
        values(rationalTypeHashVar)        <> 0 times boolean or
        values(rationalReferenceHashVar)   <> 0 times NIL then
      writeln(" ***** Number of values in empty hash[rational] table is not 0");
      okay := FALSE;
    end if;
    if  not raisesIndexError(rationalBooleanHashVar     [9876543212 / 1234567890]) or
        not raisesIndexError(rationalIntegerHashVar     [9876543212 / 1234567890]) or
        not raisesIndexError(rationalBigIntegerHashVar  [9876543212 / 1234567890]) or
        not raisesIndexError(rationalBigRationalHashVar [9876543212 / 1234567890]) or
        not raisesIndexError(rationalFloatHashVar       [9876543212 / 1234567890]) or
        not raisesIndexError(rationalComplexHashVar     [9876543212 / 1234567890]) or
        not raisesIndexError(rationalCharHashVar        [9876543212 / 1234567890]) or
        not raisesIndexError(rationalStringHashVar      [9876543212 / 1234567890]) or
        not raisesIndexError(rationalBstringHashVar     [9876543212 / 1234567890]) or
        not raisesIndexError(rationalBitsetHashVar      [9876543212 / 1234567890]) or
        not raisesIndexError(rationalTimeHashVar        [9876543212 / 1234567890]) or
        not raisesIndexError(rationalEnumTypeHashVar    [9876543212 / 1234567890]) or
        not raisesIndexError(rationalTypeHashVar        [9876543212 / 1234567890]) or
        not raisesIndexError(rationalReferenceHashVar   [9876543212 / 1234567890]) then
      writeln(" ***** Indexing into an empty hash[rational] does not raise INDEX_ERROR");
      okay := FALSE;
    end if;
    rationalBooleanHashVar     @:= [9876543212 / 1234567890] TRUE;
    rationalIntegerHashVar     @:= [9876543212 / 1234567890] 1234;
    rationalBigIntegerHashVar  @:= [9876543212 / 1234567890] 9999999999_;
    rationalBigRationalHashVar @:= [9876543212 / 1234567890] 9999999999_ / 12345678_;
    rationalFloatHashVar       @:= [9876543212 / 1234567890] 3.1415926535;
    rationalComplexHashVar     @:= [9876543212 / 1234567890] complex(1.2, 3.4);
    rationalCharHashVar        @:= [9876543212 / 1234567890] 'Q';
    rationalStringHashVar      @:= [9876543212 / 1234567890] "success";
    rationalBstringHashVar     @:= [9876543212 / 1234567890] bstring("okay");
    rationalBitsetHashVar      @:= [9876543212 / 1234567890] {123};
    rationalTimeHashVar        @:= [9876543212 / 1234567890] time("2011-12-13 14:15");
    rationalEnumTypeHashVar    @:= [9876543212 / 1234567890] GREEN;
    rationalTypeHashVar        @:= [9876543212 / 1234567890] char;
    rationalReferenceHashVar   @:= [9876543212 / 1234567890] NIL;
    rationalHashHashVar        @:= [9876543212 / 1234567890] rationalBooleanHashVar;
    if  length(rationalBooleanHashVar)     <> 1 or
        length(rationalIntegerHashVar)     <> 1 or
        length(rationalBigIntegerHashVar)  <> 1 or
        length(rationalBigRationalHashVar) <> 1 or
        length(rationalFloatHashVar)       <> 1 or
        length(rationalComplexHashVar)     <> 1 or
        length(rationalCharHashVar)        <> 1 or
        length(rationalStringHashVar)      <> 1 or
        length(rationalBstringHashVar)     <> 1 or
        length(rationalBitsetHashVar)      <> 1 or
        length(rationalTimeHashVar)        <> 1 or
        length(rationalEnumTypeHashVar)    <> 1 or
        length(rationalTypeHashVar)        <> 1 or
        length(rationalReferenceHashVar)   <> 1 or
        length(rationalHashHashVar)        <> 1 then
      writeln(" ***** Number of elements in hash[rational] table not 1");
      okay := FALSE;
    end if;
    if  9876543212 / 1234567890 in rationalBooleanHashVar     and
        9876543212 / 1234567890 in rationalIntegerHashVar     and
        9876543212 / 1234567890 in rationalBigIntegerHashVar  and
        9876543212 / 1234567890 in rationalBigRationalHashVar and
        9876543212 / 1234567890 in rationalFloatHashVar       and
        9876543212 / 1234567890 in rationalComplexHashVar     and
        9876543212 / 1234567890 in rationalCharHashVar        and
        9876543212 / 1234567890 in rationalStringHashVar      and
        9876543212 / 1234567890 in rationalBstringHashVar     and
        9876543212 / 1234567890 in rationalBitsetHashVar      and
        9876543212 / 1234567890 in rationalTimeHashVar        and
        9876543212 / 1234567890 in rationalEnumTypeHashVar    and
        9876543212 / 1234567890 in rationalTypeHashVar        and
        9876543212 / 1234567890 in rationalReferenceHashVar   and
        9876543212 / 1234567890 in rationalHashHashVar        then
      noop;
    else
      writeln(" ***** Elements missing in hash[rational] table");
      okay := FALSE;
    end if;
    if  keys(rationalBooleanHashVar)     <> [] (9876543212 / 1234567890) or
        keys(rationalIntegerHashVar)     <> [] (9876543212 / 1234567890) or
        keys(rationalBigIntegerHashVar)  <> [] (9876543212 / 1234567890) or
        keys(rationalBigRationalHashVar) <> [] (9876543212 / 1234567890) or
        keys(rationalFloatHashVar)       <> [] (9876543212 / 1234567890) or
        keys(rationalComplexHashVar)     <> [] (9876543212 / 1234567890) or
        keys(rationalCharHashVar)        <> [] (9876543212 / 1234567890) or
        keys(rationalStringHashVar)      <> [] (9876543212 / 1234567890) or
        keys(rationalBstringHashVar)     <> [] (9876543212 / 1234567890) or
        keys(rationalBitsetHashVar)      <> [] (9876543212 / 1234567890) or
        keys(rationalTimeHashVar)        <> [] (9876543212 / 1234567890) or
        keys(rationalEnumTypeHashVar)    <> [] (9876543212 / 1234567890) or
        keys(rationalTypeHashVar)        <> [] (9876543212 / 1234567890) or
        keys(rationalReferenceHashVar)   <> [] (9876543212 / 1234567890) or
        keys(rationalHashHashVar)        <> [] (9876543212 / 1234567890) then
      writeln(" ***** keys(hash[rational]) does not work correctly");
      okay := FALSE;
    end if;
    if  values(rationalBooleanHashVar)     <> [] (TRUE) or
        values(rationalIntegerHashVar)     <> [] (1234) or
        values(rationalBigIntegerHashVar)  <> [] (9999999999_) or
        values(rationalBigRationalHashVar) <> [] (9999999999_ / 12345678_) or
        values(rationalFloatHashVar)       <> [] (3.1415926535) or
        values(rationalComplexHashVar)     <> [] (complex(1.2, 3.4)) or
        values(rationalCharHashVar)        <> [] ('Q') or
        values(rationalStringHashVar)      <> [] ("success") or
        values(rationalBstringHashVar)     <> [] (bstring("okay")) or
        values(rationalBitsetHashVar)      <> [] ({123}) or
        values(rationalTimeHashVar)        <> [] (time("2011-12-13 14:15")) or
        values(rationalEnumTypeHashVar)    <> [] (GREEN) or
        values(rationalTypeHashVar)        <> [] (char) or
        values(rationalReferenceHashVar)   <> [] (NIL) then
      writeln(" ***** values(hash[rational]) does not work correctly");
      okay := FALSE;
    end if;
    rationalBooleanHashVar     @:= [9876543212 / 1234567890] TRUE;
    rationalIntegerHashVar     @:= [9876543212 / 1234567890] 1234;
    rationalBigIntegerHashVar  @:= [9876543212 / 1234567890] 9999999999_;
    rationalBigRationalHashVar @:= [9876543212 / 1234567890] 9999999999_ / 12345678_;
    rationalFloatHashVar       @:= [9876543212 / 1234567890] 3.1415926535;
    rationalComplexHashVar     @:= [9876543212 / 1234567890] complex(1.2, 3.4);
    rationalCharHashVar        @:= [9876543212 / 1234567890] 'Q';
    rationalStringHashVar      @:= [9876543212 / 1234567890] "success";
    rationalBstringHashVar     @:= [9876543212 / 1234567890] bstring("okay");
    rationalBitsetHashVar      @:= [9876543212 / 1234567890] {123};
    rationalTimeHashVar        @:= [9876543212 / 1234567890] time("2011-12-13 14:15");
    rationalEnumTypeHashVar    @:= [9876543212 / 1234567890] GREEN;
    rationalTypeHashVar        @:= [9876543212 / 1234567890] char;
    rationalReferenceHashVar   @:= [9876543212 / 1234567890] NIL;
    rationalHashHashVar        @:= [9876543212 / 1234567890] rationalBooleanHashVar;
    if  9876543212 / 1234567890 not in rationalBooleanHashVar     or
        9876543212 / 1234567890 not in rationalIntegerHashVar     or
        9876543212 / 1234567890 not in rationalBigIntegerHashVar  or
        9876543212 / 1234567890 not in rationalBigRationalHashVar or
        9876543212 / 1234567890 not in rationalFloatHashVar       or
        9876543212 / 1234567890 not in rationalComplexHashVar     or
        9876543212 / 1234567890 not in rationalCharHashVar        or
        9876543212 / 1234567890 not in rationalStringHashVar      or
        9876543212 / 1234567890 not in rationalBstringHashVar     or
        9876543212 / 1234567890 not in rationalBitsetHashVar      or
        9876543212 / 1234567890 not in rationalTimeHashVar        or
        9876543212 / 1234567890 not in rationalEnumTypeHashVar    or
        9876543212 / 1234567890 not in rationalTypeHashVar        or
        9876543212 / 1234567890 not in rationalReferenceHashVar   or
        9876543212 / 1234567890 not in rationalHashHashVar        then
      writeln(" ***** Elements missing in hash[rational] table");
      okay := FALSE;
    end if;
    if  rationalBooleanHashVar     [9876543212 / 1234567890] <> TRUE                     or
        rationalIntegerHashVar     [9876543212 / 1234567890] <> 1234                     or
        rationalBigIntegerHashVar  [9876543212 / 1234567890] <> 9999999999_              or
        rationalBigRationalHashVar [9876543212 / 1234567890] <> 9999999999_ / 12345678_  or
        rationalFloatHashVar       [9876543212 / 1234567890] <> 3.1415926535             or
        rationalComplexHashVar     [9876543212 / 1234567890] <> complex(1.2, 3.4)        or
        rationalCharHashVar        [9876543212 / 1234567890] <> 'Q'                      or
        rationalStringHashVar      [9876543212 / 1234567890] <> "success"                or
        rationalBstringHashVar     [9876543212 / 1234567890] <> bstring("okay")          or
        rationalBitsetHashVar      [9876543212 / 1234567890] <> {123}                    or
        rationalTimeHashVar        [9876543212 / 1234567890] <> time("2011-12-13 14:15") or
        rationalEnumTypeHashVar    [9876543212 / 1234567890] <> GREEN                    or
        rationalTypeHashVar        [9876543212 / 1234567890] <> char                     or
        rationalReferenceHashVar   [9876543212 / 1234567890] <> NIL                      then
      writeln(" ***** Elements with wrong value in hash[rational] table");
      okay := FALSE;
    end if;
    if okay then
      writeln("Hash tables with rational keys work correctly.");
    else
      writeln(" ***** Hash tables with rational keys do not work correctly");
      writeln;
    end if;
  end func;


const proc: chkBigRationalHash is func
  local
    var boolean: okay is TRUE;
    var bigRationalBooleanHash:     bigRationalBooleanHashVar     is bigRationalBooleanHash    .EMPTY_HASH;
    var bigRationalIntegerHash:     bigRationalIntegerHashVar     is bigRationalIntegerHash    .EMPTY_HASH;
    var bigRationalBigIntegerHash:  bigRationalBigIntegerHashVar  is bigRationalBigIntegerHash .EMPTY_HASH;
    var bigRationalBigRationalHash: bigRationalBigRationalHashVar is bigRationalBigRationalHash.EMPTY_HASH;
    var bigRationalFloatHash:       bigRationalFloatHashVar       is bigRationalFloatHash      .EMPTY_HASH;
    var bigRationalComplexHash:     bigRationalComplexHashVar     is bigRationalComplexHash    .EMPTY_HASH;
    var bigRationalCharHash:        bigRationalCharHashVar        is bigRationalCharHash       .EMPTY_HASH;
    var bigRationalStringHash:      bigRationalStringHashVar      is bigRationalStringHash     .EMPTY_HASH;
    var bigRationalBstringHash:     bigRationalBstringHashVar     is bigRationalBstringHash    .EMPTY_HASH;
    var bigRationalBitsetHash:      bigRationalBitsetHashVar      is bigRationalBitsetHash     .EMPTY_HASH;
    var bigRationalTimeHash:        bigRationalTimeHashVar        is bigRationalTimeHash       .EMPTY_HASH;
    var bigRationalEnumTypeHash:    bigRationalEnumTypeHashVar    is bigRationalEnumTypeHash   .EMPTY_HASH;
    var bigRationalTypeHash:        bigRationalTypeHashVar        is bigRationalTypeHash       .EMPTY_HASH;
    var bigRationalReferenceHash:   bigRationalReferenceHashVar   is bigRationalReferenceHash  .EMPTY_HASH;
    var bigRationalHashHash:        bigRationalHashHashVar        is bigRationalHashHash       .EMPTY_HASH;
  begin
    if  length(bigRationalBooleanHashVar)     <> 0 or
        length(bigRationalIntegerHashVar)     <> 0 or
        length(bigRationalBigIntegerHashVar)  <> 0 or
        length(bigRationalBigRationalHashVar) <> 0 or
        length(bigRationalFloatHashVar)       <> 0 or
        length(bigRationalComplexHashVar)     <> 0 or
        length(bigRationalCharHashVar)        <> 0 or
        length(bigRationalStringHashVar)      <> 0 or
        length(bigRationalBstringHashVar)     <> 0 or
        length(bigRationalBitsetHashVar)      <> 0 or
        length(bigRationalTimeHashVar)        <> 0 or
        length(bigRationalEnumTypeHashVar)    <> 0 or
        length(bigRationalTypeHashVar)        <> 0 or
        length(bigRationalReferenceHashVar)   <> 0 or
        length(bigRationalHashHashVar)        <> 0 then
      writeln(" ***** Number of elements in empty hash[bigRational] table not 0");
      okay := FALSE;
    end if;
    if  9876543212_ / 1234567890_ in bigRationalBooleanHashVar     or
        9876543212_ / 1234567890_ in bigRationalIntegerHashVar     or
        9876543212_ / 1234567890_ in bigRationalBigIntegerHashVar  or
        9876543212_ / 1234567890_ in bigRationalBigRationalHashVar or
        9876543212_ / 1234567890_ in bigRationalFloatHashVar       or
        9876543212_ / 1234567890_ in bigRationalComplexHashVar     or
        9876543212_ / 1234567890_ in bigRationalCharHashVar        or
        9876543212_ / 1234567890_ in bigRationalStringHashVar      or
        9876543212_ / 1234567890_ in bigRationalBstringHashVar     or
        9876543212_ / 1234567890_ in bigRationalBitsetHashVar      or
        9876543212_ / 1234567890_ in bigRationalTimeHashVar        or
        9876543212_ / 1234567890_ in bigRationalEnumTypeHashVar    or
        9876543212_ / 1234567890_ in bigRationalTypeHashVar        or
        9876543212_ / 1234567890_ in bigRationalReferenceHashVar   or
        9876543212_ / 1234567890_ in bigRationalHashHashVar        then
      writeln(" ***** Elements found in empty hash table");
      okay := FALSE;
    end if;
    if  keys(bigRationalBooleanHashVar)     <> 0 times 0_ / 1_ or
        keys(bigRationalIntegerHashVar)     <> 0 times 0_ / 1_ or
        keys(bigRationalBigIntegerHashVar)  <> 0 times 0_ / 1_ or
        keys(bigRationalBigRationalHashVar) <> 0 times 0_ / 1_ or
        keys(bigRationalFloatHashVar)       <> 0 times 0_ / 1_ or
        keys(bigRationalComplexHashVar)     <> 0 times 0_ / 1_ or
        keys(bigRationalCharHashVar)        <> 0 times 0_ / 1_ or
        keys(bigRationalStringHashVar)      <> 0 times 0_ / 1_ or
        keys(bigRationalBstringHashVar)     <> 0 times 0_ / 1_ or
        keys(bigRationalBitsetHashVar)      <> 0 times 0_ / 1_ or
        keys(bigRationalTimeHashVar)        <> 0 times 0_ / 1_ or
        keys(bigRationalEnumTypeHashVar)    <> 0 times 0_ / 1_ or
        keys(bigRationalTypeHashVar)        <> 0 times 0_ / 1_ or
        keys(bigRationalReferenceHashVar)   <> 0 times 0_ / 1_ or
        keys(bigRationalHashHashVar)        <> 0 times 0_ / 1_ then
      writeln(" ***** Number of keys in empty hash[bigRational] table is not 0");
      okay := FALSE;
    end if;
    if  values(bigRationalBooleanHashVar)     <> 0 times FALSE or
        values(bigRationalIntegerHashVar)     <> 0 times 0 or
        values(bigRationalBigIntegerHashVar)  <> 0 times 0_ or
        values(bigRationalBigRationalHashVar) <> 0 times 0_ / 1_ or
        values(bigRationalFloatHashVar)       <> 0 times 0.0 or
        values(bigRationalComplexHashVar)     <> 0 times complex(0.0, 0.0) or
        values(bigRationalCharHashVar)        <> 0 times ' ' or
        values(bigRationalStringHashVar)      <> 0 times "" or
        values(bigRationalBstringHashVar)     <> 0 times bstring("") or
        values(bigRationalBitsetHashVar)      <> 0 times {} or
        values(bigRationalTimeHashVar)        <> 0 times time.value or
        values(bigRationalEnumTypeHashVar)    <> 0 times RED or
        values(bigRationalTypeHashVar)        <> 0 times boolean or
        values(bigRationalReferenceHashVar)   <> 0 times NIL then
      writeln(" ***** Number of values in empty hash[bigRational] table is not 0");
      okay := FALSE;
    end if;
    if  not raisesIndexError(bigRationalBooleanHashVar     [9876543212_ / 1234567890_]) or
        not raisesIndexError(bigRationalIntegerHashVar     [9876543212_ / 1234567890_]) or
        not raisesIndexError(bigRationalBigIntegerHashVar  [9876543212_ / 1234567890_]) or
        not raisesIndexError(bigRationalBigRationalHashVar [9876543212_ / 1234567890_]) or
        not raisesIndexError(bigRationalFloatHashVar       [9876543212_ / 1234567890_]) or
        not raisesIndexError(bigRationalComplexHashVar     [9876543212_ / 1234567890_]) or
        not raisesIndexError(bigRationalCharHashVar        [9876543212_ / 1234567890_]) or
        not raisesIndexError(bigRationalStringHashVar      [9876543212_ / 1234567890_]) or
        not raisesIndexError(bigRationalBstringHashVar     [9876543212_ / 1234567890_]) or
        not raisesIndexError(bigRationalBitsetHashVar      [9876543212_ / 1234567890_]) or
        not raisesIndexError(bigRationalTimeHashVar        [9876543212_ / 1234567890_]) or
        not raisesIndexError(bigRationalEnumTypeHashVar    [9876543212_ / 1234567890_]) or
        not raisesIndexError(bigRationalTypeHashVar        [9876543212_ / 1234567890_]) or
        not raisesIndexError(bigRationalReferenceHashVar   [9876543212_ / 1234567890_]) then
      writeln(" ***** Indexing into an empty hash[bigRational] does not raise INDEX_ERROR");
      okay := FALSE;
    end if;
    bigRationalBooleanHashVar     @:= [9876543212_ / 1234567890_] TRUE;
    bigRationalIntegerHashVar     @:= [9876543212_ / 1234567890_] 1234;
    bigRationalBigIntegerHashVar  @:= [9876543212_ / 1234567890_] 9999999999_;
    bigRationalBigRationalHashVar @:= [9876543212_ / 1234567890_] 9999999999_ / 12345678_;
    bigRationalFloatHashVar       @:= [9876543212_ / 1234567890_] 3.1415926535;
    bigRationalComplexHashVar     @:= [9876543212_ / 1234567890_] complex(1.2, 3.4);
    bigRationalCharHashVar        @:= [9876543212_ / 1234567890_] 'Q';
    bigRationalStringHashVar      @:= [9876543212_ / 1234567890_] "success";
    bigRationalBstringHashVar     @:= [9876543212_ / 1234567890_] bstring("okay");
    bigRationalBitsetHashVar      @:= [9876543212_ / 1234567890_] {123};
    bigRationalTimeHashVar        @:= [9876543212_ / 1234567890_] time("2011-12-13 14:15");
    bigRationalEnumTypeHashVar    @:= [9876543212_ / 1234567890_] GREEN;
    bigRationalTypeHashVar        @:= [9876543212_ / 1234567890_] char;
    bigRationalReferenceHashVar   @:= [9876543212_ / 1234567890_] NIL;
    bigRationalHashHashVar        @:= [9876543212_ / 1234567890_] bigRationalBooleanHashVar;
    if  length(bigRationalBooleanHashVar)     <> 1 or
        length(bigRationalIntegerHashVar)     <> 1 or
        length(bigRationalBigIntegerHashVar)  <> 1 or
        length(bigRationalBigRationalHashVar) <> 1 or
        length(bigRationalFloatHashVar)       <> 1 or
        length(bigRationalComplexHashVar)     <> 1 or
        length(bigRationalCharHashVar)        <> 1 or
        length(bigRationalStringHashVar)      <> 1 or
        length(bigRationalBstringHashVar)     <> 1 or
        length(bigRationalBitsetHashVar)      <> 1 or
        length(bigRationalTimeHashVar)        <> 1 or
        length(bigRationalEnumTypeHashVar)    <> 1 or
        length(bigRationalTypeHashVar)        <> 1 or
        length(bigRationalReferenceHashVar)   <> 1 or
        length(bigRationalHashHashVar)        <> 1 then
      writeln(" ***** Number of elements in hash[bigRational] table not 1");
      okay := FALSE;
    end if;
    if  9876543212_ / 1234567890_ in bigRationalBooleanHashVar     and
        9876543212_ / 1234567890_ in bigRationalIntegerHashVar     and
        9876543212_ / 1234567890_ in bigRationalBigIntegerHashVar  and
        9876543212_ / 1234567890_ in bigRationalBigRationalHashVar and
        9876543212_ / 1234567890_ in bigRationalFloatHashVar       and
        9876543212_ / 1234567890_ in bigRationalComplexHashVar     and
        9876543212_ / 1234567890_ in bigRationalCharHashVar        and
        9876543212_ / 1234567890_ in bigRationalStringHashVar      and
        9876543212_ / 1234567890_ in bigRationalBstringHashVar     and
        9876543212_ / 1234567890_ in bigRationalBitsetHashVar      and
        9876543212_ / 1234567890_ in bigRationalTimeHashVar        and
        9876543212_ / 1234567890_ in bigRationalEnumTypeHashVar    and
        9876543212_ / 1234567890_ in bigRationalTypeHashVar        and
        9876543212_ / 1234567890_ in bigRationalReferenceHashVar   and
        9876543212_ / 1234567890_ in bigRationalHashHashVar        then
      noop;
    else
      writeln(" ***** Elements missing in hash[bigRational] table");
      okay := FALSE;
    end if;
    if  keys(bigRationalBooleanHashVar)     <> [] (9876543212_ / 1234567890_) or
        keys(bigRationalIntegerHashVar)     <> [] (9876543212_ / 1234567890_) or
        keys(bigRationalBigIntegerHashVar)  <> [] (9876543212_ / 1234567890_) or
        keys(bigRationalBigRationalHashVar) <> [] (9876543212_ / 1234567890_) or
        keys(bigRationalFloatHashVar)       <> [] (9876543212_ / 1234567890_) or
        keys(bigRationalComplexHashVar)     <> [] (9876543212_ / 1234567890_) or
        keys(bigRationalCharHashVar)        <> [] (9876543212_ / 1234567890_) or
        keys(bigRationalStringHashVar)      <> [] (9876543212_ / 1234567890_) or
        keys(bigRationalBstringHashVar)     <> [] (9876543212_ / 1234567890_) or
        keys(bigRationalBitsetHashVar)      <> [] (9876543212_ / 1234567890_) or
        keys(bigRationalTimeHashVar)        <> [] (9876543212_ / 1234567890_) or
        keys(bigRationalEnumTypeHashVar)    <> [] (9876543212_ / 1234567890_) or
        keys(bigRationalTypeHashVar)        <> [] (9876543212_ / 1234567890_) or
        keys(bigRationalReferenceHashVar)   <> [] (9876543212_ / 1234567890_) or
        keys(bigRationalHashHashVar)        <> [] (9876543212_ / 1234567890_) then
      writeln(" ***** keys(hash[bigRational]) does not work correctly");
      okay := FALSE;
    end if;
    if  values(bigRationalBooleanHashVar)     <> [] (TRUE) or
        values(bigRationalIntegerHashVar)     <> [] (1234) or
        values(bigRationalBigIntegerHashVar)  <> [] (9999999999_) or
        values(bigRationalBigRationalHashVar) <> [] (9999999999_ / 12345678_) or
        values(bigRationalFloatHashVar)       <> [] (3.1415926535) or
        values(bigRationalComplexHashVar)     <> [] (complex(1.2, 3.4)) or
        values(bigRationalCharHashVar)        <> [] ('Q') or
        values(bigRationalStringHashVar)      <> [] ("success") or
        values(bigRationalBstringHashVar)     <> [] (bstring("okay")) or
        values(bigRationalBitsetHashVar)      <> [] ({123}) or
        values(bigRationalTimeHashVar)        <> [] (time("2011-12-13 14:15")) or
        values(bigRationalEnumTypeHashVar)    <> [] (GREEN) or
        values(bigRationalTypeHashVar)        <> [] (char) or
        values(bigRationalReferenceHashVar)   <> [] (NIL) then
      writeln(" ***** values(hash[bigRational]) does not work correctly");
      okay := FALSE;
    end if;
    bigRationalBooleanHashVar     @:= [9876543212_ / 1234567890_] TRUE;
    bigRationalIntegerHashVar     @:= [9876543212_ / 1234567890_] 1234;
    bigRationalBigIntegerHashVar  @:= [9876543212_ / 1234567890_] 9999999999_;
    bigRationalBigRationalHashVar @:= [9876543212_ / 1234567890_] 9999999999_ / 12345678_;
    bigRationalFloatHashVar       @:= [9876543212_ / 1234567890_] 3.1415926535;
    bigRationalComplexHashVar     @:= [9876543212_ / 1234567890_] complex(1.2, 3.4);
    bigRationalCharHashVar        @:= [9876543212_ / 1234567890_] 'Q';
    bigRationalStringHashVar      @:= [9876543212_ / 1234567890_] "success";
    bigRationalBstringHashVar     @:= [9876543212_ / 1234567890_] bstring("okay");
    bigRationalBitsetHashVar      @:= [9876543212_ / 1234567890_] {123};
    bigRationalTimeHashVar        @:= [9876543212_ / 1234567890_] time("2011-12-13 14:15");
    bigRationalEnumTypeHashVar    @:= [9876543212_ / 1234567890_] GREEN;
    bigRationalTypeHashVar        @:= [9876543212_ / 1234567890_] char;
    bigRationalReferenceHashVar   @:= [9876543212_ / 1234567890_] NIL;
    bigRationalHashHashVar        @:= [9876543212_ / 1234567890_] bigRationalBooleanHashVar;
    if  9876543212_ / 1234567890_ not in bigRationalBooleanHashVar     or
        9876543212_ / 1234567890_ not in bigRationalIntegerHashVar     or
        9876543212_ / 1234567890_ not in bigRationalBigIntegerHashVar  or
        9876543212_ / 1234567890_ not in bigRationalBigRationalHashVar or
        9876543212_ / 1234567890_ not in bigRationalFloatHashVar       or
        9876543212_ / 1234567890_ not in bigRationalComplexHashVar     or
        9876543212_ / 1234567890_ not in bigRationalCharHashVar        or
        9876543212_ / 1234567890_ not in bigRationalStringHashVar      or
        9876543212_ / 1234567890_ not in bigRationalBstringHashVar     or
        9876543212_ / 1234567890_ not in bigRationalBitsetHashVar      or
        9876543212_ / 1234567890_ not in bigRationalTimeHashVar        or
        9876543212_ / 1234567890_ not in bigRationalEnumTypeHashVar    or
        9876543212_ / 1234567890_ not in bigRationalTypeHashVar        or
        9876543212_ / 1234567890_ not in bigRationalReferenceHashVar   or
        9876543212_ / 1234567890_ not in bigRationalHashHashVar        then
      writeln(" ***** Elements missing in hash[bigRational] table");
      okay := FALSE;
    end if;
    if  bigRationalBooleanHashVar     [9876543212_ / 1234567890_] <> TRUE                     or
        bigRationalIntegerHashVar     [9876543212_ / 1234567890_] <> 1234                     or
        bigRationalBigIntegerHashVar  [9876543212_ / 1234567890_] <> 9999999999_              or
        bigRationalBigRationalHashVar [9876543212_ / 1234567890_] <> 9999999999_ / 12345678_  or
        bigRationalFloatHashVar       [9876543212_ / 1234567890_] <> 3.1415926535             or
        bigRationalComplexHashVar     [9876543212_ / 1234567890_] <> complex(1.2, 3.4)        or
        bigRationalCharHashVar        [9876543212_ / 1234567890_] <> 'Q'                      or
        bigRationalStringHashVar      [9876543212_ / 1234567890_] <> "success"                or
        bigRationalBstringHashVar     [9876543212_ / 1234567890_] <> bstring("okay")          or
        bigRationalBitsetHashVar      [9876543212_ / 1234567890_] <> {123}                    or
        bigRationalTimeHashVar        [9876543212_ / 1234567890_] <> time("2011-12-13 14:15") or
        bigRationalEnumTypeHashVar    [9876543212_ / 1234567890_] <> GREEN                    or
        bigRationalTypeHashVar        [9876543212_ / 1234567890_] <> char                     or
        bigRationalReferenceHashVar   [9876543212_ / 1234567890_] <> NIL                      then
      writeln(" ***** Elements with wrong value in hash[bigRational] table");
      okay := FALSE;
    end if;
    if okay then
      writeln("Hash tables with bigRational keys work correctly.");
    else
      writeln(" ***** Hash tables with bigRational keys do not work correctly");
      writeln;
    end if;
  end func;


const proc: chkFloatHash is func
  local
    var boolean: okay is TRUE;
    var floatBooleanHash:     floatBooleanHashVar     is floatBooleanHash    .EMPTY_HASH;
    var floatIntegerHash:     floatIntegerHashVar     is floatIntegerHash    .EMPTY_HASH;
    var floatBigIntegerHash:  floatBigIntegerHashVar  is floatBigIntegerHash .EMPTY_HASH;
    var floatBigRationalHash: floatBigRationalHashVar is floatBigRationalHash.EMPTY_HASH;
    var floatFloatHash:       floatFloatHashVar       is floatFloatHash      .EMPTY_HASH;
    var floatComplexHash:     floatComplexHashVar     is floatComplexHash    .EMPTY_HASH;
    var floatCharHash:        floatCharHashVar        is floatCharHash       .EMPTY_HASH;
    var floatStringHash:      floatStringHashVar      is floatStringHash     .EMPTY_HASH;
    var floatBstringHash:     floatBstringHashVar     is floatBstringHash    .EMPTY_HASH;
    var floatBitsetHash:      floatBitsetHashVar      is floatBitsetHash     .EMPTY_HASH;
    var floatTimeHash:        floatTimeHashVar        is floatTimeHash       .EMPTY_HASH;
    var floatEnumTypeHash:    floatEnumTypeHashVar    is floatEnumTypeHash   .EMPTY_HASH;
    var floatTypeHash:        floatTypeHashVar        is floatTypeHash       .EMPTY_HASH;
    var floatReferenceHash:   floatReferenceHashVar   is floatReferenceHash  .EMPTY_HASH;
    var floatHashHash:        floatHashHashVar        is floatHashHash       .EMPTY_HASH;
  begin
    if  length(floatBooleanHashVar)     <> 0 or
        length(floatIntegerHashVar)     <> 0 or
        length(floatBigIntegerHashVar)  <> 0 or
        length(floatBigRationalHashVar) <> 0 or
        length(floatFloatHashVar)       <> 0 or
        length(floatComplexHashVar)     <> 0 or
        length(floatCharHashVar)        <> 0 or
        length(floatStringHashVar)      <> 0 or
        length(floatBstringHashVar)     <> 0 or
        length(floatBitsetHashVar)      <> 0 or
        length(floatTimeHashVar)        <> 0 or
        length(floatEnumTypeHashVar)    <> 0 or
        length(floatTypeHashVar)        <> 0 or
        length(floatReferenceHashVar)   <> 0 or
        length(floatHashHashVar)        <> 0 then
      writeln(" ***** Number of elements in empty hash[float] table not 0");
      okay := FALSE;
    end if;
    if  3.1415926535 in floatBooleanHashVar     or
        3.1415926535 in floatIntegerHashVar     or
        3.1415926535 in floatBigIntegerHashVar  or
        3.1415926535 in floatBigRationalHashVar or
        3.1415926535 in floatFloatHashVar       or
        3.1415926535 in floatComplexHashVar     or
        3.1415926535 in floatCharHashVar        or
        3.1415926535 in floatStringHashVar      or
        3.1415926535 in floatBstringHashVar     or
        3.1415926535 in floatBitsetHashVar      or
        3.1415926535 in floatTimeHashVar        or
        3.1415926535 in floatEnumTypeHashVar    or
        3.1415926535 in floatTypeHashVar        or
        3.1415926535 in floatReferenceHashVar   or
        3.1415926535 in floatHashHashVar        then
      writeln(" ***** Elements found in empty hash table");
      okay := FALSE;
    end if;
    if  keys(floatBooleanHashVar)     <> 0 times 0.0 or
        keys(floatIntegerHashVar)     <> 0 times 0.0 or
        keys(floatBigIntegerHashVar)  <> 0 times 0.0 or
        keys(floatBigRationalHashVar) <> 0 times 0.0 or
        keys(floatFloatHashVar)       <> 0 times 0.0 or
        keys(floatComplexHashVar)     <> 0 times 0.0 or
        keys(floatCharHashVar)        <> 0 times 0.0 or
        keys(floatStringHashVar)      <> 0 times 0.0 or
        keys(floatBstringHashVar)     <> 0 times 0.0 or
        keys(floatBitsetHashVar)      <> 0 times 0.0 or
        keys(floatTimeHashVar)        <> 0 times 0.0 or
        keys(floatEnumTypeHashVar)    <> 0 times 0.0 or
        keys(floatTypeHashVar)        <> 0 times 0.0 or
        keys(floatReferenceHashVar)   <> 0 times 0.0 or
        keys(floatHashHashVar)        <> 0 times 0.0 then
      writeln(" ***** Number of keys in empty hash[float] table is not 0");
      okay := FALSE;
    end if;
    if  values(floatBooleanHashVar)     <> 0 times FALSE or
        values(floatIntegerHashVar)     <> 0 times 0 or
        values(floatBigIntegerHashVar)  <> 0 times 0_ or
        values(floatBigRationalHashVar) <> 0 times 0_ / 1_ or
        values(floatFloatHashVar)       <> 0 times 0.0 or
        values(floatComplexHashVar)     <> 0 times complex(0.0, 0.0) or
        values(floatCharHashVar)        <> 0 times ' ' or
        values(floatStringHashVar)      <> 0 times "" or
        values(floatBstringHashVar)     <> 0 times bstring("") or
        values(floatBitsetHashVar)      <> 0 times {} or
        values(floatTimeHashVar)        <> 0 times time.value or
        values(floatEnumTypeHashVar)    <> 0 times RED or
        values(floatTypeHashVar)        <> 0 times boolean or
        values(floatReferenceHashVar)   <> 0 times NIL then
      writeln(" ***** Number of values in empty hash[float] table is not 0");
      okay := FALSE;
    end if;
    if  not raisesIndexError(floatBooleanHashVar     [3.1415926535]) or
        not raisesIndexError(floatIntegerHashVar     [3.1415926535]) or
        not raisesIndexError(floatBigIntegerHashVar  [3.1415926535]) or
        not raisesIndexError(floatBigRationalHashVar [3.1415926535]) or
        not raisesIndexError(floatFloatHashVar       [3.1415926535]) or
        not raisesIndexError(floatComplexHashVar     [3.1415926535]) or
        not raisesIndexError(floatCharHashVar        [3.1415926535]) or
        not raisesIndexError(floatStringHashVar      [3.1415926535]) or
        not raisesIndexError(floatBstringHashVar     [3.1415926535]) or
        not raisesIndexError(floatBitsetHashVar      [3.1415926535]) or
        not raisesIndexError(floatTimeHashVar        [3.1415926535]) or
        not raisesIndexError(floatEnumTypeHashVar    [3.1415926535]) or
        not raisesIndexError(floatTypeHashVar        [3.1415926535]) or
        not raisesIndexError(floatReferenceHashVar   [3.1415926535]) then
      writeln(" ***** Indexing into an empty hash[float] does not raise INDEX_ERROR");
      okay := FALSE;
    end if;
    floatBooleanHashVar     @:= [3.1415926535] TRUE;
    floatIntegerHashVar     @:= [3.1415926535] 1234;
    floatBigIntegerHashVar  @:= [3.1415926535] 9999999999_;
    floatBigRationalHashVar @:= [3.1415926535] 9999999999_ / 12345678_;
    floatFloatHashVar       @:= [3.1415926535] 3.1415926535;
    floatComplexHashVar     @:= [3.1415926535] complex(1.2, 3.4);
    floatCharHashVar        @:= [3.1415926535] 'Q';
    floatStringHashVar      @:= [3.1415926535] "success";
    floatBstringHashVar     @:= [3.1415926535] bstring("okay");
    floatBitsetHashVar      @:= [3.1415926535] {123};
    floatTimeHashVar        @:= [3.1415926535] time("2011-12-13 14:15");
    floatEnumTypeHashVar    @:= [3.1415926535] GREEN;
    floatTypeHashVar        @:= [3.1415926535] char;
    floatReferenceHashVar   @:= [3.1415926535] NIL;
    floatHashHashVar        @:= [3.1415926535] floatBooleanHashVar;
    if  length(floatBooleanHashVar)     <> 1 or
        length(floatIntegerHashVar)     <> 1 or
        length(floatBigIntegerHashVar)  <> 1 or
        length(floatBigRationalHashVar) <> 1 or
        length(floatFloatHashVar)       <> 1 or
        length(floatComplexHashVar)     <> 1 or
        length(floatCharHashVar)        <> 1 or
        length(floatStringHashVar)      <> 1 or
        length(floatBstringHashVar)     <> 1 or
        length(floatBitsetHashVar)      <> 1 or
        length(floatTimeHashVar)        <> 1 or
        length(floatEnumTypeHashVar)    <> 1 or
        length(floatTypeHashVar)        <> 1 or
        length(floatReferenceHashVar)   <> 1 or
        length(floatHashHashVar)        <> 1 then
      writeln(" ***** Number of elements in hash[float] table not 1");
      okay := FALSE;
    end if;
    if  3.1415926535 in floatBooleanHashVar     and
        3.1415926535 in floatIntegerHashVar     and
        3.1415926535 in floatBigIntegerHashVar  and
        3.1415926535 in floatBigRationalHashVar and
        3.1415926535 in floatFloatHashVar       and
        3.1415926535 in floatComplexHashVar     and
        3.1415926535 in floatCharHashVar        and
        3.1415926535 in floatStringHashVar      and
        3.1415926535 in floatBstringHashVar     and
        3.1415926535 in floatBitsetHashVar      and
        3.1415926535 in floatTimeHashVar        and
        3.1415926535 in floatEnumTypeHashVar    and
        3.1415926535 in floatTypeHashVar        and
        3.1415926535 in floatReferenceHashVar   and
        3.1415926535 in floatHashHashVar        then
      noop;
    else
      writeln(" ***** Elements missing in hash[float] table");
      okay := FALSE;
    end if;
    if  keys(floatBooleanHashVar)     <> [] (3.1415926535) or
        keys(floatIntegerHashVar)     <> [] (3.1415926535) or
        keys(floatBigIntegerHashVar)  <> [] (3.1415926535) or
        keys(floatBigRationalHashVar) <> [] (3.1415926535) or
        keys(floatFloatHashVar)       <> [] (3.1415926535) or
        keys(floatComplexHashVar)     <> [] (3.1415926535) or
        keys(floatCharHashVar)        <> [] (3.1415926535) or
        keys(floatStringHashVar)      <> [] (3.1415926535) or
        keys(floatBstringHashVar)     <> [] (3.1415926535) or
        keys(floatBitsetHashVar)      <> [] (3.1415926535) or
        keys(floatTimeHashVar)        <> [] (3.1415926535) or
        keys(floatEnumTypeHashVar)    <> [] (3.1415926535) or
        keys(floatTypeHashVar)        <> [] (3.1415926535) or
        keys(floatReferenceHashVar)   <> [] (3.1415926535) or
        keys(floatHashHashVar)        <> [] (3.1415926535) then
      writeln(" ***** keys(hash[float]) does not work correctly");
      okay := FALSE;
    end if;
    if  values(floatBooleanHashVar)     <> [] (TRUE) or
        values(floatIntegerHashVar)     <> [] (1234) or
        values(floatBigIntegerHashVar)  <> [] (9999999999_) or
        values(floatBigRationalHashVar) <> [] (9999999999_ / 12345678_) or
        values(floatFloatHashVar)       <> [] (3.1415926535) or
        values(floatComplexHashVar)     <> [] (complex(1.2, 3.4)) or
        values(floatCharHashVar)        <> [] ('Q') or
        values(floatStringHashVar)      <> [] ("success") or
        values(floatBstringHashVar)     <> [] (bstring("okay")) or
        values(floatBitsetHashVar)      <> [] ({123}) or
        values(floatTimeHashVar)        <> [] (time("2011-12-13 14:15")) or
        values(floatEnumTypeHashVar)    <> [] (GREEN) or
        values(floatTypeHashVar)        <> [] (char) or
        values(floatReferenceHashVar)   <> [] (NIL) then
      writeln(" ***** values(hash[float]) does not work correctly");
      okay := FALSE;
    end if;
    floatBooleanHashVar     @:= [3.1415926535] TRUE;
    floatIntegerHashVar     @:= [3.1415926535] 1234;
    floatBigIntegerHashVar  @:= [3.1415926535] 9999999999_;
    floatBigRationalHashVar @:= [3.1415926535] 9999999999_ / 12345678_;
    floatFloatHashVar       @:= [3.1415926535] 3.1415926535;
    floatComplexHashVar     @:= [3.1415926535] complex(1.2, 3.4);
    floatCharHashVar        @:= [3.1415926535] 'Q';
    floatStringHashVar      @:= [3.1415926535] "success";
    floatBstringHashVar     @:= [3.1415926535] bstring("okay");
    floatBitsetHashVar      @:= [3.1415926535] {123};
    floatTimeHashVar        @:= [3.1415926535] time("2011-12-13 14:15");
    floatEnumTypeHashVar    @:= [3.1415926535] GREEN;
    floatTypeHashVar        @:= [3.1415926535] char;
    floatReferenceHashVar   @:= [3.1415926535] NIL;
    floatHashHashVar        @:= [3.1415926535] floatBooleanHashVar;
    if  3.1415926535 not in floatBooleanHashVar     or
        3.1415926535 not in floatIntegerHashVar     or
        3.1415926535 not in floatBigIntegerHashVar  or
        3.1415926535 not in floatBigRationalHashVar or
        3.1415926535 not in floatFloatHashVar       or
        3.1415926535 not in floatComplexHashVar     or
        3.1415926535 not in floatCharHashVar        or
        3.1415926535 not in floatStringHashVar      or
        3.1415926535 not in floatBstringHashVar     or
        3.1415926535 not in floatBitsetHashVar      or
        3.1415926535 not in floatTimeHashVar        or
        3.1415926535 not in floatEnumTypeHashVar    or
        3.1415926535 not in floatTypeHashVar        or
        3.1415926535 not in floatReferenceHashVar   or
        3.1415926535 not in floatHashHashVar        then
      writeln(" ***** Elements missing in hash[float] table");
      okay := FALSE;
    end if;
    if  floatBooleanHashVar     [3.1415926535] <> TRUE                     or
        floatIntegerHashVar     [3.1415926535] <> 1234                     or
        floatBigIntegerHashVar  [3.1415926535] <> 9999999999_              or
        floatBigRationalHashVar [3.1415926535] <> 9999999999_ / 12345678_  or
        floatFloatHashVar       [3.1415926535] <> 3.1415926535             or
        floatComplexHashVar     [3.1415926535] <> complex(1.2, 3.4)        or
        floatCharHashVar        [3.1415926535] <> 'Q'                      or
        floatStringHashVar      [3.1415926535] <> "success"                or
        floatBstringHashVar     [3.1415926535] <> bstring("okay")          or
        floatBitsetHashVar      [3.1415926535] <> {123}                    or
        floatTimeHashVar        [3.1415926535] <> time("2011-12-13 14:15") or
        floatEnumTypeHashVar    [3.1415926535] <> GREEN                    or
        floatTypeHashVar        [3.1415926535] <> char                     or
        floatReferenceHashVar   [3.1415926535] <> NIL                      then
      writeln(" ***** Elements with wrong value in hash[float] table");
      okay := FALSE;
    end if;
    if okay then
      writeln("Hash tables with float keys work correctly.");
    else
      writeln(" ***** Hash tables with float keys do not work correctly");
      writeln;
    end if;
  end func;


const proc: chkComplexHash is func
  local
    var boolean: okay is TRUE;
    var complexBooleanHash:     complexBooleanHashVar     is complexBooleanHash    .EMPTY_HASH;
    var complexIntegerHash:     complexIntegerHashVar     is complexIntegerHash    .EMPTY_HASH;
    var complexBigIntegerHash:  complexBigIntegerHashVar  is complexBigIntegerHash .EMPTY_HASH;
    var complexBigRationalHash: complexBigRationalHashVar is complexBigRationalHash.EMPTY_HASH;
    var complexFloatHash:       complexFloatHashVar       is complexFloatHash      .EMPTY_HASH;
    var complexComplexHash:     complexComplexHashVar     is complexComplexHash    .EMPTY_HASH;
    var complexCharHash:        complexCharHashVar        is complexCharHash       .EMPTY_HASH;
    var complexStringHash:      complexStringHashVar      is complexStringHash     .EMPTY_HASH;
    var complexBstringHash:     complexBstringHashVar     is complexBstringHash    .EMPTY_HASH;
    var complexBitsetHash:      complexBitsetHashVar      is complexBitsetHash     .EMPTY_HASH;
    var complexTimeHash:        complexTimeHashVar        is complexTimeHash       .EMPTY_HASH;
    var complexEnumTypeHash:    complexEnumTypeHashVar    is complexEnumTypeHash   .EMPTY_HASH;
    var complexTypeHash:        complexTypeHashVar        is complexTypeHash       .EMPTY_HASH;
    var complexReferenceHash:   complexReferenceHashVar   is complexReferenceHash  .EMPTY_HASH;
    var complexHashHash:        complexHashHashVar        is complexHashHash       .EMPTY_HASH;
  begin
    if  length(complexBooleanHashVar)     <> 0 or
        length(complexIntegerHashVar)     <> 0 or
        length(complexBigIntegerHashVar)  <> 0 or
        length(complexBigRationalHashVar) <> 0 or
        length(complexFloatHashVar)       <> 0 or
        length(complexComplexHashVar)     <> 0 or
        length(complexCharHashVar)        <> 0 or
        length(complexStringHashVar)      <> 0 or
        length(complexBstringHashVar)     <> 0 or
        length(complexBitsetHashVar)      <> 0 or
        length(complexTimeHashVar)        <> 0 or
        length(complexEnumTypeHashVar)    <> 0 or
        length(complexTypeHashVar)        <> 0 or
        length(complexReferenceHashVar)   <> 0 or
        length(complexHashHashVar)        <> 0 then
      writeln(" ***** Number of elements in empty hash[complex] table not 0");
      okay := FALSE;
    end if;
    if  complex(5.6, 7.8) in complexBooleanHashVar     or
        complex(5.6, 7.8) in complexIntegerHashVar     or
        complex(5.6, 7.8) in complexBigIntegerHashVar  or
        complex(5.6, 7.8) in complexBigRationalHashVar or
        complex(5.6, 7.8) in complexFloatHashVar       or
        complex(5.6, 7.8) in complexComplexHashVar     or
        complex(5.6, 7.8) in complexCharHashVar        or
        complex(5.6, 7.8) in complexStringHashVar      or
        complex(5.6, 7.8) in complexBstringHashVar     or
        complex(5.6, 7.8) in complexBitsetHashVar      or
        complex(5.6, 7.8) in complexTimeHashVar        or
        complex(5.6, 7.8) in complexEnumTypeHashVar    or
        complex(5.6, 7.8) in complexTypeHashVar        or
        complex(5.6, 7.8) in complexReferenceHashVar   or
        complex(5.6, 7.8) in complexHashHashVar        then
      writeln(" ***** Elements found in empty hash table");
      okay := FALSE;
    end if;
    if  keys(complexBooleanHashVar)     <> 0 times complex(0.0, 0.0) or
        keys(complexIntegerHashVar)     <> 0 times complex(0.0, 0.0) or
        keys(complexBigIntegerHashVar)  <> 0 times complex(0.0, 0.0) or
        keys(complexBigRationalHashVar) <> 0 times complex(0.0, 0.0) or
        keys(complexFloatHashVar)       <> 0 times complex(0.0, 0.0) or
        keys(complexComplexHashVar)     <> 0 times complex(0.0, 0.0) or
        keys(complexCharHashVar)        <> 0 times complex(0.0, 0.0) or
        keys(complexStringHashVar)      <> 0 times complex(0.0, 0.0) or
        keys(complexBstringHashVar)     <> 0 times complex(0.0, 0.0) or
        keys(complexBitsetHashVar)      <> 0 times complex(0.0, 0.0) or
        keys(complexTimeHashVar)        <> 0 times complex(0.0, 0.0) or
        keys(complexEnumTypeHashVar)    <> 0 times complex(0.0, 0.0) or
        keys(complexTypeHashVar)        <> 0 times complex(0.0, 0.0) or
        keys(complexReferenceHashVar)   <> 0 times complex(0.0, 0.0) or
        keys(complexHashHashVar)        <> 0 times complex(0.0, 0.0) then
      writeln(" ***** Number of keys in empty hash[complex] table is not 0");
      okay := FALSE;
    end if;
    if  values(complexBooleanHashVar)     <> 0 times FALSE or
        values(complexIntegerHashVar)     <> 0 times 0 or
        values(complexBigIntegerHashVar)  <> 0 times 0_ or
        values(complexBigRationalHashVar) <> 0 times 0_ / 1_ or
        values(complexFloatHashVar)       <> 0 times 0.0 or
        values(complexComplexHashVar)     <> 0 times complex(0.0, 0.0) or
        values(complexCharHashVar)        <> 0 times ' ' or
        values(complexStringHashVar)      <> 0 times "" or
        values(complexBstringHashVar)     <> 0 times bstring("") or
        values(complexBitsetHashVar)      <> 0 times {} or
        values(complexTimeHashVar)        <> 0 times time.value or
        values(complexEnumTypeHashVar)    <> 0 times RED or
        values(complexTypeHashVar)        <> 0 times boolean or
        values(complexReferenceHashVar)   <> 0 times NIL then
      writeln(" ***** Number of values in empty hash[complex] table is not 0");
      okay := FALSE;
    end if;
    if  not raisesIndexError(complexBooleanHashVar     [complex(5.6, 7.8)]) or
        not raisesIndexError(complexIntegerHashVar     [complex(5.6, 7.8)]) or
        not raisesIndexError(complexBigIntegerHashVar  [complex(5.6, 7.8)]) or
        not raisesIndexError(complexBigRationalHashVar [complex(5.6, 7.8)]) or
        not raisesIndexError(complexFloatHashVar       [complex(5.6, 7.8)]) or
        not raisesIndexError(complexComplexHashVar     [complex(5.6, 7.8)]) or
        not raisesIndexError(complexCharHashVar        [complex(5.6, 7.8)]) or
        not raisesIndexError(complexStringHashVar      [complex(5.6, 7.8)]) or
        not raisesIndexError(complexBstringHashVar     [complex(5.6, 7.8)]) or
        not raisesIndexError(complexBitsetHashVar      [complex(5.6, 7.8)]) or
        not raisesIndexError(complexTimeHashVar        [complex(5.6, 7.8)]) or
        not raisesIndexError(complexEnumTypeHashVar    [complex(5.6, 7.8)]) or
        not raisesIndexError(complexTypeHashVar        [complex(5.6, 7.8)]) or
        not raisesIndexError(complexReferenceHashVar   [complex(5.6, 7.8)]) then
      writeln(" ***** Indexing into an empty hash[complex] does not raise INDEX_ERROR");
      okay := FALSE;
    end if;
    complexBooleanHashVar     @:= [complex(5.6, 7.8)] TRUE;
    complexIntegerHashVar     @:= [complex(5.6, 7.8)] 1234;
    complexBigIntegerHashVar  @:= [complex(5.6, 7.8)] 9999999999_;
    complexBigRationalHashVar @:= [complex(5.6, 7.8)] 9999999999_ / 12345678_;
    complexFloatHashVar       @:= [complex(5.6, 7.8)] 3.1415926535;
    complexComplexHashVar     @:= [complex(5.6, 7.8)] complex(1.2, 3.4);
    complexCharHashVar        @:= [complex(5.6, 7.8)] 'Q';
    complexStringHashVar      @:= [complex(5.6, 7.8)] "success";
    complexBstringHashVar     @:= [complex(5.6, 7.8)] bstring("okay");
    complexBitsetHashVar      @:= [complex(5.6, 7.8)] {123};
    complexTimeHashVar        @:= [complex(5.6, 7.8)] time("2011-12-13 14:15");
    complexEnumTypeHashVar    @:= [complex(5.6, 7.8)] GREEN;
    complexTypeHashVar        @:= [complex(5.6, 7.8)] char;
    complexReferenceHashVar   @:= [complex(5.6, 7.8)] NIL;
    complexHashHashVar        @:= [complex(5.6, 7.8)] complexBooleanHashVar;
    if  length(complexBooleanHashVar)     <> 1 or
        length(complexIntegerHashVar)     <> 1 or
        length(complexBigIntegerHashVar)  <> 1 or
        length(complexBigRationalHashVar) <> 1 or
        length(complexFloatHashVar)       <> 1 or
        length(complexComplexHashVar)     <> 1 or
        length(complexCharHashVar)        <> 1 or
        length(complexStringHashVar)      <> 1 or
        length(complexBstringHashVar)     <> 1 or
        length(complexBitsetHashVar)      <> 1 or
        length(complexTimeHashVar)        <> 1 or
        length(complexEnumTypeHashVar)    <> 1 or
        length(complexTypeHashVar)        <> 1 or
        length(complexReferenceHashVar)   <> 1 or
        length(complexHashHashVar)        <> 1 then
      writeln(" ***** Number of elements in hash[complex] table not 1");
      okay := FALSE;
    end if;
    if  complex(5.6, 7.8) in complexBooleanHashVar     and
        complex(5.6, 7.8) in complexIntegerHashVar     and
        complex(5.6, 7.8) in complexBigIntegerHashVar  and
        complex(5.6, 7.8) in complexBigRationalHashVar and
        complex(5.6, 7.8) in complexFloatHashVar       and
        complex(5.6, 7.8) in complexComplexHashVar     and
        complex(5.6, 7.8) in complexCharHashVar        and
        complex(5.6, 7.8) in complexStringHashVar      and
        complex(5.6, 7.8) in complexBstringHashVar     and
        complex(5.6, 7.8) in complexBitsetHashVar      and
        complex(5.6, 7.8) in complexTimeHashVar        and
        complex(5.6, 7.8) in complexEnumTypeHashVar    and
        complex(5.6, 7.8) in complexTypeHashVar        and
        complex(5.6, 7.8) in complexReferenceHashVar   and
        complex(5.6, 7.8) in complexHashHashVar        then
      noop;
    else
      writeln(" ***** Elements missing in hash[complex] table");
      okay := FALSE;
    end if;
    if  keys(complexBooleanHashVar)     <> [] (complex(5.6, 7.8)) or
        keys(complexIntegerHashVar)     <> [] (complex(5.6, 7.8)) or
        keys(complexBigIntegerHashVar)  <> [] (complex(5.6, 7.8)) or
        keys(complexBigRationalHashVar) <> [] (complex(5.6, 7.8)) or
        keys(complexFloatHashVar)       <> [] (complex(5.6, 7.8)) or
        keys(complexComplexHashVar)     <> [] (complex(5.6, 7.8)) or
        keys(complexCharHashVar)        <> [] (complex(5.6, 7.8)) or
        keys(complexStringHashVar)      <> [] (complex(5.6, 7.8)) or
        keys(complexBstringHashVar)     <> [] (complex(5.6, 7.8)) or
        keys(complexBitsetHashVar)      <> [] (complex(5.6, 7.8)) or
        keys(complexTimeHashVar)        <> [] (complex(5.6, 7.8)) or
        keys(complexEnumTypeHashVar)    <> [] (complex(5.6, 7.8)) or
        keys(complexTypeHashVar)        <> [] (complex(5.6, 7.8)) or
        keys(complexReferenceHashVar)   <> [] (complex(5.6, 7.8)) or
        keys(complexHashHashVar)        <> [] (complex(5.6, 7.8)) then
      writeln(" ***** keys(hash[complex]) does not work correctly");
      okay := FALSE;
    end if;
    if  values(complexBooleanHashVar)     <> [] (TRUE) or
        values(complexIntegerHashVar)     <> [] (1234) or
        values(complexBigIntegerHashVar)  <> [] (9999999999_) or
        values(complexBigRationalHashVar) <> [] (9999999999_ / 12345678_) or
        values(complexFloatHashVar)       <> [] (3.1415926535) or
        values(complexComplexHashVar)     <> [] (complex(1.2, 3.4)) or
        values(complexCharHashVar)        <> [] ('Q') or
        values(complexStringHashVar)      <> [] ("success") or
        values(complexBstringHashVar)     <> [] (bstring("okay")) or
        values(complexBitsetHashVar)      <> [] ({123}) or
        values(complexTimeHashVar)        <> [] (time("2011-12-13 14:15")) or
        values(complexEnumTypeHashVar)    <> [] (GREEN) or
        values(complexTypeHashVar)        <> [] (char) or
        values(complexReferenceHashVar)   <> [] (NIL) then
      writeln(" ***** values(hash[complex]) does not work correctly");
      okay := FALSE;
    end if;
    complexBooleanHashVar     @:= [complex(5.6, 7.8)] TRUE;
    complexIntegerHashVar     @:= [complex(5.6, 7.8)] 1234;
    complexBigIntegerHashVar  @:= [complex(5.6, 7.8)] 9999999999_;
    complexBigRationalHashVar @:= [complex(5.6, 7.8)] 9999999999_ / 12345678_;
    complexFloatHashVar       @:= [complex(5.6, 7.8)] 3.1415926535;
    complexComplexHashVar     @:= [complex(5.6, 7.8)] complex(1.2, 3.4);
    complexCharHashVar        @:= [complex(5.6, 7.8)] 'Q';
    complexStringHashVar      @:= [complex(5.6, 7.8)] "success";
    complexBstringHashVar     @:= [complex(5.6, 7.8)] bstring("okay");
    complexBitsetHashVar      @:= [complex(5.6, 7.8)] {123};
    complexTimeHashVar        @:= [complex(5.6, 7.8)] time("2011-12-13 14:15");
    complexEnumTypeHashVar    @:= [complex(5.6, 7.8)] GREEN;
    complexTypeHashVar        @:= [complex(5.6, 7.8)] char;
    complexReferenceHashVar   @:= [complex(5.6, 7.8)] NIL;
    complexHashHashVar        @:= [complex(5.6, 7.8)] complexBooleanHashVar;
    if  complex(5.6, 7.8) not in complexBooleanHashVar     or
        complex(5.6, 7.8) not in complexIntegerHashVar     or
        complex(5.6, 7.8) not in complexBigIntegerHashVar  or
        complex(5.6, 7.8) not in complexBigRationalHashVar or
        complex(5.6, 7.8) not in complexFloatHashVar       or
        complex(5.6, 7.8) not in complexComplexHashVar     or
        complex(5.6, 7.8) not in complexCharHashVar        or
        complex(5.6, 7.8) not in complexStringHashVar      or
        complex(5.6, 7.8) not in complexBstringHashVar     or
        complex(5.6, 7.8) not in complexBitsetHashVar      or
        complex(5.6, 7.8) not in complexTimeHashVar        or
        complex(5.6, 7.8) not in complexEnumTypeHashVar    or
        complex(5.6, 7.8) not in complexTypeHashVar        or
        complex(5.6, 7.8) not in complexReferenceHashVar   or
        complex(5.6, 7.8) not in complexHashHashVar        then
      writeln(" ***** Elements missing in hash[complex] table");
      okay := FALSE;
    end if;
    if  complexBooleanHashVar     [complex(5.6, 7.8)] <> TRUE                     or
        complexIntegerHashVar     [complex(5.6, 7.8)] <> 1234                     or
        complexBigIntegerHashVar  [complex(5.6, 7.8)] <> 9999999999_              or
        complexBigRationalHashVar [complex(5.6, 7.8)] <> 9999999999_ / 12345678_  or
        complexFloatHashVar       [complex(5.6, 7.8)] <> 3.1415926535             or
        complexComplexHashVar     [complex(5.6, 7.8)] <> complex(1.2, 3.4)        or
        complexCharHashVar        [complex(5.6, 7.8)] <> 'Q'                      or
        complexStringHashVar      [complex(5.6, 7.8)] <> "success"                or
        complexBstringHashVar     [complex(5.6, 7.8)] <> bstring("okay")          or
        complexBitsetHashVar      [complex(5.6, 7.8)] <> {123}                    or
        complexTimeHashVar        [complex(5.6, 7.8)] <> time("2011-12-13 14:15") or
        complexEnumTypeHashVar    [complex(5.6, 7.8)] <> GREEN                    or
        complexTypeHashVar        [complex(5.6, 7.8)] <> char                     or
        complexReferenceHashVar   [complex(5.6, 7.8)] <> NIL                      then
      writeln(" ***** Elements with wrong value in hash[complex] table");
      okay := FALSE;
    end if;
    if okay then
      writeln("Hash tables with complex keys work correctly.");
    else
      writeln(" ***** Hash tables with complex keys do not work correctly");
      writeln;
    end if;
  end func;


const proc: chkCharHash is func
  local
    var boolean: okay is TRUE;
    var charBooleanHash:     charBooleanHashVar     is charBooleanHash    .EMPTY_HASH;
    var charIntegerHash:     charIntegerHashVar     is charIntegerHash    .EMPTY_HASH;
    var charBigIntegerHash:  charBigIntegerHashVar  is charBigIntegerHash .EMPTY_HASH;
    var charBigRationalHash: charBigRationalHashVar is charBigRationalHash.EMPTY_HASH;
    var charFloatHash:       charFloatHashVar       is charFloatHash      .EMPTY_HASH;
    var charComplexHash:     charComplexHashVar     is charComplexHash    .EMPTY_HASH;
    var charCharHash:        charCharHashVar        is charCharHash       .EMPTY_HASH;
    var charStringHash:      charStringHashVar      is charStringHash     .EMPTY_HASH;
    var charBstringHash:     charBstringHashVar     is charBstringHash    .EMPTY_HASH;
    var charBitsetHash:      charBitsetHashVar      is charBitsetHash     .EMPTY_HASH;
    var charTimeHash:        charTimeHashVar        is charTimeHash       .EMPTY_HASH;
    var charEnumTypeHash:    charEnumTypeHashVar    is charEnumTypeHash   .EMPTY_HASH;
    var charTypeHash:        charTypeHashVar        is charTypeHash       .EMPTY_HASH;
    var charReferenceHash:   charReferenceHashVar   is charReferenceHash  .EMPTY_HASH;
    var charHashHash:        charHashHashVar        is charHashHash       .EMPTY_HASH;
  begin
    if  length(charBooleanHashVar)     <> 0 or
        length(charIntegerHashVar)     <> 0 or
        length(charBigIntegerHashVar)  <> 0 or
        length(charBigRationalHashVar) <> 0 or
        length(charFloatHashVar)       <> 0 or
        length(charComplexHashVar)     <> 0 or
        length(charCharHashVar)        <> 0 or
        length(charStringHashVar)      <> 0 or
        length(charBstringHashVar)     <> 0 or
        length(charBitsetHashVar)      <> 0 or
        length(charTimeHashVar)        <> 0 or
        length(charEnumTypeHashVar)    <> 0 or
        length(charTypeHashVar)        <> 0 or
        length(charReferenceHashVar)   <> 0 or
        length(charHashHashVar)        <> 0 then
      writeln(" ***** Number of elements in empty hash[char] table not 0");
      okay := FALSE;
    end if;
    if  'k' in charBooleanHashVar     or
        'k' in charIntegerHashVar     or
        'k' in charBigIntegerHashVar  or
        'k' in charBigRationalHashVar or
        'k' in charFloatHashVar       or
        'k' in charComplexHashVar     or
        'k' in charCharHashVar        or
        'k' in charStringHashVar      or
        'k' in charBstringHashVar     or
        'k' in charBitsetHashVar      or
        'k' in charTimeHashVar        or
        'k' in charEnumTypeHashVar    or
        'k' in charTypeHashVar        or
        'k' in charReferenceHashVar   or
        'k' in charHashHashVar        then
      writeln(" ***** Elements found in empty hash table");
      okay := FALSE;
    end if;
    if  keys(charBooleanHashVar)     <> 0 times ' ' or
        keys(charIntegerHashVar)     <> 0 times ' ' or
        keys(charBigIntegerHashVar)  <> 0 times ' ' or
        keys(charBigRationalHashVar) <> 0 times ' ' or
        keys(charFloatHashVar)       <> 0 times ' ' or
        keys(charComplexHashVar)     <> 0 times ' ' or
        keys(charCharHashVar)        <> 0 times ' ' or
        keys(charStringHashVar)      <> 0 times ' ' or
        keys(charBstringHashVar)     <> 0 times ' ' or
        keys(charBitsetHashVar)      <> 0 times ' ' or
        keys(charTimeHashVar)        <> 0 times ' ' or
        keys(charEnumTypeHashVar)    <> 0 times ' ' or
        keys(charTypeHashVar)        <> 0 times ' ' or
        keys(charReferenceHashVar)   <> 0 times ' ' or
        keys(charHashHashVar)        <> 0 times ' ' then
      writeln(" ***** Number of keys in empty hash[char] table is not 0");
      okay := FALSE;
    end if;
    if  values(charBooleanHashVar)     <> 0 times FALSE or
        values(charIntegerHashVar)     <> 0 times 0 or
        values(charBigIntegerHashVar)  <> 0 times 0_ or
        values(charBigRationalHashVar) <> 0 times 0_ / 1_ or
        values(charFloatHashVar)       <> 0 times 0.0 or
        values(charComplexHashVar)     <> 0 times complex(0.0, 0.0) or
        values(charCharHashVar)        <> 0 times ' ' or
        values(charStringHashVar)      <> 0 times "" or
        values(charBstringHashVar)     <> 0 times bstring("") or
        values(charBitsetHashVar)      <> 0 times {} or
        values(charTimeHashVar)        <> 0 times time.value or
        values(charEnumTypeHashVar)    <> 0 times RED or
        values(charTypeHashVar)        <> 0 times boolean or
        values(charReferenceHashVar)   <> 0 times NIL then
      writeln(" ***** Number of values in empty hash[char] table is not 0");
      okay := FALSE;
    end if;
    if  not raisesIndexError(charBooleanHashVar     ['k']) or
        not raisesIndexError(charIntegerHashVar     ['k']) or
        not raisesIndexError(charBigIntegerHashVar  ['k']) or
        not raisesIndexError(charBigRationalHashVar ['k']) or
        not raisesIndexError(charFloatHashVar       ['k']) or
        not raisesIndexError(charComplexHashVar     ['k']) or
        not raisesIndexError(charCharHashVar        ['k']) or
        not raisesIndexError(charStringHashVar      ['k']) or
        not raisesIndexError(charBstringHashVar     ['k']) or
        not raisesIndexError(charBitsetHashVar      ['k']) or
        not raisesIndexError(charTimeHashVar        ['k']) or
        not raisesIndexError(charEnumTypeHashVar    ['k']) or
        not raisesIndexError(charTypeHashVar        ['k']) or
        not raisesIndexError(charReferenceHashVar   ['k']) then
      writeln(" ***** Indexing into an empty hash[char] does not raise INDEX_ERROR");
      okay := FALSE;
    end if;
    charBooleanHashVar     @:= ['k'] TRUE;
    charIntegerHashVar     @:= ['k'] 1234;
    charBigIntegerHashVar  @:= ['k'] 9999999999_;
    charBigRationalHashVar @:= ['k'] 9999999999_ / 12345678_;
    charFloatHashVar       @:= ['k'] 3.1415926535;
    charComplexHashVar     @:= ['k'] complex(1.2, 3.4);
    charCharHashVar        @:= ['k'] 'Q';
    charStringHashVar      @:= ['k'] "success";
    charBstringHashVar     @:= ['k'] bstring("okay");
    charBitsetHashVar      @:= ['k'] {123};
    charTimeHashVar        @:= ['k'] time("2011-12-13 14:15");
    charEnumTypeHashVar    @:= ['k'] GREEN;
    charTypeHashVar        @:= ['k'] char;
    charReferenceHashVar   @:= ['k'] NIL;
    charHashHashVar        @:= ['k'] charBooleanHashVar;
    if  length(charBooleanHashVar)     <> 1 or
        length(charIntegerHashVar)     <> 1 or
        length(charBigIntegerHashVar)  <> 1 or
        length(charBigRationalHashVar) <> 1 or
        length(charFloatHashVar)       <> 1 or
        length(charComplexHashVar)     <> 1 or
        length(charCharHashVar)        <> 1 or
        length(charStringHashVar)      <> 1 or
        length(charBstringHashVar)     <> 1 or
        length(charBitsetHashVar)      <> 1 or
        length(charTimeHashVar)        <> 1 or
        length(charEnumTypeHashVar)    <> 1 or
        length(charTypeHashVar)        <> 1 or
        length(charReferenceHashVar)   <> 1 or
        length(charHashHashVar)        <> 1 then
      writeln(" ***** Number of elements in hash[char] table not 1");
      okay := FALSE;
    end if;
    if  'k' in charBooleanHashVar     and
        'k' in charIntegerHashVar     and
        'k' in charBigIntegerHashVar  and
        'k' in charBigRationalHashVar and
        'k' in charFloatHashVar       and
        'k' in charComplexHashVar     and
        'k' in charCharHashVar        and
        'k' in charStringHashVar      and
        'k' in charBstringHashVar     and
        'k' in charBitsetHashVar      and
        'k' in charTimeHashVar        and
        'k' in charEnumTypeHashVar    and
        'k' in charTypeHashVar        and
        'k' in charReferenceHashVar   and
        'k' in charHashHashVar        then
      noop;
    else
      writeln(" ***** Elements missing in hash[char] table");
      okay := FALSE;
    end if;
    if  keys(charBooleanHashVar)     <> [] ('k') or
        keys(charIntegerHashVar)     <> [] ('k') or
        keys(charBigIntegerHashVar)  <> [] ('k') or
        keys(charBigRationalHashVar) <> [] ('k') or
        keys(charFloatHashVar)       <> [] ('k') or
        keys(charComplexHashVar)     <> [] ('k') or
        keys(charCharHashVar)        <> [] ('k') or
        keys(charStringHashVar)      <> [] ('k') or
        keys(charBstringHashVar)     <> [] ('k') or
        keys(charBitsetHashVar)      <> [] ('k') or
        keys(charTimeHashVar)        <> [] ('k') or
        keys(charEnumTypeHashVar)    <> [] ('k') or
        keys(charTypeHashVar)        <> [] ('k') or
        keys(charReferenceHashVar)   <> [] ('k') or
        keys(charHashHashVar)        <> [] ('k') then
      writeln(" ***** keys(hash[char]) does not work correctly");
      okay := FALSE;
    end if;
    if  values(charBooleanHashVar)     <> [] (TRUE) or
        values(charIntegerHashVar)     <> [] (1234) or
        values(charBigIntegerHashVar)  <> [] (9999999999_) or
        values(charBigRationalHashVar) <> [] (9999999999_ / 12345678_) or
        values(charFloatHashVar)       <> [] (3.1415926535) or
        values(charComplexHashVar)     <> [] (complex(1.2, 3.4)) or
        values(charCharHashVar)        <> [] ('Q') or
        values(charStringHashVar)      <> [] ("success") or
        values(charBstringHashVar)     <> [] (bstring("okay")) or
        values(charBitsetHashVar)      <> [] ({123}) or
        values(charTimeHashVar)        <> [] (time("2011-12-13 14:15")) or
        values(charEnumTypeHashVar)    <> [] (GREEN) or
        values(charTypeHashVar)        <> [] (char) or
        values(charReferenceHashVar)   <> [] (NIL) then
      writeln(" ***** values(hash[char]) does not work correctly");
      okay := FALSE;
    end if;
    charBooleanHashVar     @:= ['k'] TRUE;
    charIntegerHashVar     @:= ['k'] 1234;
    charBigIntegerHashVar  @:= ['k'] 9999999999_;
    charBigRationalHashVar @:= ['k'] 9999999999_ / 12345678_;
    charFloatHashVar       @:= ['k'] 3.1415926535;
    charComplexHashVar     @:= ['k'] complex(1.2, 3.4);
    charCharHashVar        @:= ['k'] 'Q';
    charStringHashVar      @:= ['k'] "success";
    charBstringHashVar     @:= ['k'] bstring("okay");
    charBitsetHashVar      @:= ['k'] {123};
    charTimeHashVar        @:= ['k'] time("2011-12-13 14:15");
    charEnumTypeHashVar    @:= ['k'] GREEN;
    charTypeHashVar        @:= ['k'] char;
    charReferenceHashVar   @:= ['k'] NIL;
    charHashHashVar        @:= ['k'] charBooleanHashVar;
    if  'k' not in charBooleanHashVar     or
        'k' not in charIntegerHashVar     or
        'k' not in charBigIntegerHashVar  or
        'k' not in charBigRationalHashVar or
        'k' not in charFloatHashVar       or
        'k' not in charComplexHashVar     or
        'k' not in charCharHashVar        or
        'k' not in charStringHashVar      or
        'k' not in charBstringHashVar     or
        'k' not in charBitsetHashVar      or
        'k' not in charTimeHashVar        or
        'k' not in charEnumTypeHashVar    or
        'k' not in charTypeHashVar        or
        'k' not in charReferenceHashVar   or
        'k' not in charHashHashVar        then
      writeln(" ***** Elements missing in hash[char] table");
      okay := FALSE;
    end if;
    if  charBooleanHashVar     ['k'] <> TRUE                     or
        charIntegerHashVar     ['k'] <> 1234                     or
        charBigIntegerHashVar  ['k'] <> 9999999999_              or
        charBigRationalHashVar ['k'] <> 9999999999_ / 12345678_  or
        charFloatHashVar       ['k'] <> 3.1415926535             or
        charComplexHashVar     ['k'] <> complex(1.2, 3.4)        or
        charCharHashVar        ['k'] <> 'Q'                      or
        charStringHashVar      ['k'] <> "success"                or
        charBstringHashVar     ['k'] <> bstring("okay")          or
        charBitsetHashVar      ['k'] <> {123}                    or
        charTimeHashVar        ['k'] <> time("2011-12-13 14:15") or
        charEnumTypeHashVar    ['k'] <> GREEN                    or
        charTypeHashVar        ['k'] <> char                     or
        charReferenceHashVar   ['k'] <> NIL                      then
      writeln(" ***** Elements with wrong value in hash[char] table");
      okay := FALSE;
    end if;
    if okay then
      writeln("Hash tables with char keys work correctly.");
    else
      writeln(" ***** Hash tables with char keys do not work correctly");
      writeln;
    end if;
  end func;


const proc: chkStringHash is func
  local
    var boolean: okay is TRUE;
    var stringBooleanHash:     stringBooleanHashVar     is stringBooleanHash    .EMPTY_HASH;
    var stringIntegerHash:     stringIntegerHashVar     is stringIntegerHash    .EMPTY_HASH;
    var stringBigIntegerHash:  stringBigIntegerHashVar  is stringBigIntegerHash .EMPTY_HASH;
    var stringBigRationalHash: stringBigRationalHashVar is stringBigRationalHash.EMPTY_HASH;
    var stringFloatHash:       stringFloatHashVar       is stringFloatHash      .EMPTY_HASH;
    var stringComplexHash:     stringComplexHashVar     is stringComplexHash    .EMPTY_HASH;
    var stringCharHash:        stringCharHashVar        is stringCharHash       .EMPTY_HASH;
    var stringStringHash:      stringStringHashVar      is stringStringHash     .EMPTY_HASH;
    var stringBstringHash:     stringBstringHashVar     is stringBstringHash    .EMPTY_HASH;
    var stringBitsetHash:      stringBitsetHashVar      is stringBitsetHash     .EMPTY_HASH;
    var stringTimeHash:        stringTimeHashVar        is stringTimeHash       .EMPTY_HASH;
    var stringEnumTypeHash:    stringEnumTypeHashVar    is stringEnumTypeHash   .EMPTY_HASH;
    var stringTypeHash:        stringTypeHashVar        is stringTypeHash       .EMPTY_HASH;
    var stringReferenceHash:   stringReferenceHashVar   is stringReferenceHash  .EMPTY_HASH;
    var stringHashHash:        stringHashHashVar        is stringHashHash       .EMPTY_HASH;
  begin
    if  length(stringBooleanHashVar)     <> 0 or
        length(stringIntegerHashVar)     <> 0 or
        length(stringBigIntegerHashVar)  <> 0 or
        length(stringBigRationalHashVar) <> 0 or
        length(stringFloatHashVar)       <> 0 or
        length(stringComplexHashVar)     <> 0 or
        length(stringCharHashVar)        <> 0 or
        length(stringStringHashVar)      <> 0 or
        length(stringBstringHashVar)     <> 0 or
        length(stringBitsetHashVar)      <> 0 or
        length(stringTimeHashVar)        <> 0 or
        length(stringEnumTypeHashVar)    <> 0 or
        length(stringTypeHashVar)        <> 0 or
        length(stringReferenceHashVar)   <> 0 or
        length(stringHashHashVar)        <> 0 then
      writeln(" ***** Number of elements in empty hash[string] table not 0");
      okay := FALSE;
    end if;
    if  "asdfghjkl" in stringBooleanHashVar     or
        "asdfghjkl" in stringIntegerHashVar     or
        "asdfghjkl" in stringBigIntegerHashVar  or
        "asdfghjkl" in stringBigRationalHashVar or
        "asdfghjkl" in stringFloatHashVar       or
        "asdfghjkl" in stringComplexHashVar     or
        "asdfghjkl" in stringCharHashVar        or
        "asdfghjkl" in stringStringHashVar      or
        "asdfghjkl" in stringBstringHashVar     or
        "asdfghjkl" in stringBitsetHashVar      or
        "asdfghjkl" in stringTimeHashVar        or
        "asdfghjkl" in stringEnumTypeHashVar    or
        "asdfghjkl" in stringTypeHashVar        or
        "asdfghjkl" in stringReferenceHashVar   or
        "asdfghjkl" in stringHashHashVar        then
      writeln(" ***** Elements found in empty hash table");
      okay := FALSE;
    end if;
    if  keys(stringBooleanHashVar)     <> 0 times "" or
        keys(stringIntegerHashVar)     <> 0 times "" or
        keys(stringBigIntegerHashVar)  <> 0 times "" or
        keys(stringBigRationalHashVar) <> 0 times "" or
        keys(stringFloatHashVar)       <> 0 times "" or
        keys(stringComplexHashVar)     <> 0 times "" or
        keys(stringCharHashVar)        <> 0 times "" or
        keys(stringStringHashVar)      <> 0 times "" or
        keys(stringBstringHashVar)     <> 0 times "" or
        keys(stringBitsetHashVar)      <> 0 times "" or
        keys(stringTimeHashVar)        <> 0 times "" or
        keys(stringEnumTypeHashVar)    <> 0 times "" or
        keys(stringTypeHashVar)        <> 0 times "" or
        keys(stringReferenceHashVar)   <> 0 times "" or
        keys(stringHashHashVar)        <> 0 times "" then
      writeln(" ***** Number of keys in empty hash[string] table is not 0");
      okay := FALSE;
    end if;
    if  values(stringBooleanHashVar)     <> 0 times FALSE or
        values(stringIntegerHashVar)     <> 0 times 0 or
        values(stringBigIntegerHashVar)  <> 0 times 0_ or
        values(stringBigRationalHashVar) <> 0 times 0_ / 1_ or
        values(stringFloatHashVar)       <> 0 times 0.0 or
        values(stringComplexHashVar)     <> 0 times complex(0.0, 0.0) or
        values(stringCharHashVar)        <> 0 times ' ' or
        values(stringStringHashVar)      <> 0 times "" or
        values(stringBstringHashVar)     <> 0 times bstring("") or
        values(stringBitsetHashVar)      <> 0 times {} or
        values(stringTimeHashVar)        <> 0 times time.value or
        values(stringEnumTypeHashVar)    <> 0 times RED or
        values(stringTypeHashVar)        <> 0 times boolean or
        values(stringReferenceHashVar)   <> 0 times NIL then
      writeln(" ***** Number of values in empty hash[string] table is not 0");
      okay := FALSE;
    end if;
    if  not raisesIndexError(stringBooleanHashVar     ["asdfghjkl"]) or
        not raisesIndexError(stringIntegerHashVar     ["asdfghjkl"]) or
        not raisesIndexError(stringBigIntegerHashVar  ["asdfghjkl"]) or
        not raisesIndexError(stringBigRationalHashVar ["asdfghjkl"]) or
        not raisesIndexError(stringFloatHashVar       ["asdfghjkl"]) or
        not raisesIndexError(stringComplexHashVar     ["asdfghjkl"]) or
        not raisesIndexError(stringCharHashVar        ["asdfghjkl"]) or
        not raisesIndexError(stringStringHashVar      ["asdfghjkl"]) or
        not raisesIndexError(stringBstringHashVar     ["asdfghjkl"]) or
        not raisesIndexError(stringBitsetHashVar      ["asdfghjkl"]) or
        not raisesIndexError(stringTimeHashVar        ["asdfghjkl"]) or
        not raisesIndexError(stringEnumTypeHashVar    ["asdfghjkl"]) or
        not raisesIndexError(stringTypeHashVar        ["asdfghjkl"]) or
        not raisesIndexError(stringReferenceHashVar   ["asdfghjkl"]) then
      writeln(" ***** Indexing into an empty hash[string] does not raise INDEX_ERROR");
      okay := FALSE;
    end if;
    stringBooleanHashVar     @:= ["asdfghjkl"] TRUE;
    stringIntegerHashVar     @:= ["asdfghjkl"] 1234;
    stringBigIntegerHashVar  @:= ["asdfghjkl"] 9999999999_;
    stringBigRationalHashVar @:= ["asdfghjkl"] 9999999999_ / 12345678_;
    stringFloatHashVar       @:= ["asdfghjkl"] 3.1415926535;
    stringComplexHashVar     @:= ["asdfghjkl"] complex(1.2, 3.4);
    stringCharHashVar        @:= ["asdfghjkl"] 'Q';
    stringStringHashVar      @:= ["asdfghjkl"] "success";
    stringBstringHashVar     @:= ["asdfghjkl"] bstring("okay");
    stringBitsetHashVar      @:= ["asdfghjkl"] {123};
    stringTimeHashVar        @:= ["asdfghjkl"] time("2011-12-13 14:15");
    stringEnumTypeHashVar    @:= ["asdfghjkl"] GREEN;
    stringTypeHashVar        @:= ["asdfghjkl"] char;
    stringReferenceHashVar   @:= ["asdfghjkl"] NIL;
    stringHashHashVar        @:= ["asdfghjkl"] stringBooleanHashVar;
    if  length(stringBooleanHashVar)     <> 1 or
        length(stringIntegerHashVar)     <> 1 or
        length(stringBigIntegerHashVar)  <> 1 or
        length(stringBigRationalHashVar) <> 1 or
        length(stringFloatHashVar)       <> 1 or
        length(stringComplexHashVar)     <> 1 or
        length(stringCharHashVar)        <> 1 or
        length(stringStringHashVar)      <> 1 or
        length(stringBstringHashVar)     <> 1 or
        length(stringBitsetHashVar)      <> 1 or
        length(stringTimeHashVar)        <> 1 or
        length(stringEnumTypeHashVar)    <> 1 or
        length(stringTypeHashVar)        <> 1 or
        length(stringReferenceHashVar)   <> 1 or
        length(stringHashHashVar)        <> 1 then
      writeln(" ***** Number of elements in hash[string] table not 1");
      okay := FALSE;
    end if;
    if  "asdfghjkl" in stringBooleanHashVar     and
        "asdfghjkl" in stringIntegerHashVar     and
        "asdfghjkl" in stringBigIntegerHashVar  and
        "asdfghjkl" in stringBigRationalHashVar and
        "asdfghjkl" in stringFloatHashVar       and
        "asdfghjkl" in stringComplexHashVar     and
        "asdfghjkl" in stringCharHashVar        and
        "asdfghjkl" in stringStringHashVar      and
        "asdfghjkl" in stringBstringHashVar     and
        "asdfghjkl" in stringBitsetHashVar      and
        "asdfghjkl" in stringTimeHashVar        and
        "asdfghjkl" in stringEnumTypeHashVar    and
        "asdfghjkl" in stringTypeHashVar        and
        "asdfghjkl" in stringReferenceHashVar   and
        "asdfghjkl" in stringHashHashVar        then
      noop;
    else
      writeln(" ***** Elements missing in hash[string] table");
      okay := FALSE;
    end if;
    if  keys(stringBooleanHashVar)     <> [] ("asdfghjkl") or
        keys(stringIntegerHashVar)     <> [] ("asdfghjkl") or
        keys(stringBigIntegerHashVar)  <> [] ("asdfghjkl") or
        keys(stringBigRationalHashVar) <> [] ("asdfghjkl") or
        keys(stringFloatHashVar)       <> [] ("asdfghjkl") or
        keys(stringComplexHashVar)     <> [] ("asdfghjkl") or
        keys(stringCharHashVar)        <> [] ("asdfghjkl") or
        keys(stringStringHashVar)      <> [] ("asdfghjkl") or
        keys(stringBstringHashVar)     <> [] ("asdfghjkl") or
        keys(stringBitsetHashVar)      <> [] ("asdfghjkl") or
        keys(stringTimeHashVar)        <> [] ("asdfghjkl") or
        keys(stringEnumTypeHashVar)    <> [] ("asdfghjkl") or
        keys(stringTypeHashVar)        <> [] ("asdfghjkl") or
        keys(stringReferenceHashVar)   <> [] ("asdfghjkl") or
        keys(stringHashHashVar)        <> [] ("asdfghjkl") then
      writeln(" ***** keys(hash[string]) does not work correctly");
      okay := FALSE;
    end if;
    if  values(stringBooleanHashVar)     <> [] (TRUE) or
        values(stringIntegerHashVar)     <> [] (1234) or
        values(stringBigIntegerHashVar)  <> [] (9999999999_) or
        values(stringBigRationalHashVar) <> [] (9999999999_ / 12345678_) or
        values(stringFloatHashVar)       <> [] (3.1415926535) or
        values(stringComplexHashVar)     <> [] (complex(1.2, 3.4)) or
        values(stringCharHashVar)        <> [] ('Q') or
        values(stringStringHashVar)      <> [] ("success") or
        values(stringBstringHashVar)     <> [] (bstring("okay")) or
        values(stringBitsetHashVar)      <> [] ({123}) or
        values(stringTimeHashVar)        <> [] (time("2011-12-13 14:15")) or
        values(stringEnumTypeHashVar)    <> [] (GREEN) or
        values(stringTypeHashVar)        <> [] (char) or
        values(stringReferenceHashVar)   <> [] (NIL) then
      writeln(" ***** values(hash[string]) does not work correctly");
      okay := FALSE;
    end if;
    stringBooleanHashVar     @:= ["asdfghjkl"] TRUE;
    stringIntegerHashVar     @:= ["asdfghjkl"] 1234;
    stringBigIntegerHashVar  @:= ["asdfghjkl"] 9999999999_;
    stringBigRationalHashVar @:= ["asdfghjkl"] 9999999999_ / 12345678_;
    stringFloatHashVar       @:= ["asdfghjkl"] 3.1415926535;
    stringComplexHashVar     @:= ["asdfghjkl"] complex(1.2, 3.4);
    stringCharHashVar        @:= ["asdfghjkl"] 'Q';
    stringStringHashVar      @:= ["asdfghjkl"] "success";
    stringBstringHashVar     @:= ["asdfghjkl"] bstring("okay");
    stringBitsetHashVar      @:= ["asdfghjkl"] {123};
    stringTimeHashVar        @:= ["asdfghjkl"] time("2011-12-13 14:15");
    stringEnumTypeHashVar    @:= ["asdfghjkl"] GREEN;
    stringTypeHashVar        @:= ["asdfghjkl"] char;
    stringReferenceHashVar   @:= ["asdfghjkl"] NIL;
    stringHashHashVar        @:= ["asdfghjkl"] stringBooleanHashVar;
    if  "asdfghjkl" not in stringBooleanHashVar     or
        "asdfghjkl" not in stringIntegerHashVar     or
        "asdfghjkl" not in stringBigIntegerHashVar  or
        "asdfghjkl" not in stringBigRationalHashVar or
        "asdfghjkl" not in stringFloatHashVar       or
        "asdfghjkl" not in stringComplexHashVar     or
        "asdfghjkl" not in stringCharHashVar        or
        "asdfghjkl" not in stringStringHashVar      or
        "asdfghjkl" not in stringBstringHashVar     or
        "asdfghjkl" not in stringBitsetHashVar      or
        "asdfghjkl" not in stringTimeHashVar        or
        "asdfghjkl" not in stringEnumTypeHashVar    or
        "asdfghjkl" not in stringTypeHashVar        or
        "asdfghjkl" not in stringReferenceHashVar   or
        "asdfghjkl" not in stringHashHashVar        then
      writeln(" ***** Elements missing in hash[string] table");
      okay := FALSE;
    end if;
    if  stringBooleanHashVar     ["asdfghjkl"] <> TRUE                     or
        stringIntegerHashVar     ["asdfghjkl"] <> 1234                     or
        stringBigIntegerHashVar  ["asdfghjkl"] <> 9999999999_              or
        stringBigRationalHashVar ["asdfghjkl"] <> 9999999999_ / 12345678_  or
        stringFloatHashVar       ["asdfghjkl"] <> 3.1415926535             or
        stringComplexHashVar     ["asdfghjkl"] <> complex(1.2, 3.4)        or
        stringCharHashVar        ["asdfghjkl"] <> 'Q'                      or
        stringStringHashVar      ["asdfghjkl"] <> "success"                or
        stringBstringHashVar     ["asdfghjkl"] <> bstring("okay")          or
        stringBitsetHashVar      ["asdfghjkl"] <> {123}                    or
        stringTimeHashVar        ["asdfghjkl"] <> time("2011-12-13 14:15") or
        stringEnumTypeHashVar    ["asdfghjkl"] <> GREEN                    or
        stringTypeHashVar        ["asdfghjkl"] <> char                     or
        stringReferenceHashVar   ["asdfghjkl"] <> NIL                      then
      writeln(" ***** Elements with wrong value in hash[string] table");
      okay := FALSE;
    end if;
    if okay then
      writeln("Hash tables with string keys work correctly.");
    else
      writeln(" ***** Hash tables with string keys do not work correctly");
      writeln;
    end if;
  end func;


const proc: chkBstringHash is func
  local
    var boolean: okay is TRUE;
    var bstringBooleanHash:     bstringBooleanHashVar     is bstringBooleanHash    .EMPTY_HASH;
    var bstringIntegerHash:     bstringIntegerHashVar     is bstringIntegerHash    .EMPTY_HASH;
    var bstringBigIntegerHash:  bstringBigIntegerHashVar  is bstringBigIntegerHash .EMPTY_HASH;
    var bstringBigRationalHash: bstringBigRationalHashVar is bstringBigRationalHash.EMPTY_HASH;
    var bstringFloatHash:       bstringFloatHashVar       is bstringFloatHash      .EMPTY_HASH;
    var bstringComplexHash:     bstringComplexHashVar     is bstringComplexHash    .EMPTY_HASH;
    var bstringCharHash:        bstringCharHashVar        is bstringCharHash       .EMPTY_HASH;
    var bstringStringHash:      bstringStringHashVar      is bstringStringHash     .EMPTY_HASH;
    var bstringBstringHash:     bstringBstringHashVar     is bstringBstringHash    .EMPTY_HASH;
    var bstringBitsetHash:      bstringBitsetHashVar      is bstringBitsetHash     .EMPTY_HASH;
    var bstringTimeHash:        bstringTimeHashVar        is bstringTimeHash       .EMPTY_HASH;
    var bstringEnumTypeHash:    bstringEnumTypeHashVar    is bstringEnumTypeHash   .EMPTY_HASH;
    var bstringTypeHash:        bstringTypeHashVar        is bstringTypeHash       .EMPTY_HASH;
    var bstringReferenceHash:   bstringReferenceHashVar   is bstringReferenceHash  .EMPTY_HASH;
    var bstringHashHash:        bstringHashHashVar        is bstringHashHash       .EMPTY_HASH;
  begin
    if  length(bstringBooleanHashVar)     <> 0 or
        length(bstringIntegerHashVar)     <> 0 or
        length(bstringBigIntegerHashVar)  <> 0 or
        length(bstringBigRationalHashVar) <> 0 or
        length(bstringFloatHashVar)       <> 0 or
        length(bstringComplexHashVar)     <> 0 or
        length(bstringCharHashVar)        <> 0 or
        length(bstringStringHashVar)      <> 0 or
        length(bstringBstringHashVar)     <> 0 or
        length(bstringBitsetHashVar)      <> 0 or
        length(bstringTimeHashVar)        <> 0 or
        length(bstringEnumTypeHashVar)    <> 0 or
        length(bstringTypeHashVar)        <> 0 or
        length(bstringReferenceHashVar)   <> 0 or
        length(bstringHashHashVar)        <> 0 then
      writeln(" ***** Number of elements in empty hash[bstring] table not 0");
      okay := FALSE;
    end if;
    if  bstring("qwert") in bstringBooleanHashVar     or
        bstring("qwert") in bstringIntegerHashVar     or
        bstring("qwert") in bstringBigIntegerHashVar  or
        bstring("qwert") in bstringBigRationalHashVar or
        bstring("qwert") in bstringFloatHashVar       or
        bstring("qwert") in bstringComplexHashVar     or
        bstring("qwert") in bstringCharHashVar        or
        bstring("qwert") in bstringStringHashVar      or
        bstring("qwert") in bstringBstringHashVar     or
        bstring("qwert") in bstringBitsetHashVar      or
        bstring("qwert") in bstringTimeHashVar        or
        bstring("qwert") in bstringEnumTypeHashVar    or
        bstring("qwert") in bstringTypeHashVar        or
        bstring("qwert") in bstringReferenceHashVar   or
        bstring("qwert") in bstringHashHashVar        then
      writeln(" ***** Elements found in empty hash table");
      okay := FALSE;
    end if;
    if  keys(bstringBooleanHashVar)     <> 0 times bstring("") or
        keys(bstringIntegerHashVar)     <> 0 times bstring("") or
        keys(bstringBigIntegerHashVar)  <> 0 times bstring("") or
        keys(bstringBigRationalHashVar) <> 0 times bstring("") or
        keys(bstringFloatHashVar)       <> 0 times bstring("") or
        keys(bstringComplexHashVar)     <> 0 times bstring("") or
        keys(bstringCharHashVar)        <> 0 times bstring("") or
        keys(bstringStringHashVar)      <> 0 times bstring("") or
        keys(bstringBstringHashVar)     <> 0 times bstring("") or
        keys(bstringBitsetHashVar)      <> 0 times bstring("") or
        keys(bstringTimeHashVar)        <> 0 times bstring("") or
        keys(bstringEnumTypeHashVar)    <> 0 times bstring("") or
        keys(bstringTypeHashVar)        <> 0 times bstring("") or
        keys(bstringReferenceHashVar)   <> 0 times bstring("") or
        keys(bstringHashHashVar)        <> 0 times bstring("") then
      writeln(" ***** Number of keys in empty hash[bstring] table is not 0");
      okay := FALSE;
    end if;
    if  values(bstringBooleanHashVar)     <> 0 times FALSE or
        values(bstringIntegerHashVar)     <> 0 times 0 or
        values(bstringBigIntegerHashVar)  <> 0 times 0_ or
        values(bstringBigRationalHashVar) <> 0 times 0_ / 1_ or
        values(bstringFloatHashVar)       <> 0 times 0.0 or
        values(bstringComplexHashVar)     <> 0 times complex(0.0, 0.0) or
        values(bstringCharHashVar)        <> 0 times ' ' or
        values(bstringStringHashVar)      <> 0 times "" or
        values(bstringBstringHashVar)     <> 0 times bstring("") or
        values(bstringBitsetHashVar)      <> 0 times {} or
        values(bstringTimeHashVar)        <> 0 times time.value or
        values(bstringEnumTypeHashVar)    <> 0 times RED or
        values(bstringTypeHashVar)        <> 0 times boolean or
        values(bstringReferenceHashVar)   <> 0 times NIL then
      writeln(" ***** Number of values in empty hash[bstring] table is not 0");
      okay := FALSE;
    end if;
    if  not raisesIndexError(bstringBooleanHashVar     [bstring("qwert")]) or
        not raisesIndexError(bstringIntegerHashVar     [bstring("qwert")]) or
        not raisesIndexError(bstringBigIntegerHashVar  [bstring("qwert")]) or
        not raisesIndexError(bstringBigRationalHashVar [bstring("qwert")]) or
        not raisesIndexError(bstringFloatHashVar       [bstring("qwert")]) or
        not raisesIndexError(bstringComplexHashVar     [bstring("qwert")]) or
        not raisesIndexError(bstringCharHashVar        [bstring("qwert")]) or
        not raisesIndexError(bstringStringHashVar      [bstring("qwert")]) or
        not raisesIndexError(bstringBstringHashVar     [bstring("qwert")]) or
        not raisesIndexError(bstringBitsetHashVar      [bstring("qwert")]) or
        not raisesIndexError(bstringTimeHashVar        [bstring("qwert")]) or
        not raisesIndexError(bstringEnumTypeHashVar    [bstring("qwert")]) or
        not raisesIndexError(bstringTypeHashVar        [bstring("qwert")]) or
        not raisesIndexError(bstringReferenceHashVar   [bstring("qwert")]) then
      writeln(" ***** Indexing into an empty hash[bstring] does not raise INDEX_ERROR");
      okay := FALSE;
    end if;
    bstringBooleanHashVar     @:= [bstring("qwert")] TRUE;
    bstringIntegerHashVar     @:= [bstring("qwert")] 1234;
    bstringBigIntegerHashVar  @:= [bstring("qwert")] 9999999999_;
    bstringBigRationalHashVar @:= [bstring("qwert")] 9999999999_ / 12345678_;
    bstringFloatHashVar       @:= [bstring("qwert")] 3.1415926535;
    bstringComplexHashVar     @:= [bstring("qwert")] complex(1.2, 3.4);
    bstringCharHashVar        @:= [bstring("qwert")] 'Q';
    bstringStringHashVar      @:= [bstring("qwert")] "success";
    bstringBstringHashVar     @:= [bstring("qwert")] bstring("okay");
    bstringBitsetHashVar      @:= [bstring("qwert")] {123};
    bstringTimeHashVar        @:= [bstring("qwert")] time("2011-12-13 14:15");
    bstringEnumTypeHashVar    @:= [bstring("qwert")] GREEN;
    bstringTypeHashVar        @:= [bstring("qwert")] char;
    bstringReferenceHashVar   @:= [bstring("qwert")] NIL;
    bstringHashHashVar        @:= [bstring("qwert")] bstringBooleanHashVar;
    if  length(bstringBooleanHashVar)     <> 1 or
        length(bstringIntegerHashVar)     <> 1 or
        length(bstringBigIntegerHashVar)  <> 1 or
        length(bstringBigRationalHashVar) <> 1 or
        length(bstringFloatHashVar)       <> 1 or
        length(bstringComplexHashVar)     <> 1 or
        length(bstringCharHashVar)        <> 1 or
        length(bstringStringHashVar)      <> 1 or
        length(bstringBstringHashVar)     <> 1 or
        length(bstringBitsetHashVar)      <> 1 or
        length(bstringTimeHashVar)        <> 1 or
        length(bstringEnumTypeHashVar)    <> 1 or
        length(bstringTypeHashVar)        <> 1 or
        length(bstringReferenceHashVar)   <> 1 or
        length(bstringHashHashVar)        <> 1 then
      writeln(" ***** Number of elements in hash[bstring] table not 1");
      okay := FALSE;
    end if;
    if  bstring("qwert") in bstringBooleanHashVar     and
        bstring("qwert") in bstringIntegerHashVar     and
        bstring("qwert") in bstringBigIntegerHashVar  and
        bstring("qwert") in bstringBigRationalHashVar and
        bstring("qwert") in bstringFloatHashVar       and
        bstring("qwert") in bstringComplexHashVar     and
        bstring("qwert") in bstringCharHashVar        and
        bstring("qwert") in bstringStringHashVar      and
        bstring("qwert") in bstringBstringHashVar     and
        bstring("qwert") in bstringBitsetHashVar      and
        bstring("qwert") in bstringTimeHashVar        and
        bstring("qwert") in bstringEnumTypeHashVar    and
        bstring("qwert") in bstringTypeHashVar        and
        bstring("qwert") in bstringReferenceHashVar   and
        bstring("qwert") in bstringHashHashVar        then
      noop;
    else
      writeln(" ***** Elements missing in hash[bstring] table");
      okay := FALSE;
    end if;
    if  keys(bstringBooleanHashVar)     <> [] (bstring("qwert")) or
        keys(bstringIntegerHashVar)     <> [] (bstring("qwert")) or
        keys(bstringBigIntegerHashVar)  <> [] (bstring("qwert")) or
        keys(bstringBigRationalHashVar) <> [] (bstring("qwert")) or
        keys(bstringFloatHashVar)       <> [] (bstring("qwert")) or
        keys(bstringComplexHashVar)     <> [] (bstring("qwert")) or
        keys(bstringCharHashVar)        <> [] (bstring("qwert")) or
        keys(bstringStringHashVar)      <> [] (bstring("qwert")) or
        keys(bstringBstringHashVar)     <> [] (bstring("qwert")) or
        keys(bstringBitsetHashVar)      <> [] (bstring("qwert")) or
        keys(bstringTimeHashVar)        <> [] (bstring("qwert")) or
        keys(bstringEnumTypeHashVar)    <> [] (bstring("qwert")) or
        keys(bstringTypeHashVar)        <> [] (bstring("qwert")) or
        keys(bstringReferenceHashVar)   <> [] (bstring("qwert")) or
        keys(bstringHashHashVar)        <> [] (bstring("qwert")) then
      writeln(" ***** keys(hash[bstring]) does not work correctly");
      okay := FALSE;
    end if;
    if  values(bstringBooleanHashVar)     <> [] (TRUE) or
        values(bstringIntegerHashVar)     <> [] (1234) or
        values(bstringBigIntegerHashVar)  <> [] (9999999999_) or
        values(bstringBigRationalHashVar) <> [] (9999999999_ / 12345678_) or
        values(bstringFloatHashVar)       <> [] (3.1415926535) or
        values(bstringComplexHashVar)     <> [] (complex(1.2, 3.4)) or
        values(bstringCharHashVar)        <> [] ('Q') or
        values(bstringStringHashVar)      <> [] ("success") or
        values(bstringBstringHashVar)     <> [] (bstring("okay")) or
        values(bstringBitsetHashVar)      <> [] ({123}) or
        values(bstringTimeHashVar)        <> [] (time("2011-12-13 14:15")) or
        values(bstringEnumTypeHashVar)    <> [] (GREEN) or
        values(bstringTypeHashVar)        <> [] (char) or
        values(bstringReferenceHashVar)   <> [] (NIL) then
      writeln(" ***** values(hash[bstring]) does not work correctly");
      okay := FALSE;
    end if;
    bstringBooleanHashVar     @:= [bstring("qwert")] TRUE;
    bstringIntegerHashVar     @:= [bstring("qwert")] 1234;
    bstringBigIntegerHashVar  @:= [bstring("qwert")] 9999999999_;
    bstringBigRationalHashVar @:= [bstring("qwert")] 9999999999_ / 12345678_;
    bstringFloatHashVar       @:= [bstring("qwert")] 3.1415926535;
    bstringComplexHashVar     @:= [bstring("qwert")] complex(1.2, 3.4);
    bstringCharHashVar        @:= [bstring("qwert")] 'Q';
    bstringStringHashVar      @:= [bstring("qwert")] "success";
    bstringBstringHashVar     @:= [bstring("qwert")] bstring("okay");
    bstringBitsetHashVar      @:= [bstring("qwert")] {123};
    bstringTimeHashVar        @:= [bstring("qwert")] time("2011-12-13 14:15");
    bstringEnumTypeHashVar    @:= [bstring("qwert")] GREEN;
    bstringTypeHashVar        @:= [bstring("qwert")] char;
    bstringReferenceHashVar   @:= [bstring("qwert")] NIL;
    bstringHashHashVar        @:= [bstring("qwert")] bstringBooleanHashVar;
    if  bstring("qwert") not in bstringBooleanHashVar     or
        bstring("qwert") not in bstringIntegerHashVar     or
        bstring("qwert") not in bstringBigIntegerHashVar  or
        bstring("qwert") not in bstringBigRationalHashVar or
        bstring("qwert") not in bstringFloatHashVar       or
        bstring("qwert") not in bstringComplexHashVar     or
        bstring("qwert") not in bstringCharHashVar        or
        bstring("qwert") not in bstringStringHashVar      or
        bstring("qwert") not in bstringBstringHashVar     or
        bstring("qwert") not in bstringBitsetHashVar      or
        bstring("qwert") not in bstringTimeHashVar        or
        bstring("qwert") not in bstringEnumTypeHashVar    or
        bstring("qwert") not in bstringTypeHashVar        or
        bstring("qwert") not in bstringReferenceHashVar   or
        bstring("qwert") not in bstringHashHashVar        then
      writeln(" ***** Elements missing in hash[bstring] table");
      okay := FALSE;
    end if;
    if  bstringBooleanHashVar     [bstring("qwert")] <> TRUE                     or
        bstringIntegerHashVar     [bstring("qwert")] <> 1234                     or
        bstringBigIntegerHashVar  [bstring("qwert")] <> 9999999999_              or
        bstringBigRationalHashVar [bstring("qwert")] <> 9999999999_ / 12345678_  or
        bstringFloatHashVar       [bstring("qwert")] <> 3.1415926535             or
        bstringComplexHashVar     [bstring("qwert")] <> complex(1.2, 3.4)        or
        bstringCharHashVar        [bstring("qwert")] <> 'Q'                      or
        bstringStringHashVar      [bstring("qwert")] <> "success"                or
        bstringBstringHashVar     [bstring("qwert")] <> bstring("okay")          or
        bstringBitsetHashVar      [bstring("qwert")] <> {123}                    or
        bstringTimeHashVar        [bstring("qwert")] <> time("2011-12-13 14:15") or
        bstringEnumTypeHashVar    [bstring("qwert")] <> GREEN                    or
        bstringTypeHashVar        [bstring("qwert")] <> char                     or
        bstringReferenceHashVar   [bstring("qwert")] <> NIL                      then
      writeln(" ***** Elements with wrong value in hash[bstring] table");
      okay := FALSE;
    end if;
    if okay then
      writeln("Hash tables with bstring keys work correctly.");
    else
      writeln(" ***** Hash tables with bstring keys do not work correctly");
      writeln;
    end if;
  end func;


const proc: chkBitsetHash is func
  local
    var boolean: okay is TRUE;
    var bitsetBooleanHash:     bitsetBooleanHashVar     is bitsetBooleanHash    .EMPTY_HASH;
    var bitsetIntegerHash:     bitsetIntegerHashVar     is bitsetIntegerHash    .EMPTY_HASH;
    var bitsetBigIntegerHash:  bitsetBigIntegerHashVar  is bitsetBigIntegerHash .EMPTY_HASH;
    var bitsetBigRationalHash: bitsetBigRationalHashVar is bitsetBigRationalHash.EMPTY_HASH;
    var bitsetFloatHash:       bitsetFloatHashVar       is bitsetFloatHash      .EMPTY_HASH;
    var bitsetComplexHash:     bitsetComplexHashVar     is bitsetComplexHash    .EMPTY_HASH;
    var bitsetCharHash:        bitsetCharHashVar        is bitsetCharHash       .EMPTY_HASH;
    var bitsetStringHash:      bitsetStringHashVar      is bitsetStringHash     .EMPTY_HASH;
    var bitsetBstringHash:     bitsetBstringHashVar     is bitsetBstringHash    .EMPTY_HASH;
    var bitsetBitsetHash:      bitsetBitsetHashVar      is bitsetBitsetHash     .EMPTY_HASH;
    var bitsetTimeHash:        bitsetTimeHashVar        is bitsetTimeHash       .EMPTY_HASH;
    var bitsetEnumTypeHash:    bitsetEnumTypeHashVar    is bitsetEnumTypeHash   .EMPTY_HASH;
    var bitsetTypeHash:        bitsetTypeHashVar        is bitsetTypeHash       .EMPTY_HASH;
    var bitsetReferenceHash:   bitsetReferenceHashVar   is bitsetReferenceHash  .EMPTY_HASH;
    var bitsetHashHash:        bitsetHashHashVar        is bitsetHashHash       .EMPTY_HASH;
  begin
    if  length(bitsetBooleanHashVar)     <> 0 or
        length(bitsetIntegerHashVar)     <> 0 or
        length(bitsetBigIntegerHashVar)  <> 0 or
        length(bitsetBigRationalHashVar) <> 0 or
        length(bitsetFloatHashVar)       <> 0 or
        length(bitsetComplexHashVar)     <> 0 or
        length(bitsetCharHashVar)        <> 0 or
        length(bitsetStringHashVar)      <> 0 or
        length(bitsetBstringHashVar)     <> 0 or
        length(bitsetBitsetHashVar)      <> 0 or
        length(bitsetTimeHashVar)        <> 0 or
        length(bitsetEnumTypeHashVar)    <> 0 or
        length(bitsetTypeHashVar)        <> 0 or
        length(bitsetReferenceHashVar)   <> 0 or
        length(bitsetHashHashVar)        <> 0 then
      writeln(" ***** Number of elements in empty hash[bitset] table not 0");
      okay := FALSE;
    end if;
    if  {234} in bitsetBooleanHashVar     or
        {234} in bitsetIntegerHashVar     or
        {234} in bitsetBigIntegerHashVar  or
        {234} in bitsetBigRationalHashVar or
        {234} in bitsetFloatHashVar       or
        {234} in bitsetComplexHashVar     or
        {234} in bitsetCharHashVar        or
        {234} in bitsetStringHashVar      or
        {234} in bitsetBstringHashVar     or
        {234} in bitsetBitsetHashVar      or
        {234} in bitsetTimeHashVar        or
        {234} in bitsetEnumTypeHashVar    or
        {234} in bitsetTypeHashVar        or
        {234} in bitsetReferenceHashVar   or
        {234} in bitsetHashHashVar        then
      writeln(" ***** Elements found in empty hash table");
      okay := FALSE;
    end if;
    if  keys(bitsetBooleanHashVar)     <> 0 times bitset.value or
        keys(bitsetIntegerHashVar)     <> 0 times bitset.value or
        keys(bitsetBigIntegerHashVar)  <> 0 times bitset.value or
        keys(bitsetBigRationalHashVar) <> 0 times bitset.value or
        keys(bitsetFloatHashVar)       <> 0 times bitset.value or
        keys(bitsetComplexHashVar)     <> 0 times bitset.value or
        keys(bitsetCharHashVar)        <> 0 times bitset.value or
        keys(bitsetStringHashVar)      <> 0 times bitset.value or
        keys(bitsetBstringHashVar)     <> 0 times bitset.value or
        keys(bitsetBitsetHashVar)      <> 0 times bitset.value or
        keys(bitsetTimeHashVar)        <> 0 times bitset.value or
        keys(bitsetEnumTypeHashVar)    <> 0 times bitset.value or
        keys(bitsetTypeHashVar)        <> 0 times bitset.value or
        keys(bitsetReferenceHashVar)   <> 0 times bitset.value or
        keys(bitsetHashHashVar)        <> 0 times bitset.value then
      writeln(" ***** Number of keys in empty hash[bitset] table is not 0");
      okay := FALSE;
    end if;
    if  values(bitsetBooleanHashVar)     <> 0 times FALSE or
        values(bitsetIntegerHashVar)     <> 0 times 0 or
        values(bitsetBigIntegerHashVar)  <> 0 times 0_ or
        values(bitsetBigRationalHashVar) <> 0 times 0_ / 1_ or
        values(bitsetFloatHashVar)       <> 0 times 0.0 or
        values(bitsetComplexHashVar)     <> 0 times complex(0.0, 0.0) or
        values(bitsetCharHashVar)        <> 0 times ' ' or
        values(bitsetStringHashVar)      <> 0 times "" or
        values(bitsetBstringHashVar)     <> 0 times bstring("") or
        values(bitsetBitsetHashVar)      <> 0 times {} or
        values(bitsetTimeHashVar)        <> 0 times time.value or
        values(bitsetEnumTypeHashVar)    <> 0 times RED or
        values(bitsetTypeHashVar)        <> 0 times boolean or
        values(bitsetReferenceHashVar)   <> 0 times NIL then
      writeln(" ***** Number of values in empty hash[bitset] table is not 0");
      okay := FALSE;
    end if;
    if  not raisesIndexError(bitsetBooleanHashVar     [{234}]) or
        not raisesIndexError(bitsetIntegerHashVar     [{234}]) or
        not raisesIndexError(bitsetBigIntegerHashVar  [{234}]) or
        not raisesIndexError(bitsetBigRationalHashVar [{234}]) or
        not raisesIndexError(bitsetFloatHashVar       [{234}]) or
        not raisesIndexError(bitsetComplexHashVar     [{234}]) or
        not raisesIndexError(bitsetCharHashVar        [{234}]) or
        not raisesIndexError(bitsetStringHashVar      [{234}]) or
        not raisesIndexError(bitsetBstringHashVar     [{234}]) or
        not raisesIndexError(bitsetBitsetHashVar      [{234}]) or
        not raisesIndexError(bitsetTimeHashVar        [{234}]) or
        not raisesIndexError(bitsetEnumTypeHashVar    [{234}]) or
        not raisesIndexError(bitsetTypeHashVar        [{234}]) or
        not raisesIndexError(bitsetReferenceHashVar   [{234}]) then
      writeln(" ***** Indexing into an empty hash[bitset] does not raise INDEX_ERROR");
      okay := FALSE;
    end if;
    bitsetBooleanHashVar     @:= [{234}] TRUE;
    bitsetIntegerHashVar     @:= [{234}] 1234;
    bitsetBigIntegerHashVar  @:= [{234}] 9999999999_;
    bitsetBigRationalHashVar @:= [{234}] 9999999999_ / 12345678_;
    bitsetFloatHashVar       @:= [{234}] 3.1415926535;
    bitsetComplexHashVar     @:= [{234}] complex(1.2, 3.4);
    bitsetCharHashVar        @:= [{234}] 'Q';
    bitsetStringHashVar      @:= [{234}] "success";
    bitsetBstringHashVar     @:= [{234}] bstring("okay");
    bitsetBitsetHashVar      @:= [{234}] {123};
    bitsetTimeHashVar        @:= [{234}] time("2011-12-13 14:15");
    bitsetEnumTypeHashVar    @:= [{234}] GREEN;
    bitsetTypeHashVar        @:= [{234}] char;
    bitsetReferenceHashVar   @:= [{234}] NIL;
    bitsetHashHashVar        @:= [{234}] bitsetBooleanHashVar;
    if  length(bitsetBooleanHashVar)     <> 1 or
        length(bitsetIntegerHashVar)     <> 1 or
        length(bitsetBigIntegerHashVar)  <> 1 or
        length(bitsetBigRationalHashVar) <> 1 or
        length(bitsetFloatHashVar)       <> 1 or
        length(bitsetComplexHashVar)     <> 1 or
        length(bitsetCharHashVar)        <> 1 or
        length(bitsetStringHashVar)      <> 1 or
        length(bitsetBstringHashVar)     <> 1 or
        length(bitsetBitsetHashVar)      <> 1 or
        length(bitsetTimeHashVar)        <> 1 or
        length(bitsetEnumTypeHashVar)    <> 1 or
        length(bitsetTypeHashVar)        <> 1 or
        length(bitsetReferenceHashVar)   <> 1 or
        length(bitsetHashHashVar)        <> 1 then
      writeln(" ***** Number of elements in hash[bitset] table not 1");
      okay := FALSE;
    end if;
    if  {234} in bitsetBooleanHashVar     and
        {234} in bitsetIntegerHashVar     and
        {234} in bitsetBigIntegerHashVar  and
        {234} in bitsetBigRationalHashVar and
        {234} in bitsetFloatHashVar       and
        {234} in bitsetComplexHashVar     and
        {234} in bitsetCharHashVar        and
        {234} in bitsetStringHashVar      and
        {234} in bitsetBstringHashVar     and
        {234} in bitsetBitsetHashVar      and
        {234} in bitsetTimeHashVar        and
        {234} in bitsetEnumTypeHashVar    and
        {234} in bitsetTypeHashVar        and
        {234} in bitsetReferenceHashVar   and
        {234} in bitsetHashHashVar        then
      noop;
    else
      writeln(" ***** Elements missing in hash[bitset] table");
      okay := FALSE;
    end if;
    if  keys(bitsetBooleanHashVar)     <> [] ({234}) or
        keys(bitsetIntegerHashVar)     <> [] ({234}) or
        keys(bitsetBigIntegerHashVar)  <> [] ({234}) or
        keys(bitsetBigRationalHashVar) <> [] ({234}) or
        keys(bitsetFloatHashVar)       <> [] ({234}) or
        keys(bitsetComplexHashVar)     <> [] ({234}) or
        keys(bitsetCharHashVar)        <> [] ({234}) or
        keys(bitsetStringHashVar)      <> [] ({234}) or
        keys(bitsetBstringHashVar)     <> [] ({234}) or
        keys(bitsetBitsetHashVar)      <> [] ({234}) or
        keys(bitsetTimeHashVar)        <> [] ({234}) or
        keys(bitsetEnumTypeHashVar)    <> [] ({234}) or
        keys(bitsetTypeHashVar)        <> [] ({234}) or
        keys(bitsetReferenceHashVar)   <> [] ({234}) or
        keys(bitsetHashHashVar)        <> [] ({234}) then
      writeln(" ***** keys(hash[bitset]) does not work correctly");
      okay := FALSE;
    end if;
    if  values(bitsetBooleanHashVar)     <> [] (TRUE) or
        values(bitsetIntegerHashVar)     <> [] (1234) or
        values(bitsetBigIntegerHashVar)  <> [] (9999999999_) or
        values(bitsetBigRationalHashVar) <> [] (9999999999_ / 12345678_) or
        values(bitsetFloatHashVar)       <> [] (3.1415926535) or
        values(bitsetComplexHashVar)     <> [] (complex(1.2, 3.4)) or
        values(bitsetCharHashVar)        <> [] ('Q') or
        values(bitsetStringHashVar)      <> [] ("success") or
        values(bitsetBstringHashVar)     <> [] (bstring("okay")) or
        values(bitsetBitsetHashVar)      <> [] ({123}) or
        values(bitsetTimeHashVar)        <> [] (time("2011-12-13 14:15")) or
        values(bitsetEnumTypeHashVar)    <> [] (GREEN) or
        values(bitsetTypeHashVar)        <> [] (char) or
        values(bitsetReferenceHashVar)   <> [] (NIL) then
      writeln(" ***** values(hash[bitset]) does not work correctly");
      okay := FALSE;
    end if;
    bitsetBooleanHashVar     @:= [{234}] TRUE;
    bitsetIntegerHashVar     @:= [{234}] 1234;
    bitsetBigIntegerHashVar  @:= [{234}] 9999999999_;
    bitsetBigRationalHashVar @:= [{234}] 9999999999_ / 12345678_;
    bitsetFloatHashVar       @:= [{234}] 3.1415926535;
    bitsetComplexHashVar     @:= [{234}] complex(1.2, 3.4);
    bitsetCharHashVar        @:= [{234}] 'Q';
    bitsetStringHashVar      @:= [{234}] "success";
    bitsetBstringHashVar     @:= [{234}] bstring("okay");
    bitsetBitsetHashVar      @:= [{234}] {123};
    bitsetTimeHashVar        @:= [{234}] time("2011-12-13 14:15");
    bitsetEnumTypeHashVar    @:= [{234}] GREEN;
    bitsetTypeHashVar        @:= [{234}] char;
    bitsetReferenceHashVar   @:= [{234}] NIL;
    bitsetHashHashVar        @:= [{234}] bitsetBooleanHashVar;
    if  {234} not in bitsetBooleanHashVar     or
        {234} not in bitsetIntegerHashVar     or
        {234} not in bitsetBigIntegerHashVar  or
        {234} not in bitsetBigRationalHashVar or
        {234} not in bitsetFloatHashVar       or
        {234} not in bitsetComplexHashVar     or
        {234} not in bitsetCharHashVar        or
        {234} not in bitsetStringHashVar      or
        {234} not in bitsetBstringHashVar     or
        {234} not in bitsetBitsetHashVar      or
        {234} not in bitsetTimeHashVar        or
        {234} not in bitsetEnumTypeHashVar    or
        {234} not in bitsetTypeHashVar        or
        {234} not in bitsetReferenceHashVar   or
        {234} not in bitsetHashHashVar        then
      writeln(" ***** Elements missing in hash[bitset] table");
      okay := FALSE;
    end if;
    if  bitsetBooleanHashVar     [{234}] <> TRUE                     or
        bitsetIntegerHashVar     [{234}] <> 1234                     or
        bitsetBigIntegerHashVar  [{234}] <> 9999999999_              or
        bitsetBigRationalHashVar [{234}] <> 9999999999_ / 12345678_  or
        bitsetFloatHashVar       [{234}] <> 3.1415926535             or
        bitsetComplexHashVar     [{234}] <> complex(1.2, 3.4)        or
        bitsetCharHashVar        [{234}] <> 'Q'                      or
        bitsetStringHashVar      [{234}] <> "success"                or
        bitsetBstringHashVar     [{234}] <> bstring("okay")          or
        bitsetBitsetHashVar      [{234}] <> {123}                    or
        bitsetTimeHashVar        [{234}] <> time("2011-12-13 14:15") or
        bitsetEnumTypeHashVar    [{234}] <> GREEN                    or
        bitsetTypeHashVar        [{234}] <> char                     or
        bitsetReferenceHashVar   [{234}] <> NIL                      then
      writeln(" ***** Elements with wrong value in hash[bitset] table");
      okay := FALSE;
    end if;
    if okay then
      writeln("Hash tables with bitset keys work correctly.");
    else
      writeln(" ***** Hash tables with bitset keys do not work correctly");
      writeln;
    end if;
  end func;


const proc: chkTimeHash is func
  local
    var boolean: okay is TRUE;
    var timeBooleanHash:     timeBooleanHashVar     is timeBooleanHash    .EMPTY_HASH;
    var timeIntegerHash:     timeIntegerHashVar     is timeIntegerHash    .EMPTY_HASH;
    var timeBigIntegerHash:  timeBigIntegerHashVar  is timeBigIntegerHash .EMPTY_HASH;
    var timeBigRationalHash: timeBigRationalHashVar is timeBigRationalHash.EMPTY_HASH;
    var timeFloatHash:       timeFloatHashVar       is timeFloatHash      .EMPTY_HASH;
    var timeComplexHash:     timeComplexHashVar     is timeComplexHash    .EMPTY_HASH;
    var timeCharHash:        timeCharHashVar        is timeCharHash       .EMPTY_HASH;
    var timeStringHash:      timeStringHashVar      is timeStringHash     .EMPTY_HASH;
    var timeBstringHash:     timeBstringHashVar     is timeBstringHash    .EMPTY_HASH;
    var timeBitsetHash:      timeBitsetHashVar      is timeBitsetHash     .EMPTY_HASH;
    var timeTimeHash:        timeTimeHashVar        is timeTimeHash       .EMPTY_HASH;
    var timeEnumTypeHash:    timeEnumTypeHashVar    is timeEnumTypeHash   .EMPTY_HASH;
    var timeTypeHash:        timeTypeHashVar        is timeTypeHash       .EMPTY_HASH;
    var timeReferenceHash:   timeReferenceHashVar   is timeReferenceHash  .EMPTY_HASH;
    var timeHashHash:        timeHashHashVar        is timeHashHash       .EMPTY_HASH;
  begin
    if  length(timeBooleanHashVar)     <> 0 or
        length(timeIntegerHashVar)     <> 0 or
        length(timeBigIntegerHashVar)  <> 0 or
        length(timeBigRationalHashVar) <> 0 or
        length(timeFloatHashVar)       <> 0 or
        length(timeComplexHashVar)     <> 0 or
        length(timeCharHashVar)        <> 0 or
        length(timeStringHashVar)      <> 0 or
        length(timeBstringHashVar)     <> 0 or
        length(timeBitsetHashVar)      <> 0 or
        length(timeTimeHashVar)        <> 0 or
        length(timeEnumTypeHashVar)    <> 0 or
        length(timeTypeHashVar)        <> 0 or
        length(timeReferenceHashVar)   <> 0 or
        length(timeHashHashVar)        <> 0 then
      writeln(" ***** Number of elements in empty hash[time] table not 0");
      okay := FALSE;
    end if;
    if  time("2010-11-12 13:14") in timeBooleanHashVar     or
        time("2010-11-12 13:14") in timeIntegerHashVar     or
        time("2010-11-12 13:14") in timeBigIntegerHashVar  or
        time("2010-11-12 13:14") in timeBigRationalHashVar or
        time("2010-11-12 13:14") in timeFloatHashVar       or
        time("2010-11-12 13:14") in timeComplexHashVar     or
        time("2010-11-12 13:14") in timeCharHashVar        or
        time("2010-11-12 13:14") in timeStringHashVar      or
        time("2010-11-12 13:14") in timeBstringHashVar     or
        time("2010-11-12 13:14") in timeBitsetHashVar      or
        time("2010-11-12 13:14") in timeTimeHashVar        or
        time("2010-11-12 13:14") in timeEnumTypeHashVar    or
        time("2010-11-12 13:14") in timeTypeHashVar        or
        time("2010-11-12 13:14") in timeReferenceHashVar   or
        time("2010-11-12 13:14") in timeHashHashVar        then
      writeln(" ***** Elements found in empty hash table");
      okay := FALSE;
    end if;
    if  keys(timeBooleanHashVar)     <> 0 times time.value or
        keys(timeIntegerHashVar)     <> 0 times time.value or
        keys(timeBigIntegerHashVar)  <> 0 times time.value or
        keys(timeBigRationalHashVar) <> 0 times time.value or
        keys(timeFloatHashVar)       <> 0 times time.value or
        keys(timeComplexHashVar)     <> 0 times time.value or
        keys(timeCharHashVar)        <> 0 times time.value or
        keys(timeStringHashVar)      <> 0 times time.value or
        keys(timeBstringHashVar)     <> 0 times time.value or
        keys(timeBitsetHashVar)      <> 0 times time.value or
        keys(timeTimeHashVar)        <> 0 times time.value or
        keys(timeEnumTypeHashVar)    <> 0 times time.value or
        keys(timeTypeHashVar)        <> 0 times time.value or
        keys(timeReferenceHashVar)   <> 0 times time.value or
        keys(timeHashHashVar)        <> 0 times time.value then
      writeln(" ***** Number of keys in empty hash[time] table is not 0");
      okay := FALSE;
    end if;
    if  values(timeBooleanHashVar)     <> 0 times FALSE or
        values(timeIntegerHashVar)     <> 0 times 0 or
        values(timeBigIntegerHashVar)  <> 0 times 0_ or
        values(timeBigRationalHashVar) <> 0 times 0_ / 1_ or
        values(timeFloatHashVar)       <> 0 times 0.0 or
        values(timeComplexHashVar)     <> 0 times complex(0.0, 0.0) or
        values(timeCharHashVar)        <> 0 times ' ' or
        values(timeStringHashVar)      <> 0 times "" or
        values(timeBstringHashVar)     <> 0 times bstring("") or
        values(timeBitsetHashVar)      <> 0 times {} or
        values(timeTimeHashVar)        <> 0 times time.value or
        values(timeEnumTypeHashVar)    <> 0 times RED or
        values(timeTypeHashVar)        <> 0 times boolean or
        values(timeReferenceHashVar)   <> 0 times NIL then
      writeln(" ***** Number of values in empty hash[time] table is not 0");
      okay := FALSE;
    end if;
    if  not raisesIndexError(timeBooleanHashVar     [time("2010-11-12 13:14")]) or
        not raisesIndexError(timeIntegerHashVar     [time("2010-11-12 13:14")]) or
        not raisesIndexError(timeBigIntegerHashVar  [time("2010-11-12 13:14")]) or
        not raisesIndexError(timeBigRationalHashVar [time("2010-11-12 13:14")]) or
        not raisesIndexError(timeFloatHashVar       [time("2010-11-12 13:14")]) or
        not raisesIndexError(timeComplexHashVar     [time("2010-11-12 13:14")]) or
        not raisesIndexError(timeCharHashVar        [time("2010-11-12 13:14")]) or
        not raisesIndexError(timeStringHashVar      [time("2010-11-12 13:14")]) or
        not raisesIndexError(timeBstringHashVar     [time("2010-11-12 13:14")]) or
        not raisesIndexError(timeBitsetHashVar      [time("2010-11-12 13:14")]) or
        not raisesIndexError(timeTimeHashVar        [time("2010-11-12 13:14")]) or
        not raisesIndexError(timeEnumTypeHashVar    [time("2010-11-12 13:14")]) or
        not raisesIndexError(timeTypeHashVar        [time("2010-11-12 13:14")]) or
        not raisesIndexError(timeReferenceHashVar   [time("2010-11-12 13:14")]) then
      writeln(" ***** Indexing into an empty hash[time] does not raise INDEX_ERROR");
      okay := FALSE;
    end if;
    timeBooleanHashVar     @:= [time("2010-11-12 13:14")] TRUE;
    timeIntegerHashVar     @:= [time("2010-11-12 13:14")] 1234;
    timeBigIntegerHashVar  @:= [time("2010-11-12 13:14")] 9999999999_;
    timeBigRationalHashVar @:= [time("2010-11-12 13:14")] 9999999999_ / 12345678_;
    timeFloatHashVar       @:= [time("2010-11-12 13:14")] 3.1415926535;
    timeComplexHashVar     @:= [time("2010-11-12 13:14")] complex(1.2, 3.4);
    timeCharHashVar        @:= [time("2010-11-12 13:14")] 'Q';
    timeStringHashVar      @:= [time("2010-11-12 13:14")] "success";
    timeBstringHashVar     @:= [time("2010-11-12 13:14")] bstring("okay");
    timeBitsetHashVar      @:= [time("2010-11-12 13:14")] {123};
    timeTimeHashVar        @:= [time("2010-11-12 13:14")] time("2011-12-13 14:15");
    timeEnumTypeHashVar    @:= [time("2010-11-12 13:14")] GREEN;
    timeTypeHashVar        @:= [time("2010-11-12 13:14")] char;
    timeReferenceHashVar   @:= [time("2010-11-12 13:14")] NIL;
    timeHashHashVar        @:= [time("2010-11-12 13:14")] timeBooleanHashVar;
    if  length(timeBooleanHashVar)     <> 1 or
        length(timeIntegerHashVar)     <> 1 or
        length(timeBigIntegerHashVar)  <> 1 or
        length(timeBigRationalHashVar) <> 1 or
        length(timeFloatHashVar)       <> 1 or
        length(timeComplexHashVar)     <> 1 or
        length(timeCharHashVar)        <> 1 or
        length(timeStringHashVar)      <> 1 or
        length(timeBstringHashVar)     <> 1 or
        length(timeBitsetHashVar)      <> 1 or
        length(timeTimeHashVar)        <> 1 or
        length(timeEnumTypeHashVar)    <> 1 or
        length(timeTypeHashVar)        <> 1 or
        length(timeReferenceHashVar)   <> 1 or
        length(timeHashHashVar)        <> 1 then
      writeln(" ***** Number of elements in hash[time] table not 1");
      okay := FALSE;
    end if;
    if  time("2010-11-12 13:14") in timeBooleanHashVar     and
        time("2010-11-12 13:14") in timeIntegerHashVar     and
        time("2010-11-12 13:14") in timeBigIntegerHashVar  and
        time("2010-11-12 13:14") in timeBigRationalHashVar and
        time("2010-11-12 13:14") in timeFloatHashVar       and
        time("2010-11-12 13:14") in timeComplexHashVar     and
        time("2010-11-12 13:14") in timeCharHashVar        and
        time("2010-11-12 13:14") in timeStringHashVar      and
        time("2010-11-12 13:14") in timeBstringHashVar     and
        time("2010-11-12 13:14") in timeBitsetHashVar      and
        time("2010-11-12 13:14") in timeTimeHashVar        and
        time("2010-11-12 13:14") in timeEnumTypeHashVar    and
        time("2010-11-12 13:14") in timeTypeHashVar        and
        time("2010-11-12 13:14") in timeReferenceHashVar   and
        time("2010-11-12 13:14") in timeHashHashVar        then
      noop;
    else
      writeln(" ***** Elements missing in hash[time] table");
      okay := FALSE;
    end if;
    if  keys(timeBooleanHashVar)     <> [] (time("2010-11-12 13:14")) or
        keys(timeIntegerHashVar)     <> [] (time("2010-11-12 13:14")) or
        keys(timeBigIntegerHashVar)  <> [] (time("2010-11-12 13:14")) or
        keys(timeBigRationalHashVar) <> [] (time("2010-11-12 13:14")) or
        keys(timeFloatHashVar)       <> [] (time("2010-11-12 13:14")) or
        keys(timeComplexHashVar)     <> [] (time("2010-11-12 13:14")) or
        keys(timeCharHashVar)        <> [] (time("2010-11-12 13:14")) or
        keys(timeStringHashVar)      <> [] (time("2010-11-12 13:14")) or
        keys(timeBstringHashVar)     <> [] (time("2010-11-12 13:14")) or
        keys(timeBitsetHashVar)      <> [] (time("2010-11-12 13:14")) or
        keys(timeTimeHashVar)        <> [] (time("2010-11-12 13:14")) or
        keys(timeEnumTypeHashVar)    <> [] (time("2010-11-12 13:14")) or
        keys(timeTypeHashVar)        <> [] (time("2010-11-12 13:14")) or
        keys(timeReferenceHashVar)   <> [] (time("2010-11-12 13:14")) or
        keys(timeHashHashVar)        <> [] (time("2010-11-12 13:14")) then
      writeln(" ***** keys(hash[time]) does not work correctly");
      okay := FALSE;
    end if;
    if  values(timeBooleanHashVar)     <> [] (TRUE) or
        values(timeIntegerHashVar)     <> [] (1234) or
        values(timeBigIntegerHashVar)  <> [] (9999999999_) or
        values(timeBigRationalHashVar) <> [] (9999999999_ / 12345678_) or
        values(timeFloatHashVar)       <> [] (3.1415926535) or
        values(timeComplexHashVar)     <> [] (complex(1.2, 3.4)) or
        values(timeCharHashVar)        <> [] ('Q') or
        values(timeStringHashVar)      <> [] ("success") or
        values(timeBstringHashVar)     <> [] (bstring("okay")) or
        values(timeBitsetHashVar)      <> [] ({123}) or
        values(timeTimeHashVar)        <> [] (time("2011-12-13 14:15")) or
        values(timeEnumTypeHashVar)    <> [] (GREEN) or
        values(timeTypeHashVar)        <> [] (char) or
        values(timeReferenceHashVar)   <> [] (NIL) then
      writeln(" ***** values(hash[time]) does not work correctly");
      okay := FALSE;
    end if;
    timeBooleanHashVar     @:= [time("2010-11-12 13:14")] TRUE;
    timeIntegerHashVar     @:= [time("2010-11-12 13:14")] 1234;
    timeBigIntegerHashVar  @:= [time("2010-11-12 13:14")] 9999999999_;
    timeBigRationalHashVar @:= [time("2010-11-12 13:14")] 9999999999_ / 12345678_;
    timeFloatHashVar       @:= [time("2010-11-12 13:14")] 3.1415926535;
    timeComplexHashVar     @:= [time("2010-11-12 13:14")] complex(1.2, 3.4);
    timeCharHashVar        @:= [time("2010-11-12 13:14")] 'Q';
    timeStringHashVar      @:= [time("2010-11-12 13:14")] "success";
    timeBstringHashVar     @:= [time("2010-11-12 13:14")] bstring("okay");
    timeBitsetHashVar      @:= [time("2010-11-12 13:14")] {123};
    timeTimeHashVar        @:= [time("2010-11-12 13:14")] time("2011-12-13 14:15");
    timeEnumTypeHashVar    @:= [time("2010-11-12 13:14")] GREEN;
    timeTypeHashVar        @:= [time("2010-11-12 13:14")] char;
    timeReferenceHashVar   @:= [time("2010-11-12 13:14")] NIL;
    timeHashHashVar        @:= [time("2010-11-12 13:14")] timeBooleanHashVar;
    if  time("2010-11-12 13:14") not in timeBooleanHashVar     or
        time("2010-11-12 13:14") not in timeIntegerHashVar     or
        time("2010-11-12 13:14") not in timeBigIntegerHashVar  or
        time("2010-11-12 13:14") not in timeBigRationalHashVar or
        time("2010-11-12 13:14") not in timeFloatHashVar       or
        time("2010-11-12 13:14") not in timeComplexHashVar     or
        time("2010-11-12 13:14") not in timeCharHashVar        or
        time("2010-11-12 13:14") not in timeStringHashVar      or
        time("2010-11-12 13:14") not in timeBstringHashVar     or
        time("2010-11-12 13:14") not in timeBitsetHashVar      or
        time("2010-11-12 13:14") not in timeTimeHashVar        or
        time("2010-11-12 13:14") not in timeEnumTypeHashVar    or
        time("2010-11-12 13:14") not in timeTypeHashVar        or
        time("2010-11-12 13:14") not in timeReferenceHashVar   or
        time("2010-11-12 13:14") not in timeHashHashVar        then
      writeln(" ***** Elements missing in hash[time] table");
      okay := FALSE;
    end if;
    if  timeBooleanHashVar     [time("2010-11-12 13:14")] <> TRUE                     or
        timeIntegerHashVar     [time("2010-11-12 13:14")] <> 1234                     or
        timeBigIntegerHashVar  [time("2010-11-12 13:14")] <> 9999999999_              or
        timeBigRationalHashVar [time("2010-11-12 13:14")] <> 9999999999_ / 12345678_  or
        timeFloatHashVar       [time("2010-11-12 13:14")] <> 3.1415926535             or
        timeComplexHashVar     [time("2010-11-12 13:14")] <> complex(1.2, 3.4)        or
        timeCharHashVar        [time("2010-11-12 13:14")] <> 'Q'                      or
        timeStringHashVar      [time("2010-11-12 13:14")] <> "success"                or
        timeBstringHashVar     [time("2010-11-12 13:14")] <> bstring("okay")          or
        timeBitsetHashVar      [time("2010-11-12 13:14")] <> {123}                    or
        timeTimeHashVar        [time("2010-11-12 13:14")] <> time("2011-12-13 14:15") or
        timeEnumTypeHashVar    [time("2010-11-12 13:14")] <> GREEN                    or
        timeTypeHashVar        [time("2010-11-12 13:14")] <> char                     or
        timeReferenceHashVar   [time("2010-11-12 13:14")] <> NIL                      then
      writeln(" ***** Elements with wrong value in hash[time] table");
      okay := FALSE;
    end if;
    if okay then
      writeln("Hash tables with time keys work correctly.");
    else
      writeln(" ***** Hash tables with time keys do not work correctly");
      writeln;
    end if;
  end func;


const proc: chkEnumerationTypeHash is func
  local
    var boolean: okay is TRUE;
    var enumTypeBooleanHash:     enumTypeBooleanHashVar     is enumTypeBooleanHash    .EMPTY_HASH;
    var enumTypeIntegerHash:     enumTypeIntegerHashVar     is enumTypeIntegerHash    .EMPTY_HASH;
    var enumTypeBigIntegerHash:  enumTypeBigIntegerHashVar  is enumTypeBigIntegerHash .EMPTY_HASH;
    var enumTypeBigRationalHash: enumTypeBigRationalHashVar is enumTypeBigRationalHash.EMPTY_HASH;
    var enumTypeFloatHash:       enumTypeFloatHashVar       is enumTypeFloatHash      .EMPTY_HASH;
    var enumTypeComplexHash:     enumTypeComplexHashVar     is enumTypeComplexHash    .EMPTY_HASH;
    var enumTypeCharHash:        enumTypeCharHashVar        is enumTypeCharHash       .EMPTY_HASH;
    var enumTypeStringHash:      enumTypeStringHashVar      is enumTypeStringHash     .EMPTY_HASH;
    var enumTypeBstringHash:     enumTypeBstringHashVar     is enumTypeBstringHash    .EMPTY_HASH;
    var enumTypeBitsetHash:      enumTypeBitsetHashVar      is enumTypeBitsetHash     .EMPTY_HASH;
    var enumTypeTimeHash:        enumTypeTimeHashVar        is enumTypeTimeHash       .EMPTY_HASH;
    var enumTypeEnumTypeHash:    enumTypeEnumTypeHashVar    is enumTypeEnumTypeHash   .EMPTY_HASH;
    var enumTypeTypeHash:        enumTypeTypeHashVar        is enumTypeTypeHash       .EMPTY_HASH;
    var enumTypeReferenceHash:   enumTypeReferenceHashVar   is enumTypeReferenceHash  .EMPTY_HASH;
    var enumTypeHashHash:        enumTypeHashHashVar        is enumTypeHashHash       .EMPTY_HASH;
  begin
    if  length(enumTypeBooleanHashVar)     <> 0 or
        length(enumTypeIntegerHashVar)     <> 0 or
        length(enumTypeBigIntegerHashVar)  <> 0 or
        length(enumTypeBigRationalHashVar) <> 0 or
        length(enumTypeFloatHashVar)       <> 0 or
        length(enumTypeComplexHashVar)     <> 0 or
        length(enumTypeCharHashVar)        <> 0 or
        length(enumTypeStringHashVar)      <> 0 or
        length(enumTypeBstringHashVar)     <> 0 or
        length(enumTypeBitsetHashVar)      <> 0 or
        length(enumTypeTimeHashVar)        <> 0 or
        length(enumTypeEnumTypeHashVar)    <> 0 or
        length(enumTypeTypeHashVar)        <> 0 or
        length(enumTypeReferenceHashVar)   <> 0 or
        length(enumTypeHashHashVar)        <> 0 then
      writeln(" ***** Number of elements in empty hash[enumerationType] table not 0");
      okay := FALSE;
    end if;
    if  YELLOW in enumTypeBooleanHashVar     or
        YELLOW in enumTypeIntegerHashVar     or
        YELLOW in enumTypeBigIntegerHashVar  or
        YELLOW in enumTypeBigRationalHashVar or
        YELLOW in enumTypeFloatHashVar       or
        YELLOW in enumTypeComplexHashVar     or
        YELLOW in enumTypeCharHashVar        or
        YELLOW in enumTypeStringHashVar      or
        YELLOW in enumTypeBstringHashVar     or
        YELLOW in enumTypeBitsetHashVar      or
        YELLOW in enumTypeTimeHashVar        or
        YELLOW in enumTypeEnumTypeHashVar    or
        YELLOW in enumTypeTypeHashVar        or
        YELLOW in enumTypeReferenceHashVar   or
        YELLOW in enumTypeHashHashVar        then
      writeln(" ***** Elements found in empty hash table");
      okay := FALSE;
    end if;
    if  keys(enumTypeBooleanHashVar)     <> 0 times RED or
        keys(enumTypeIntegerHashVar)     <> 0 times RED or
        keys(enumTypeBigIntegerHashVar)  <> 0 times RED or
        keys(enumTypeBigRationalHashVar) <> 0 times RED or
        keys(enumTypeFloatHashVar)       <> 0 times RED or
        keys(enumTypeComplexHashVar)     <> 0 times RED or
        keys(enumTypeCharHashVar)        <> 0 times RED or
        keys(enumTypeStringHashVar)      <> 0 times RED or
        keys(enumTypeBstringHashVar)     <> 0 times RED or
        keys(enumTypeBitsetHashVar)      <> 0 times RED or
        keys(enumTypeTimeHashVar)        <> 0 times RED or
        keys(enumTypeEnumTypeHashVar)    <> 0 times RED or
        keys(enumTypeTypeHashVar)        <> 0 times RED or
        keys(enumTypeReferenceHashVar)   <> 0 times RED or
        keys(enumTypeHashHashVar)        <> 0 times RED then
      writeln(" ***** Number of keys in empty hash[enumerationType] table is not 0");
      okay := FALSE;
    end if;
    if  values(enumTypeBooleanHashVar)     <> 0 times FALSE or
        values(enumTypeIntegerHashVar)     <> 0 times 0 or
        values(enumTypeBigIntegerHashVar)  <> 0 times 0_ or
        values(enumTypeBigRationalHashVar) <> 0 times 0_ / 1_ or
        values(enumTypeFloatHashVar)       <> 0 times 0.0 or
        values(enumTypeComplexHashVar)     <> 0 times complex(0.0, 0.0) or
        values(enumTypeCharHashVar)        <> 0 times ' ' or
        values(enumTypeStringHashVar)      <> 0 times "" or
        values(enumTypeBstringHashVar)     <> 0 times bstring("") or
        values(enumTypeBitsetHashVar)      <> 0 times {} or
        values(enumTypeTimeHashVar)        <> 0 times time.value or
        values(enumTypeEnumTypeHashVar)    <> 0 times RED or
        values(enumTypeTypeHashVar)        <> 0 times boolean or
        values(enumTypeReferenceHashVar)   <> 0 times NIL then
      writeln(" ***** Number of values in empty hash[enumerationType] table is not 0");
      okay := FALSE;
    end if;
    if  not raisesIndexError(enumTypeBooleanHashVar     [YELLOW]) or
        not raisesIndexError(enumTypeIntegerHashVar     [YELLOW]) or
        not raisesIndexError(enumTypeBigIntegerHashVar  [YELLOW]) or
        not raisesIndexError(enumTypeBigRationalHashVar [YELLOW]) or
        not raisesIndexError(enumTypeFloatHashVar       [YELLOW]) or
        not raisesIndexError(enumTypeComplexHashVar     [YELLOW]) or
        not raisesIndexError(enumTypeCharHashVar        [YELLOW]) or
        not raisesIndexError(enumTypeStringHashVar      [YELLOW]) or
        not raisesIndexError(enumTypeBstringHashVar     [YELLOW]) or
        not raisesIndexError(enumTypeBitsetHashVar      [YELLOW]) or
        not raisesIndexError(enumTypeTimeHashVar        [YELLOW]) or
        not raisesIndexError(enumTypeEnumTypeHashVar    [YELLOW]) or
        not raisesIndexError(enumTypeTypeHashVar        [YELLOW]) or
        not raisesIndexError(enumTypeReferenceHashVar   [YELLOW]) then
      writeln(" ***** Indexing into an empty hash[enumerationType] does not raise INDEX_ERROR");
      okay := FALSE;
    end if;
    enumTypeBooleanHashVar     @:= [YELLOW] TRUE;
    enumTypeIntegerHashVar     @:= [YELLOW] 1234;
    enumTypeBigIntegerHashVar  @:= [YELLOW] 9999999999_;
    enumTypeBigRationalHashVar @:= [YELLOW] 9999999999_ / 12345678_;
    enumTypeFloatHashVar       @:= [YELLOW] 3.1415926535;
    enumTypeComplexHashVar     @:= [YELLOW] complex(1.2, 3.4);
    enumTypeCharHashVar        @:= [YELLOW] 'Q';
    enumTypeStringHashVar      @:= [YELLOW] "success";
    enumTypeBstringHashVar     @:= [YELLOW] bstring("okay");
    enumTypeBitsetHashVar      @:= [YELLOW] {123};
    enumTypeTimeHashVar        @:= [YELLOW] time("2011-12-13 14:15");
    enumTypeEnumTypeHashVar    @:= [YELLOW] GREEN;
    enumTypeTypeHashVar        @:= [YELLOW] char;
    enumTypeReferenceHashVar   @:= [YELLOW] NIL;
    enumTypeHashHashVar        @:= [YELLOW] enumTypeBooleanHashVar;
    if  length(enumTypeBooleanHashVar)     <> 1 or
        length(enumTypeIntegerHashVar)     <> 1 or
        length(enumTypeBigIntegerHashVar)  <> 1 or
        length(enumTypeBigRationalHashVar) <> 1 or
        length(enumTypeFloatHashVar)       <> 1 or
        length(enumTypeComplexHashVar)     <> 1 or
        length(enumTypeCharHashVar)        <> 1 or
        length(enumTypeStringHashVar)      <> 1 or
        length(enumTypeBstringHashVar)     <> 1 or
        length(enumTypeBitsetHashVar)      <> 1 or
        length(enumTypeTimeHashVar)        <> 1 or
        length(enumTypeEnumTypeHashVar)    <> 1 or
        length(enumTypeTypeHashVar)        <> 1 or
        length(enumTypeReferenceHashVar)   <> 1 or
        length(enumTypeHashHashVar)        <> 1 then
      writeln(" ***** Number of elements in hash[enumerationType] table not 1");
      okay := FALSE;
    end if;
    if  YELLOW in enumTypeBooleanHashVar     and
        YELLOW in enumTypeIntegerHashVar     and
        YELLOW in enumTypeBigIntegerHashVar  and
        YELLOW in enumTypeBigRationalHashVar and
        YELLOW in enumTypeFloatHashVar       and
        YELLOW in enumTypeComplexHashVar     and
        YELLOW in enumTypeCharHashVar        and
        YELLOW in enumTypeStringHashVar      and
        YELLOW in enumTypeBstringHashVar     and
        YELLOW in enumTypeBitsetHashVar      and
        YELLOW in enumTypeTimeHashVar        and
        YELLOW in enumTypeEnumTypeHashVar    and
        YELLOW in enumTypeTypeHashVar        and
        YELLOW in enumTypeReferenceHashVar   and
        YELLOW in enumTypeHashHashVar        then
      noop;
    else
      writeln(" ***** Elements missing in hash[enumerationType] table");
      okay := FALSE;
    end if;
    if  keys(enumTypeBooleanHashVar)     <> [] (YELLOW) or
        keys(enumTypeIntegerHashVar)     <> [] (YELLOW) or
        keys(enumTypeBigIntegerHashVar)  <> [] (YELLOW) or
        keys(enumTypeBigRationalHashVar) <> [] (YELLOW) or
        keys(enumTypeFloatHashVar)       <> [] (YELLOW) or
        keys(enumTypeComplexHashVar)     <> [] (YELLOW) or
        keys(enumTypeCharHashVar)        <> [] (YELLOW) or
        keys(enumTypeStringHashVar)      <> [] (YELLOW) or
        keys(enumTypeBstringHashVar)     <> [] (YELLOW) or
        keys(enumTypeBitsetHashVar)      <> [] (YELLOW) or
        keys(enumTypeTimeHashVar)        <> [] (YELLOW) or
        keys(enumTypeEnumTypeHashVar)    <> [] (YELLOW) or
        keys(enumTypeTypeHashVar)        <> [] (YELLOW) or
        keys(enumTypeReferenceHashVar)   <> [] (YELLOW) or
        keys(enumTypeHashHashVar)        <> [] (YELLOW) then
      writeln(" ***** keys(hash[enumerationType]) does not work correctly");
      okay := FALSE;
    end if;
    if  values(enumTypeBooleanHashVar)     <> [] (TRUE) or
        values(enumTypeIntegerHashVar)     <> [] (1234) or
        values(enumTypeBigIntegerHashVar)  <> [] (9999999999_) or
        values(enumTypeBigRationalHashVar) <> [] (9999999999_ / 12345678_) or
        values(enumTypeFloatHashVar)       <> [] (3.1415926535) or
        values(enumTypeComplexHashVar)     <> [] (complex(1.2, 3.4)) or
        values(enumTypeCharHashVar)        <> [] ('Q') or
        values(enumTypeStringHashVar)      <> [] ("success") or
        values(enumTypeBstringHashVar)     <> [] (bstring("okay")) or
        values(enumTypeBitsetHashVar)      <> [] ({123}) or
        values(enumTypeTimeHashVar)        <> [] (time("2011-12-13 14:15")) or
        values(enumTypeEnumTypeHashVar)    <> [] (GREEN) or
        values(enumTypeTypeHashVar)        <> [] (char) or
        values(enumTypeReferenceHashVar)   <> [] (NIL) then
      writeln(" ***** values(hash[enumerationType]) does not work correctly");
      okay := FALSE;
    end if;
    enumTypeBooleanHashVar     @:= [YELLOW] TRUE;
    enumTypeIntegerHashVar     @:= [YELLOW] 1234;
    enumTypeBigIntegerHashVar  @:= [YELLOW] 9999999999_;
    enumTypeBigRationalHashVar @:= [YELLOW] 9999999999_ / 12345678_;
    enumTypeFloatHashVar       @:= [YELLOW] 3.1415926535;
    enumTypeComplexHashVar     @:= [YELLOW] complex(1.2, 3.4);
    enumTypeCharHashVar        @:= [YELLOW] 'Q';
    enumTypeStringHashVar      @:= [YELLOW] "success";
    enumTypeBstringHashVar     @:= [YELLOW] bstring("okay");
    enumTypeBitsetHashVar      @:= [YELLOW] {123};
    enumTypeTimeHashVar        @:= [YELLOW] time("2011-12-13 14:15");
    enumTypeEnumTypeHashVar    @:= [YELLOW] GREEN;
    enumTypeTypeHashVar        @:= [YELLOW] char;
    enumTypeReferenceHashVar   @:= [YELLOW] NIL;
    enumTypeHashHashVar        @:= [YELLOW] enumTypeBooleanHashVar;
    if  YELLOW not in enumTypeBooleanHashVar     or
        YELLOW not in enumTypeIntegerHashVar     or
        YELLOW not in enumTypeBigIntegerHashVar  or
        YELLOW not in enumTypeBigRationalHashVar or
        YELLOW not in enumTypeFloatHashVar       or
        YELLOW not in enumTypeComplexHashVar     or
        YELLOW not in enumTypeCharHashVar        or
        YELLOW not in enumTypeStringHashVar      or
        YELLOW not in enumTypeBstringHashVar     or
        YELLOW not in enumTypeBitsetHashVar      or
        YELLOW not in enumTypeTimeHashVar        or
        YELLOW not in enumTypeEnumTypeHashVar    or
        YELLOW not in enumTypeTypeHashVar        or
        YELLOW not in enumTypeReferenceHashVar   or
        YELLOW not in enumTypeHashHashVar        then
      writeln(" ***** Elements missing in hash[enumerationType] table");
      okay := FALSE;
    end if;
    if  enumTypeBooleanHashVar     [YELLOW] <> TRUE                     or
        enumTypeIntegerHashVar     [YELLOW] <> 1234                     or
        enumTypeBigIntegerHashVar  [YELLOW] <> 9999999999_              or
        enumTypeBigRationalHashVar [YELLOW] <> 9999999999_ / 12345678_  or
        enumTypeFloatHashVar       [YELLOW] <> 3.1415926535             or
        enumTypeComplexHashVar     [YELLOW] <> complex(1.2, 3.4)        or
        enumTypeCharHashVar        [YELLOW] <> 'Q'                      or
        enumTypeStringHashVar      [YELLOW] <> "success"                or
        enumTypeBstringHashVar     [YELLOW] <> bstring("okay")          or
        enumTypeBitsetHashVar      [YELLOW] <> {123}                    or
        enumTypeTimeHashVar        [YELLOW] <> time("2011-12-13 14:15") or
        enumTypeEnumTypeHashVar    [YELLOW] <> GREEN                    or
        enumTypeTypeHashVar        [YELLOW] <> char                     or
        enumTypeReferenceHashVar   [YELLOW] <> NIL                      then
      writeln(" ***** Elements with wrong value in hash[enumerationType] table");
      okay := FALSE;
    end if;
    if okay then
      writeln("Hash tables with enumeration type keys work correctly.");
    else
      writeln(" ***** Hash tables with enumeration type keys do not work correctly");
      writeln;
    end if;
  end func;


const proc: chkKeysFunction is func
  local
    var boolean: okay is TRUE;
    var integerIntegerHash: aHash is integerIntegerHash.value;
    var array integer: hashKeys is 0 times 0;
    var integer: number is 0;
  begin
    for number range 1 to 50000 do
      aHash @:= [number] number;
    end for;
    hashKeys := keys(aHash);
    if length(hashKeys) <> 50000 then
      okay := FALSE;
    else
      hashKeys := sort(hashKeys);
      for number range 1 to 50000 do
        if hashKeys[number] <> number then
          okay := FALSE;
        end if;
      end for;
    end if;
    if okay then
      writeln("The keys function for hash tables works correctly.");
    else
      writeln(" ***** The keys function for hash tables does not work correctly.");
      writeln;
    end if;
  end func;


const proc: chkValuesFunction is func
  local
    var boolean: okay is TRUE;
    var integerIntegerHash: aHash is integerIntegerHash.value;
    var array integer: hashValues is 0 times 0;
    var integer: number is 0;
  begin
    for number range 1 to 50000 do
      aHash @:= [number] number;
    end for;
    hashValues := values(aHash);
    if length(hashValues) <> 50000 then
      okay := FALSE;
    else
      hashValues := sort(hashValues);
      for number range 1 to 50000 do
        if hashValues[number] <> number then
          okay := FALSE;
        end if;
      end for;
    end if;
    if okay then
      writeln("The values function for hash tables works correctly.");
    else
      writeln(" ***** The values function for hash tables does not work correctly.");
      writeln;
    end if;
  end func;


const proc: chkForLoop is func
  local
    var boolean: okay is TRUE;
    var integerIntegerHash: aHash is integerIntegerHash.value;
    var bitset: checkKeySet is bitset.value;
    var bitset: checkValueSet is bitset.value;
    var integer: number is 0;
  begin
    for number range 1 to 1000 do
      aHash @:= [number] number;
    end for;
    checkValueSet := {1 .. 1000};
    for number range aHash do
      excl(checkValueSet, number);
    end for;
    if checkValueSet <> bitset.value then
      writeln(" ***** for loop over the values does not work correctly.");
      okay := FALSE;
    end if;
    checkKeySet := {1 .. 1000};
    for key number range aHash do
      excl(checkKeySet, number);
    end for;
    if checkKeySet <> bitset.value then
      writeln(" ***** for loop over the keys does not work correctly.");
      okay := FALSE;
    end if;
    checkKeySet := {1 .. 1000};
    checkValueSet := {1 .. 1000};
    for key number range aHash do
      excl(checkKeySet, number);
      excl(checkValueSet, number);
    end for;
    if checkKeySet <> bitset.value or checkValueSet <> bitset.value then
      writeln(" ***** for loop over keys and values does not work correctly.");
      okay := FALSE;
    end if;
    if okay then
      writeln("The for loop for hash tables works correctly.");
    else
      writeln(" ***** The for loop for hash tables does not work correctly.");
      writeln;
    end if;
  end func;


const proc: chkAssignmentToItself is func
  local
    var boolean: okay is TRUE;
    var stringStringHash: aHash is stringStringHash.value;
  begin
    aHash @:= ["asdf"] "qwer";
    okay := okay and aHash["asdf"] = "qwer";
    aHash := aHash;
    okay := okay and aHash["asdf"] = "qwer";
    if okay then
      writeln("The assignment of a hash variable to itself works correctly.");
    else
      writeln(" ***** The assignment of a hash variable to itself does not work correctly.");
      writeln;
    end if;
  end func;


const proc: chkHashLiteral is func
  local
    var boolean: okay is TRUE;
    var stringIntegerHash:  stringIntegerHashVar1  is [] (["one" : 1]);
    var stringFloatHash:    stringFloatHashVar1    is [] (["one" : 1.0]);
    var stringStringHash:   stringStringHashVar1   is [] (["one" : "1"]);
    var stringIntegerHash:  stringIntegerHashVar2  is [] (["one" : 1], ["two" : 2]);
    var stringFloatHash:    stringFloatHashVar2    is [] (["one" : 1.0], ["two" : 2.0]);
    var stringStringHash:   stringStringHashVar2   is [] (["one" : "1"], ["two" : "2"]);
    var stringIntegerHash:  stringIntegerHashVar3  is [] (["one" : 1], ["two" : 2], ["three" : 3]);
    var stringFloatHash:    stringFloatHashVar3    is [] (["one" : 1.0], ["two" : 2.0], ["three" : 3.0]);
    var stringStringHash:   stringStringHashVar3   is [] (["one" : "1"], ["two" : "2"], ["three" : "3"]);
    var stringIntegerHash:  stringIntegerHashVar4  is [] (["one" : 1], ["two" : 2], (["three" : 3], ["four" : 4]));
    var stringFloatHash:    stringFloatHashVar4    is [] (["one" : 1.0], ["two" : 2.0], (["three" : 3.0], ["four" : 4.0]));
    var stringStringHash:   stringStringHashVar4   is [] (["one" : "1"], ["two" : "2"], (["three" : "3"], ["four" : "4"]));
    var complexStringHash:  complexStringHashVar1  is [] ([complex(1.0, 1.0) : "one"]);
    var complexStringHash:  complexStringHashVar2  is [] ([complex(1.0, 1.0) : "one"], [complex(2.0, 2.0) : "two"]);
    var complexStringHash:  complexStringHashVar3  is [] ([complex(1.0, 1.0) : "one"], [complex(2.0, 2.0) : "two"], [complex(3.0, 3.0) : "three"]);
    var complexComplexHash: complexComplexHashVar1 is [] ([complex(1.0, 1.0) : complex(1.0, -1.0)]);
    var complexComplexHash: complexComplexHashVar2 is [] ([complex(1.0, 1.0) : complex(1.0, -1.0)], [complex(2.0, 2.0) : complex(2.0, -2.0)]);
  begin
    if  length(stringIntegerHashVar1) <> 1 or
        length(stringFloatHashVar1)   <> 1 or
        length(stringStringHashVar1)  <> 1 or
        stringIntegerHashVar1["one"] <> 1 or
        stringFloatHashVar1["one"]   <> 1.0 or
        stringStringHashVar1["one"]  <> "1" or
        stringIntegerHashVar1 <> [] (["one" : 1]) or
        stringFloatHashVar1   <> [] (["one" : 1.0]) or
        stringStringHashVar1  <> [] (["one" : "1"]) then
      okay := FALSE;
      writeln(" ***** Hash literals do not work correctly. (1)");
    end if;
    if  length(stringIntegerHashVar2) <> 2 or
        length(stringFloatHashVar2)   <> 2 or
        length(stringStringHashVar2)  <> 2 or
        stringIntegerHashVar2["one"] <> 1 or
        stringIntegerHashVar2["two"] <> 2 or
        stringFloatHashVar2["one"] <> 1.0 or
        stringFloatHashVar2["two"] <> 2.0 or
        stringStringHashVar2["one"] <> "1" or
        stringStringHashVar2["two"] <> "2" or
        stringIntegerHashVar2 <> [] (["one" : 1], ["two" : 2]) or
        stringFloatHashVar2   <> [] (["one" : 1.0], ["two" : 2.0]) or
        stringStringHashVar2  <> [] (["one" : "1"], ["two" : "2"]) then
      okay := FALSE;
      writeln(" ***** Hash literals do not work correctly. (2)");
    end if;
    if  length(stringIntegerHashVar3) <> 3 or
        length(stringFloatHashVar3)   <> 3 or
        length(stringStringHashVar3)  <> 3 or
        stringIntegerHashVar3["one"]   <> 1 or
        stringIntegerHashVar3["two"]   <> 2 or
        stringIntegerHashVar3["three"] <> 3 or
        stringFloatHashVar3["one"]   <> 1.0 or
        stringFloatHashVar3["two"]   <> 2.0 or
        stringFloatHashVar3["three"] <> 3.0 or
        stringStringHashVar3["one"]   <> "1" or
        stringStringHashVar3["two"]   <> "2" or
        stringStringHashVar3["three"] <> "3" or
        stringIntegerHashVar3 <> [] (["one" : 1], ["two" : 2], ["three" : 3]) or
        stringFloatHashVar3   <> [] (["one" : 1.0], ["two" : 2.0], ["three" : 3.0]) or
        stringStringHashVar3  <> [] (["one" : "1"], ["two" : "2"], ["three" : "3"]) then
      okay := FALSE;
      writeln(" ***** Hash literals do not work correctly. (3)");
    end if;
    if  length(stringIntegerHashVar4) <> 4 or
        length(stringFloatHashVar4)   <> 4 or
        length(stringStringHashVar4)  <> 4 or
        stringIntegerHashVar4["one"]   <> 1 or
        stringIntegerHashVar4["two"]   <> 2 or
        stringIntegerHashVar4["three"] <> 3 or
        stringIntegerHashVar4["four"]  <> 4 or
        stringFloatHashVar4["one"]   <> 1.0 or
        stringFloatHashVar4["two"]   <> 2.0 or
        stringFloatHashVar4["three"] <> 3.0 or
        stringFloatHashVar4["four"]  <> 4.0 or
        stringStringHashVar4["one"]   <> "1" or
        stringStringHashVar4["two"]   <> "2" or
        stringStringHashVar4["three"] <> "3" or
        stringStringHashVar4["four"]  <> "4" or
        stringIntegerHashVar4 <> [] (["one" : 1], ["two" : 2], (["three" : 3], ["four" : 4])) or
        stringFloatHashVar4   <> [] (["one" : 1.0], ["two" : 2.0], (["three" : 3.0], ["four" : 4.0])) or
        stringStringHashVar4  <> [] (["one" : "1"], ["two" : "2"], (["three" : "3"], ["four" : "4"])) then
      okay := FALSE;
      writeln(" ***** Hash literals do not work correctly. (4)");
    end if;
    if  complexStringHashVar1 <> [] ([complex(1.0, 1.0) : "one"]) or
        complexStringHashVar2 <> [] ([complex(1.0, 1.0) : "one"], [complex(2.0, 2.0) : "two"]) or
        complexStringHashVar3 <> [] ([complex(1.0, 1.0) : "one"], [complex(2.0, 2.0) : "two"], [complex(3.0, 3.0) : "three"]) then
      okay := FALSE;
      writeln(" ***** Hash literals do not work correctly. (5)");
    end if;
    if  complexComplexHashVar1 <> [] ([complex(1.0, 1.0) : complex(1.0, -1.0)]) or
        complexComplexHashVar2 <> [] ([complex(1.0, 1.0) : complex(1.0, -1.0)], [complex(2.0, 2.0) : complex(2.0, -2.0)]) then
      okay := FALSE;
      writeln(" ***** Hash literals do not work correctly. (6)");
    end if;
    if  not raisesRangeError([] (["one" : 1], ["one" : -1])) then
      okay := FALSE;
      writeln(" ***** Hash literals with double keys do not raise RANGE_ERROR.");
    end if;
    if okay then
      writeln("Hash literals work correctly.");
    end if;
  end func;


const type: win_table_hash is hash [PRIMITIVE_WINDOW] integer;
const type: win_index_hash is hash [integer] array PRIMITIVE_WINDOW;

const proc: chkInlineHashKeys is func
  local
    var win_table_hash: win_const_table is win_table_hash.EMPTY_HASH;
    var win_index_hash: win_index is win_index_hash.EMPTY_HASH;
    var PRIMITIVE_WINDOW: win1 is PRIMITIVE_WINDOW.value;
    var boolean: okay is FALSE;
  begin
    # The code below is a regression test for the compiler.
    # It uses inlining and a result expression with a name.
    if length(win_const_table) <> 1 or length(win_index) <> 1 or
        width(win_index[keys(win_index)[1]][1]) <> 0 or
        height(win_index[keys(win_index)[1]][1]) <> 0 then
      okay := TRUE;
    end if;
  end func;


const proc: main is func
  begin
    writeln;
    chkBooleanHash;
    chkIntegerHash;
    chkBigIntegerHash;
    chkRationalHash;
    chkBigRationalHash;
    chkFloatHash;
    chkComplexHash;
    chkCharHash;
    chkStringHash;
    chkBstringHash;
    chkBitsetHash;
    chkTimeHash;
    chkEnumerationTypeHash;
    chkKeysFunction;
    chkValuesFunction;
    chkForLoop;
    chkAssignmentToItself;
    chkHashLiteral;
    chkInlineHashKeys;
  end func;
