
(********************************************************************)
(*                                                                  *)
(*  bas7.sd7      Basic interpreter                                 *)
(*  Copyright (C) 1994, 2001, 2004 - 2008  Thomas Mertes            *)
(*                                                                  *)
(*  This program is free software; you can redistribute it and/or   *)
(*  modify it under the terms of the GNU General Public License as  *)
(*  published by the Free Software Foundation; either version 2 of  *)
(*  the License, or (at your option) any later version.             *)
(*                                                                  *)
(*  This program is distributed in the hope that it will be useful, *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of  *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *)
(*  GNU General Public License for more details.                    *)
(*                                                                  *)
(*  You should have received a copy of the GNU General Public       *)
(*  License along with this program; if not, write to the           *)
(*  Free Software Foundation, Inc., 51 Franklin Street,             *)
(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)
(*                                                                  *)
(*  This basic interpreter implements the following functions and   *)
(*  statements ( ** means recognized but not implemented):          *)
(*                                                                  *)
(*  ABS, ASC, ATN, **BEEP, **CALL, CASE, CDBL, CHAIN, CHR$, CINT,   *)
(*  **CIRCLE, CLEAR, CLOSE, CLS, **COLOR, **COMMON, CONST, COS,     *)
(*  CSNG, CSRLIN, DATA, DATE$, **DECLARE, DECR, DEF FN, **DEF SEG,  *)
(*  **DEFDBL, **DEFINT, **DEFSNG, DEFSTR, DIM, DO, DO UNTIL,        *)
(*  DO WHILE, **DRAW, ELSE, ELSEIF, END, EOF, **ERASE, ERR, ERROR,  *)
(*  EXIT DO, EXIT FOR, EXP, FIX, FOR, FREEFILE, GET, **GET#, GOSUB, *)
(*  GOSUB OF, GOTO, GOTO OF, HEX$, IF, INCR, INKEY$, **INP, INPUT,  *)
(*  INPUT#, INPUT$, INSTR, INT, **KEY, LCASE$, LEFT$, LEN, LET,     *)
(*  LINE INPUT, LINE INPUT#, LOCATE, LOF, LOG, LOOP, LOOP UNTIL,    *)
(*  LOOP WHILE, LTRIM$, MID$, NEXT, OCT$, ON ERROR, ON GOSUB,       *)
(*  ON GOTO, **ON KEY, **ON TIMER, OPEN, OPTION BASE, **OUT,        *)
(*  **PAINT, **PALETTE, **PEEK, **PLAY, **POINT, **POKE, POS,       *)
(*  PRESET, PRINT, PRINT#, PRINT USING, PSET, PUT, **PUT#,          *)
(*  RANDOMIZE, READ, REDIM, REM, RESET, RESTORE, RESUME, RETURN,    *)
(*  RIGHT$, RND, RTRIM$, SCREEN, SEEK#, SELECT, SGN, SIN, SLEEP,    *)
(*  **SOUND, SPACE$, SPC, SQR, STOP, STR$, **STRIG, STRING$, **SUB, *)
(*  SWAP, SYSTEM, TAB, TAN, TIME$, TIMER, UCASE$, VAL, WEND, WHILE, *)
(*  **WIDTH, WRITE, WRITE#                                          *)
(*                                                                  *)
(********************************************************************)


$ include "seed7_05.s7i";
  include "scanfile.s7i";
  include "scanstri.s7i";
  include "float.s7i";
  include "screen.s7i";
  include "draw.s7i";
  include "window.s7i";
  include "keybd.s7i";
  include "echo.s7i";
  include "line.s7i";
  include "time.s7i";

const integer: MAX_LINENUM is 2147483647;

const set of char: basic_name_char is alphanum_char | {'.'};
const set of char: hexdigit_char is digit_char | {'A' .. 'F'} | {'a' .. 'f'};
const set of char: octdigit_char is {'0' .. '7'};
const set of char: number_suffix is {'!', '#', '&'};

const type: lineType is new struct
    var string: fileName is "";
    var integer: fileLine is 0;
    var string: linenum is "";
    var string: label is "";
    var string: line is "";
  end struct;

var array lineType: prg is 0 times lineType.value;

var file: log is STD_NULL;
var file: err is STD_NULL;
var text: scr is STD_NULL;
var text: win is STD_NULL;

var integer: file_line_number is 0;
var string: statement_label is "";
var string: on_error_label is "";

var integer: error_code is 0;

var integer: resume_next_line is 0;
var integer: resume_next_column is 0;
var integer: resume_same_line is 0;
var integer: resume_same_column is 0;
var boolean: in_error_handler is FALSE;

const type: label_hash is hash [string] integer;
var label_hash: label is label_hash.EMPTY_HASH;
var label_hash: subprogram is label_hash.EMPTY_HASH;
var label_hash: declared is label_hash.EMPTY_HASH;

var integer: data_line_number is 0;
var string: data_line is "";

var set of char: defstr_any is {'\"'};
var set of char: defstr_var is (set of char).EMPTY_SET;

const type: defFnType is new struct
    var string: name is "";
    var string: params is "";
    var string: expression is "";
  end struct;

const type: def_fn_hash is hash [string] defFnType;
var def_fn_hash: def_fn_list is def_fn_hash.EMPTY_HASH;

const type: numeric_hash is hash [string] float;
var numeric_hash: numeric_var is numeric_hash.EMPTY_HASH;

const type: string_hash is hash [string] string;
var string_hash: string_var is string_hash.EMPTY_HASH;

const type: image_hash is hash [string] PRIMITIVE_WINDOW;
var image_hash: image_var is image_hash.EMPTY_HASH;

const type: file_array is array file;
var file_array: file_value is 256 times STD_NULL;

const type: forLoopDescrType is new struct
    var string: varName is "";
    var float: endValue is 0.0;
    var float: stepValue is 0.0;
    var integer: bodyLine is 0;
    var integer: bodyColumn is 0;
  end struct;

var array forLoopDescrType: forLoop is 0 times forLoopDescrType.value;

const type: whileLoopDescrType is new struct
    var integer: condLine is 0;
    var integer: condColumn is 0;
  end struct;

var array whileLoopDescrType: whileLoop is 0 times whileLoopDescrType.value;

const type: doLoopDescrType is new struct
    var integer: headLine is 0;
    var integer: headColumn is 0;
  end struct;

var array doLoopDescrType: doLoop is 0 times doLoopDescrType.value;

const type: gosubReturnDescrType is new struct
    var integer: returnLine is 0;
    var integer: returnColumn is 0;
    var integer: subEntryLine is 0;
    var integer: forLoopStackDepth is 0;
  end struct;

var array gosubReturnDescrType: gosubReturn is 0 times gosubReturnDescrType.value;

var integer: screenMode is 0;
var integer: currX is 0;
var integer: currY is 0;
var integer: foreground_color is 0;
var integer: background_color is 0;


const proc: sleep (in integer: secs) is func
  local
    var time: start_time is time.value;
  begin
    start_time := time(NOW);
    await(start_time + secs . SECONDS);
  end func;


const proc: list_prog is func
  local
    var integer: number is 0;
  begin
    for number range 1 to length(prg) do
      if prg[number].line <> "" or prg[number].linenum <> "" or prg[number].label <> "" then
        write(log, ("(" <& number <& ")") lpad 5 <& " ");
        write(log, prg[number].linenum lpad 5 <& " ");
        if prg[number].label <> "" then
          write(log, prg[number].label <& ": ");
        end if;
        writeln(log, prg[number].line);
      end if;
    end for;
  end func;


const func integer: hex_value (in string: stri) is func
  result
    var integer: result is 0;
  local
    var integer: pos is 0;
    var integer: digit is 0;
  begin
    pos := 1;
    while pos <= length(stri) do
      if stri[pos] >= '0' and stri[pos] <= '9' then
        digit := ord(stri[pos]) - ord('0');
      elsif stri[pos] >= 'A' and stri[pos] <= 'F' then
        digit := 10 + ord(stri[pos]) - ord('A');
      elsif stri[pos] >= 'a' and stri[pos] <= 'f' then
        digit := 10 + ord(stri[pos]) - ord('a');
      end if;
      result := result * 16 + digit;
      incr(pos);
    end while;
  end func;


const func integer: oct_value (in string: stri) is func
  result
    var integer: result is 0;
  local
    var integer: pos is 0;
    var integer: digit is 0;
  begin
    pos := 1;
    while pos <= length(stri) do
      if stri[pos] >= '0' and stri[pos] <= '7' then
        digit := ord(stri[pos]) - ord('0');
      end if;
      result := result * 8 + digit;
      incr(pos);
    end while;
  end func;


const func string: hex_str (in var integer: number) is func
  result
    var string: result is "";
  local
    var integer: digit is 0;
  begin
    while number >= 0 do
      digit := number rem 16;
      number := number div 16;
      if digit <= 9 then
        result := str(chr(ord('0') + digit)) & result;
      else
        result := str(chr(ord('A') + digit - 10)) & result;
      end if;
    end while;
  end func;


const func string: oct_str (in var integer: number) is func
  result
    var string: result is "";
  begin
    while number >= 0 do
      result := str(number rem 8) & result;
      number := number div 8;
    end while;
  end func;


(**
 *  Reads a BASIC symbol from 'line'.
 *  When the function is called it is assumed that 'line' is empty or
 *  line[1] contains the first character to be handled. When the
 *  function is left 'line' is empty or line[1] contains the character
 *  after the BASIC symbol. A BASIC symbol can be:
 *    - A name: A letter followed by letters, digits or '.'.
 *              Optionally a '$', '%', '!', '#' or '&' can be added.
 *    - An integer number: A sequence of digits.
 *    - A float number: A sequence of digits which contains one decimal
 *              point. An optional exponent may follow. When an
 *              exponent is present the decimal point may be ommited.
 *              The exponent is introduced with 'E' or 'e' followed
 *              by an optional sign ('+' or '-') and a sequence of
 *              digits. When the float number does start with '.' a
 *              '0' is added in front of the returned symbol.
 *    - A hex literal: It starts with '&H' followed by hex digits.
 *              A hex literal is converted to decimal and the decimal
 *              literal is returned.
 *    - An octal literal: It starts with '&O' followed by octal digits.
 *              An octal literal is converted to decimal and the
 *              decimal literal is returned.
 *    - A string literal: A sequence of characters enclosed in double
 *              quotation marks. A string literal is returned with the
 *              introducing " but without the ending " .
 *    - A special symbol: The symbols '<>', '<=' and '>=' are special
 *              symbols consisting of two characters. There can be a
 *              spaces and tabs between the two characters. Such spaces
 *              and tabs are removed from the symbol.
 *    - A one character symbol: When no other symbols can be recognized
 *              a symbol consisting of one character is created.
 *              E.g.: '=', '+', '-'.
 *  @return the BASIC symbol or "" at the end of the line.
 *)
const func string: get_symbol (inout string: line) is func
  result
    var string: symbol is "";
  local
    var integer: leng is 0;
    var integer: start is 0;
    var integer: index is 0;
    var char: ch is ' ';
  begin
    leng := length(line);
    if leng > 0 then
      repeat
        incr(start);
        if start <= leng then
          ch := line[start];
        else
          ch :=  '\0\';
        end if;
      until ch <> ' ' and ch <> '\t';
      index := start;
      case ch of
        when letter_char:
          repeat
            incr(index);
            if index <= leng then
              ch := line[index];
            else
              ch :=  ' ';
            end if;
          until ch not in basic_name_char;
          if ch = '$' or ch = '%' or ch = '!' or ch = '#' or ch = '&' then
            incr(index);
          end if;
          symbol := upper(line[start .. pred(index)]);
          line := line[index .. ];
        when digit_char:
          repeat
            incr(index);
            if index <= leng then
              ch := line[index];
            else
              ch :=  ' ';
            end if;
          until ch not in digit_char;
          if ch = '.' then
            incr(index);
            if index <= leng and line[index] in digit_char then
              repeat
                incr(index);
                if index <= leng then
                  ch := line[index];
                else
                  ch :=  ' ';
                end if;
              until ch not in digit_char;
            end if;
          end if;
          if ch = 'E' or ch = 'e' then
            incr(index);
            if index <= leng then
              ch := line[index];
            else
              ch :=  ' ';
            end if;
            if ch in digit_char or ch = '+' or ch = '-' then
              if ch = '+' or ch = '-' then
                incr(index);
                if index <= leng then
                  ch := line[index];
                else
                  ch :=  ' ';
                end if;
              end if;
              while ch in digit_char do
                incr(index);
                if index <= leng then
                  ch := line[index];
                else
                  ch :=  ' ';
                end if;
              end while;
            else
              decr(index);
            end if;
          end if;
          if ch in number_suffix then
            incr(index);
          end if;
          symbol := line[start .. pred(index)];
          line := line[index .. ];
        when {'.'}:
          incr(index);
          if index <= leng and line[index] in digit_char then
            repeat
              incr(index);
              if index <= leng then
                ch := line[index];
              else
                ch :=  ' ';
              end if;
            until ch not in digit_char;
            if ch = 'E' or ch = 'e' then
              incr(index);
              if index <= leng then
                ch := line[index];
              else
                ch :=  ' ';
              end if;
              if ch in digit_char or ch = '+' or ch = '-' then
                if ch = '+' or ch = '-' then
                  incr(index);
                  if index <= leng then
                    ch := line[index];
                  else
                    ch :=  ' ';
                  end if;
                end if;
                while ch in digit_char do
                  incr(index);
                  if index <= leng then
                    ch := line[index];
                  else
                    ch :=  ' ';
                  end if;
                end while;
              else
                decr(index);
              end if;
            end if;
            if ch in number_suffix then
              incr(index);
            end if;
            symbol := "0" & line[start .. pred(index)];
            line := line[index .. ];
          else
            symbol := ".";
            line := line[index .. ];
          end if;
        when {'&'}:
          incr(index);
          if index <= leng then
            ch := line[index];
            if ch = 'H' then
              incr(index);
              start := index;
              while index <= leng and line[index] in hexdigit_char do
                incr(index);
              end while;
              symbol := str(hex_value(line[start .. pred(index)]));
              if index <= leng and line[index] in number_suffix then
                symbol &:= line[index len 1];
                incr(index);
              end if;
            elsif ch = 'O' then
              incr(index);
              start := index;
              while index <= leng and line[index] in octdigit_char do
                incr(index);
              end while;
              symbol := str(oct_value(line[start .. pred(index)]));
              if index <= leng and line[index] in number_suffix then
                symbol &:= line[index len 1];
                incr(index);
              end if;
            else
              symbol := "&";
            end if;
          else
            symbol := "&";
          end if;
          line := line[index .. ];
        when {'"'}:
          repeat
            incr(index);
          until index > leng or line[index] = '"';
          symbol := line[start .. pred(index)];
          line := line[succ(index) .. ];
        when {'<'}:
          (* Sometimes <> or <= are written as < > or < =  *)
          repeat
            incr(index);
            if index <= leng then
              ch := line[index];
            else
              ch :=  '\0\';
            end if;
          until ch <> ' ' and ch <> '\t';
          if ch = '>' then
            incr(index);
            symbol := "<>";
          elsif ch = '=' then
            incr(index);
            symbol := "<=";
          else
            symbol := "<";
          end if;
          line := line[index .. ];
        when {'>'}:
          (* Sometimes >= is written as > =  *)
          repeat
            incr(index);
            if index <= leng then
              ch := line[index];
            else
              ch :=  '\0\';
            end if;
          until ch <> ' ' and ch <> '\t';
          if ch = '=' then
            incr(index);
            symbol := ">=";
          else
            symbol := ">";
          end if;
          line := line[index .. ];
        when {'\r'}:
          symbol := "";
          line := line[succ(index) .. ];
        otherwise:
          symbol := str(line[index]);
          line := line[succ(index) .. ];
      end case;
    end if;
    # writeln(log, "SY=" <& literal(symbol));
  end func;


const func boolean: endOfStatement (in string: symbol) is
  return symbol = ":" or symbol = "" or symbol = "'" or symbol = "REM" or symbol = "ELSE";


const func boolean: isStringExpr (in string: symbol) is
  return symbol[length(symbol)] = '$' or symbol[1] in defstr_any;


const func boolean: isStringVar (in string: symbol) is
  return symbol[length(symbol)] = '$' or symbol[1] in defstr_var;


const func float: getNumericVar (in string: varName) is func
  result
    var float: result is 0.0;
  begin
    if varName in numeric_var then
      result := numeric_var[varName];
    end if;
  end func;


const proc: setNumericVar (in string: varName, in float: number) is func
  begin
    numeric_var @:= [varName] number;
  end func;


const func string: getStringVar (in string: varName) is func
  result
    var string: result is "";
  begin
    if varName in string_var then
      result := string_var[varName];
    end if;
  end func;


const proc: setStringVar (in string: varName, in string: stri) is func
  begin
    string_var @:= [varName] stri;
  end func;


const proc: line_marker is func
  begin
    if statement_label <> "" then
      log << statement_label;
      log << " ";
    elsif file_line_number <= length(prg) then
      if prg[file_line_number].fileName <> prg[1].fileName then
        log << prg[file_line_number].fileName;
      end if;
      log << "(";
      log << prg[file_line_number].fileLine;
      log << ") ";
    else
      log << "##### ";
      log << file_line_number;
      log << " ##### ";      
    end if;
  end func;


const proc: line_marker (in integer: line_number) is func
  begin
    if prg[line_number].label <> "" then
      log << prg[line_number].label;
    elsif prg[line_number].linenum <> "" then
      log << prg[line_number].linenum;
    else
      if prg[line_number].fileName <> prg[1].fileName then
        log << prg[line_number].fileName;
      end if;
      log << "(";
      log << prg[line_number].fileLine;
      log << ")";
    end if;
  end func;


const proc: error_marker is func
  begin
    err << " ***** ";
    if statement_label <> "" then
      err << "[";
      err << statement_label;
      err << "] ";
    else
      if prg[file_line_number].fileName <> prg[1].fileName then
        err << prg[file_line_number].fileName;
      end if;
      err << "(";
      err << prg[file_line_number].fileLine;
      err << ") ";
    end if;
  end func;


const proc: error_expect (in string: expected_symbol, in string: symbol) is func
  begin
    error_marker;
    err << literal(expected_symbol);
    err << " EXPECTED - FOUND ";
    err << literal(symbol);
    err << ".";
    err << NL;
  end func;


const proc: error_expect2 (in string: expected_symbol1, in string: expected_symbol2, in string: symbol) is func
  begin
    error_marker;
    err << literal(expected_symbol1);
    err << " OR ";
    err << literal(expected_symbol2);
    err << " EXPECTED - FOUND ";
    err << literal(symbol);
    err << ".";
    err << NL;
  end func;


const proc: expect (in string: expected_symbol, inout string: symbol, inout string: line) is func
  begin
    if symbol = expected_symbol then
      symbol := get_symbol(line);
    else
      error_expect(expected_symbol, symbol);
    end if;
  end func;


const func color: color_num (in integer: col_num) is func
  result
    var color: result is black;
  begin
    case col_num of
      when {0}: result := black;
      when {1}: result := dark_blue;
      when {2}: result := dark_green;
      when {3}: result := dark_cyan;
      when {4}: result := dark_red;
      when {5}: result := dark_magenta;
      when {6}: result := brown;
      when {7}: result := light_gray;
      when {8}: result := dark_gray;
      when {9}: result := light_blue;
      when {10}: result := light_green;
      when {11}: result := light_cyan;
      when {12}: result := light_red;
      when {13}: result := light_magenta;
      when {14}: result := yellow;
      when {15}: result := white;
    end case;
  end func;


const func string: get_data_line is func
  result
    var string: data_line is "";
  local
    var boolean: searching is TRUE;
    var string: data_symbol is "";
  begin
    while searching do
      incr(data_line_number);
      if data_line_number > length(prg) then
        error_marker;
        err << "OUT OF DATA";
        err << NL;
        data_line := ",,,,,,,,,,,,,,,,,,,,,,,,,";
        searching := FALSE;
      elsif prg[data_line_number].line <> "" then
        data_line := prg[data_line_number].line;
        (* write(data_line_number lpad 5);
        write(" ");
        write(prg[data_line_number].line);
        writeln; *)
        repeat
          data_symbol := get_symbol(data_line);
        until data_symbol = "" or data_symbol = "DATA" or
            data_symbol = "'" or data_symbol = "REM";
        if data_symbol = "DATA" then
          searching := FALSE;
        end if;
      end if;
    end while;
  end func;


const func string: get_data_field is func
  result
    var string: data_field is "";
  local
    var integer: comma_pos is 0;
    var integer: quote_pos is 0;
    var integer: colon_pos is 0;
    var string: data_symbol is "";
  begin
    if data_line = "" then
      data_line := get_data_line;
    end if;
    while data_line <> "" and data_line[1] = ' ' do
      data_line := data_line[2 .. ];
    end while;
    if data_line <> "" and data_line[1] = '"' then
      data_field := "";
      data_line := data_line[2 .. ];
      quote_pos := pos(data_line, "\"");
      while quote_pos <> 0 do
        if succ(quote_pos) <= length(data_line) and
            data_line[succ(quote_pos)] = '"' then
          data_field &:= data_line[ .. quote_pos];
          data_line := data_line[quote_pos + 2 .. ];
          quote_pos := pos(data_line, "\"");
        else
          data_field &:= data_line[ .. pred(quote_pos)];
          data_line := data_line[succ(quote_pos) .. ];
          quote_pos := 0;
        end if;
      end while;
      comma_pos := pos(data_line, ",");
      if comma_pos <> 0 then
        data_line := data_line[succ(comma_pos) .. ];
      else
        data_line := "";
      end if;
    else
      comma_pos := pos(data_line, ",");
      colon_pos := pos(data_line, ":");
      if colon_pos <> 0 then
        if comma_pos = 0 or colon_pos < comma_pos then
          data_field := data_line[ .. pred(colon_pos)];
          data_line :=  data_line[succ(colon_pos) .. ];
          repeat
            data_symbol := get_symbol(data_line);
          until data_symbol = "" or data_symbol = "DATA" or
              data_symbol = "'" or data_symbol = "REM";
          if data_symbol <> "DATA" then
            data_line := "";
          end if;
        else
          data_field := data_line[ .. pred(comma_pos)];
          data_line :=  data_line[succ(comma_pos) .. ];
          if data_line = "" then
            (* A comma at the end of a DATA line is READ as an    *)
            (* empty string with the next call of get_data_field. *)
            data_line := " ";
          end if;
        end if;
      else
        if comma_pos <> 0 then
          data_field := data_line[ .. pred(comma_pos)];
          data_line :=  data_line[succ(comma_pos) .. ];
          if data_line = "" then
            (* A comma at the end of a DATA line is READ as an    *)
            (* empty string with the next call of get_data_field. *)
            data_line := " ";
          end if;
        else
          data_field := data_line;
          data_line := "";
        end if;
      end if;
    end if;
  end func;


const proc: skip_space_cr_lf (inout file: inFile) is func
  local
    var char: ch is ' ';
  begin
    ch := inFile.bufferChar;
    while ch = ' ' or ch = '\r' or ch = '\n' do
      ch := getc(inFile);
    end while;
    inFile.bufferChar := ch;
  end func;


const func string: read_input_string (inout file: inFile) is func
  result
    var string: result is "";
  local
    var char: ch is ' ';
  begin
    ch := inFile.bufferChar;
    if ch = '"' then
      ch := getc(inFile);
      while ch <> '"' and ch <> '\r' and ch <> '\n' and ch <> EOF do
        result &:= str(ch);
        ch := getc(inFile);
      end while;
      ch := getc(inFile);
    else
      while ch <> ',' and ch <> '\r' and ch <> '\n' and ch <> EOF do
        result &:= str(ch);
        ch := getc(inFile);
      end while;
    end if;
    while ch = ' ' do
      ch := getc(inFile);
    end while;
    if ch = '\r' then
      ch := getc(inFile);
    end if;
    inFile.bufferChar := ch;
  end func;


const func string: read_input_number (inout file: inFile) is func
  result
    var string: result is "";
  local
    var char: ch is ' ';
  begin
    ch := inFile.bufferChar;
    if ch = '"' then
      ch := getc(inFile);
      while ch <> '"' and ch <> '\r' and ch <> '\n' and ch <> EOF do
        result &:= str(ch);
        ch := getc(inFile);
      end while;
      ch := getc(inFile);
    else
      while ch <> ',' and ch <> ' ' and ch <> '\r' and ch <> '\n' and ch <> EOF do
        result &:= str(ch);
        ch := getc(inFile);
      end while;
    end if;
    while ch = ' ' do
      ch := getc(inFile);
    end while;
    if ch = '\r' then
      ch := getc(inFile);
    end if;
    inFile.bufferChar := ch;
  end func;


const proc: assign_input_number (in string: variable_name, in string: param1) is func
  local
    var float: num1 is 0.0;
  begin
    block
      num1 := float parse param1;
      setNumericVar(variable_name, num1);
      line_marker;
      log << "INPUT ";
      log << variable_name;
      log << " <- ";
      log << num1;
      log << NL;
      flush(log);
    exception
      catch RANGE_ERROR:
        error_marker;
        err << "NUMBER EXPECTED FOR INPUT OF ";
        err << variable_name;
        err << " FOUND ";
        err << literal(param1);
        err << ".";
        err << NL;
    end block;
  end func;


const proc: assign_input_string (in string: variable_name, in string: param1) is func
  local
    var float: num1 is 0.0;
  begin
    setStringVar(variable_name, param1);
    line_marker;
    log << "INPUT ";
    log << variable_name;
    log << " <- ";
    log << literal(param1);
    log << NL;
    flush(log);
  end func;


const proc: set_function (in string: name, in string: params, in string: expression) is func
  local
    var defFnType: newDefFn is defFnType.value;
  begin
    if name not in def_fn_list then
      newDefFn.name := name;
      newDefFn.params := params;
      newDefFn.expression := expression;
      def_fn_list @:= [name] (newDefFn);
    end if;
  end func;


const proc: define_function (in var string: variable_name,
    inout string: symbol, inout string: line, in boolean: doLog) is func
  local
    var string: param1 is "";
    var string: param2 is "";
  begin
    symbol := get_symbol(line);
    if variable_name = "FN" and symbol[1] >= 'A' and symbol[1] <= 'Z' then
      variable_name &:= symbol;
      symbol := get_symbol(line);
    end if;
    param1 := "";
    if symbol = "(" then
      repeat
        symbol := get_symbol(line);
        if symbol[1] >= 'A' and symbol[1] <= 'Z' then
          param1 &:= symbol & " ";
        end if;
        symbol := get_symbol(line);
      until symbol <> ",";
      expect(")", symbol, line);
      if length(param1) >= 1 then
        param1 := param1[.. pred(length(param1))];
      end if;
    end if;
    if symbol = "=" then
      param2 := line;
      while symbol <> ":" and symbol <> "" do
        symbol := get_symbol(line);
      end while;
      if symbol = ":" then
        param2 := param2[ .. length(param2) - length(line) - 1];
      else
        param2 := param2[ .. length(param2) - length(line)];
      end if;
      set_function(variable_name, param1, param2);
      if doLog then
        line_marker;
        log << "DEF ";
        log << variable_name;
        log << "(";
        log << param1;
        log << ")";
        log << "=";
        log << param2;
        log << NL;
        flush(log);
      end if;
    else
      expect("=", symbol, line);
    end if;
  end func;


const func float: exec_expr (inout string: symbol, inout string: line) is forward;


const proc: append_index (inout string: name, inout string: symbol, inout string: line) is func
  local
    var float: num is 0.0;
  begin
    if symbol = "(" or symbol = "[" then
      symbol := get_symbol(line);
      num := exec_expr(symbol, line);
      name &:= "(" & str(round(num));
      while symbol = "," do
        symbol := get_symbol(line);
        num := exec_expr(symbol, line);
        name &:= "," & str(round(num));
      end while;
      if symbol <> ")" and symbol <> "]" then
        error_expect2(")", "]", symbol);
      else
        name &:= ")";
        symbol := get_symbol(line);
      end if;
    end if;
    if symbol = "." then
      symbol := get_symbol(line);
      name &:= "." & symbol;
      symbol := get_symbol(line);
    end if;
  end func;


const func string: get_name (inout string: symbol, inout string: line) is func
  result
    var string: name is "";
  begin
    name := symbol;
    symbol := get_symbol(line);
    append_index(name, symbol, line);
  end func;


const func string: exec_str_expr (
    inout string: symbol,
    inout string: line,
    inout string: variable_name) is forward;


const func string: exec_str_function (in defFnType: defFn, inout string: symbol, inout string: line) is func
  result
    var string: result is "";
  local
    var string: func_expr is "";
    var string: func_symbol is "";
    var string: formal_params is "";
    var string: formal_param is "";
    var string: unused_name is "";
    var array string: str_value_backup is 0 times "";
    var array float: num_value_backup is 0 times 0.0;
  begin
    log << "function ";
    log << defFn.name;
    formal_params := defFn.params;
    symbol := get_symbol(line);
    if symbol = "(" then
      log << "(";
      repeat
        symbol := get_symbol(line);
        formal_param := get_symbol(formal_params);
        if formal_param[length(formal_param)] = '$' then
          if formal_param in string_var then
            str_value_backup &:= [] (string_var[formal_param]);
          else
            str_value_backup &:= [] ("");
          end if;
          string_var @:= [formal_param] exec_str_expr(symbol, line, unused_name);
          log << string_var[formal_param];
        else
          if formal_param in numeric_var then
            num_value_backup &:= [] (numeric_var[formal_param]);
          else
            num_value_backup &:= [] (0.0);
          end if;
          numeric_var @:= [formal_param] exec_expr(symbol, line);
          log << numeric_var[formal_param];
        end if;
        log << symbol;
      until symbol <> ",";
      expect(")", symbol, line);
    end if;
    func_expr := defFn.expression;
    log << " = ";
    log << func_expr;
    log << NL;
    flush(log);
    func_symbol := get_symbol(func_expr);
    result := exec_str_expr(func_symbol, func_expr, unused_name);
    formal_params := defFn.params;
    formal_param := get_symbol(formal_params);
    while formal_param <> "" do
      if formal_param[length(formal_param)] = '$' then
        string_var @:= [formal_param] str_value_backup[1];
        str_value_backup := str_value_backup[2 ..];
      else
        numeric_var @:= [formal_param] num_value_backup[1];
        num_value_backup := num_value_backup[2 ..];
      end if;
      formal_param := get_symbol(formal_params);
    end while;
  end func;


const func string: extendedKeyCode (in char: current_key) is func
  result
    var string: result is "";
  begin
    case current_key of
      when {KEY_NL}:        result := "\r";
      when {KEY_ALT_A}:     result := "\0\\30\";
      when {KEY_ALT_B}:     result := "\0\\48\";
      when {KEY_ALT_C}:     result := "\0\\46\";
      when {KEY_ALT_D}:     result := "\0\\32\";
      when {KEY_ALT_E}:     result := "\0\\18\";
      when {KEY_ALT_F}:     result := "\0\\33\";
      when {KEY_ALT_G}:     result := "\0\\34\";
      when {KEY_ALT_H}:     result := "\0\\35\";
      when {KEY_ALT_I}:     result := "\0\\23\";
      when {KEY_ALT_J}:     result := "\0\\36\";
      when {KEY_ALT_K}:     result := "\0\\37\";
      when {KEY_ALT_L}:     result := "\0\\38\";
      when {KEY_ALT_M}:     result := "\0\\50\";
      when {KEY_ALT_N}:     result := "\0\\49\";
      when {KEY_ALT_O}:     result := "\0\\24\";
      when {KEY_ALT_P}:     result := "\0\\25\";
      when {KEY_ALT_Q}:     result := "\0\\16\";
      when {KEY_ALT_R}:     result := "\0\\19\";
      when {KEY_ALT_S}:     result := "\0\\31\";
      when {KEY_ALT_T}:     result := "\0\\20\";
      when {KEY_ALT_U}:     result := "\0\\22\";
      when {KEY_ALT_V}:     result := "\0\\47\";
      when {KEY_ALT_W}:     result := "\0\\17\";
      when {KEY_ALT_X}:     result := "\0\\45\";
      when {KEY_ALT_Y}:     result := "\0\\21\";
      when {KEY_ALT_Z}:     result := "\0\\44\";
      when {KEY_ALT_0}:     result := "\0\\120\";
      when {KEY_ALT_1}:     result := "\0\\121\";
      when {KEY_ALT_2}:     result := "\0\\122\";
      when {KEY_ALT_3}:     result := "\0\\123\";
      when {KEY_ALT_4}:     result := "\0\\124\";
      when {KEY_ALT_5}:     result := "\0\\125\";
      when {KEY_ALT_6}:     result := "\0\\126\";
      when {KEY_ALT_7}:     result := "\0\\127\";
      when {KEY_ALT_8}:     result := "\0\\128\";
      when {KEY_ALT_9}:     result := "\0\\129\";
      when {KEY_F1}:        result := "\0\;";
      when {KEY_F2}:        result := "\0\<";
      when {KEY_F3}:        result := "\0\=";
      when {KEY_F4}:        result := "\0\>";
      when {KEY_F5}:        result := "\0\?";
      when {KEY_F6}:        result := "\0\@";
      when {KEY_F7}:        result := "\0\A";
      when {KEY_F8}:        result := "\0\B";
      when {KEY_F9}:        result := "\0\C";
      when {KEY_F10}:       result := "\0\D";
      when {KEY_SFT_F1}:    result := "\0\T";
      when {KEY_SFT_F2}:    result := "\0\U";
      when {KEY_SFT_F3}:    result := "\0\V";
      when {KEY_SFT_F4}:    result := "\0\W";
      when {KEY_SFT_F5}:    result := "\0\X";
      when {KEY_SFT_F6}:    result := "\0\Y";
      when {KEY_SFT_F7}:    result := "\0\Z";
      when {KEY_SFT_F8}:    result := "\0\[";
      when {KEY_SFT_F9}:    result := "\0\\\";
      when {KEY_SFT_F10}:   result := "\0\]";
      when {KEY_CTL_F1}:    result := "\0\^";
      when {KEY_CTL_F2}:    result := "\0\_";
      when {KEY_CTL_F3}:    result := "\0\`";
      when {KEY_CTL_F4}:    result := "\0\a";
      when {KEY_CTL_F5}:    result := "\0\b";
      when {KEY_CTL_F6}:    result := "\0\c";
      when {KEY_CTL_F7}:    result := "\0\d";
      when {KEY_CTL_F8}:    result := "\0\e";
      when {KEY_CTL_F9}:    result := "\0\f";
      when {KEY_CTL_F10}:   result := "\0\g";
      when {KEY_ALT_F1}:    result := "\0\h";
      when {KEY_ALT_F2}:    result := "\0\i";
      when {KEY_ALT_F3}:    result := "\0\j";
      when {KEY_ALT_F4}:    result := "\0\k";
      when {KEY_ALT_F5}:    result := "\0\l";
      when {KEY_ALT_F6}:    result := "\0\m";
      when {KEY_ALT_F7}:    result := "\0\n";
      when {KEY_ALT_F8}:    result := "\0\o";
      when {KEY_ALT_F9}:    result := "\0\p";
      when {KEY_ALT_F10}:   result := "\0\q";
      when {KEY_BACKTAB}:   result := "\0\\15\";
      when {KEY_LEFT}:      result := "\0\K";
      when {KEY_RIGHT}:     result := "\0\M";
      when {KEY_UP}:        result := "\0\H";
      when {KEY_DOWN}:      result := "\0\P";
      when {KEY_HOME}:      result := "\0\G";
      when {KEY_END}:       result := "\0\O";
      when {KEY_PGUP}:      result := "\0\I";
      when {KEY_PGDN}:      result := "\0\Q";
      when {KEY_INS}:       result := "\0\R";
      when {KEY_DEL}:       result := "\0\S";
      when {KEY_CTL_LEFT}:  result := "\0\\115\";
      when {KEY_CTL_RIGHT}: result := "\0\\116\";
      when {KEY_CTL_HOME}:  result := "\0\\119\";
      when {KEY_CTL_END}:   result := "\0\\117\";
      when {KEY_CTL_PGUP}:  result := "\0\\132\";
      when {KEY_CTL_PGDN}:  result := "\0\\118\";
      otherwise:            result := str(current_key);
    end case;
  end func;


const func integer: keyboardScanCode (in char: current_key) is func
  result
    var integer: result is 0;
  begin
    case current_key of


      when {KEY_ESC}:                                        result := 16#01;
      when {'!' (* At keypad: '1' *) }:                      result := 16#02;
      when {'@' (* At keypad: '2' *) }:                      result := 16#03;
      when {'#' (* At keypad: '3' *) }:                      result := 16#04;
      when {'$' (* At keypad: '4' *) }:                      result := 16#05;
      when {'%' (* At keypad: '5' *) }:                      result := 16#06;
      when {'^' (* At keypad: '6' *) }:                      result := 16#07;
      when {'&' (* At keypad: '7' *) }:                      result := 16#08;
      when {'*' (* At keypad: '8' *) }:                      result := 16#09;
      when {'(' (* At keypad: '9' *) }:                      result := 16#0A;
      when {')' (* At keypad: '0' *) }:                      result := 16#0B;
      when {'_', '-'}:                                       result := 16#0C;
      when {'+', '='}:                                       result := 16#0D;
      when {KEY_BS}:                                         result := 16#0E;
      when {KEY_TAB}:                                        result := 16#0F;
      when {'Q', 'q', KEY_ALT_Q, KEY_CTL_Q}:                 result := 16#10;
      when {'W', 'w', KEY_ALT_W, KEY_CTL_W}:                 result := 16#11;
      when {'E', 'e', KEY_ALT_E, KEY_CTL_E}:                 result := 16#12;
      when {'R', 'r', KEY_ALT_R, KEY_CTL_R}:                 result := 16#13;
      when {'T', 't', KEY_ALT_T, KEY_CTL_T}:                 result := 16#14;
      when {'Y', 'y', KEY_ALT_Y, KEY_CTL_Y}:                 result := 16#15;
      when {'U', 'u', KEY_ALT_U, KEY_CTL_U}:                 result := 16#16;
      when {'I', 'i', KEY_ALT_I  (* KEY_TAB=KEY_CTL_I *) }:  result := 16#17;
      when {'O', 'o', KEY_ALT_O, KEY_CTL_O}:                 result := 16#18;
      when {'P', 'p', KEY_ALT_P, KEY_CTL_P}:                 result := 16#19;
      when {'{', '['}:                                       result := 16#1A;
      when {'}', ']'}:                                       result := 16#1B;
      when {KEY_NL}:                                         result := 16#1C;
      #     Not mapped: CTRL                                 result := 16#1D;
      when {'A', 'a', KEY_ALT_A, KEY_CTL_A}:                 result := 16#1E;
      when {'S', 's', KEY_ALT_S, KEY_CTL_S}:                 result := 16#1F;
      when {'D', 'd', KEY_ALT_D, KEY_CTL_D}:                 result := 16#20;
      when {'F', 'f', KEY_ALT_F, KEY_CTL_F}:                 result := 16#21;
      when {'G', 'g', KEY_ALT_G, KEY_CTL_G}:                 result := 16#22;
      when {'H', 'h', KEY_ALT_H  (* KEY_BS=KEY_CTL_H *) }:   result := 16#23;
      when {'J', 'j', KEY_ALT_J  (* KEY_NL=KEY_CTL_J *) }:   result := 16#24;
      when {'K', 'k', KEY_ALT_K, KEY_CTL_K}:                 result := 16#25;
      when {'L', 'l', KEY_ALT_L, KEY_CTL_L}:                 result := 16#26;
      when {':', ';'}:                                       result := 16#27;
      when {'"', '\''}:                                      result := 16#28;
      when {'~', '`'}:                                       result := 16#29;
      #     Not mapped: LEFT SHIFT                           result := 16#2A;
      when {'|', '\\'}:                                      result := 16#2B;
      when {'Z', 'z', KEY_ALT_Z, KEY_CTL_Z}:                 result := 16#2C;
      when {'X', 'x', KEY_ALT_X, KEY_CTL_X}:                 result := 16#2D;
      when {'C', 'c', KEY_ALT_C, KEY_CTL_C}:                 result := 16#2E;
      when {'V', 'v', KEY_ALT_V, KEY_CTL_V}:                 result := 16#2F;
      when {'B', 'b', KEY_ALT_B, KEY_CTL_B}:                 result := 16#30;
      when {'N', 'n', KEY_ALT_N, KEY_CTL_N}:                 result := 16#31;
      when {'M', 'm', KEY_ALT_M, KEY_CTL_M}:                 result := 16#32;
      when {'<', ','}:                                       result := 16#33;
      when {'>', '.'}:                                       result := 16#34;
      when {'?', '/'}:                                       result := 16#35;
      #     Not mapped: RIGHT SHIFT                          result := 16#36;
      #     Not mapped: PRTSC or *                           result := 16#37;
      #     Not mapped: ALT                                  result := 16#38;
      when {' '}:                                            result := 16#39;
      #     Not mapped: CAPSLOCK                             result := 16#3A;
      when {KEY_F1,  KEY_SFT_F1,  KEY_CTL_F1,  KEY_ALT_F1}:  result := 16#3B;
      when {KEY_F2,  KEY_SFT_F2,  KEY_CTL_F2,  KEY_ALT_F2}:  result := 16#3C;
      when {KEY_F3,  KEY_SFT_F3,  KEY_CTL_F3,  KEY_ALT_F3}:  result := 16#3D;
      when {KEY_F4,  KEY_SFT_F4,  KEY_CTL_F4,  KEY_ALT_F4}:  result := 16#3E;
      when {KEY_F5,  KEY_SFT_F5,  KEY_CTL_F5,  KEY_ALT_F5}:  result := 16#3F;
      when {KEY_F6,  KEY_SFT_F6,  KEY_CTL_F6,  KEY_ALT_F6}:  result := 16#40;
      when {KEY_F7,  KEY_SFT_F7,  KEY_CTL_F7,  KEY_ALT_F7}:  result := 16#41;
      when {KEY_F8,  KEY_SFT_F8,  KEY_CTL_F8,  KEY_ALT_F8}:  result := 16#42;
      when {KEY_F9,  KEY_SFT_F9,  KEY_CTL_F9,  KEY_ALT_F9}:  result := 16#43;
      when {KEY_F10, KEY_SFT_F10, KEY_CTL_F10, KEY_ALT_F10}: result := 16#44;
      #     Not mapped: NUMLOCK                              result := 16#45;
      #     Not mapped: SCROLL LOCK                          result := 16#46;
      when {KEY_HOME,       KEY_CTL_HOME,  '7'}:             result := 16#47;
      when {KEY_UP,         KEY_CTL_UP,    '8'}:             result := 16#48;
      when {KEY_PGUP,       KEY_CTL_PGUP,  '9'}:             result := 16#49;
      #     Already mapped: '-'                              result := 16#4A;
      when {KEY_LEFT,       KEY_CTL_LEFT,  '4'}:             result := 16#4B;
      when {KEY_PAD_CENTER,                '5'}:             result := 16#4C;
      when {KEY_RIGHT,      KEY_CTL_RIGHT, '6'}:             result := 16#4D;
      #     Already mapped: '+'                              result := 16#4E;
      when {KEY_END,        KEY_CTL_END,   '1'}:             result := 16#4F;
      when {KEY_DOWN,       KEY_CTL_DOWN,  '2'}:             result := 16#50;
      when {KEY_PGDN,       KEY_CTL_PGDN,  '3'}:             result := 16#51;
      when {KEY_INS,        KEY_CTL_INS,   '0'}:             result := 16#52;
      when {KEY_DEL,        KEY_CTL_DEL    (*  '.' *) }:     result := 16#53;
      otherwise:                                             result := 0;
    end case;
  end func;


const func string: exec_str_primary (
    inout string: symbol,
    inout string: line,
    inout string: variable_name) is func
  result
    var string: result is "";
  local
    var string: unused_name is "";
    var string: stri1 is "";
    var string: stri2 is "";
    var float: num1 is 0.0;
    var float: num2 is 0.0;
    var integer: index1 is 0;
    var integer: index2 is 0;
    var char: current_key is ' ';
    var string: func_name is "";
  begin
    variable_name := "";
    if symbol[1] = '"' then
      result := symbol[2 .. ];
      symbol := get_symbol(line);
    elsif symbol = "LEFT$" then
      symbol := get_symbol(line);
      expect("(", symbol, line);
      stri1 := exec_str_expr(symbol, line, unused_name);
      expect(",", symbol, line);
      num1 := exec_expr(symbol, line);
      expect(")", symbol, line);
      result := stri1[ .. round(num1)];
      log << "LEFT$(";
      log << literal(stri1);
      log << ", ";
      log << num1;
      log << ")";
      log << NL;
      flush(log);
    elsif symbol = "RIGHT$" then
      symbol := get_symbol(line);
      expect("(", symbol, line);
      stri1 := exec_str_expr(symbol, line, unused_name);
      expect(",", symbol, line);
      num1 := exec_expr(symbol, line);
      expect(")", symbol, line);
      result := stri1[length(stri1) - round(num1) + 1 .. ];
      log << "RIGHT$(";
      log << literal(stri1);
      log << ", ";
      log << num1;
      log << ")";
      log << NL;
      flush(log);
    elsif symbol = "MID$" then
      symbol := get_symbol(line);
      expect("(", symbol, line);
      stri1 := exec_str_expr(symbol, line, unused_name);
      expect(",", symbol, line);
      num1 := exec_expr(symbol, line);
      log << "MID$(";
      log << literal(stri1);
      log << ", ";
      log << num1;
      if symbol = "," then
        symbol := get_symbol(line);
        num2 := exec_expr(symbol, line);
        result := stri1[round(num1) .. round(num1) + round(num2) - 1];
        log << ", ";
        log << num2;
      else
        result := stri1[round(num1) .. ];
      end if;
      expect(")", symbol, line);
      log << ")";
      log << NL;
      flush(log);
    elsif symbol = "STRING$" then
      symbol := get_symbol(line);
      expect("(", symbol, line);
      num1 := exec_expr(symbol, line);
      expect(",", symbol, line);
      if isStringExpr(symbol) then
        stri1 := exec_str_expr(symbol, line, unused_name);
        result := stri1 mult round(num1);
        log << "STRING$(";
        log << num1;
        log << ", ";
        log << literal(stri1);
        log << ")";
        log << NL;
        flush(log);
      else
        num2 := exec_expr(symbol, line);
        result := str(chr(round(num2))) mult round(num1);
        log << "STRING$(";
        log << num1;
        log << ", ";
        log << num2;
        log << ")";
        log << NL;
        flush(log);
      end if;
      expect(")", symbol, line);
    elsif symbol = "SPACE$" then
      symbol := get_symbol(line);
      expect("(", symbol, line);
      num1 := exec_expr(symbol, line);
      expect(")", symbol, line);
      result := " " mult round(num1);
      log << "SPACE$(";
      log << num1;
      log << ")";
      log << NL;
      flush(log);
    elsif symbol = "CHR$" then
      symbol := get_symbol(line);
      expect("(", symbol, line);
      num1 := exec_expr(symbol, line);
      expect(")", symbol, line);
      result := str(chr(round(num1)));
      log << "CHR$(";
      log << num1;
      log << ")";
      log << NL;
      flush(log);
    elsif symbol = "STR$" then
      symbol := get_symbol(line);
      expect("(", symbol, line);
      num1 := exec_expr(symbol, line);
      expect(")", symbol, line);
      result := str(round(num1));
      if result[1] <> '-' then
        result := " " & result;
      end if;
      if result[length(result) - 1 .. ] = ".0" then
        result := result[ .. length(result) - 2];
      end if;
      log << "STR$(";
      log << num1;
      log << ")";
      log << NL;
      flush(log);
    elsif symbol = "LCASE$" then
      symbol := get_symbol(line);
      expect("(", symbol, line);
      stri1 := exec_str_expr(symbol, line, unused_name);
      expect(")", symbol, line);
      result := lower(stri1);
      log << "LCASE$(";
      log << literal(stri1);
      log << ")";
      log << NL;
      flush(log);
    elsif symbol = "UCASE$" then
      symbol := get_symbol(line);
      expect("(", symbol, line);
      stri1 := exec_str_expr(symbol, line, unused_name);
      expect(")", symbol, line);
      result := upper(stri1);
      log << "UCASE$(";
      log << literal(stri1);
      log << ")";
      log << NL;
      flush(log);
    elsif symbol = "LTRIM$" then
      symbol := get_symbol(line);
      expect("(", symbol, line);
      stri1 := exec_str_expr(symbol, line, unused_name);
      expect(")", symbol, line);
      index1 := 1;
      while index1 <= length(stri1) and stri1[index1] = ' ' do
        incr(index1);
      end while;
      result := stri1[index1 ..];
      log << "LTRIM$(";
      log << literal(stri1);
      log << ")";
      log << NL;
      flush(log);
    elsif symbol = "RTRIM$" then
      symbol := get_symbol(line);
      expect("(", symbol, line);
      stri1 := exec_str_expr(symbol, line, unused_name);
      expect(")", symbol, line);
      index1 := length(stri1);
      while index1 >= 1 and stri1[index1] = ' ' do
        decr(index1);
      end while;
      result := stri1[.. index1];
      log << "RTRIM$(";
      log << literal(stri1);
      log << ")";
      log << NL;
      flush(log);
    elsif symbol = "INKEY$" then
      symbol := get_symbol(line);
      flush(win);
      if keypressed(KEYBOARD) then
        current_key := getc(KEYBOARD);
        result := extendedKeyCode(current_key);
      else
        result := "";
      end if;
      log << "INKEY$ -> ";
      log << literal(result);
      if result <> "" and current_key >= '\0\' and
          current_key <= chr(length(EVENT_DESCR)) then
        log << " (";
        log << EVENT_DESCR[ord(current_key)];
        log << ")";
      end if;
      log << NL;
      flush(log);
    elsif symbol = "INPUT$" then
      symbol := get_symbol(line);
      expect("(", symbol, line);
      index1 := round(exec_expr(symbol, line));
      if index1 >= 0 then
        if symbol = "," then
          symbol := get_symbol(line);
          if symbol = "#" then
            symbol := get_symbol(line);
          end if;
          index2 := round(exec_expr(symbol, line));
          expect(")", symbol, line);
          if file_value[index2] <> STD_NULL then
            log << "INPUT$(";
            log << index1;
            log << ", #";
            log << index2;
            log << ") -> ";
            log << literal(result);
            log << NL;
            flush(log);
            result := gets(file_value[index2], index1);
          else
            error_marker;
            err << "FILE #";
            err << index2;
            err << " NOT OPEN IN INPUT$.";
            err << NL;
          end if;
        else
          expect(")", symbol, line);
          flush(win);
          result := gets(KEYBOARD, index1);
          log << "INPUT$(";
          log << index1;
          log << ") -> ";
          log << literal(result);
          log << NL;
          flush(log);
        end if;
      else
        error_marker;
        err << "INPUT$ WITH NEGATIVE NUMBER ";
        err << index1;
        err << ".";
        err << NL;
        while symbol <> ")" do
          symbol := get_symbol(line);
        end while;
        symbol := get_symbol(line);
      end if;
    elsif symbol = "HEX$" then
      symbol := get_symbol(line);
      expect("(", symbol, line);
      num1 := exec_expr(symbol, line);
      expect(")", symbol, line);
      result := hex_str(round(num1));
      log << "HEX$(";
      log << num1;
      log << ")";
      log << NL;
      flush(log);
    elsif symbol = "OCT$" then
      symbol := get_symbol(line);
      expect("(", symbol, line);
      num1 := exec_expr(symbol, line);
      expect(")", symbol, line);
      result := oct_str(round(num1));
      log << "OCT$(";
      log << num1;
      log << ")";
      log << NL;
      flush(log);
    elsif symbol = "TIME$" then
      symbol := get_symbol(line);
      result := str_time(time(NOW));
      log << "TIME$ -> ";
      log << literal(result);
      log << NL;
      flush(log);
    elsif symbol = "DATE$" then
      symbol := get_symbol(line);
      result := str_mm_dd_yyyy(time(NOW), "-");
      log << "DATE$ -> ";
      log << literal(result);
      log << NL;
      flush(log);
    elsif symbol[1] >= 'A' and symbol[1] <= 'Z' then
      if symbol not in def_fn_list then
        variable_name := get_name(symbol, line);
        result := getStringVar(variable_name);
        log << variable_name;
        log << " is ";
        log << literal(result);
        log << NL;
        flush(log);
      else
        func_name := symbol;
        result := exec_str_function(def_fn_list[func_name], symbol, line);
        log << "function ";
        log << func_name;
        log << " is ";
        log << literal(result);
        log << NL;
        flush(log);
      end if;
    end if;
  end func;


const func string: exec_str_expr (
    inout string: symbol,
    inout string: line,
    inout string: variable_name) is func
  result
    var string: result is "";
  local
    var string: unused_name is "";
    var string: op is "";
    var string: stri is "";
  begin
    result := exec_str_primary(symbol, line, variable_name);
    while symbol = "+" do
      variable_name := "";
      op := symbol;
      symbol := get_symbol(line);
      stri := exec_str_primary(symbol, line, unused_name);
      if op = "+" then
         result &:= stri;
      end if;
    end while;
  end func;


const func float: exec_function (in defFnType: defFn, inout string: symbol, inout string: line) is func
  result
    var float: result is 0.0;
  local
    var string: func_expr is "";
    var string: func_symbol is "";
    var string: formal_params is "";
    var string: formal_param is "";
    var string: unused_name is "";
    var array string: str_value_backup is 0 times "";
    var array float: num_value_backup is 0 times 0.0;
  begin
    log << "function ";
    log << defFn.name;
    formal_params := defFn.params;
    symbol := get_symbol(line);
    if symbol = "(" then
      log << "(";
      repeat
        symbol := get_symbol(line);
        formal_param := get_symbol(formal_params);
        if formal_param[length(formal_param)] = '$' then
          if formal_param in string_var then
            str_value_backup &:= [] (string_var[formal_param]);
          else
            str_value_backup &:= [] ("");
          end if;
          string_var @:= [formal_param] exec_str_expr(symbol, line, unused_name);
          log << string_var[formal_param];
        else
          if formal_param in numeric_var then
            num_value_backup &:= [] (numeric_var[formal_param]);
          else
            num_value_backup &:= [] (0.0);
          end if;
          numeric_var @:= [formal_param] exec_expr(symbol, line);
          log << numeric_var[formal_param];
        end if;
        log << symbol;
      until symbol <> ",";
      expect(")", symbol, line);
    end if;
    func_expr := defFn.expression;
    log << " = ";
    log << func_expr;
    log << NL;
    flush(log);
    func_symbol := get_symbol(func_expr);
    result := exec_expr(func_symbol, func_expr);
    formal_params := defFn.params;
    formal_param := get_symbol(formal_params);
    while formal_param <> "" do
      if formal_param[length(formal_param)] = '$' then
        string_var @:= [formal_param] str_value_backup[1];
        str_value_backup := str_value_backup[2 ..];
      else
        numeric_var @:= [formal_param] num_value_backup[1];
        num_value_backup := num_value_backup[2 ..];
      end if;
      formal_param := get_symbol(formal_params);
    end while;
  end func;


const func float: exec_primary (inout string: symbol, inout string: line) is func
  result
    var float: result is 0.0;
  local
    var string: variable_name is "";
    var string: unused_name is "";
    var string: stri1 is "";
    var string: stri2 is "";
    var float: num1 is 0.0;
    var integer: index1 is 0;
    var integer: index2 is 0;
    var char: current_key is ' ';
    var time: time_now is time.value;
    var duration: since_midnight is duration.value;
    var string: func_name is "";
  begin
    if symbol[1] in digit_char then
      if symbol[length(symbol)] in number_suffix then
        symbol := symbol[.. pred(length(symbol))];
      end if;
      block
        result := float parse symbol;
      exception
        catch RANGE_ERROR:
          error_marker;
          err << "ERROR IN PARSE NUMBER ";
          err << literal(symbol);
          err << ".";
          err << NL;
      end block;
      symbol := get_symbol(line);
    elsif symbol = "INT" then
      symbol := get_symbol(line);
      expect("(", symbol, line);
      num1 := exec_expr(symbol, line);
      expect(")", symbol, line);
      result := floor(num1);
      log << "INT(";
      log << num1;
      log << ")";
      log << NL;
      flush(log);
    elsif symbol = "ABS" then
      symbol := get_symbol(line);
      expect("(", symbol, line);
      num1 := exec_expr(symbol, line);
      expect(")", symbol, line);
      result := abs(num1);
      log << "ABS(";
      log << num1;
      log << ")";
      log << NL;
      flush(log);
    elsif symbol = "LEN" then
      symbol := get_symbol(line);
      expect("(", symbol, line);
      stri1 := exec_str_expr(symbol, line, unused_name);
      expect(")", symbol, line);
      result := flt(length(stri1));
      log << "LEN(";
      log << literal(stri1);
      log << ")";
      log << NL;
      flush(log);
    elsif symbol = "ASC" then
      symbol := get_symbol(line);
      expect("(", symbol, line);
      stri1 := exec_str_expr(symbol, line, unused_name);
      expect(")", symbol, line);
      log << "ASC(";
      log << literal(stri1);
      log << ")";
      log << NL;
      flush(log);
      if stri1 <> "" then
        result := flt(ord(stri1[1]));
      else
        error_marker;
        err << "ASC(\"\") IS ILLEGAL.";
        err << NL;
      end if;
    elsif symbol = "INSTR" then
      symbol := get_symbol(line);
      expect("(", symbol, line);
      if isStringExpr(symbol) then
        num1 := 1.0;
      else
        num1 := exec_expr(symbol, line);
        expect(",", symbol, line);
      end if;
      stri1 := exec_str_expr(symbol, line, unused_name);
      expect(",", symbol, line);
      stri2 := exec_str_expr(symbol, line, unused_name);
      expect(")", symbol, line);
      result := flt(pos(stri1[round(num1) .. ], stri2));
      log << "INSTR(";
      log << num1;
      log << ", ";
      log << literal(stri1);
      log << ", ";
      log << literal(stri2);
      log << ") -> ";
      log << result;
      log << NL;
      flush(log);
    elsif symbol = "RND" then
      symbol := get_symbol(line);
      if symbol = "(" then
        symbol := get_symbol(line);
        num1 := exec_expr(symbol, line);
        expect(")", symbol, line);
      end if;
      result := rand(0.0, 1.0);
      log << "RND -> ";
      log << result;
      log << NL;
      flush(log);
    elsif symbol = "SQR" then
      symbol := get_symbol(line);
      expect("(", symbol, line);
      num1 := exec_expr(symbol, line);
      expect(")", symbol, line);
      result := sqrt(num1);
      log << "SQR(";
      log << num1;
      log << ")";
      log << NL;
      flush(log);
    elsif symbol = "CINT" then
      symbol := get_symbol(line);
      expect("(", symbol, line);
      num1 := exec_expr(symbol, line);
      expect(")", symbol, line);
      result := flt(round(num1));
      log << "CINT(";
      log << num1;
      log << ")";
      log << NL;
      flush(log);
    elsif symbol = "FIX" then
      symbol := get_symbol(line);
      expect("(", symbol, line);
      num1 := exec_expr(symbol, line);
      expect(")", symbol, line);
      result := flt(trunc(num1));
      log << "FIX(";
      log << num1;
      log << ")";
      log << NL;
      flush(log);
    elsif symbol = "VAL" then
      symbol := get_symbol(line);
      expect("(", symbol, line);
      stri1 := exec_str_expr(symbol, line, unused_name);
      expect(")", symbol, line);
      block
        result := float parse stri1;
      exception
        catch RANGE_ERROR:
          result := 0.0;
      end block;
      log << "VAL(";
      log << literal(stri1);
      log << ")";
      log << NL;
      flush(log);
    elsif symbol = "SGN" then
      symbol := get_symbol(line);
      expect("(", symbol, line);
      num1 := exec_expr(symbol, line);
      expect(")", symbol, line);
      if num1 > 0.0 then
        result := 1.0;
      elsif num1 = 0.0 then
        result := 0.0;
      else
        result := -1.0;
      end if;
      log << "SGN(";
      log << num1;
      log << ")";
      log << NL;
      flush(log);
    elsif symbol = "SIN" then
      symbol := get_symbol(line);
      expect("(", symbol, line);
      num1 := exec_expr(symbol, line);
      expect(")", symbol, line);
      result := sin(num1);
      log << "SIN(";
      log << num1;
      log << ")";
      log << NL;
      flush(log);
    elsif symbol = "COS" then
      symbol := get_symbol(line);
      expect("(", symbol, line);
      num1 := exec_expr(symbol, line);
      expect(")", symbol, line);
      result := cos(num1);
      log << "COS(";
      log << num1;
      log << ")";
      log << NL;
      flush(log);
    elsif symbol = "TAN" then
      symbol := get_symbol(line);
      expect("(", symbol, line);
      num1 := exec_expr(symbol, line);
      expect(")", symbol, line);
      result := tan(num1);
      log << "TAN(";
      log << num1;
      log << ")";
      log << NL;
      flush(log);
    elsif symbol = "ATN" then
      symbol := get_symbol(line);
      expect("(", symbol, line);
      num1 := exec_expr(symbol, line);
      expect(")", symbol, line);
      result := atan(num1);
      log << "ATN(";
      log << num1;
      log << ")";
      log << NL;
      flush(log);
    elsif symbol = "EXP" then
      symbol := get_symbol(line);
      expect("(", symbol, line);
      num1 := exec_expr(symbol, line);
      expect(")", symbol, line);
      result := exp(num1);
      log << "EXP(";
      log << num1;
      log << ")";
      log << NL;
      flush(log);
    elsif symbol = "LOG" then
      symbol := get_symbol(line);
      expect("(", symbol, line);
      num1 := exec_expr(symbol, line);
      expect(")", symbol, line);
      result := log(num1);
      log << "LOG(";
      log << num1;
      log << ")";
      log << NL;
      flush(log);
    elsif symbol = "EOF" then
      symbol := get_symbol(line);
      expect("(", symbol, line);
      index1 := round(exec_expr(symbol, line));
      expect(")", symbol, line);
      if hasNext(file_value[index1]) then
        result := 0.0;
      else
        result := -1.0;
      end if;
      log << "EOF(";
      log << index1;
      log << ") -> ";
      log << result;
      log << NL;
      flush(log);
    elsif symbol = "LOF" then
      symbol := get_symbol(line);
      expect("(", symbol, line);
      index1 := round(exec_expr(symbol, line));
      expect(")", symbol, line);
      result := flt(length(file_value[index1]));
      log << "LOF(";
      log << index1;
      log << ")";
      log << NL;
      flush(log);
    elsif symbol = "POS" then
      symbol := get_symbol(line);
      expect("(", symbol, line);
      num1 := exec_expr(symbol, line);
      expect(")", symbol, line);
      result := flt(column(win));
      log << "POS -> ";
      log << result;
      log << NL;
      flush(log);
    elsif symbol = "CSRLIN" then
      symbol := get_symbol(line);
      result := flt(line(win));
      log << "CSRLIN -> ";
      log << result;
      log << NL;
      flush(log);
    elsif symbol = "TIMER" then
      symbol := get_symbol(line);
      time_now := time(NOW);
      since_midnight := time_now - truncToDay(time_now);
      result := flt(seconds(since_midnight)) +
        flt(since_midnight.mycro_second) / 1000000.0;
      log << "TIMER -> ";
      log << result;
      log << NL;
      flush(log);
    elsif symbol = "CDBL" then
      symbol := get_symbol(line);
      expect("(", symbol, line);
      result := exec_expr(symbol, line);
      expect(")", symbol, line);
      log << "CDBL(";
      log << result;
      log << ")";
      log << NL;
      flush(log);
    elsif symbol = "CSNG" then
      symbol := get_symbol(line);
      expect("(", symbol, line);
      result := exec_expr(symbol, line);
      expect(")", symbol, line);
      log << "CSNG(";
      log << result;
      log << ")";
      log << NL;
      flush(log);
    elsif symbol = "PEEK" then
      symbol := get_symbol(line);
      expect("(", symbol, line);
      index1 := round(exec_expr(symbol, line));
      expect(")", symbol, line);
      case index1 of
        when {16}:    # Is it a bw or color screen?
          result := 35.0;
        when {1040}:  # Is it a bw or color screen?
          result := 35.0;
        otherwise:
          result := 0.0;
      end case;
      log << "**PEEK(";
      log << index1;
      log << ") -> ";
      log << result;
      log << NL;
      flush(log);
    elsif symbol = "INP" then
      symbol := get_symbol(line);
      expect("(", symbol, line);
      index1 := round(exec_expr(symbol, line));
      expect(")", symbol, line);
      case index1 of
        when {16#60}:  # &H60/96    Get keyboard scan code
          current_key := busy_getc(KEYBOARD);
          if current_key = KEY_NONE then
            result := 128.0; # This is a key release code
          else
            result := flt(keyboardScanCode(current_key));
          end if;
        when {16#3DA}: # &H3DA/986  Indicate vertical retrace
          result := flt(rand(0, 1) * 8);
        otherwise:
          result := 0.0;
      end case;
      log << "**INP(";
      log << index1;
      log << ") -> ";
      log << result;
      log << NL;
      flush(log);
    elsif symbol = "SCREEN" then
      symbol := get_symbol(line);
      expect("(", symbol, line);
      index1 := round(exec_expr(symbol, line));
      expect(",", symbol, line);
      index2 := round(exec_expr(symbol, line));
      if symbol = "," then
        symbol := get_symbol(line);
        num1 := exec_expr(symbol, line);
      end if;
      expect(")", symbol, line);
      result := 32.0;
      log << "**SCREEN(";
      log << index1;
      log << ", ";
      log << index2;
      log << ")";
      log << NL;
      flush(log);
    elsif symbol = "POINT" then
      symbol := get_symbol(line);
      expect("(", symbol, line);
      index1 := round(exec_expr(symbol, line));
      if symbol = "," then
        symbol := get_symbol(line);
        index2 := round(exec_expr(symbol, line));
        expect(")", symbol, line);
        result := 0.0;
        log << "**POINT(";
        log << index1;
        log << ", ";
        log << index2;
        log << ")";
        log << NL;
        flush(log);
      else
        expect(")", symbol, line);
        result := 0.0;
        log << "**POINT(";
        log << index1;
        log << ")";
        log << NL;
        flush(log);
      end if;
    elsif symbol = "STRIG" then
      symbol := get_symbol(line);
      expect("(", symbol, line);
      index1 := round(exec_expr(symbol, line));
      expect(")", symbol, line);
      result := 0.0;
      current_key := busy_getc(KEYBOARD);
      case index1 of
        when {0, 1}:
          if current_key = KEY_MOUSE1 then
            current_key := getc(KEYBOARD);
            result := -1.0;
          end if;
        when {4, 5}:
          if current_key = KEY_MOUSE3 then
            current_key := getc(KEYBOARD);
            result := -1.0;
          end if;
      end case;
      log << "**STRIG(";
      log << index1;
      log << ") -> ";
      log << result;
      log << NL;
      flush(log);
    elsif symbol = "FREEFILE" then
      symbol := get_symbol(line);
      index1 := 1;
      while index1 <= 255 and file_value[index1] <> STD_NULL do
        incr(index1);
      end while;
      result := flt(index1);
      log << "FREEFILE -> ";
      log << result;
      log << NL;
      flush(log);
    elsif symbol = "ERR" then
      symbol := get_symbol(line);
      result := flt(error_code);
      log << "ERR -> ";
      log << result;
      log << NL;
      flush(log);
    elsif symbol = "(" then
      symbol := get_symbol(line);
      result := exec_expr(symbol, line);
      expect(")", symbol, line);
    elsif symbol[1] >= 'A' and symbol[1] <= 'Z' then
      if symbol not in def_fn_list then
        variable_name := get_name(symbol, line);
        result := getNumericVar(variable_name);
        log << variable_name;
        log << " is ";
        log << result;
        log << NL;
        flush(log);
      else
        func_name := symbol;
        result := exec_function(def_fn_list[func_name], symbol, line);
        log << "function ";
        log << func_name;
        log << " is ";
        log << result;
        log << NL;
        flush(log);
      end if;
    elsif symbol = "%" then
      variable_name := "";
      repeat
        variable_name &:= symbol;
        symbol := get_symbol(line);
        if symbol <> "" and symbol[1] in alphanum_char then
          variable_name &:= symbol;
          symbol := get_symbol(line);
        end if;
      until symbol <> "_";
      append_index(variable_name, symbol, line);
      result := getNumericVar(variable_name);
      log << variable_name;
      log << " is ";
      log << result;
      log << NL;
      flush(log);
    end if;
  end func;


const func float: exec_exponentation (inout string: symbol, inout string: line) is func
  result
    var float: result is 0.0;
  local
    var float: num is 0.0;
  begin
    result := exec_primary(symbol, line);
    if symbol = "^" then
      symbol := get_symbol(line);
      num := exec_primary(symbol, line);
      if flt(round(num)) = num then
        result := result ** round(num);
      else
        result := result ** num;
      end if;
    end if;
  end func;


const func float: exec_negation (inout string: symbol, inout string: line) is func
  result
    var float: result is 0.0;
  begin
    if symbol = "-" then
      symbol := get_symbol(line);
      result := -exec_exponentation(symbol, line);
    elsif symbol = "+" then
      symbol := get_symbol(line);
      result := exec_exponentation(symbol, line);
    else
      result := exec_exponentation(symbol, line);
    end if;
  end func;


const func float: exec_multdiv (inout string: symbol, inout string: line) is func
  result
    var float: result is 0.0;
  local
    var string: op is "";
    var float: num is 0.0;
  begin
    result := exec_negation(symbol, line);
    while symbol = "*" or symbol = "/" or symbol = "\\" or symbol = "MOD" do
      op := symbol;
      symbol := get_symbol(line);
      num := exec_negation(symbol, line);
      if op = "*" then
        result := result * num;
      else
        block
          if op = "/" then
            result := result / num;
          elsif op = "\\" then
            result := flt(round(result) div round(num));
          elsif op = "MOD" then
            result := flt(round(result) rem round(num));
          end if;
        exception
          catch NUMERIC_ERROR:
            error_marker;
            err << "DIVISION BY ZERO (";
            err << result;
            err << op;
            err << num;
            err << ")";
            err << NL;
            result := 0.0;
        end block;
      end if;
    end while;
  end func;


const func float: exec_addsub (inout string: symbol, inout string: line) is func
  result
    var float: result is 0.0;
  local
    var string: op is "";
    var float: num is 0.0;
  begin
    result := exec_multdiv(symbol, line);
    while symbol = "+" or symbol = "-" do
      op := symbol;
      symbol := get_symbol(line);
      num := exec_multdiv(symbol, line);
      if op = "+" then
         result := result + num;
      elsif op = "-" then
         result := result - num;
      end if;
    end while;
  end func;


const func float: exec_comparison (inout string: symbol, inout string: line) is func
  result
    var float: result is 0.0;
  local
    var string: unused_name is "";
    var string: op is "";
    var string: stri1 is "";
    var string: stri2 is "";
    var float: num is 0.0;
  begin
    if isStringExpr(symbol) and
        symbol <> "INT"    and symbol <> "ABS"    and symbol <> "LEN"    and
        symbol <> "ASC"    and symbol <> "INSTR"  and symbol <> "RND"    and
        symbol <> "SQR"    and symbol <> "CINT"   and symbol <> "FIX"    and
        symbol <> "VAL"    and symbol <> "SGN"    and symbol <> "SIN"    and
        symbol <> "COS"    and symbol <> "TAN"    and symbol <> "ATN"    and
        symbol <> "EXP"    and symbol <> "LOG"    and symbol <> "EOF"    and
        symbol <> "LOF"    and symbol <> "POS"    and symbol <> "CSRLIN" and
        symbol <> "TIMER"  and symbol <> "CDBL"   and symbol <> "CSNG"   and
        symbol <> "PEEK"   and symbol <> "INP"    and symbol <> "SCREEN" and
        symbol <> "POINT"  and symbol <> "ERR"    and symbol <> "STRIG"  and
        symbol <> "FREEFILE" then
      stri1 := exec_str_expr(symbol, line, unused_name);
      if symbol = "=" or symbol = "<>" or
          symbol = "<" or symbol = ">" or
          symbol = "<=" or symbol = ">=" then
        op := symbol;
        symbol := get_symbol(line);
        stri2 := exec_str_expr(symbol, line, unused_name);
        if op = "=" then
           result := flt(-ord(stri1 = stri2));
        elsif op = "<>" then
           result := flt(-ord(stri1 <> stri2));
        elsif op = "<" then
           result := flt(-ord(stri1 < stri2));
        elsif op = ">" then
           result := flt(-ord(stri1 > stri2));
        elsif op = "<=" then
           result := flt(-ord(stri1 <= stri2));
        elsif op = ">=" then
           result := flt(-ord(stri1 >= stri2));
        end if;
      end if;
    else
      result := exec_addsub(symbol, line);
      if symbol = "=" or symbol = "<>" or
          symbol = "<" or symbol = ">" or
          symbol = "<=" or symbol = ">=" then
        op := symbol;
        symbol := get_symbol(line);
        num := exec_addsub(symbol, line);
        if op = "=" then
           result := flt(-ord(result = num));
        elsif op = "<>" then
           result := flt(-ord(result <> num));
        elsif op = "<" then
           result := flt(-ord(result < num));
        elsif op = ">" then
           result := flt(-ord(result > num));
        elsif op = "<=" then
           result := flt(-ord(result <= num));
        elsif op = ">=" then
           result := flt(-ord(result >= num));
        end if;
      end if;
    end if;
  end func;


const func float: exec_cond_not (inout string: symbol, inout string: line) is func
  result
    var float: result is 0.0;
  local
    var float: num is 0.0;
  begin
    if symbol = "NOT" then
      symbol := get_symbol(line);
      num := exec_comparison(symbol, line);
      result := flt(-ord(num = 0.0));
    else
      result := exec_comparison(symbol, line);
    end if;
  end func;


const func integer: binary_and (in var integer: number1, in var integer: number2) is func
  result
    var integer: result is 0;
  local
    var integer: count is 0;
  begin
    for count range 0 to 15 do
      if odd(number1) and odd(number2) then
        result +:= 2 ** count;
      end if;
      number1 := number1 div 2;
      number2 := number2 div 2;
    end for;
  end func;


const func float: exec_cond_and (inout string: symbol, inout string: line) is func
  result
    var float: result is 0.0;
  local
    var integer: number1 is 0;
    var integer: number2 is 0;
  begin
    result := exec_cond_not(symbol, line);
    while symbol = "AND" do
      number1 := round(result);
      symbol := get_symbol(line);
      number2 := round(exec_cond_not(symbol, line));
      result := flt(binary_and(number1, number2));
    end while;
  end func;


const func integer: binary_or (in var integer: number1, in var integer: number2) is func
  result
    var integer: result is 0;
  local
    var integer: count is 0;
  begin
    for count range 0 to 15 do
      if odd(number1) or odd(number2) then
        result +:= 2 ** count;
      end if;
      number1 := number1 div 2;
      number2 := number2 div 2;
    end for;
  end func;


const func integer: binary_xor (in var integer: number1, in var integer: number2) is func
  result
    var integer: result is 0;
  local
    var integer: count is 0;
  begin
    for count range 0 to 15 do
      if odd(number1) <> odd(number2) then
        result +:= 2 ** count;
      end if;
      number1 := number1 div 2;
      number2 := number2 div 2;
    end for;
  end func;


const func float: exec_cond_or (inout string: symbol, inout string: line) is func
  result
    var float: result is 0.0;
  local
    var string: op is "";
    var float: num is 0.0;
    var integer: number1 is 0;
    var integer: number2 is 0;
  begin
    result := exec_cond_and(symbol, line);
    while symbol = "OR" or symbol = "XOR" do
      number1 := round(result);
      op := symbol;
      symbol := get_symbol(line);
      number2 := round(exec_cond_and(symbol, line));
      if op = "OR" then
        result := flt(binary_or(number1, number2));
      elsif op = "XOR" then
        result := flt(binary_xor(number1, number2));
      end if;
    end while;
  end func;


const func float: exec_expr (inout string: symbol, inout string: line) is func
  result
    var float: result is 0.0;
  local
    var float: num is 0.0;
  begin
    if symbol <> "" then
      result := exec_cond_or(symbol, line);
    else
      error_marker;
      err << "EXPRESSION EXPECTED - FOUND END OF LINE.";
      err << NL;
    end if;
  end func;


(**
 *  Get the next BASIC symbol from the program.
 *  When the end of the line is reached the search for a symbol is
 *  continued in the next line.
 *  @return the BASIC symbol or "" at the end of the program.
 *)
const func string: next_symbol (inout string: line) is func
  result
    var string: symbol is "";
  begin
    repeat
      symbol := get_symbol(line);
      if symbol = "" then
        incr(file_line_number);
        if file_line_number <= length(prg) then
          statement_label := prg[file_line_number].linenum;
          line := prg[file_line_number].line;
          symbol := get_symbol(line);
        end if;
      end if;
    until symbol <> "" or file_line_number > length(prg);
  end func;


(**
 *  Search for an ELSE in the current line.
 *  @return "THEN" when a THEN was found, "" otherwise.
 *)
const func string: find_then (inout string: line) is func
  result
    var string: symbol is "";
  begin
    symbol := get_symbol(line);
    while symbol <> "THEN" and symbol <> "" do
      if symbol = "'" or symbol = "REM" then
        line := "";
      end if;
      symbol := get_symbol(line);
    end while;
  end func;


(**
 *  Search for an ELSE in the current line.
 *  When an IF is found a recursive call searches for a possible
 *  inner ELSE which would belong to the inner IF. Such an inner ELSE
 *  is skipped.
 *  @param line contains the current line. After the call it contains
 *         the rest of the line after the ELSE or "" when no ELSE was
 *         found.
 *  @return "ELSE" when a corresponding ELSE was found, "" otherwise.
 *)
const func string: find_else (inout string: line) is func
  result
    var string: symbol is "";
  begin
    symbol := get_symbol(line);
    while symbol <> "ELSE" and symbol <> "" do
      if symbol = "IF" then
        symbol := find_else(line);
      elsif symbol = "'" or symbol = "REM" then
        line := "";
      end if;
      symbol := get_symbol(line);
    end while;
  end func;


const func string: find_next (inout string: line) is func
  result
    var string: symbol is "";
  begin
    symbol := next_symbol(line);
    while symbol <> "NEXT" and symbol <> "" do
      if symbol = "FOR" then
        symbol := find_next(line);
      elsif symbol = "EXIT" then
        symbol := get_symbol(line);
      elsif symbol = "'" or symbol = "REM" then
        line := "";
      end if;
      symbol := next_symbol(line);
    end while;
  end func;


const func string: find_wend (inout string: line) is func
  result
    var string: symbol is "";
  begin
    symbol := next_symbol(line);
    while symbol <> "WEND" and symbol <> "" do
      if symbol = "WHILE" then
        symbol := find_wend(line);
      elsif symbol = "EXIT" then
        symbol := get_symbol(line);
      elsif symbol = "'" or symbol = "REM" then
        line := "";
      end if;
      symbol := next_symbol(line);
    end while;
  end func;


const func string: find_loop (inout string: line) is func
  result
    var string: symbol is "";
  begin
    symbol := next_symbol(line);
    while symbol <> "LOOP" and symbol <> "" do
      if symbol = "DO" then
        symbol := find_loop(line);
      elsif symbol = "EXIT" then
        symbol := get_symbol(line);
      elsif symbol = "'" or symbol = "REM" then
        line := "";
      end if;
      symbol := next_symbol(line);
    end while;
  end func;


const func string: find_end_sub (inout string: line) is func
  result
    var string: symbol is "";
  begin
    symbol := next_symbol(line);
    while symbol <> "END" and symbol <> "" do
      if symbol = "SUB" then
        symbol := find_end_sub(line);
      elsif symbol = "EXIT" then
        symbol := get_symbol(line);
      elsif symbol = "'" or symbol = "REM" then
        line := "";
      end if;
      symbol := next_symbol(line);
    end while;
    if symbol = "END" then
      repeat
        symbol := get_symbol(line);
      until symbol <> "END";
      if symbol = "'" or symbol = "REM" then
        line := "";
      end if;
      if symbol <> "SUB" then
        symbol := find_end_sub(line);
      end if;
    end if;
  end func;


const func string: find_end_select (inout string: line) is func
  result
    var string: symbol is "";
  begin
    symbol := next_symbol(line);
    while symbol <> "END" and symbol <> "" do
      if symbol = "SELECT" then
        symbol := find_end_select(line);
      elsif symbol = "EXIT" then
        symbol := get_symbol(line);
      elsif symbol = "'" or symbol = "REM" then
        line := "";
      end if;
      symbol := next_symbol(line);
    end while;
    if symbol = "END" then
      repeat
        symbol := get_symbol(line);
      until symbol <> "END";
      if symbol = "'" or symbol = "REM" then
        line := "";
      end if;
      if symbol <> "SELECT" then
        symbol := find_end_select(line);
      end if;
    end if;
  end func;


const func string: find_end_if (inout string: line) is func
  result
    var string: symbol is "";
  begin
    symbol := next_symbol(line);
    while symbol <> "END" and symbol <> "" do
      if symbol = "IF" then
        repeat
          symbol := find_then(line);
          if symbol = "THEN" then
            symbol := get_symbol(line);
            if symbol = ""  or symbol = "'" or symbol = "REM" then
              symbol := find_end_if(line);
              if symbol = "IF" then
                symbol := "";
              end if;
            else
              symbol := "";
              line := "";
            end if;
          end if;
        until symbol <> "IF";
      end if;
      if symbol = "'" or symbol = "REM" then
        line := "";
      end if;
      symbol := next_symbol(line);
    end while;
    if symbol = "END" then
      repeat
        symbol := get_symbol(line);
      until symbol <> "END";
      if symbol = "'" or symbol = "REM" then
        line := "";
      end if;
      if symbol <> "IF" then
        symbol := find_end_if(line);
      end if;
    end if;
  end func;


const func string: find_else_elseif_or_end_if (inout string: line) is func
  result
    var string: symbol is "";
  begin
    symbol := next_symbol(line);
    while symbol <> "ELSE" and symbol <> "ELSEIF" and
        symbol <> "END" and symbol <> "" do
      if symbol = "IF" then
        repeat
          symbol := find_then(line);
          if symbol = "THEN" then
            symbol := get_symbol(line);
            if symbol = ""  or symbol = "'" or symbol = "REM" then
              symbol := find_end_if(line);
              if symbol = "IF" then
                symbol := "";
              end if;
            else
              symbol := "";
              line := "";
            end if;
          end if;
        until symbol <> "IF";
      elsif symbol = "CASE" then
        symbol := get_symbol(line);
      end if;
      if symbol = "'" or symbol = "REM" then
        line := "";
      end if;
      symbol := next_symbol(line);
    end while;
    if symbol = "END" then
      repeat
        symbol := get_symbol(line);
      until symbol <> "END";
      if symbol = "'" or symbol = "REM" then
        line := "";
      end if;
      if symbol <> "IF" then
        symbol := find_else_elseif_or_end_if(line);
      end if;
    end if;
  end func;


const func string: find_case_or_end_select (inout string: line) is func
  result
    var string: symbol is "";
  begin
    symbol := next_symbol(line);
    while symbol <> "CASE" and symbol <> "END" and symbol <> "" do
      if symbol = "SELECT" then
        symbol := get_symbol(line);
        if symbol = "CASE" then
          symbol := find_end_select(line);
        end if;
      elsif symbol = "EXIT" then
        symbol := get_symbol(line);
      elsif symbol = "'" or symbol = "REM" then
        line := "";
      end if;
      symbol := next_symbol(line);
    end while;
    if symbol = "END" then
      repeat
        symbol := get_symbol(line);
      until symbol <> "END";
      if symbol = "'" or symbol = "REM" then
        line := "";
      end if;
      if symbol <> "SELECT" then
        symbol := find_case_or_end_select(line);
      end if;
    end if;
  end func;


const proc: exec_elseif_else_chain (inout string: symbol, inout string: line,
    inout boolean: process_next) is func
  local
    var float: num1 is 0.0;
    var boolean: leaveChain is TRUE;
  begin
    repeat
      symbol := find_else_elseif_or_end_if(line);
      if symbol = "ELSE" then
        if upper(prg[file_line_number].line[.. 4]) <> "ELSE" then
          error_marker;
          err << "ELSE NOT AT BEGINNING OF LINE";
          err << NL;
        end if;
        symbol := get_symbol(line);
        # Execute the following statements until "ELSE", "ELSEIF" or "END" "IF".
        line_marker;
        log << "ELSE - EXECUTE STATEMENT BLOCK";
        log << NL;
        flush(log);
        if symbol <> "" and symbol <> "'" and symbol <> "REM" then
          error_marker;
          err << "BLOCK STARTS DIRECTLY AFTER ELSE";
          err << NL;
          process_next := TRUE;
        end if;
        leaveChain := TRUE;
      elsif symbol = "ELSEIF" then
        symbol := get_symbol(line);
        num1 := exec_expr(symbol, line);
        if num1 <> 0.0 then
          expect("THEN", symbol, line);
          # Execute the following statements until "ELSE", "ELSEIF" or "END" "IF".
          line_marker;
          log << "ELSEIF ";
          log << num1;
          log << " THEN - EXECUTE STATEMENT BLOCK";
          log << NL;
          flush(log);
          if symbol <> "" and symbol <> "'" and symbol <> "REM" then
            error_marker;
            err << "BLOCK STARTS DIRECTLY AFTER THEN";
            err << NL;
            process_next := TRUE;
          end if;
          leaveChain := TRUE;
        else
          line_marker;
          log << "ELSEIF ";
          log << num1;
          log << " THEN - SKIP STATEMENT BLOCK";
          log << NL;
          flush(log);
          leaveChain := FALSE;
        end if;
      elsif symbol = "IF" then
        symbol := get_symbol(line);
        line_marker;
        log << "END IF - NO \"THEN\" BLOCK WAS EXECUTED";
        log << NL;
        flush(log);
        leaveChain := TRUE;
      end if;
    until leaveChain;
  end func;


const func boolean: label_or_linenum (in string: symbol) is
  return symbol in label or (symbol <> "" and symbol[1] in digit_char);


const proc: goto_label_or_linenum (in string: new_label) is func
  local
    var integer: number is 0;
    var integer: searched_linenum is 0;
    var integer: matched_linenum is MAX_LINENUM;
    var integer: linenum is 0;
  begin
    if new_label in label then
      statement_label := new_label;
      file_line_number := label[statement_label];
    elsif new_label <> "" and new_label[1] in digit_char then
      searched_linenum := integer parse new_label;
      for number range 1 to length(prg) do
        if prg[number].linenum <> "" then
          linenum := integer parse (prg[number].linenum);
          if linenum >= searched_linenum and
              linenum < matched_linenum then
            matched_linenum := linenum;
          end if;
        end if;
      end for;
      if matched_linenum <> MAX_LINENUM and
          str(matched_linenum) in label then
        error_marker;
        err << "LABEL ";
        err << new_label;
        err << " DOES NOT EXIST - USE ";
        err << matched_linenum;
        err << " INSTEAD";
        err << NL;
        statement_label := str(matched_linenum);
        file_line_number := label[statement_label];
      else
        error_marker;
        err << "LABEL ";
        err << new_label;
        err << " DOES NOT EXIST";
        err << NL;
      end if;
    else
      error_marker;
      err << "LABEL ";
      err << new_label;
      err << " DOES NOT EXIST";
      err << NL;
    end if;
    decr(file_line_number);
  end func;


const proc: advance_after_statement (inout string: line) is func
  local
    var integer: length is 0;
    var integer: column is 0;
    var string: symbol is "";
  begin
    repeat
      length := length(line);
      symbol := get_symbol(line);
    until endOfStatement(symbol);
    column := length(prg[file_line_number].line) - length + 1;
    line := prg[file_line_number].line[column ..];
  end func;


const proc: set_return_position (in string: line) is func
  local
    var integer: column is 0;
  begin
    column := length(prg[file_line_number].line) - length(line) + 1;
    gosubReturn := [] (gosubReturnDescrType.value) & gosubReturn;
    gosubReturn[1].returnLine := file_line_number;
    gosubReturn[1].returnColumn := column;
    gosubReturn[1].forLoopStackDepth := length(forLoop);
  end func;


const proc: set_sub_entry_position is func
  local
    var integer: column is 0;
  begin
    gosubReturn[1].subEntryLine := succ(file_line_number);
  end func;


const proc: check_for_loop_stack_before_return is func
  begin
    if length(forLoop) > gosubReturn[1].forLoopStackDepth then
      error_marker;
      err << "RETURN - SOME FOR LOOPS WERE NOT LEFT";
      err << NL;
      repeat
        line_marker;
        log << "LEAVE THE FOR ";
        log << forLoop[1].varName;
        log << " LOOP AT LINE ";
        line_marker(forLoop[1].bodyLine);
        log << NL;
        flush(log);
        forLoop := forLoop[2 .. ];
      until length(forLoop) <= gosubReturn[1].forLoopStackDepth;
    end if;
  end func;
      

const proc: do_return (inout string: symbol, inout string: line) is func
  begin
    file_line_number := gosubReturn[1].returnLine;
    statement_label := prg[file_line_number].linenum;
    line := prg[file_line_number].line[gosubReturn[1].returnColumn .. ];
    symbol := get_symbol(line);
    gosubReturn := gosubReturn[2 .. ];
  end func;


const proc: goto_on_error (in string: on_error_label, in string: line) is func
  begin
    resume_next_line := file_line_number;
    resume_next_column :=
        length(prg[file_line_number].line) - length(line) + 1;
    in_error_handler := TRUE;
    goto_label_or_linenum(on_error_label);
  end func;


const proc: do_resume_next (inout string: symbol, inout string: line) is func
  begin
    if resume_next_line <> 0 then
      file_line_number := resume_next_line;
      statement_label := prg[file_line_number].linenum;
      line := prg[file_line_number].line[resume_next_column .. ];
      symbol := get_symbol(line);
      in_error_handler := FALSE;
      resume_next_line := 0;
    else
      error_marker;
      err << "CANNOT RESUME NEXT";
      err << NL;
    end if;
  end func;


const proc: do_resume_same (inout string: symbol, inout string: line) is func
  begin
    if resume_same_line <> 0 then
      file_line_number := resume_same_line;
      statement_label := prg[file_line_number].linenum;
      line := prg[file_line_number].line[resume_same_column .. ];
      symbol := get_symbol(line);
      in_error_handler := FALSE;
      resume_same_line := 0;
    else
      error_marker;
      err << "CANNOT RESUME 0";
      err << NL;
    end if;
  end func;


const proc: exec_goto (inout string: symbol, inout string: line) is func
  local
    var integer: index1 is 0;
    var integer: index2 is 0;
  begin
    symbol := get_symbol(line);
    if label_or_linenum(symbol) then
      line_marker;
      log << "GOTO ";
      log << symbol;
      log << NL;
      flush(log);
      goto_label_or_linenum(symbol);
      symbol := "";
      line := "";
    else
      index1 := round(exec_expr(symbol, line));
      expect("OF", symbol, line);
      if index1 >= 1 then
        index2 := 1;
        while index2 < index1 do
          symbol := get_symbol(line);
          if symbol = "," then
            symbol := get_symbol(line);
            incr(index2);
          else
            index2 := succ(index1);
          end if;
        end while;
        if index2 = index1 then
          if label_or_linenum(symbol) then
            line_marker;
            log << "GOTO ";
            log << index1;
            log << " OF ";
            log << symbol;
            log << NL;
            flush(log);
            goto_label_or_linenum(symbol);
            symbol := "";
            line := "";
          else
            error_marker;
            err << "UNDEFINED LABEL ";
            err << symbol;
            err << " AFTER \"OF\".";
            err << NL;
          end if;
        else
          line_marker;
          log << "GOTO ";
          log << index1;
          log << " OF NEXT STATEMENT";
          log << NL;
          flush(log);
          while not endOfStatement(symbol) do
            symbol := get_symbol(line);
          end while;
        end if;
      else
        line_marker;
        log << "GOTO ";
        log << index1;
        log << " OF NEXT STATEMENT";
        log << NL;
        flush(log);
        while not endOfStatement(symbol) do
          symbol := get_symbol(line);
        end while;
      end if;
    end if;
  end func;


const proc: exec_gosub (inout string: symbol, inout string: line) is func
  local
    var integer: index1 is 0;
    var integer: index2 is 0;
  begin
    symbol := get_symbol(line);
    if label_or_linenum(symbol) then
      line_marker;
      log << "GOSUB ";
      log << symbol;
      log << NL;
      flush(log);
      set_return_position(line);
      goto_label_or_linenum(symbol);
      set_sub_entry_position;
      symbol := "";
      line := "";
    else
      index1 := round(exec_expr(symbol, line));
      expect("OF", symbol, line);
      if index1 >= 1 then
        index2 := 1;
        while index2 < index1 do
          symbol := get_symbol(line);
          if symbol = "," then
            symbol := get_symbol(line);
            incr(index2);
          else
            index2 := succ(index1);
          end if;
        end while;
        if index2 = index1 then
          if label_or_linenum(symbol) then
            line_marker;
            log << "GOSUB ";
            log << index1;
            log << " OF ";
            log << symbol;
            log << NL;
            flush(log);
            advance_after_statement(line);
            set_return_position(line);
            goto_label_or_linenum(symbol);
            set_sub_entry_position;
            symbol := "";
            line := "";
          else
            error_marker;
            err << "UNDEFINED LABEL ";
            err << symbol;
            err << " AFTER \"OF\".";
            err << NL;
          end if;
        else
          line_marker;
          log << "GOSUB ";
          log << index1;
          log << " OF NEXT STATEMENT";
          log << NL;
          flush(log);
          while not endOfStatement(symbol) do
            symbol := get_symbol(line);
          end while;
        end if;
      else
        line_marker;
        log << "GOSUB ";
        log << index1;
        log << " OF NEXT STATEMENT";
        log << NL;
        flush(log);
        while not endOfStatement(symbol) do
          symbol := get_symbol(line);
        end while;
      end if;
    end if;
  end func;


const proc: exec_let (in var string: variable_name,
    inout string: symbol, inout string: line) is func
  local
    var string: param1 is "";
    var float: num1 is 0.0;
    var string: unused_name is "";
  begin
    if isStringVar(variable_name) then
      append_index(variable_name, symbol, line);
      if symbol = "=" then
        symbol := get_symbol(line);
        param1 := exec_str_expr(symbol, line, unused_name);
        setStringVar(variable_name, param1);
        line_marker;
        log << "LET ";
        log << variable_name;
        log << "=";
        log << literal(param1);
        log << NL;
        flush(log);
      else
        error_marker;
        err << "\"=\" EXPECTED AFTER ";
        err << literal(variable_name);
        err << " - FOUND ";
        err << literal(symbol);
        err << ".";
        err << NL;
      end if;
    else
      append_index(variable_name, symbol, line);
      if symbol = "=" then
        symbol := get_symbol(line);
        num1 := exec_expr(symbol, line);
        setNumericVar(variable_name, num1);
        line_marker;
        log << "LET ";
        log << variable_name;
        log << "=";
        log << num1;
        log << NL;
        flush(log);
      else
        error_marker;
        err << "\"=\" EXPECTED AFTER ";
        err << literal(variable_name);
        err << " - FOUND ";
        err << literal(symbol);
        err << ".";
        err << NL;
      end if;
    end if;
  end func;


const proc: exec_mid_statement (inout string: symbol, inout string: line) is func
  local
    var string: variable_name is "";
    var string: unused_name is "";
    var string: var_value is "";
    var string: stri is "";
    var integer: position is 0;
    var integer: length is 0;
  begin
    symbol := get_symbol(line);
    expect("(", symbol, line);
    if isStringVar(symbol) then
      variable_name := get_name(symbol, line);
      expect(",", symbol, line);
      position := round(exec_expr(symbol, line));
      log << "MID$(";
      log << variable_name;
      log << ", ";
      log << position;
      if symbol = "," then
        symbol := get_symbol(line);
        length := round(exec_expr(symbol, line));
        log << ", ";
        log << length;
        expect(")", symbol, line);
        expect("=", symbol, line);
        stri := exec_str_expr(symbol, line, unused_name);
        if length > length(stri) then
          length := length(stri);
        end if;
      else
        expect(")", symbol, line);
        expect("=", symbol, line);
        stri := exec_str_expr(symbol, line, unused_name);
        length := length(stri);
      end if;
      var_value := getStringVar(variable_name);
      if position <= length(var_value) then
        if succ(length(var_value) - position) < length then
          length := succ(length(var_value) - position);
        end if;
        var_value := var_value[ .. pred(position)] & stri[ .. length] &
            var_value[position + length ..];
        setStringVar(variable_name, var_value);
        log << ")=";
        log << literal(stri);
      else
        error_marker;
        err << "MID$ POSITION ";
        err << position;
        err << " LARGER THAN LENGTH OF ";
        err << literal(var_value);
        err << NL;
      end if;
    else
      error_marker;
      err << "STRING VARIABLE EXPECTED - FOUND ";
      err << literal(symbol);
      err << NL;
    end if;
  end func;


const proc: exec_do (inout string: symbol, inout string: line) is func
  local
    var string: variable_name is "";
    var string: param1 is "";
    var float: num1 is 0.0;
    var integer: index1 is 0;
    var integer: index2 is 0;
  begin
    index1 := file_line_number;
    index2 := length(prg[file_line_number].line) - length(line) + 1;
    symbol := get_symbol(line);
    if symbol = "WHILE" then
      symbol := get_symbol(line);
      num1 := exec_expr(symbol, line);
      line_marker;
      log << "DO WHILE ";
      log << num1;
      log << NL;
      flush(log);
      if num1 <> 0.0 then
        doLoop := [] (doLoopDescrType.value) & doLoop;
        doLoop[1].headLine := index1;
        doLoop[1].headColumn := index2;
      else
        line_marker;
        log << "EMPTY \"DO WHILE\"";
        log << NL;
        if symbol <> "LOOP" then
          param1 := statement_label;
          symbol := find_loop(line);
        end if;
        if symbol = "LOOP" then
          repeat
            symbol := get_symbol(line);
          until endOfStatement(symbol);
          line_marker;
          log << "CONTINUE AFTER \"DO WHILE ... LOOP\"";
          log << NL;
          flush(log);
        else
          err << " ***** (";
          err << param1;
          err << ") NO CORRESPONDING \"LOOP\" FOUND FOR \"DO WHILE\"";
          err << NL;
        end if;
      end if;
    elsif symbol = "UNTIL" then
      symbol := get_symbol(line);
      num1 := exec_expr(symbol, line);
      line_marker;
      log << "DO UNTIL ";
      log << num1;
      log << NL;
      flush(log);
      if num1 = 0.0 then
        doLoop := [] (doLoopDescrType.value) & doLoop;
        doLoop[1].headLine := index1;
        doLoop[1].headColumn := index2;
      else
        line_marker;
        log << "EMPTY \"DO UNTIL\"";
        log << NL;
        if symbol <> "LOOP" then
          param1 := statement_label;
          symbol := find_loop(line);
        end if;
        if symbol = "LOOP" then
          repeat
            symbol := get_symbol(line);
          until endOfStatement(symbol);
          line_marker;
          log << "CONTINUE AFTER \"DO UNTIL ... LOOP\n";
          log << NL;
          flush(log);
        else
          err << " ***** (";
          err << param1;
          err << ") NO CORRESPONDING \"LOOP\" FOUND FOR \"DO UNTIL\"";
          err << NL;
        end if;
      end if;
    elsif symbol = "=" or symbol = "("  or symbol = "[" then
      exec_let("DO", symbol, line);
    else
      line_marker;
      log << "DO ... LOOP";
      log << NL;
      flush(log);
      doLoop := [] (doLoopDescrType.value) & doLoop;
      doLoop[1].headLine := index1;
      doLoop[1].headColumn := index2;
    end if;
  end func;


const proc: exec_loop (inout string: symbol, inout string: line) is func
  local
    var string: param1 is "";
    var string: param2 is "";
    var float: num1 is 0.0;
    var integer: index1 is 0;
  begin
    symbol := get_symbol(line);
    if symbol = "WHILE" then
      symbol := get_symbol(line);
      if length(doLoop) >= 1 then
        num1 := exec_expr(symbol, line);
        if num1 <> 0.0 then
          line_marker;
          file_line_number := doLoop[1].headLine;
          statement_label := prg[file_line_number].linenum;
          line := prg[file_line_number].line[doLoop[1].headColumn .. ];
          symbol := get_symbol(line);
          if symbol <> "WHILE" and symbol <> "UNTIL" then
            log << "LOOP - CONTINUE \"DO ... LOOP WHILE\"";
            log << NL;
            flush(log);
          else
            error_marker;
            err << "ILLEGAL - \"DO ";
            err << symbol;
            err << " ... LOOP WHILE\"";
            err << NL;
            repeat
              symbol := get_symbol(line);
            until endOfStatement(symbol);
          end if;
        else
          doLoop := doLoop[2 .. ];
          line_marker;
          log << "LOOP - LEAVE \"DO ... LOOP WHILE\"";
          log << NL;
          flush(log);
        end if;
      else
        error_marker;
        err << "UNEXPECTED \"LOOP WHILE\"";
        err << NL;
      end if;
    elsif symbol = "UNTIL" then
      symbol := get_symbol(line);
      if length(doLoop) >= 1 then
        num1 := exec_expr(symbol, line);
        if num1 = 0.0 then
          line_marker;
          file_line_number := doLoop[1].headLine;
          statement_label := prg[file_line_number].linenum;
          line := prg[file_line_number].line[doLoop[1].headColumn .. ];
          symbol := get_symbol(line);
          if symbol <> "WHILE" and symbol <> "UNTIL" then
            log << "LOOP - CONTINUE \"DO ... LOOP UNTIL\"";
            log << NL;
            flush(log);
          else
            error_marker;
            err << "ILLEGAL - \"DO ";
            err << symbol;
            err << " .. LOOP UNTIL\"";
            err << NL;
            repeat
              symbol := get_symbol(line);
            until endOfStatement(symbol);
          end if;
        else
          doLoop := doLoop[2 .. ];
          line_marker;
          log << "LOOP - LEAVE \"DO ... LOOP UNTIL\"";
          log << NL;
          flush(log);
        end if;
      else
        error_marker;
        err << "UNEXPECTED \"LOOP UNTIL\"";
        err << NL;
      end if;
    else
      if length(doLoop) >= 1 then
        index1 := doLoop[1].headLine;
        param2 := prg[index1].line[doLoop[1].headColumn .. ];
        param1 := get_symbol(param2);
        if param1 = "WHILE" then
          param1 := get_symbol(param2);
          num1 := exec_expr(param1, param2);
          if num1 <> 0.0 then
            line_marker;
            file_line_number := index1;
            statement_label := prg[file_line_number].linenum;
            symbol := param1;
            line := param2;
            log << "LOOP - CONTINUE \"DO WHILE ... LOOP\"";
            log << NL;
            flush(log);
          else
            doLoop := doLoop[2 .. ];
            line_marker;
            log << "LOOP - LEAVE \"DO WHILE ... LOOP\"";
            log << NL;
            flush(log);
          end if;
        elsif param1 = "UNTIL" then
          param1 := get_symbol(param2);
          num1 := exec_expr(param1, param2);
          if num1 = 0.0 then
            line_marker;
            file_line_number := index1;
            statement_label := prg[file_line_number].linenum;
            symbol := param1;
            line := param2;
            log << "LOOP - CONTINUE \"DO UNTIL ... LOOP\"";
            log << NL;
            flush(log);
          else
            doLoop := doLoop[2 .. ];
            line_marker;
            log << "LOOP - LEAVE \"DO UNTIL ... LOOP\"";
            log << NL;
            flush(log);
          end if;
        else
          line_marker;
          file_line_number := index1;
          statement_label := prg[file_line_number].linenum;
          symbol := param1;
          line := param2;
          log << "LOOP - CONTINUE \"DO ... LOOP\"";
          log << NL;
          flush(log);
        end if;
      else
        error_marker;
        err << "UNEXPECTED \"LOOP UNTIL\"";
        err << NL;
      end if;
    end if;
  end func;


const proc: exec_select (inout string: symbol, inout string: line) is func
  local
    var string: unused_name is "";
    var string: param1 is "";
    var string: param2 is "";
    var string: param3 is "";
    var float: num1 is 0.0;
    var float: num2 is 0.0;
    var float: num3 is 0.0;
    var boolean: found is FALSE;
    var boolean: end_select is FALSE;
    var boolean: end_case is FALSE;
    var string: comparison is "";
  begin
    symbol := get_symbol(line);
    if symbol = "CASE" then
      symbol := get_symbol(line);
      if isStringExpr(symbol) then
        param1 := exec_str_expr(symbol, line, unused_name);
        line_marker;
        log << "SELECT CASE ";
        log << literal(param1);
        log << NL;
        flush(log);
        repeat
          symbol := find_case_or_end_select(line);
          if symbol = "CASE" then
            symbol := get_symbol(line);
            if symbol = "ELSE" then
              symbol := get_symbol(line);
              found := TRUE;
              line_marker;
              log << "CASE ELSE - FOUND";
              log << NL;
              flush(log);
            else
              end_case := FALSE;
              repeat
                if symbol = "IS" then
                  symbol := get_symbol(line);
                end if;
                if symbol = "=" or symbol = "<>" or
                    symbol = "<" or symbol = ">" or
                    symbol = "<=" or symbol = ">=" then
                  comparison := symbol;
                  symbol := get_symbol(line);
                else
                  comparison := "=";
                end if;
                param2 := exec_str_expr(symbol, line, unused_name);
                if symbol = "TO" then
                  symbol := get_symbol(line);
                  param3 := exec_str_expr(symbol, line, unused_name);
                  line_marker;
                  log << "CASE ";
                  log << literal(param2);
                  log << " TO ";
                  log << literal(param3);
                  if param1 >= param2 and param1 <= param3 then
                    found := TRUE;
                    log << " - FOUND";
                  end if;
                  log << NL;
                  flush(log);
                else
                  if comparison = "=" then
                    found := param1 = param2;
                  elsif comparison = "<>" then
                    found := param1 <> param2;
                  elsif comparison = "<" then
                    found := param1 < param2;
                  elsif comparison = ">" then
                    found := param1 > param2;
                  elsif comparison = "<=" then
                    found := param1 <= param2;
                  elsif comparison = ">=" then
                    found := param1 >= param2;
                  end if;
                  line_marker;
                  log << "CASE IS ";
                  log << comparison;
                  log << " ";
                  log << literal(param2);
                  if found then
                    log << " - FOUND";
                  end if;
                  log << NL;
                  flush(log);
                end if;
                if symbol = "," then
                  symbol := get_symbol(line);
                else
                  end_case := TRUE;
                end if;
              until found or end_case;
            end if;
          else
            end_select := TRUE;
          end if;
        until found or end_select;
        if not found then
          line_marker;
          log << "END SELECT - NO CASE FOUND FOR ";
          log << literal(param1);
          log << NL;
          flush(log);
        end if;
      else
        num1 := exec_expr(symbol, line);
        line_marker;
        log << "SELECT CASE ";
        log << num1;
        log << NL;
        flush(log);
        repeat
          symbol := find_case_or_end_select(line);
          if symbol = "CASE" then
            symbol := get_symbol(line);
            if symbol = "ELSE" then
              symbol := get_symbol(line);
              found := TRUE;
              line_marker;
              log << "CASE ELSE - FOUND";
              log << NL;
              flush(log);
            else
              end_case := FALSE;
              repeat
                if symbol = "IS" then
                  symbol := get_symbol(line);
                end if;
                if symbol = "=" or symbol = "<>" or
                    symbol = "<" or symbol = ">" or
                    symbol = "<=" or symbol = ">=" then
                  comparison := symbol;
                  symbol := get_symbol(line);
                else
                  comparison := "=";
                end if;
                num2 := exec_expr(symbol, line);
                if symbol = "TO" then
                  symbol := get_symbol(line);
                  num3 := exec_expr(symbol, line);
                  line_marker;
                  log << "CASE ";
                  log << num2;
                  log << " TO ";
                  log << num3;
                  if num1 >= num2 and num1 <= num3 then
                    found := TRUE;
                    log << " - FOUND";
                  end if;
                  log << NL;
                  flush(log);
                else
                  if comparison = "=" then
                    found := num1 = num2;
                  elsif comparison = "<>" then
                    found := num1 <> num2;
                  elsif comparison = "<" then
                    found := num1 < num2;
                  elsif comparison = ">" then
                    found := num1 > num2;
                  elsif comparison = "<=" then
                    found := num1 <= num2;
                  elsif comparison = ">=" then
                    found := num1 >= num2;
                  end if;
                  line_marker;
                  log << "CASE IS ";
                  log << comparison;
                  log << " ";
                  log << num2;
                  if found then
                    log << " - FOUND";
                  end if;
                  log << NL;
                  flush(log);
                end if;
                if symbol = "," then
                  symbol := get_symbol(line);
                else
                  end_case := TRUE;
                end if;
              until found or end_case;
            end if;
          else
            end_select := TRUE;
          end if;
        until found or end_select;
        if not found then
          line_marker;
          log << "END SELECT - NO CASE FOUND FOR ";
          log << num1;
          log << NL;
          flush(log);
        end if;
      end if;
      while not endOfStatement(symbol) do
        symbol := get_symbol(line);
      end while;
    else
      error_marker;
      err << "\"CASE\" EXPECTED AFTER \"SELECT\"";
      err << NL;
    end if;
  end func;


const proc: exec_print (inout string: symbol, inout string: line) is func
  local
    var string: unused_name is "";
    var string: param1 is "";
    var float: num1 is 0.0;
  begin
    if endOfStatement(symbol) then
      win << NL;
      flush(win);
      log << NL;
      flush(log);
    else
      repeat
        if isStringExpr(symbol) then
          param1 := exec_str_expr(symbol, line, unused_name);
          win << param1;
          log << literal(param1);
        elsif symbol = "TAB" then
          symbol := get_symbol(line);
          expect("(", symbol, line);
          num1 := exec_expr(symbol, line);
          expect(")", symbol, line);
          if column(win) < round(num1) then
            win << "" rpad round(num1) - column(win);
          end if;
          log << "TAB(";
          log << round(num1);
          log << ")";
        elsif symbol = "SPC" then
          symbol := get_symbol(line);
          expect("(", symbol, line);
          num1 := exec_expr(symbol, line);
          expect(")", symbol, line);
          win << "" rpad round(num1);
          log << "SPC(";
          log << round(num1);
          log << ")";
        else
          win << " ";
          log << " ";
          num1 := exec_expr(symbol, line);
          param1 := str(num1);
          if param1[length(param1) - 1 .. ] = ".0" then
            param1 := param1[ .. length(param1) - 2];
          end if;
          win << param1;
          log << num1;
          if not endOfStatement(symbol) then
            win << " ";
            log << " ";
          end if;
        end if;
        if endOfStatement(symbol) then
          win << NL;
        elsif symbol = ";" then
          symbol := get_symbol(line);
          log << "; ";
        elsif symbol = "," then
          symbol := get_symbol(line);
          win << "  ";
          log << ", ";
        else
          (* This is the next thing to be printed *)
          log << " (;) ";
          log << symbol;
        end if;
      until endOfStatement(symbol);
    end if;
    flush(win);
    flush(log);
    log << NL;
  end func;


const proc: exec_print (inout file: outFile,
    inout string: symbol, inout string: line) is func
  local
    var string: unused_name is "";
    var string: param1 is "";
    var float: num1 is 0.0;
  begin
    if endOfStatement(symbol) then
      outFile << NL;
      flush(outFile);
      log << NL;
      flush(log);
    else
      repeat
        if isStringExpr(symbol) then
          param1 := exec_str_expr(symbol, line, unused_name);
          outFile << param1;
          log << literal(param1);
        elsif symbol = "TAB" then
          symbol := get_symbol(line);
          expect("(", symbol, line);
          num1 := exec_expr(symbol, line);
          expect(")", symbol, line);
          outFile << "  ";
          log << "TAB(";
          log << round(num1);
          log << ")";
        elsif symbol = "SPC" then
          symbol := get_symbol(line);
          expect("(", symbol, line);
          num1 := exec_expr(symbol, line);
          expect(")", symbol, line);
          outFile << "" rpad round(num1);
          log << "SPC(";
          log << round(num1);
          log << ")";
        else
          outFile << " ";
          log << " ";
          num1 := exec_expr(symbol, line);
          param1 := str(num1);
          if param1[length(param1) - 1 .. ] = ".0" then
            param1 := param1[ .. length(param1) - 2];
          end if;
          outFile << param1;
          log << num1;
          if not endOfStatement(symbol) then
            outFile << " ";
            log << " ";
          end if;
        end if;
        if endOfStatement(symbol) then
          outFile << NL;
        elsif symbol = ";" then
          symbol := get_symbol(line);
          log << "; ";
        elsif symbol = "," then
          symbol := get_symbol(line);
          outFile << "  ";
          log << ", ";
        else
          (* This is the next thing to be printed *)
          log << " (;) ";
          log << symbol;
        end if;
      until endOfStatement(symbol);
    end if;
    flush(outFile);
    flush(log);
    log << NL;
  end func;


const proc: exec_print_using (inout file: outFile,
    inout string: symbol, inout string: line) is func
  local
    var string: unused_name is "";
    var string: param1 is "";
    var string: param2 is "";
    var float: num1 is 0.0;
    var integer: index1 is 0;
    var integer: index2 is 0;
    var integer: index3 is 0;
    var integer: index4 is 0;
    var char: ch1 is ' ';
    var char: ch2 is ' ';
  begin
    log << "USING ";
    symbol := get_symbol(line);
    if isStringExpr(symbol) then
      param1 := exec_str_expr(symbol, line, unused_name);
      log << literal(param1);
      log << NL;
      expect(";", symbol, line);
      repeat
        index1 := 1;
        while index1 <= length(param1) do
          ch1 := param1[index1];
          case ch1 of
            when {'!', '\\', '&'}:
              if symbol = ";" or symbol = "," then
                symbol := get_symbol(line);
              end if;
              if isStringExpr(symbol) then
                param2 := exec_str_expr(symbol, line, unused_name);
                if ch1 = '!' then
                  outFile << param2[1 len 1] rpad 1;
                  log << literal(param2);
                elsif ch1 = '\\' then
                  index2 := index1;
                  repeat
                    incr(index1);
                    if index1 <= length(param1) then
                      ch1 := param1[index1];
                    else
                      ch1 := '\0\';
                    end if;
                  until ch1 <> ' ';
                  if ch1 = '\\' then
                    outFile << param2[1 len succ(index2 - index1)] rpad succ(index2 - index1);
                    log << literal(param2);
                  else
                    error_marker;
                    err << "'\\' - FOUND ";
                    err << literal(ch1);
                    err << ".";
                    err << NL;
                  end if;
                elsif ch1 = '&' then
                  outFile << param2;
                  log << literal(param2);
                end if;
              else
                error_marker;
                err << "STRING EXPECTED - FOUND ";
                err << symbol;
                err << ".";
                err << NL;
              end if;
            when {'#', '+', '.'}:
              if index1 < length(param1) then
                ch2 := param1[succ(index1)];
              else
                ch2 := '\0\';
              end if;
              if ch1 = '#' or
                  ch1 = '+' and ch2 in {'#', '.'} or
                  ch1 = '.' and ch2 = '#' then
                if symbol = ";" or symbol = "," then
                  symbol := get_symbol(line);
                end if;
                num1 := exec_expr(symbol, line);
                if ch1 = '+' then
                  if num1 >= 0.0 then
                    outFile << '+';
                    log << '+';
                  end if;
                  ch1 := ch2;
                  incr(index1);
                end if;
                index2 := index1;
                index3 := 0;
                index4 := 0;
                while ch1 = '#' do
                  incr(index2);
                  incr(index3);
                  if index2 <= length(param1) then
                    ch1 := param1[index2];
                  else
                    ch1 := '\0\';
                  end if;
                  if index2 < length(param1) then
                    ch2 := param1[succ(index2)];
                  else
                    ch2 := '\0\';
                  end if;
                  if ch1 = ',' and ch2 = '#' then
                    ch1 := ch2;
                    incr(index2);
                  end if;
                end while;
                if ch1 = '.' then
                  incr(index2);
                  if index2 <= length(param1) then
                    ch1 := param1[index2];
                  else
                    ch1 := '\0\';
                  end if;
                  while ch1 = '#' do
                    incr(index2);
                    incr(index4);
                    if index2 <= length(param1) then
                      ch1 := param1[index2];
                    else
                      ch1 := '\0\';
                    end if;
                    if index2 < length(param1) then
                      ch2 := param1[succ(index2)];
                    else
                      ch2 := '\0\';
                    end if;
                    if ch1 = ',' and ch2 = '#' then
                      ch1 := ch2;
                      incr(index2);
                    end if;
                  end while;
                end if;
                if index4 = 0 then
                  param2 := num1 digits 0 lpad index3;
                else
                  param2 := num1 digits index4 lpad index3 + index4 + 1;
                end if;
                log << num1;
                log << " ";
                log << "#" mult index3;
                log << ".";
                log << "#" mult index4;
                log << " ";
                log << literal(param2);
                index3 := 1;
                while index1 < index2 do
                  if index1 <= length(param1) then
                    ch1 := param1[index1];
                  else
                    ch1 := '\0\';
                  end if;
                  ch2 := param2[index3];
                  if ch1 = ',' then
                    if index3 >= 2 and param2[pred(index3)] in digit then
                      param2 := param2[.. pred(index3)] & "," & param2[index3 ..];
                    else
                      param2 := param2[.. pred(index3)] & " " & param2[index3 ..];
                    end if;
                  end if;
                  incr(index1);
                  incr(index3);
                end while;
                outFile << param2;
                log << " ";
                log << literal(param2);
                index1 := pred(index2);
              else
                outFile << ch1;
                log << ch1;
              end if;
            when {'*'}:
              noop;
            when {'$'}:
              noop;
            otherwise:
              outFile << ch1;
              log << ch1;
          end case;
          incr(index1);
        end while;
        if endOfStatement(symbol) then
          outFile << NL;
        elsif symbol = ";" then
          symbol := get_symbol(line);
        elsif symbol = "," then
          symbol := get_symbol(line);
        else
          (* This is the next thing to be printed *)
          log << " (;) ";
          log << symbol;
        end if;
      until endOfStatement(symbol);
      log << NL;
      flush(log);
    end if;
  end func;


const proc: exec_print_to_file (inout string: symbol, inout string: line) is func
  local
    var integer: index1 is 0;
  begin
    symbol := get_symbol(line);
    index1 := round(exec_expr(symbol, line));
    expect(",", symbol, line);
    if file_value[index1] <> STD_NULL then
      line_marker;
      log << "PRINT #";
      log << index1;
      log << ", ";
      if symbol = "USING" then
        exec_print_using(file_value[index1], symbol, line);
      else
        exec_print(file_value[index1], symbol, line);
      end if;
    else
      error_marker;
      err << "FILE #";
      err << index1;
      err << " NOT OPEN IN PRINT.";
      err << NL;
      while not endOfStatement(symbol) do
        symbol := get_symbol(line);
      end while;
    end if;
  end func;


const proc: exec_write_to_file (inout string: symbol, inout string: line) is func
  local
    var string: variable_name is "";
    var string: param1 is "";
    var float: num1 is 0.0;
    var integer: index1 is 0;
  begin
    symbol := get_symbol(line);
    index1 := round(exec_expr(symbol, line));
    if file_value[index1] <> STD_NULL then
      while symbol = "," do
        symbol := get_symbol(line);
        if isStringExpr(symbol) then
          param1 := exec_str_expr(symbol, line, variable_name);
          file_value[index1] << literal(param1);
          line_marker;
          log << "WRITE #";
          log << index1;
          log << ", ";
          log << literal(param1);
          log << NL;
          flush(log);
        else
          num1 := exec_expr(symbol, line);
          file_value[index1] << num1;
          line_marker;
          log << "WRITE #";
          log << index1;
          log << ", ";
          log << num1;
          log << NL;
          flush(log);
        end if;
        if symbol = "," then
          file_value[index1] << ", ";
        end if;
      end while;
      file_value[index1] << NL;
      flush(file_value[index1]);
    else
      error_marker;
      err << "FILE #";
      err << index1;
      err << " NOT OPEN IN WRITE.";
      err << NL;
      while not endOfStatement(symbol) do
        symbol := get_symbol(line);
      end while;
    end if;
  end func;


const proc: exec_write (inout string: symbol, inout string: line) is func
  local
    var string: variable_name is "";
    var string: param1 is "";
    var float: num1 is 0.0;
    var boolean: finished is FALSE;
  begin
    if endOfStatement(symbol) then
      win << NL;
      flush(win);
      log << "WRITE";
      log << NL;
      flush(log);
    else
      repeat
        if isStringExpr(symbol) then
          param1 := exec_str_expr(symbol, line, variable_name);
          win << literal(param1);
          line_marker;
          log << "WRITE ";
          log << literal(param1);
          log << NL;
          flush(log);
        else
          num1 := exec_expr(symbol, line);
          win << num1;
          line_marker;
          log << "WRITE ";
          log << num1;
          log << NL;
          flush(log);
        end if;
        if symbol = "," then
          symbol := get_symbol(line);
          win << ", ";
        else
          finished := TRUE;
        end if;
      until finished;
      win << NL;
      flush(win);
    end if;
  end func;


const proc: exec_read (inout string: symbol, inout string: line) is func
  local
    var string: variable_name is "";
    var string: data_elem is "";
    var string: param1 is "";
    var float: num1 is 0.0;
  begin
    repeat
      symbol := get_symbol(line);
      if isStringVar(symbol) then
        variable_name := get_name(symbol, line);
        param1 := get_data_field;
        setStringVar(variable_name, param1);
        line_marker;
        log << "READ ";
        log << variable_name;
        log << " ";
        log << literal(param1);
        log << " IN DATA LINE ";
        line_marker(data_line_number);
        log << NL;
        flush(log);
      else
        variable_name := get_name(symbol, line);
        data_elem := trim(get_data_field);
        if data_elem = "" then
          (* Empty DATA fields can be read as 0.0 *)
          setNumericVar(variable_name, 0.0);
          line_marker;
          log << "READ ";
          log << variable_name;
          log << " ";
          log << 0.0;
          log << " IN DATA LINE ";
          line_marker(data_line_number);
          log << NL;
          flush(log);
        else
          param1 := get_symbol(data_elem);
          if param1 = "-" then
            param1 &:= get_symbol(data_elem);
          end if;
          block
            num1 := float parse param1;
            setNumericVar(variable_name, num1);
            line_marker;
            log << "READ ";
            log << variable_name;
            log << " ";
            log << num1;
            log << " IN DATA LINE ";
            line_marker(data_line_number);
            log << NL;
            flush(log);
          exception
            catch RANGE_ERROR:
              error_marker;
              err << "NUMBER EXPECTED IN READ FOUND ";
              err << literal(param1);
              err << " IN DATA LINE ";
              line_marker(data_line_number);
              err << ".";
              err << NL;
          end block;
          if data_elem <> "" then
            error_marker;
            err << "FOUND ";
            err << literal(data_elem);
            err << " AFTER ";
            err << literal(param1);
            err << " IN DATA LINE ";
            line_marker(data_line_number);
            err << ".";
            err << NL;
          end if;
        end if;
      end if;
    until symbol <> ",";
  end func;


const proc: exec_input_from_file (inout string: symbol, inout string: line) is func
  local
    var string: variable_name is "";
    var string: param1 is "";
    var float: num1 is 0.0;
    var integer: index1 is 0;
  begin
    symbol := get_symbol(line);
    index1 := round(exec_expr(symbol, line));
    if file_value[index1] <> STD_NULL then
      file_value[index1].bufferChar := getc(file_value[index1]);
      while symbol = "," do
        symbol := get_symbol(line);
        skip_space_cr_lf(file_value[index1]);
        if isStringVar(symbol) then
          variable_name := get_name(symbol, line);
          param1 := read_input_string(file_value[index1]);
          setStringVar(variable_name, param1);
          line_marker;
          log << "INPUT #";
          log << index1;
          log << ", ";
          log << variable_name;
          log << " ";
          log << literal(param1);
          log << NL;
          flush(log);
        else
          variable_name := get_name(symbol, line);
          param1 := read_input_number(file_value[index1]);
          block
            num1 := float parse param1;
            setNumericVar(variable_name, num1);
            line_marker;
            log << "INPUT #";
            log << index1;
            log << ", ";
            log << variable_name;
            log << " ";
            log << num1;
            log << NL;
            flush(log);
          exception
            catch RANGE_ERROR:
              error_marker;
              err << "NUMBER EXPECTED FOR INPUT OF ";
              err << variable_name;
              err << " FOUND ";
              err << literal(param1);
              err << ".";
              err << NL;
          end block;
        end if;
        if file_value[index1].bufferChar = ',' then
          file_value[index1].bufferChar := getc(file_value[index1]);
        end if;
      end while;
    else
      error_marker;
      err << "FILE #";
      err << index1;
      err << " NOT OPEN IN INPUT.";
      err << NL;
      while not endOfStatement(symbol) do
        symbol := get_symbol(line);
      end while;
    end if;
  end func;


const proc: read_input (inout file: inFile,
    inout string: symbol, inout string: line) is func
  local
    var string: variable_name is "";
    var string: param1 is "";
    var float: num1 is 0.0;
  begin
    while symbol = "," do
      symbol := get_symbol(line);
      skipSpace(inFile);
      if isStringVar(symbol) then
        variable_name := get_name(symbol, line);
        param1 := read_input_string(inFile);
        assign_input_string(variable_name, param1);
      else
        variable_name := get_name(symbol, line);
        param1 := read_input_number(inFile);
        assign_input_number(variable_name, param1);
      end if;
      if inFile.bufferChar = ',' then
        inFile.bufferChar := getc(inFile);
      end if;
    end while;
  end func;


const proc: exec_input (inout string: symbol, inout string: line) is func
  local
    var string: variable_name is "";
    var string: param1 is "";
    var string: param2 is "";
    var float: num1 is 0.0;
  begin
    if symbol = ";" then
      symbol := get_symbol(line);
    end if;
    if isStringExpr(symbol) then
      param1 := exec_str_expr(symbol, line, variable_name);
      if symbol = ";" or symbol = "," then
        win << param1;
        line_marker;
        log << "INPUT ";
        log << literal(param1);
        if symbol = ";" then
          (* A comma is used to suppress the question mark *)
          win << "? ";
          symbol := ",";
          log << "? ";
        end if;
        flush(win);
        log << NL;
        flush(log);
        IN.bufferChar := getc(IN);
        read_input(IN, symbol, line);
      elsif variable_name <> "" then
        win << "? ";
        flush(win);
        line_marker;
        log << "INPUT ? ";
        log << variable_name;
        log << NL;
        flush(log);
        IN.bufferChar := getc(IN);
        skipSpace(IN);
        param2 := read_input_string(IN);
        assign_input_string(variable_name, param2);
        if IN.bufferChar = ',' then
          IN.bufferChar := getc(IN);
        end if;
        read_input(IN, symbol, line);
      else
        error_expect2(";", ",", symbol);
      end if;
    else
      variable_name := get_name(symbol, line);
      win << "? ";
      flush(win);
      line_marker;
      log << "INPUT ? ";
      log << variable_name;
      log << NL;
      flush(log);
      IN.bufferChar := getc(IN);
      skipSpace(IN);
      param1 := read_input_number(IN);
      assign_input_number(variable_name, param1);
      if IN.bufferChar = ',' then
        IN.bufferChar := getc(IN);
      end if;
      read_input(IN, symbol, line);
    end if;
  end func;


const proc: exec_line_input_from_file (inout string: symbol, inout string: line) is func
  local
    var string: variable_name is "";
    var string: param1 is "";
    var integer: index1 is 0;
  begin
    symbol := get_symbol(line);
    index1 := round(exec_expr(symbol, line));
    if file_value[index1] <> STD_NULL then
      expect(",", symbol, line);
      if isStringVar(symbol) then
        variable_name := get_name(symbol, line);
        param1 := getln(file_value[index1]);
        setStringVar(variable_name, param1);
        line_marker;
        log << "LINE INPUT #";
        log << index1;
        log << ", ";
        log << variable_name;
        log << " ";
        log << literal(param1);
        log << NL;
        flush(log);
      else
        error_marker;
        err << "STRING VARIABLE EXPECTED IN LINE INPUT FOUND ";
        err << literal(symbol);
        err << ".";
        err << NL;
      end if;
    else
      error_marker;
      err << "FILE #";
      err << index1;
      err << " NOT OPEN IN LINE INPUT.";
      err << NL;
      while not endOfStatement(symbol) do
        symbol := get_symbol(line);
      end while;
    end if;
  end func;


const proc: exec_line_input (inout string: symbol, inout string: line) is func
  local
    var string: variable_name is "";
    var string: param1 is "";
    var string: param2 is "";
  begin
    if symbol = ";" then
      symbol := get_symbol(line);
    end if;
    if isStringExpr(symbol) then
      param1 := exec_str_expr(symbol, line, variable_name);
      if symbol = ";" or symbol = "," then
        symbol := get_symbol(line);
        win << param1;
        flush(win);
        if isStringVar(symbol) then
          variable_name := get_name(symbol, line);
          line_marker;
          log << "LINE INPUT ";
          log << literal(param1);
          log << "; ";
          log << variable_name;
          flush(log);
          readln(param2);
          win << NL;
          flush(win);
          setStringVar(variable_name, param2);
          log << " <- ";
          log << literal(param2);
          log << NL;
          flush(log);
        else
          error_marker;
          err << "STRING EXPECTED FOR LINE INPUT - FOUND ";
          err << symbol;
          err << ".";
          err << NL;
        end if;
      elsif variable_name <> "" then
        win << "? ";
        flush(win);
        line_marker;
        log << "LINE INPUT ";
        log << variable_name;
        flush(log);
        readln(param2);
        win << NL;
        flush(win);
        setStringVar(variable_name, param2);
        log << " <- ";
        log << literal(param2);
        log << NL;
        flush(log);
      else
        error_expect2(";", ",", symbol);
      end if;
    else
      error_marker;
      err << "STRING EXPECTED FOR LINE INPUT - FOUND ";
      err << symbol;
      err << ".";
      err << NL;
    end if;
  end func;


const func file: basicOpen (in var string: filePath, in string: access) is func
  result
    var file: result is STD_NULL;
  local
    var array string: pathElems is 0 times "";
    var integer: startElem is 1;
    var integer: number is 0;
    var array string: directoryContent is 0 times "";
    var string: directoryElement is "";
    var boolean: foundTwice is FALSE;
    var string: foundElement is "";
    var boolean: path_okay is TRUE;
    var string: path is "";
  begin
    filePath := replace(filePath, "\\", "/");
    pathElems := split(filePath, '/');
    if length(pathElems) >= 1 and pathElems[1] = "" then
      # absolute path
      path := "/";
      startElem := 2;
    else
      # relative path
      path := getcwd;
      startElem := 1;
    end if;
    for number range startElem to length(pathElems) do
      # writeln(log, literal(path) <& " " <& literal(pathElems[number]));
      if file_type(path & "/" & pathElems[number]) <> FILE_UNKNOWN then
        path &:= "/" & pathElems[number];
      elsif file_type(path) = FILE_DIR then
        directoryContent := read_dir(path);
        foundTwice := FALSE;
        foundElement := "";
        for directoryElement range directoryContent do
          if upper(pathElems[number]) = upper(directoryElement) then
            if foundElement = "" then
              foundElement := directoryElement;
            else
              foundTwice := TRUE;
            end if;
          end if;
        end for;
        if foundElement <> "" and not foundTwice and
            file_type(path & "/" & foundElement) <> FILE_UNKNOWN then
          path &:= "/" & foundElement;
        else
          path_okay := FALSE;
        end if;
      else
        path_okay := FALSE;
      end if;
    end for;
    if path_okay then
      result := open(path, access);
    end if;
  end func;


const proc: exec_open (inout string: symbol, inout string: line) is func
  local
    var string: unused_name is "";
    var string: param1 is "";
    var string: param2 is "";
    var string: mode is "";
    var string: file_name is "";
    var integer: index1 is 0;
    var integer: index2 is 0;
  begin
    symbol := get_symbol(line);
    param1 := exec_str_expr(symbol, line, unused_name);
    if symbol = "FOR" then
      param2 := get_symbol(line);
      if param2 = "INPUT" then
        mode := "r";
      elsif param2 = "OUTPUT" then
        mode := "w";
      elsif param2 = "APPEND" then
        mode := "a";
      elsif param2 = "RANDOM" then
        mode := "r+";
      elsif param2 = "BINARY" then
        mode := "r+";
      else
        mode := "r";
        error_marker;
        err << "ILLEGAL - OPEN FOR ";
        err << param2;
        err << NL;
      end if;
      symbol := get_symbol(line);
    end if;
    if symbol = "ACCESS" then
      symbol := get_symbol(line);
      if symbol = "READ" then
        symbol := get_symbol(line);
      end if;
      if symbol = "WRITE" then
        symbol := get_symbol(line);
      end if;
    end if;
    if symbol = "SHARED" then
      symbol := get_symbol(line);
    elsif symbol = "LOCK" then
      symbol := get_symbol(line);
      if symbol = "READ" then
        symbol := get_symbol(line);
      end if;
      if symbol = "WRITE" then
        symbol := get_symbol(line);
      end if;
    end if;
    if symbol = "AS" or symbol = "AS#" then
      if symbol = "AS#" then
        symbol := "#";
      else
        symbol := get_symbol(line);
      end if;
      if symbol = "#" then
        symbol := get_symbol(line);
      end if;
      index1 := round(exec_expr(symbol, line));
      if symbol = "LEN" then
        symbol := get_symbol(line);
        index2 := round(exec_expr(symbol, line));
      end if;
      file_name := param1;
      file_value[index1] := basicOpen(file_name, mode);
      line_marker;
      log << "OPEN ";
      log << param1;
      log << " FOR ";
      log << param2;
      log << " AS #";
      log << index1;
      log << " - open(";
      log << literal(file_name);
      log << ", ";
      log << literal(mode);
      log << ")";
      log << NL;
      flush(log);
    else
      if param1 <> "" then
        if param1[.. 1] = "I" then
          mode := "r";
        elsif param1[.. 1] = "O" then
          mode := "w";
        elsif param1[.. 1] = "R" then
          mode := "r+";
        elsif param1[.. 1] = "B" then
          mode := "r+";
        end if;
      end if;
      if mode = "" then
        mode := "r";
        error_marker;
        err << "ILLEGAL - OPEN ";
        err << literal(param1);
        err << NL;
      end if;
      expect(",", symbol, line);
      if symbol = "#" then
        symbol := get_symbol(line);
      end if;
      index1 := round(exec_expr(symbol, line));
      expect(",", symbol, line);
      param2 := exec_str_expr(symbol, line, unused_name);
      file_name := param2;
      file_value[index1] := basicOpen(file_name, mode);
      if symbol = "," then
        symbol := get_symbol(line);
        index2 := round(exec_expr(symbol, line));
      end if;
      line_marker;
      log << "OPEN ";
      log << literal(param1);
      log << ", #";
      log << index1;
      log << ", ";
      log << literal(param2);
      log << " - open(";
      log << literal(file_name);
      log << ", ";
      log << literal(mode);
      log << ")";
      log << NL;
      flush(log);
    end if;
    if file_value[index1] = STD_NULL then
      if on_error_label <> "" then
        error_code := 53; # File not found
        line_marker;
        log << "COULD NOT OPEN ";
        log << literal(file_name);
        log << " - ON ERROR GOTO ";
        log << on_error_label;
        log << NL;
        flush(log);
        goto_on_error(on_error_label, line);
        symbol := "";
        line := "";
      else
        error_marker;
        err << "COULD NOT OPEN ";
        err << literal(file_name);
        err << NL;
      end if;
    end if;
  end func;


const proc: exec_screen (inout string: symbol, inout string: line) is func
  local
    var integer: newScreenMode is 0;
    var integer: colorswitch is 0;
  begin
    symbol := get_symbol(line);
    newScreenMode := round(exec_expr(symbol, line));
    if symbol = "," then
      symbol := get_symbol(line);
      colorswitch := round(exec_expr(symbol, line));
    end if;
    if newScreenMode <> screenMode then
      case newScreenMode of
        when  {0}: # Text mode
          # Some programs set screen to 0 and draw...
          # curr_win := PRIMITIVE_WINDOW.value;
          scr := open(SCREEN);
          win := open_window(scr, 1, 1, 35, 150);
          KEYBOARD := SCREEN_KEYBOARD;
          OUT := win;
          IN := KEYBOARD;
          IN := open_echo(IN, OUT);
          IN := open_line(IN);
          screenMode := newScreenMode;

        when  {1}:          # 320 x 200 pixel, 40 x 25 text, 8 x 8 chars
          screen(320, 200);
          win := open(curr_win, 8);
          screenMode := newScreenMode;

        when  {2}:          # 640 x 200 pixel, 80 x 25 text, 8 x 8 chars
          screen(640, 200);
          win := open(curr_win, 8);
          screenMode := newScreenMode;

        when  {7}:          # 320 x 200 pixel, 40 x 25 text, 8 x 8 chars
          screen(320, 200);
          win := open(curr_win, 8);
          screenMode := newScreenMode;

        when  {8}:          # 640 x 200 pixel, 80 x 25 text, 8 x 8 chars
          screen(640, 200);
          win := open(curr_win, 8);
          screenMode := newScreenMode;

        when  {9}:          # 640 x 350 pixel, 80 x 25 text, 8 x 14 chars
          screen(640, 350);
          win := open(curr_win, 14);
          screenMode := newScreenMode;

        when {10}:          # 640 x 350 pixel, 80 x 25 text, 8 x 14 chars
          screen(640, 350);
          win := open(curr_win, 14);
          screenMode := newScreenMode;

        when {11}:          # 640 x 480 pixel, 80 x 30 text, 8 x 16 chars
          screen(640, 480);
          win := open(curr_win, 16);
          screenMode := newScreenMode;

        when {12}:          # 640 x 480 pixel, 80 x 30 text, 8 x 16 chars
          screen(640, 480);
          win := open(curr_win, 16);
          screenMode := newScreenMode;

        when {13}:          # 320 x 200 pixel, 40 x 25 text, 8 x 8 chars
          screen(320, 200);
          win := open(curr_win, 16);
          screenMode := newScreenMode;

        otherwise:
          error_marker;
          err << "ILLEGAL SCREEN NUMBER: ";
          err << newScreenMode;
          err << NL;
      end case;
      if screenMode <> 0 and curr_win <> PRIMITIVE_WINDOW.value then
        clear(curr_win, white);
        color(white, black);
        scr := open(curr_win);
        KEYBOARD := GRAPH_KEYBOARD;
        OUT := win;
        IN := KEYBOARD;
        IN := open_echo(IN, OUT);
        IN := open_line(IN);
      end if;
    end if;
    line_marker;
    log << "SCREEN ";
    log << newScreenMode;
    log << ", ";
    log << colorswitch;
    log << " ";
    log << line;
    log << NL;
    flush(log);
    while not endOfStatement(symbol) do
      symbol := get_symbol(line);
    end while;
  end func;


const proc: exec_pset (inout string: symbol, inout string: line) is func
  local
    var integer: col is 0;
  begin
    symbol := get_symbol(line);
    if symbol = "STEP" then
      symbol := get_symbol(line);
      expect("(", symbol, line);
      currX +:= round(exec_expr(symbol, line));
      expect(",", symbol, line);
      currY +:= round(exec_expr(symbol, line));
      expect(")", symbol, line);
    else
      expect("(", symbol, line);
      currX := round(exec_expr(symbol, line));
      expect(",", symbol, line);
      currY := round(exec_expr(symbol, line));
      expect(")", symbol, line);
    end if;
    if symbol = "," then
      symbol := get_symbol(line);
      col := round(exec_expr(symbol, line));
    else
      col := foreground_color;
    end if;
    point(currX, currY, color_num(col));
    DRAW_FLUSH;
    line_marker;
    log << "PSET (";
    log << currX;
    log << ", ";
    log << currY;
    log << "), ";
    log << col;
    log << NL;
    flush(log);
  end func;


const proc: exec_preset (inout string: symbol, inout string: line) is func
  local
    var integer: col is 0;
  begin
    symbol := get_symbol(line);
    if symbol = "STEP" then
      symbol := get_symbol(line);
      expect("(", symbol, line);
      currX +:= round(exec_expr(symbol, line));
      expect(",", symbol, line);
      currY +:= round(exec_expr(symbol, line));
      expect(")", symbol, line);
    else
      expect("(", symbol, line);
      currX := round(exec_expr(symbol, line));
      expect(",", symbol, line);
      currY := round(exec_expr(symbol, line));
      expect(")", symbol, line);
    end if;
    if symbol = "," then
      symbol := get_symbol(line);
      col := round(exec_expr(symbol, line));
    else
      col := background_color;
    end if;
    point(currX, currY, color_num(col));
    DRAW_FLUSH;
    line_marker;
    log << "PSET (";
    log << currX;
    log << ", ";
    log << currY;
    log << "), ";
    log << col;
    log << NL;
    flush(log);
  end func;


const proc: exec_line (inout string: symbol, inout string: line) is func
  local
    var string: param1 is "";
    var integer: x1 is 0;
    var integer: y1 is 0;
    var integer: col is 0;
  begin
    if symbol = "STEP" then
      symbol := get_symbol(line);
      expect("(", symbol, line);
      x1 := currX + round(exec_expr(symbol, line));
      expect(",", symbol, line);
      y1 := currY + round(exec_expr(symbol, line));
      expect(")", symbol, line);
    elsif symbol = "-" then
      x1 := currX;
      y1 := currY;
    else
      expect("(", symbol, line);
      x1 := round(exec_expr(symbol, line));
      expect(",", symbol, line);
      y1 := round(exec_expr(symbol, line));
      expect(")", symbol, line);
    end if;
    expect("-", symbol, line);
    if symbol = "STEP" then
      symbol := get_symbol(line);
      expect("(", symbol, line);
      currX := x1 + round(exec_expr(symbol, line));
      expect(",", symbol, line);
      currY := y1 + round(exec_expr(symbol, line));
    else
      expect("(", symbol, line);
      currX := round(exec_expr(symbol, line));
      expect(",", symbol, line);
      currY := round(exec_expr(symbol, line));
    end if;
    expect(")", symbol, line);
    col := foreground_color;
    if symbol = "," then
      symbol := get_symbol(line);
      if symbol <> "," then
        col := round(exec_expr(symbol, line));
      end if;
      if symbol = "," then
        param1 := get_symbol(line);
        symbol := get_symbol(line);
      end if;
    end if;
    if param1 = "BF" then
      rectTo(x1, y1, currX, currY, color_num(col));
      DRAW_FLUSH;
      line_marker;
      log << "LINE (";
      log << x1;
      log << ", ";
      log << y1;
      log << ") - (";
      log << currX;
      log << ", ";
      log << currY;
      log << "), ";
      log << col;
      log << ", ";
      log << param1;
      log << " ";
      log << line;
      log << NL;
      flush(log);
    elsif param1 = "B" then
      boxTo(x1, y1, currX, currY, color_num(col));
      DRAW_FLUSH;
      line_marker;
      log << "LINE (";
      log << x1;
      log << ", ";
      log << y1;
      log << ") - (";
      log << currX;
      log << ", ";
      log << currY;
      log << "), ";
      log << col;
      log << ", ";
      log << param1;
      log << " ";
      log << line;
      log << NL;
      flush(log);
    else
      lineTo(x1, y1, currX, currY, color_num(col));
      DRAW_FLUSH;
      line_marker;
      log << "LINE (";
      log << x1;
      log << ", ";
      log << y1;
      log << ") - (";
      log << currX;
      log << ", ";
      log << currY;
      log << "), ";
      log << col;
      log << " ";
      log << line;
      log << NL;
      flush(log);
    end if;
  end func;


const proc: exec_circle (inout string: symbol, inout string: line) is func
  local
    var integer: x1 is 0;
    var integer: y1 is 0;
    var integer: radius is 0;
    var integer: col is 0;
    var integer: start is 0;
    var integer: stop is 0;
    var integer: aspect is 0;
  begin
    symbol := get_symbol(line);
    if symbol = "STEP" then
      symbol := get_symbol(line);
      expect("(", symbol, line);
      currX +:= round(exec_expr(symbol, line));
      expect(",", symbol, line);
      currY +:= round(exec_expr(symbol, line));
    else
      expect("(", symbol, line);
      currX := round(exec_expr(symbol, line));
      expect(",", symbol, line);
      currY := round(exec_expr(symbol, line));
    end if;
    expect(")", symbol, line);
    expect(",", symbol, line);
    radius := round(exec_expr(symbol, line));
    col := foreground_color;
    if symbol = "," then
      symbol := get_symbol(line);
      if symbol <> "," then
        col := round(exec_expr(symbol, line));
      end if;
    end if;
    if symbol = "," then
      symbol := get_symbol(line);
      if symbol <> "," then
        start := round(exec_expr(symbol, line));
      end if;
    end if;
    if symbol = "," then
      symbol := get_symbol(line);
      if symbol <> "," then
        stop := round(exec_expr(symbol, line));
      end if;
    end if;
    if symbol = "," then
      symbol := get_symbol(line);
      if symbol <> "," then
        aspect := round(exec_expr(symbol, line));
      end if;
    end if;
    circle(currX, currY, radius, color_num(col));
    DRAW_FLUSH;
    line_marker;
    log << "CIRCLE (";
    log << currX;
    log << ", ";
    log << currY;
    log << "), ";
    log << radius;
    log << ", ";
    log << col;
    log << NL;
    flush(log);
  end func;


const proc: exec_put (inout string: symbol, inout string: line) is func
  local
    var integer: x1 is 0;
    var integer: y1 is 0;
    var string: variable_name is "";
    var PRIMITIVE_WINDOW: image is PRIMITIVE_WINDOW.value;
  begin
    expect("(", symbol, line);
    x1 := round(exec_expr(symbol, line));
    expect(",", symbol, line);
    y1 := round(exec_expr(symbol, line));
    expect(")", symbol, line);
    expect(",", symbol, line);
    variable_name := get_name(symbol, line);
    if symbol = "," then
      symbol := get_symbol(line);
      symbol := get_symbol(line);
    end if;
    line_marker;
    log << "PUT (";
    log << x1;
    log << ", ";
    log << y1;
    log << "), ";
    log << variable_name;
    log << NL;
    flush(log);
    if variable_name in image_var then
      image := image_var[variable_name];
      put(x1, y1, image, PSET);
    else
      error_marker;
      err << "UNDEFINED IMAGE VARIABLE ";
      err << literal(variable_name);
      err << NL;
    end if;
  end func;


const proc: exec_get (inout string: symbol, inout string: line) is func
  local
    var integer: x1 is 0;
    var integer: y1 is 0;
    var integer: x2 is 0;
    var integer: y2 is 0;
    var integer: help is 0;
    var string: variable_name is "";
    var PRIMITIVE_WINDOW: image is PRIMITIVE_WINDOW.value;
  begin
    expect("(", symbol, line);
    x1 := round(exec_expr(symbol, line));
    expect(",", symbol, line);
    y1 := round(exec_expr(symbol, line));
    expect(")", symbol, line);
    expect("-", symbol, line);
    if symbol = "STEP" then
      symbol := get_symbol(line);
      expect("(", symbol, line);
      x2 := x1 + round(exec_expr(symbol, line));
      expect(",", symbol, line);
      y2 := y1 + round(exec_expr(symbol, line));
    else
      expect("(", symbol, line);
      x2 := round(exec_expr(symbol, line));
      expect(",", symbol, line);
      y2 := round(exec_expr(symbol, line));
    end if;
    expect(")", symbol, line);
    expect(",", symbol, line);
    variable_name := get_name(symbol, line);
    if x1 > x2 or y1 > y2 then
      error_marker;
      err << "GET (";
      err << x1;
      err << ", ";
      err << y1;
      err << ") - (";
      err << x2;
      err << ", ";
      err << y2;
      err << ") = ";
    end if;
    if x1 > x2 and y1 > y2 then
      err << "GET (LOWER RIGHT) - (UPPER LEFT)";
      err << NL;
      help := x1;
      x1 := x2;
      x2 := help;
      help := y1;
      y1 := y2;
      y2 := help;
    elsif x1 > x2 then
      err << "GET (UPPER RIGHT) - (LOWER LEFT)";
      err << NL;
      help := x1;
      x1 := x2;
      x2 := help;
    elsif y1 > y2 then
      err << "GET (LOWER LEFT) - (UPPER RIGHT)";
      err << NL;
      help := y1;
      y1 := y2;
      y2 := help;
    end if;
    image := getPixmap(x1, y1, x2 - x1 + 1, y2 - y1 + 1);
    image_var @:= [variable_name] image;
    line_marker;
    log << "GET (";
    log << x1;
    log << ", ";
    log << y1;
    log << ") - (";
    log << x2;
    log << ", ";
    log << y2;
    log << "), ";
    log << variable_name;
    log << NL;
    flush(log);
  end func;


const proc: exec_draw (inout string: symbol, inout string: line) is func
  local
    var string: cmdStri is "";
    var string: unused_name is "";
    var integer: currPos is 1;
    var char: currCmd is ' ';
    var string: param1 is "";
    var integer: num1 is 0;
    var integer: num2 is 0;
    var boolean: pen_up is FALSE;
    var boolean: move_back is FALSE;
    var integer: scale_factor is 1;
  begin
    symbol := get_symbol(line);
    cmdStri := exec_str_expr(symbol, line, unused_name);
(*
    skipWhiteSpace(cmdStri);
    while cmdStri <> "" do
      currCmd := upper(getChar(cmdStri)[1]);
      skipWhiteSpace(cmdStri);
      if currCmd = 'B' then
        pen_up := TRUE;
        if cmdStri <> "" then
          currCmd := upper(getChar(cmdStri)[1]);
        else
          currCmd := ' ';
        end if;
        skipWhiteSpace(cmdStri);
      elsif currCmd = 'N' then
        move_back := TRUE;
        if cmdStri <> "" then
          currCmd := upper(getChar(cmdStri)[1]);
        else
          currCmd := ' ';
        end if;
        skipWhiteSpace(cmdStri);
      end if;
      case currCmd of
        when [' '}:
          noop;
        when {'U'}:
          param1 := getDigits(cmdStri);
          if param1 <> "" then
            yPos -:= scale_factor * integer parse param1;
          end if;
        when {'D'}:
          param1 := getDigits(cmdStri);
          if param1 <> "" then
            yPos +:= scale_factor * integer parse param1;
          end if;
        when {'L'}:
          param1 := getDigits(cmdStri);
          if param1 <> "" then
            xPos -:= scale_factor * integer parse param1;
          end if;
        when {'R'}:
          param1 := getDigits(cmdStri);
          if param1 <> "" then
            xPos +:= scale_factor * integer parse param1;
          end if;
        when {'E'}:
          param1 := getDigits(cmdStri);
          if param1 <> "" then
            num1 := integer parse param1
            xPos +:= scale_factor * num1;
            yPos -:= scale_factor * num1;
          end if;
        when {'F'}:
          param1 := getDigits(cmdStri);
          if param1 <> "" then
            num1 := integer parse param1
            xPos +:= scale_factor * num1;
            yPos +:= scale_factor * num1;
          end if;
        when {'G'}:
          param1 := getDigits(cmdStri);
          if param1 <> "" then
            num1 := integer parse param1
            xPos -:= scale_factor * num1;
            yPos +:= scale_factor * num1;
          end if;
        when {'H'}:
          param1 := getDigits(cmdStri);
          if param1 <> "" then
            num1 := integer parse param1
            xPos -:= scale_factor * num1;
            yPos -:= scale_factor * num1;
          end if;
        when {'M'}:
          param1 := getDigits(cmdStri);
          if param1 <> "" then
            num1 := integer parse param1
            skipWhiteSpace(cmdStri);
            param1 := getChar(cmdStri);
            if param1 = "," then
              skipWhiteSpace(cmdStri);
              param1 := getDigits(cmdStri);
              if param1 <> "" then
                num2 := integer parse param1
                xPos -:= scale_factor * num1;
                yPos -:= scale_factor * num2;
              end if;
            end if;
          end if;
        when {'C'}:
          param1 := getDigits(cmdStri);
          if param1 <> "" then
            foreground_color := integer parse param1;
          end if;
        when {'S'}:
          param1 := getDigits(cmdStri);
          if param1 <> "" then
            scale_factor := integer parse param1;
          end if;

      end case;
      pen_up := FALSE;
      move_back := FALSE;
    end while;
*)
    line_marker;
    log << "**DRAW ";
    log << literal(cmdStri);
    log << NL;
    flush(log);
  end func;


const func boolean: load_prog (in string: name) is forward;


const func boolean: exec_cmd (inout string: symbol, inout string: line) is func
  result
    var boolean: result is TRUE;
  local
    var string: variable_name is "";
    var string: variable2_name is "";
    var string: unused_name is "";
    var string: param1 is "";
    var string: param2 is "";
    var string: param3 is "";
    var float: num1 is 0.0;
    var float: num2 is 0.0;
    var float: num3 is 0.0;
    var integer: index1 is 0;
    var integer: index2 is 0;
    var boolean: okay is FALSE;
    var boolean: process_next is FALSE;
    var char: ch1 is ' ';
  begin
    # log << literal(symbol) <& '\n';
    repeat
      process_next := FALSE;
      if symbol = "IF" then
        symbol := get_symbol(line);
        num1 := exec_expr(symbol, line);
        if num1 <> 0.0 then
          if symbol = "THEN" then
            line_marker;
            log << "IF ";
            log << num1;
            symbol := get_symbol(line);
            if symbol = "" or symbol = "'" or symbol = "REM" then
              # Execute the following statements until "ELSE", "ELSEIF" or "END" "IF".
              log << " THEN - EXECUTE STATEMENT BLOCK";
              log << NL;
              flush(log);
            elsif label_or_linenum(symbol) then
              param1 := symbol;
              symbol := get_symbol(line);
              # A label and a variable can share the same name
              if symbol = "=" or symbol = "("  or symbol = "[" then
                # A let statement is recognized: Write log and exec the let statement.
                log << " THEN - EXECUTE STATEMENTS IN LINE UNTIL \"ELSE\"";
                log << NL;
                flush(log);
                exec_let(param1, symbol, line);
              else
                log << " THEN - GOTO ";
                log << param1;
                log << NL;
                flush(log);
                goto_label_or_linenum(param1);
                symbol := "";
                line := "";
              end if;
            else
              log << " THEN - EXECUTE STATEMENTS IN LINE UNTIL \"ELSE\"";
              log << NL;
              flush(log);
              process_next := TRUE;
            end if;
          elsif symbol = "GOTO" then
            symbol := get_symbol(line);
            line_marker;
            log << "IF ";
            log << num1;
            log << " GOTO ";
            log << symbol;
            log << NL;
            flush(log);
            if label_or_linenum(symbol) then
              goto_label_or_linenum(symbol);
              symbol := "";
              line := "";
            else
              error_marker;
              err << "UNDEFINED LABEL ";
              err << symbol;
              err << " AFTER \"GOTO\".";
              err << NL;
            end if;
          else
            error_expect2("THEN", "GOTO", symbol);
          end if;
        else
          if symbol = "THEN" or symbol = "GOTO" then
            symbol := get_symbol(line);
          else
            error_expect2("THEN", "GOTO", symbol);
          end if;
          line_marker;
          log << "IF ";
          log << num1;
          if symbol = "" or symbol = "'" or symbol = "REM" then
            log << " THEN - SKIP STATEMENT BLOCK";
            log << NL;
            flush(log);
            exec_elseif_else_chain(symbol, line, process_next);
          elsif label_or_linenum(symbol) then
            log << " THEN - SKIP LABEL";
            log << NL;
            flush(log);
            symbol := get_symbol(line);
            if symbol = "ELSE" then
              symbol := get_symbol(line);
              if label_or_linenum(symbol) then
                line_marker;
                log << "ELSE - GOTO ";
                log << symbol;
                log << NL;
                flush(log);
                goto_label_or_linenum(symbol);
                symbol := "";
                line := "";
              else
                line_marker;
                log << "ELSE - EXECUTE STATEMENTS IN LINE";
                log << NL;
                flush(log);
                process_next := TRUE;
              end if;
            elsif symbol = ":" then
              line_marker;
              log << "NO ELSE - CONTINUE AFTER THE LABEL";
              log << NL;
              flush(log);
            else
              line_marker;
              log << "NO ELSE - CONTINUE AT NEXT LINE";
              log << NL;
              flush(log);
              symbol := "";
              line := "";
            end if;
          else
            log << " THEN - SKIP STATEMENTS IN LINE UNTIL \"ELSE\"";
            log << NL;
            flush(log);
            if symbol <> "ELSE" then
              symbol := find_else(line);
            end if;
            if symbol = "ELSE" then
              symbol := get_symbol(line);
              if label_or_linenum(symbol) then
                line_marker;
                log << "ELSE GOTO ";
                log << symbol;
                log << NL;
                flush(log);
                goto_label_or_linenum(symbol);
                symbol := "";
                line := "";
              else
                line_marker;
                log << "ELSE - EXECUTE STATEMENTS IN LINE";
                log << NL;
                flush(log);
                process_next := TRUE;
              end if;
            else
              line_marker;
              log << "NO ELSE - CONTINUE AT NEXT LINE";
              log << NL;
              flush(log);
              symbol := "";
              line := "";
            end if;
          end if;
        end if;
      elsif symbol = "GOTO" then
        exec_goto(symbol, line);
      elsif symbol = "GO" then
        symbol := get_symbol(line);
        if symbol = "TO" then
          exec_goto(symbol, line);
        elsif symbol = "=" or symbol = "("  or symbol = "[" then
          exec_let("GO", symbol, line);
        else
          error_marker;
          err << "UNEXPECTED SYMBOL ";
          err << literal("GO");
          err << ".";
          err << NL;
          repeat
            symbol := get_symbol(line);
          until endOfStatement(symbol);
        end if;
      elsif symbol = "PRINT" or symbol = "PRINT#" or symbol = "?" then
        if symbol = "PRINT#" then
          symbol := "#";
        else
          symbol := get_symbol(line);
        end if;
        if symbol = "#" then
          exec_print_to_file(symbol, line);
        else
          line_marker;
          log << "PRINT ";
          if symbol = "USING" then
            exec_print_using(win, symbol, line);
          else
            exec_print(symbol, line);
          end if;
        end if;
      elsif symbol = "WRITE" or symbol = "WRITE#" then
        if symbol = "WRITE#" then
          symbol := "#";
        else
          symbol := get_symbol(line);
        end if;
        if symbol = "#" then
          exec_write_to_file(symbol, line);
        else
          exec_write(symbol, line);
        end if;
      elsif symbol = "GOSUB" then
        exec_gosub(symbol, line);
      elsif symbol = "RETURN" then
        if length(gosubReturn) >= 1 then
          check_for_loop_stack_before_return;
          line_marker;
          log << "RETURN FROM \"GOSUB ";
          line_marker(gosubReturn[1].subEntryLine);
          log << "\"";
          do_return(symbol, line);
          log << " AT LINE ";
          line_marker;
          log << NL;
          flush(log);
        elsif on_error_label <> "" then
          symbol := get_symbol(line);
          error_code := 3; # RETURN without GOSUB
          line_marker;
          log << "RETURN WITHOUT GOSUB - ON ERROR GOTO ";
          log << on_error_label;
          log << NL;
          flush(log);
          goto_on_error(on_error_label, line);
          symbol := "";
          line := "";
        else
          symbol := get_symbol(line);
          error_marker;
          err << "RETURN WITHOUT GOSUB.";
          err << NL;
        end if;
      elsif symbol = "LOCATE" then
        symbol := get_symbol(line);
        if symbol = "," or endOfStatement(symbol) then
          index1 := line(win);
        else
          index1 := round(exec_expr(symbol, line));
        end if;
        if symbol = "," then
          symbol := get_symbol(line);
        end if;
        if symbol = "," or endOfStatement(symbol) then
          index2 := column(win);
        else
          index2 := round(exec_expr(symbol, line));
        end if;
        if symbol = "," then
          symbol := get_symbol(line);
        end if;
        setPos(win, index1, index2);
        line_marker;
        log << "LOCATE ";
        log << index1;
        log << ",";
        log << index2;
        log << NL;
        flush(log);
        if not endOfStatement(symbol) then
          num1 := exec_expr(symbol, line);
          if round(num1) = 0 then
            cursor(scr, FALSE);
          else
            cursor(scr, TRUE);
          end if;
          line_marker;
          log << "LOCATE ,,";
          log << round(num1);
          log << NL;
          flush(log);
        end if;
      elsif symbol = "READ" then
        exec_read(symbol, line);
      elsif symbol = "INPUT" or symbol = "INPUT#" then
        if symbol = "INPUT#" then
          symbol := "#";
        else
          symbol := get_symbol(line);
        end if;
        if symbol = "#" then
          exec_input_from_file(symbol, line);
        else
          exec_input(symbol, line);
        end if;
      elsif symbol = "LINE" then
        symbol := get_symbol(line);
        if symbol = "INPUT" or symbol = "INPUT#" then
          if symbol = "INPUT#" then
            symbol := "#";
          else
            symbol := get_symbol(line);
          end if;
          if symbol = "#" then
            exec_line_input_from_file(symbol, line);
          else
            exec_line_input(symbol, line);
          end if;
        elsif symbol = "(" or symbol = "-" or symbol = "STEP" then
          exec_line(symbol, line);
        else
          expect("INPUT", symbol, line);
        end if;
      elsif symbol = "ELSE" then
        line_marker;
        log << "ELSE - THE \"THEN\" BLOCK BEFORE WAS EXECUTED";
        log << NL;
        flush(log);
        if upper(prg[file_line_number].line[.. 4]) = "ELSE" then
          symbol := find_end_if(line);
          if symbol = "IF" then
            symbol := get_symbol(line);
            line_marker;
            log << "END IF";
            log << NL;
            flush(log);
          else
            error_marker;
            err << "ELSE - MISSING \"END IF\".";
            err << NL;
          end if;
        else
          line := "";
          symbol := "";
          line_marker;
          log << "SKIP ELSE PART - CONTINUE AT NEXT LINE";
          log << NL;
          flush(log);
        end if;
      elsif symbol = "ELSEIF" then
        line_marker;
        log << "ELSEIF - THE \"THEN\" BLOCK BEFORE WAS EXECUTED";
        log << NL;
        flush(log);
        symbol := find_end_if(line);
        if symbol = "IF" then
          symbol := get_symbol(line);
          line_marker;
          log << "END IF";
          log << NL;
          flush(log);
        else
          error_marker;
          err << "ELSEIF - MISSING \"END IF\".";
          err << NL;
        end if;
      elsif symbol = "END" then
        symbol := get_symbol(line);
        if symbol = "IF" then
          symbol := get_symbol(line);
          line_marker;
          log << "END IF - THE \"THEN\" OR \"ELSE\" BLOCK BEFORE WAS EXECUTED";
          log << NL;
          flush(log);
        elsif symbol = "SELECT" then
          symbol := get_symbol(line);
          line_marker;
          log << "END SELECT";
          log << NL;
          flush(log);
        elsif symbol = "SUB" then
          if length(gosubReturn) >= 1 then
            check_for_loop_stack_before_return;
            line_marker;
            do_return(symbol, line);
            log << "END SUB - RETURN TO ";
            line_marker;
            log << NL;
            flush(log);
          else
            symbol := get_symbol(line);
            error_marker;
            err << "END SUB - RETURN WITHOUT CALL.";
            err << NL;
          end if;
        elsif endOfStatement(symbol) then
          line_marker;
          log << "END";
          log << NL;
          flush(log);
          symbol := "";
          result := FALSE;
        else
          error_marker;
          err << "UNEXPECTED SYMBOL AFTER END ";
          err << literal(symbol);
          err << NL;
        end if;
      elsif symbol = "FOR" then
        variable_name := get_symbol(line);
        symbol := get_symbol(line);
        expect("=", symbol, line);
        num1 := exec_expr(symbol, line);
        setNumericVar(variable_name, num1);
        expect("TO", symbol, line);
        num2 := exec_expr(symbol, line);
        if symbol = "STEP" then
          symbol := get_symbol(line);
          num3 := exec_expr(symbol, line);
        else
          num3 := 1.0;
        end if;
        if (num3 > 0.0 and num1 <= num2) or
           (num3 < 0.0 and num1 >= num2) then
          if symbol = "'" or symbol = "REM" then
            index1 := succ(length(prg[file_line_number].line));
          else
            index1 := length(prg[file_line_number].line) - length(line) + 1;
          end if;
          forLoop := [] (forLoopDescrType.value) & forLoop;
          forLoop[1].varName := variable_name;
          forLoop[1].endValue := num2;
          forLoop[1].stepValue := num3;
          forLoop[1].bodyLine := file_line_number;
          forLoop[1].bodyColumn := index1;
          line_marker;
          log << "FOR ";
          log << variable_name;
          log << "=";
          log << num1;
          log << " TO ";
          log << num2;
          log << " STEP ";
          log << num3;
          log << NL;
          flush(log);
        else
          line_marker;
          log << "EMPTY FOR ";
          log << variable_name;
          log << "=";
          log << num1;
          log << " TO ";
          log << num2;
          log << " STEP ";
          log << num3;
          log << NL;
          if symbol <> "NEXT" then
            param1 := statement_label;
            symbol := find_next(line);
          end if;
          if symbol = "NEXT" then
            symbol := get_symbol(line);
            if not endOfStatement(symbol) then
              if symbol <> variable_name then
                error_marker;
                err << "NEXT ";
                err << symbol;
                err << " DOES NOT FIT TO FOR ";
                err << variable_name;
                err << NL;
              end if;
              repeat
                symbol := get_symbol(line);
              until endOfStatement(symbol);
            end if;
            line_marker;
            log << "CONTINUE AFTER NEXT";
            log << NL;
            flush(log);
          else
            err << " ***** (";
            err << param1;
            err << ") NO CORRESPONDING \"NEXT\" FOUND FOR \"FOR ";
            err << variable_name;
            err << "\"";
            err << NL;
          end if;
        end if;
      elsif symbol = "NEXT" then
        repeat
          symbol := get_symbol(line);
          if length(forLoop) >= 1 then
            if endOfStatement(symbol) then
              variable_name := forLoop[1].varName;
            else
              variable_name := symbol;
              symbol := get_symbol(line);
            end if;
            if variable_name <> forLoop[1].varName then
              index1 := 2;
              while index1 <= length(forLoop) and variable_name <> forLoop[index1].varName do
                incr(index1)
              end while;
              if index1 <= length(forLoop) and variable_name = forLoop[index1].varName then
                for index2 range 1 to pred(index1) do
                  line_marker;
                  log << "THE FOR ";
                  log << forLoop[index2].varName;
                  log << " LOOP SEEMS TO HAVE BEEN LEFT";
                  log << NL;
                  flush(log);
                end for;
                forLoop := forLoop[index1 .. ];
              end if;
            end if;
            if variable_name = forLoop[1].varName then
              num1 := getNumericVar(variable_name);
              if (forLoop[1].stepValue > 0.0 and num1 + forLoop[1].stepValue <= forLoop[1].endValue) or
                 (forLoop[1].stepValue < 0.0 and num1 + forLoop[1].stepValue >= forLoop[1].endValue) then
                line_marker;
                setNumericVar(variable_name, num1 + forLoop[1].stepValue);
                file_line_number := forLoop[1].bodyLine;
                statement_label := prg[file_line_number].linenum;
                line := prg[file_line_number].line[forLoop[1].bodyColumn .. ];
                if line <> "" then
                  symbol := ":";
                else
                  symbol := "";
                end if;
                log << "NEXT ";
                log << variable_name;
                log << " = ";
                log << num1 + forLoop[1].stepValue;
                log << " CONTINUE FOR";
                log << NL;
                flush(log);
              else
                line_marker;
                log << "NEXT ";
                log << variable_name;
                log << " = ";
                log << num1;
                log << " END FOR";
                log << NL;
                flush(log);
                forLoop := forLoop[2 .. ];
              end if;
            else
              error_marker;
              err << "\"NEXT ";
              err << forLoop[1].varName;
              err << "\" EXPECTED - FOUND \"NEXT ";
              err << variable_name;
              err << "\"";
              err << NL;
            end if;
          elsif on_error_label <> "" then
            error_code := 1; # NEXT without FOR
            line_marker;
            log << "NEXT ";
            log << variable_name;
            log << " WITHOUT FOR - ON ERROR GOTO ";
            log << on_error_label;
            log << NL;
            flush(log);
            goto_on_error(on_error_label, line);
            symbol := "";
            line := "";
          else
            error_marker;
            err << "NEXT ";
            err << variable_name;
            err << " WITHOUT FOR";
            err << NL;
          end if;
        until symbol <> ",";
      elsif symbol = "ON" then
        symbol := get_symbol(line);
        if symbol = "ERROR" then
          symbol := get_symbol(line);
          expect("GOTO", symbol, line);
          if symbol = "0" then
            on_error_label := "";
            line_marker;
            log << "**ON ERROR GOTO 0 - DISABLE ERROR HANDLING";
            log << NL;
            flush(log);
            symbol := get_symbol(line);
          elsif label_or_linenum(symbol) then
            on_error_label := symbol;
            line_marker;
            log << "**ON ERROR GOTO ";
            log << literal(symbol);
            log << " LINE: ";
            log << label[symbol];
            log << NL;
            flush(log);
            symbol := get_symbol(line);
          else
            error_marker;
            err << "ON ERROR GOTO NEEDS A LABEL NOT ";
            err << literal(symbol);
            err << ".";
            err << NL;
          end if;
        elsif symbol = "KEY" then
          line_marker;
          log << "**ON KEY ";
          log << line;
          log << NL;
          flush(log);
          repeat
            symbol := get_symbol(line);
          until endOfStatement(symbol);
        elsif symbol = "TIMER" then
          line_marker;
          log << "**ON TIMER ";
          log << line;
          log << NL;
          flush(log);
          repeat
            symbol := get_symbol(line);
          until endOfStatement(symbol);
        else
          index1 := round(exec_expr(symbol, line));
          if symbol = "GOTO" or symbol = "GOSUB" then
            param1 := symbol;
            symbol := get_symbol(line);
            if index1 >= 1 then
              index2 := 1;
              while index2 < index1 do
                symbol := get_symbol(line);
                if symbol = "," then
                  symbol := get_symbol(line);
                  incr(index2);
                else
                  index2 := succ(index1);
                end if;
              end while;
              if index2 = index1 then
                if label_or_linenum(symbol) then
                  line_marker;
                  log << "ON ";
                  log << index1;
                  log << " ";
                  log << param1;
                  log << " ";
                  log << symbol;
                  log << NL;
                  flush(log);
                  if param1 = "GOSUB" then
                    advance_after_statement(line);
                    set_return_position(line);
                    goto_label_or_linenum(symbol);
                    set_sub_entry_position;
                  else
                    goto_label_or_linenum(symbol);
                  end if;
                  symbol := "";
                  line := "";
                else
                  error_marker;
                  err << "UNDEFINED LABEL ";
                  err << symbol;
                  err << " AFTER \"";
                  log << "ON ";
                  log << index1;
                  log << " ";
                  err << param1;
                  err << "\".";
                  err << NL;
                end if;
              else
                line_marker;
                log << "ON ";
                log << index1;
                log << " GOTO NEXT STATEMENT";
                log << NL;
                flush(log);
                while not endOfStatement(symbol) do
                  symbol := get_symbol(line);
                end while;
              end if;
            else
              line_marker;
              log << "ON ";
              log << index1;
              log << " GOTO NEXT STATEMENT";
              log << NL;
              flush(log);
              while not endOfStatement(symbol) do
                symbol := get_symbol(line);
              end while;
            end if;
          else
            error_expect2("GOTO", "GOSUB", symbol);
          end if;
        end if;
      elsif symbol = "WHILE" then
        index1 := file_line_number;
        index2 := length(prg[file_line_number].line) - length(line) + 1;
        symbol := get_symbol(line);
        num1 := exec_expr(symbol, line);
        line_marker;
        log << "WHILE ";
        log << num1;
        log << NL;
        flush(log);
        if num1 <> 0.0 then
          whileLoop := [] (whileLoopDescrType.value) & whileLoop;
          whileLoop[1].condLine := index1;
          whileLoop[1].condColumn := index2;
        else
          line_marker;
          log << "EMPTY WHILE";
          log << NL;
          if symbol <> "WEND" then
            param1 := statement_label;
            symbol := find_wend(line);
          end if;
          if symbol = "WEND" then
            repeat
              symbol := get_symbol(line);
            until endOfStatement(symbol);
            line_marker;
            log << "CONTINUE AFTER WEND";
            log << NL;
            flush(log);
          else
            err << " ***** (";
            err << param1;
            err << ") NO CORRESPONDING \"WEND\" FOUND FOR \"WHILE\"";
            err << NL;
          end if;
        end if;
      elsif symbol = "WEND" then
        if length(whileLoop) >= 1 then
          index1 := whileLoop[1].condLine;
          param2 := prg[index1].line[whileLoop[1].condColumn .. ];
          param1 := get_symbol(param2);
          num1 := exec_expr(param1, param2);
          if num1 <> 0.0 then
            line_marker;
            file_line_number := index1;
            statement_label := prg[file_line_number].linenum;
            symbol := param1;
            line := param2;
            log << "WEND - CONTINUE WHILE";
            log << NL;
            flush(log);
          else
            symbol := get_symbol(line);
            whileLoop := whileLoop[2 .. ];
            line_marker;
            log << "WEND - END WHILE";
            log << NL;
            flush(log);
          end if;
        else
          error_marker;
          err << "UNEXPECTED \"WEND\"";
          err << NL;
        end if;
      elsif symbol = "DO" then
        exec_do(symbol, line);
      elsif symbol = "LOOP" then
        exec_loop(symbol, line);
      elsif symbol = "SELECT" then
        exec_select(symbol, line);
      elsif symbol = "CASE" then
        line_marker;
        log << "CASE - SKIP TO \"END SELECT\"";
        log << NL;
        flush(log);
        symbol := find_end_select(line);
        if symbol = "SELECT" then
          symbol := get_symbol(line);
          line_marker;
          log << "END SELECT";
          log << NL;
          flush(log);
        else
          error_marker;
          err << "NO CORRESPONDING \"END SELECT\" FOUND";
          err << NL;
        end if;
      elsif symbol = "CIRCLE" then
        exec_circle(symbol, line);
      elsif symbol = "PSET" then
        exec_pset(symbol, line);
      elsif symbol = "PRESET" then
        exec_preset(symbol, line);
      elsif symbol = "DRAW" then
        exec_draw(symbol, line);
      elsif symbol = "COLOR" then
        symbol := get_symbol(line);
        foreground_color := round(exec_expr(symbol, line));
        if symbol = "," then
          symbol := get_symbol(line);
          background_color := round(exec_expr(symbol, line));
          if symbol = "," then
            symbol := get_symbol(line);
            index1 := round(exec_expr(symbol, line));
          end if;
        end if;
        line_marker;
        log << "**COLOR ";
        log << foreground_color;
        log << ",";
        log << background_color;
        log << NL;
      elsif symbol = "PUT" or symbol = "PUT#" then
        if symbol = "PUT#" then
          symbol := "#";
        else
          symbol := get_symbol(line);
        end if;
        if symbol = "#" then
          symbol := get_symbol(line);
          index1 := round(exec_expr(symbol, line));
          if file_value[index1] <> STD_NULL then
            line_marker;
            log << "**PUT ";
            log << symbol;
            log << ",";
            log << line;
            log << NL;
            while not endOfStatement(symbol) do
              symbol := get_symbol(line);
            end while
          else
            error_marker;
            err << "FILE #";
            err << index1;
            err << " NOT OPEN IN PUT.";
            err << NL;
          end if;
        else
          exec_put(symbol, line);
        end if;
      elsif symbol = "GET" or symbol = "GET#" then
        if symbol = "GET#" then
          symbol := "#";
        else
          symbol := get_symbol(line);
        end if;
        if symbol = "#" then
          symbol := get_symbol(line);
          index1 := round(exec_expr(symbol, line));
          if file_value[index1] <> STD_NULL then
            line_marker;
            log << "**GET ";
            log << symbol;
            log << ",";
            log << line;
            log << NL;
            while not endOfStatement(symbol) do
              symbol := get_symbol(line);
            end while
          else
            error_marker;
            err << "FILE #";
            err << index1;
            err << " NOT OPEN IN GET.";
            err << NL;
          end if;
        else
          exec_get(symbol, line);
        end if;
      elsif symbol = "SEEK" or symbol = "SEEK#" then
        if symbol = "SEEK#" then
          symbol := get_symbol(line);
        else
          symbol := get_symbol(line);
          if symbol = "#" then
            symbol := get_symbol(line);
          end if;
        end if;
        index1 := round(exec_expr(symbol, line));
        expect(",", symbol, line);
        index2 := round(exec_expr(symbol, line));
        if file_value[index1] <> STD_NULL then
          seek(file_value[index1], index2);
          line_marker;
          log << "SEEK ";
          log << symbol;
          log << ",";
          log << line;
          log << NL;
        else
          error_marker;
          err << "FILE #";
          err << index1;
          err << " NOT OPEN IN SEEK.";
          err << NL;
        end if;
      elsif symbol = "DEF" then
        symbol := get_symbol(line);
        if symbol = "SEG" then
          line_marker;
          log << "**DEF SEG";
          log << NL;
          flush(log);
          while not endOfStatement(symbol) do
            symbol := get_symbol(line);
          end while;
        else
          variable_name := symbol;
          if variable_name[1] >= 'A' and variable_name[1] <= 'Z' then
            define_function(variable_name, symbol, line, TRUE);
          end if;
        end if;
      elsif symbol = "REM" then
        symbol := "";
        line_marker;
        log << "REM ";
        log << line;
        log << NL;
        flush(log);
      elsif symbol = "'" then
        symbol := "";
        line_marker;
        log << "'";
        log << line;
        log << NL;
        flush(log);
      elsif symbol = "CLEAR" then
        symbol := get_symbol(line);
        for index1 range 1 to length(file_value) do
          close(file_value[index1]);
          file_value[index1] := STD_NULL;
        end for;
        numeric_var := numeric_hash.EMPTY_HASH;
        string_var := string_hash.EMPTY_HASH;
        image_var := image_hash.EMPTY_HASH;
        def_fn_list := def_fn_hash.EMPTY_HASH;
        defstr_any := {'\"'};
        defstr_var := (set of char).EMPTY_SET;
        line_marker;
        log << "CLEAR ";
        log << symbol;
        log << NL;
        flush(log);
        while not endOfStatement(symbol) do
          symbol := get_symbol(line);
        end while;
      elsif symbol = "BEEP" then
        symbol := get_symbol(line);
        line_marker;
        log << "**BEEP";
        log << NL;
        flush(log);
      elsif symbol = "SOUND" then
        symbol := get_symbol(line);
        num1 := exec_expr(symbol, line);
        expect(",", symbol, line);
        num2 := exec_expr(symbol, line);
        line_marker;
        log << "**SOUND ";
        log << symbol;
        log << NL;
        flush(log);
      elsif symbol = "DATA" then
        symbol := "";
        line_marker;
        log << "DATA";
        log << NL;
        flush(log);
      elsif symbol = "RESTORE" then
        symbol := get_symbol(line);
        if label_or_linenum(symbol) then
          data_line_number := label[symbol];
          decr(data_line_number);
          data_line := "";
          line_marker;
          log << "RESTORE ";
          log << symbol;
          log << NL;
          flush(log);
          symbol := get_symbol(line);
        else
          data_line_number := 0;
          data_line := "";
          line_marker;
          log << "RESTORE";
          log << NL;
          flush(log);
        end if;
      elsif symbol = "CLS" then
        symbol := get_symbol(line);
        if symbol = "0" or symbol = "1" or symbol = "2" then
          symbol := get_symbol(line);
        end if;
        clear(win);
        line_marker;
        log << "CLS";
        log << NL;
        flush(log);
      elsif symbol = "DIM" then
        line_marker;
        log << "DIM ";
        log << line;
        log << NL;
        flush(log);
        repeat
          symbol := get_symbol(line);
        until endOfStatement(symbol);
      elsif symbol = "REDIM" then
        line_marker;
        log << "REDIM ";
        log << line;
        log << NL;
        flush(log);
        repeat
          symbol := get_symbol(line);
        until endOfStatement(symbol);
      elsif symbol = "DECLARE" then
        symbol := get_symbol(line);
        if symbol = "SUB" then
          symbol := get_symbol(line);
          declared @:= [symbol] file_line_number;
          line_marker;
          log << "**DECLARE SUB ";
          log << symbol;
          log << " ";
          log << line;
          log << NL;
          flush(log);
          repeat
            symbol := get_symbol(line);
          until endOfStatement(symbol);
        elsif symbol = "FUNCTION" then
          symbol := get_symbol(line);
          line_marker;
          log << "**DECLARE FUNCTION ";
          log << symbol;
          log << " ";
          log << line;
          log << NL;
          flush(log);
          repeat
            symbol := get_symbol(line);
          until endOfStatement(symbol);
        else
          error_marker;
          err << "ILLEGAL DECLARE ";
          err << symbol;
          err << NL;
        end if;
      elsif symbol = "OPTION" then
        line_marker;
        log << "OPTION ";
        log << line;
        log << NL;
        flush(log);
        repeat
          symbol := get_symbol(line);
        until endOfStatement(symbol);
      elsif symbol = "SCREEN" then
        exec_screen(symbol, line);
      elsif symbol = "WIDTH" then
        line_marker;
        log << "**WIDTH ";
        log << line;
        log << NL;
        flush(log);
        repeat
          symbol := get_symbol(line);
        until endOfStatement(symbol);
      elsif symbol = "KEY" then
        line_marker;
        log << "**KEY ";
        log << line;
        log << NL;
        flush(log);
        repeat
          symbol := get_symbol(line);
        until endOfStatement(symbol);
      elsif symbol = "RANDOMIZE" then
        symbol := get_symbol(line);
        if not endOfStatement(symbol) then
          num1 := exec_expr(symbol, line);
        end if;
        line_marker;
        log << "RANDOMIZE";
        log << NL;
        flush(log);
      elsif symbol = "RUN" then
        file_line_number := 0;
        symbol := "";
        line := "";
        line_marker;
        log << "RUN";
        log << NL;
        flush(log);
      elsif symbol = "DEFINT" then
        line_marker;
        log << "**DEFINT ";
        log << line;
        log << NL;
        flush(log);
        repeat
          symbol := get_symbol(line);
        until endOfStatement(symbol);
      elsif symbol = "DEFDBL" then
        line_marker;
        log << "**DEFDBL ";
        log << line;
        log << NL;
        flush(log);
        repeat
          symbol := get_symbol(line);
        until endOfStatement(symbol);
      elsif symbol = "DEFSNG" then
        line_marker;
        log << "**DEFSNG ";
        log << line;
        log << NL;
        flush(log);
        repeat
          symbol := get_symbol(line);
        until endOfStatement(symbol);
      elsif symbol = "DEFSTR" then
        symbol := get_symbol(line);
        defstr_any := {'\"'};
        defstr_var := (set of char).EMPTY_SET;
        okay := FALSE;
        repeat
          if length(symbol) = 1 and symbol >= "A" and symbol <= "Z" then
            param1 := symbol;
            symbol := get_symbol(line);
            if symbol = "-" then
              symbol := get_symbol(line);
              if length(symbol) = 1 and symbol >= param1 and symbol <= "Z" then
                param2 := symbol;
                symbol := get_symbol(line);
                for ch1 range param1[1] to param2[1] do
                  incl(defstr_any, ch1);
                  incl(defstr_var, ch1);
                end for;
                line_marker;
                log << "DEFSTR ";
                log << param1;
                log << "-";
                log << param2;
                log << NL;
                flush(log);
              else
                error_marker;
                err << "ILLEGAL DEFSTR ";
                err << param1;
                err << "-";
                err << symbol;
                err << NL;
              end if;
            else
              incl(defstr_any, param1[1]);
              incl(defstr_var, param1[1]);
              line_marker;
              log << "DEFSTR ";
              log << param1;
              log << NL;
              flush(log);
            end if;
          else
            error_marker;
            err << "ILLEGAL DEFSTR ";
            err << symbol;
            err << NL;
          end if;
          if symbol = "," then
            symbol := get_symbol(line);
          else
            okay := TRUE;
          end if;
        until okay;
      elsif symbol = "OPEN" then
        exec_open(symbol, line);
      elsif symbol = "CLOSE" or symbol = "CLOSE#" then
        if symbol = "CLOSE#" then
          symbol := "#";
        else
          symbol := get_symbol(line);
        end if;
        if endOfStatement(symbol) then
          for index1 range 1 to length(file_value) do
            close(file_value[index1]);
            file_value[index1] := STD_NULL;
          end for;
          line_marker;
          log << "CLOSE";
          log << NL;
          flush(log);
        else
          okay := FALSE;
          repeat
            if symbol = "#" then
              symbol := get_symbol(line);
            end if;
            index1 := round(exec_expr(symbol, line));
            close(file_value[index1]);
            file_value[index1] := STD_NULL;
            line_marker;
            log << "CLOSE #";
            log << index1;
            log << NL;
            flush(log);
            if symbol = "," then
              symbol := get_symbol(line);
            else
              okay := TRUE;
            end if;
          until okay;
        end if;
      elsif symbol = "PLAY" then
        symbol := get_symbol(line);
        line_marker;
        log << "**PLAY ";
        log << line;
        log << NL;
        flush(log);
        repeat
          symbol := get_symbol(line);
        until endOfStatement(symbol);
      elsif symbol = "RESET" then
        symbol := get_symbol(line);
        for index1 range 1 to length(file_value) do
          close(file_value[index1]);
          file_value[index1] := STD_NULL;
        end for;
        line_marker;
        log << "RESET";
        log << NL;
        flush(log);
      elsif symbol = "EXIT" then
        symbol := get_symbol(line);
        if symbol = "FOR" then
          param1 := statement_label;
          symbol := find_next(line);
          if symbol = "NEXT" then
            line_marker;
            repeat
              symbol := get_symbol(line);
            until endOfStatement(symbol);
            log << "EXIT FOR";
            log << NL;
            flush(log);
          else
            err << " ***** (";
            err << param1;
            err << ") NO CORRESPONDING \"NEXT\" FOUND FOR \"EXIT FOR\"";
            err << NL;
          end if;
        elsif symbol = "DO" or symbol = "LOOP" then
          param1 := statement_label;
          symbol := find_loop(line);
          if symbol = "LOOP" then
            line_marker;
            repeat
              symbol := get_symbol(line);
            until endOfStatement(symbol);
            log << "EXIT DO";
            log << NL;
            flush(log);
          else
            err << " ***** (";
            err << param1;
            err << ") NO CORRESPONDING \"LOOP\" FOUND FOR \"EXIT DO\"";
            err << NL;
          end if;
        elsif symbol = "SELECT" then
          param1 := statement_label;
          symbol := find_end_select(line);
          if symbol = "SELECT" then
            symbol := get_symbol(line);
            line_marker;
            log << "EXIT SELECT";
            log << NL;
            flush(log);
          else
            err << " ***** (";
            err << param1;
            err << ") NO \"END SELECT\" FOUND";
            err << NL;
          end if;
        elsif symbol = "SUB" then
          if length(gosubReturn) >= 1 then
            check_for_loop_stack_before_return;
            line_marker;
            do_return(symbol, line);
            log << "EXIT SUB - RETURN TO ";
            line_marker;
            log << NL;
            flush(log);
          else
            symbol := get_symbol(line);
            error_marker;
            err << "EXIT SUB - RETURN WITHOUT CALL.";
            err << NL;
          end if;
        else
          error_marker;
          err << "ILLEGAL STATEMENT \"EXIT ";
          err << symbol;
          err << "\"";
          err << NL;
        end if;
      elsif symbol = "PALETTE" then
        line_marker;
        log << "**PALETTE ";
        log << line;
        log << NL;
        flush(log);
        repeat
          symbol := get_symbol(line);
        until endOfStatement(symbol);
      elsif symbol = "PAINT" then
        line_marker;
        log << "**PAINT ";
        log << line;
        log << NL;
        flush(log);
        repeat
          symbol := get_symbol(line);
        until endOfStatement(symbol);
      elsif symbol = "POKE" then
        symbol := get_symbol(line);
        index1 := round(exec_expr(symbol, line));
        expect(",", symbol, line);
        index2 := round(exec_expr(symbol, line));
        line_marker;
        log << "**POKE ";
        log << index1;
        log << ", ";
        log << index2;
        log << NL;
        flush(log);
      elsif symbol = "OUT" then
        symbol := get_symbol(line);
        index1 := round(exec_expr(symbol, line));
        expect(",", symbol, line);
        index2 := round(exec_expr(symbol, line));
        line_marker;
        log << "**OUT ";
        log << index1;
        log << ", ";
        log << index2;
        log << NL;
        flush(log);
      elsif symbol = "SUB" then
        symbol := get_symbol(line);
        line_marker;
        log << "SKIP SUB ";
        log << symbol;
        log << NL;
        flush(log);
        symbol := find_end_sub(line);
        symbol := get_symbol(line);
        line_marker;
        log << "END SKIP SUB ";
        log << symbol;
        log << " ";
        log << line;
        log << NL;
        flush(log);
      elsif symbol = "ERASE" then
        line_marker;
        log << "**ERASE ";
        log << line;
        log << NL;
        flush(log);
        repeat
          symbol := get_symbol(line);
        until endOfStatement(symbol);
      elsif symbol = "COMMON" then
        line_marker;
        log << "**COMMON ";
        log << line;
        log << NL;
        flush(log);
        repeat
          symbol := get_symbol(line);
        until endOfStatement(symbol);
      elsif symbol = "SLEEP" then
        symbol := get_symbol(line);
        if endOfStatement(symbol) then
          index1 := 1;
        else
          index1 := round(exec_expr(symbol, line));
        end if;
        flush(win);
        sleep(index1);
        line_marker;
        log << "SLEEP ";
        log << index1;
        log << NL;
        flush(log);
      elsif symbol = "STOP" or symbol = "SYSTEM" then
        line_marker;
        log << symbol;
        log << NL;
        flush(log);
        symbol := "";
        result := FALSE;
      elsif symbol = "SWAP" then
        symbol := get_symbol(line);
        if isStringVar(symbol) then
          variable_name := get_name(symbol, line);
          expect(",", symbol, line);
          if isStringVar(symbol) then
            variable2_name := get_name(symbol, line);
            param1 := getStringVar(variable_name);
            param2 := getStringVar(variable2_name);
            setStringVar(variable_name, param2);
            setStringVar(variable2_name, param1);
          else
            error_marker;
            err << "STRING VARIABLE EXPECTED - FOUND ";
            err << literal(symbol);
            err << ".";
            err << NL;
          end if;
        else
          variable_name := get_name(symbol, line);
          expect(",", symbol, line);
          if not isStringVar(symbol) then
            variable2_name := get_name(symbol, line);
            num1 := getNumericVar(variable_name);
            num2 := getNumericVar(variable2_name);
            setNumericVar(variable_name, num2);
            setNumericVar(variable2_name, num1);
          else
            error_marker;
            err << "NUMERIC VARIABLE EXPECTED - FOUND ";
            err << literal(symbol);
            err << ".";
            err << NL;
          end if;
        end if;
      elsif symbol = "CALL" then
        symbol := get_symbol(line);
        if symbol in subprogram then
          line_marker;
          log << "CALL ";
          log << symbol;
          log << NL;
          flush(log);
          advance_after_statement(line);
          set_return_position(line);
          file_line_number := subprogram[symbol];
          statement_label := prg[file_line_number].label;
          line := prg[file_line_number].line;
          symbol := get_symbol(line);
          symbol := get_symbol(line);
          set_sub_entry_position;
          line_marker;
          log << "EXECUTE SUB ";
          log << symbol;
          log << NL;
        else
          error_marker;
          err << "CALL UNDEFINED SUB ";
          err << literal(symbol);
          err << ".";
          err << NL;
        end if;
        while not endOfStatement(symbol) do
          symbol := get_symbol(line);
        end while;
      elsif symbol in subprogram then
        line_marker;
        log << "CALL ";
        log << symbol;
        log << NL;
        flush(log);
        advance_after_statement(line);
        set_return_position(line);
        file_line_number := subprogram[symbol];
        statement_label := prg[file_line_number].label;
        line := prg[file_line_number].line;
        symbol := get_symbol(line);
        symbol := get_symbol(line);
        set_sub_entry_position;
        line_marker;
        log << "EXECUTE SUB ";
        log << symbol;
        log << NL;
        while not endOfStatement(symbol) do
          symbol := get_symbol(line);
        end while;
      elsif symbol = "CONST" then
        repeat
          symbol := get_symbol(line);
          if isStringVar(symbol) then
            variable_name := get_name(symbol, line);
            if symbol = "=" then
              symbol := get_symbol(line);
              param3 := exec_str_expr(symbol, line, unused_name);
              setStringVar(variable_name, param3);
              line_marker;
              log << "CONST ";
              log << variable_name;
              log << "=";
              log << literal(param3);
              log << NL;
              flush(log);
            else
              error_marker;
              err << "\"=\" EXPECTED AFTER ";
              err << literal(variable_name);
              err << " - FOUND ";
              err << literal(symbol);
              err << ".";
              err << NL;
            end if;
          else
            variable_name := get_name(symbol, line);
            if symbol = "=" then
              symbol := get_symbol(line);
              num1 := exec_expr(symbol, line);
              setNumericVar(variable_name, num1);
              line_marker;
              log << "CONST ";
              log << variable_name;
              log << "=";
              log << num1;
              log << NL;
              flush(log);
            else
              error_marker;
              err << "\"=\" EXPECTED AFTER ";
              err << literal(variable_name);
              err << " - FOUND ";
              err << literal(symbol);
              err << ".";
              err << NL;
            end if;
          end if;
        until symbol <> ",";
      elsif symbol = "%" then
        variable_name := "";
        repeat
          variable_name &:= symbol;
          symbol := get_symbol(line);
          if symbol <> "" and symbol[1] in alphanum_char then
            variable_name &:= symbol;
            symbol := get_symbol(line);
          end if;
        until symbol <> "_";
        append_index(variable_name, symbol, line);
        if symbol = "=" then
          symbol := get_symbol(line);
          num1 := exec_expr(symbol, line);
          setNumericVar(variable_name, num1);
          line_marker;
          log << variable_name;
          log << "=";
          log << num1;
          log << NL;
          flush(log);
        else
          error_marker;
          err << "\"=\" EXPECTED AFTER ";
          err << literal(variable_name);
          err << " - FOUND ";
          err << literal(symbol);
          err << ".";
          err << NL;
        end if;
      elsif symbol = "RESUME" then
        symbol := get_symbol(line);
        if symbol = "NEXT" then
          if in_error_handler then
            line_marker;
            log << "RESUME NEXT";
            log << NL;
            flush(log);
            do_resume_next(symbol, line);
            if symbol <> "" then
              process_next := TRUE;
            end if;
          else
            error_marker;
            err << "RESUME NEXT - NOT IN ERROR HANDLER.";
            err << NL;
          end if;
        elsif label_or_linenum(symbol) then
          if in_error_handler then
            goto_label_or_linenum(symbol);
            symbol := "";
            line := "";
          else
            error_marker;
            err << "RESUME ";
            err << symbol;
            err << " - NOT IN ERROR HANDLER.";
            err << NL;
          end if;
        elsif symbol = "0" or endOfStatement(symbol) then
          if in_error_handler then
            do_resume_same(symbol, line);
          else
            error_marker;
            err << "RESUME 0 - NOT IN ERROR HANDLER.";
            err << NL;
          end if;
        else
          error_marker;
          err << "RESUME ";
          err << symbol;
          err << " - UNDEFINED RESUME.";
          err << NL;
        end if;
      elsif symbol = "MID$" then
        exec_mid_statement(symbol, line);
      elsif symbol = "INCR" then
        symbol := get_symbol(line);
        if symbol = "=" or symbol = "("  or symbol = "[" then
          exec_let("INCR", symbol, line);
        else
          variable_name := get_name(symbol, line);
          if symbol = "," then
            symbol := get_symbol(line);
            num1 := exec_expr(symbol, line);
          else
            num1 := 1.0;
          end if;
          setNumericVar(variable_name, getNumericVar(variable_name) + num1);
          line_marker;
          log << "INCR ";
          log << variable_name;
          log << " BY ";
          log << num1;
          log << NL;
          flush(log);
        end if;
      elsif symbol = "DECR" then
        symbol := get_symbol(line);
        if symbol = "=" or symbol = "("  or symbol = "[" then
          exec_let("DECR", symbol, line);
        else
          variable_name := get_name(symbol, line);
          if symbol = "," then
            symbol := get_symbol(line);
            num1 := exec_expr(symbol, line);
          else
            num1 := 1.0;
          end if;
          setNumericVar(variable_name, getNumericVar(variable_name) - num1);
          line_marker;
          log << "DECR ";
          log << variable_name;
          log << " BY ";
          log << num1;
          log << NL;
          flush(log);
        end if;
      elsif symbol = "CHAIN" then
        symbol := get_symbol(line);
        if isStringExpr(symbol) then
          param1 := exec_str_expr(symbol, line, variable_name);
          prg := 0 times lineType.value;
          label := label_hash.EMPTY_HASH;
          subprogram := label_hash.EMPTY_HASH;
          declared := label_hash.EMPTY_HASH;
          line_marker;
          log << "CHAIN ";
          log << literal(param1);
          log << NL;
          if load_prog(param1) then
            log << "load_prog finished";
            log << NL;
            line_marker;
            log << "CHAIN ";
            log << literal(param1);
            log << " - ";
            log << length(prg);
            log << " LINES";
            log << NL;
            flush(log);
            file_line_number := 0;
            symbol := "";
            line := "";
          else
            error_marker;
            err << "CHAIN ";
            err << literal(param1);
            err << " - FILE NOT FOUND.";
            err << NL;
          end if;
        else
          error_marker;
          err << "STRING EXPECTED FOR CHAIN - FOUND ";
          err << symbol;
          err << ".";
          err << NL;
        end if;
      elsif symbol = "ERROR" then
        symbol := get_symbol(line);
        error_code := round(exec_expr(symbol, line));
        if on_error_label <> "" then
          line_marker;
          log << "ERROR ";
          log << error_code;
          log << " - ON ERROR GOTO ";
          log << on_error_label;
          log << NL;
          flush(log);
          goto_on_error(on_error_label, line);
          symbol := "";
          line := "";
        else
          error_marker;
          err << "ERROR ";
          err << error_code;
          err << " WITHOUT ON ERROR HANDLER";
          err << NL;
        end if;
      elsif symbol = ":" then
        error_marker;
        err << "UNEXPECTED \":\" - IGNORED.";
        err << NL;
      elsif symbol <> "" then
        if symbol = "LET" then
          symbol := get_symbol(line);
        end if;
        if isStringVar(symbol) then
          variable_name := get_name(symbol, line);
          if symbol = "=" then
            symbol := get_symbol(line);
            param3 := exec_str_expr(symbol, line, unused_name);
            setStringVar(variable_name, param3);
            line_marker;
            log << "LET ";
            log << variable_name;
            log << "=";
            log << literal(param3);
            log << NL;
            flush(log);
          else
            error_marker;
            err << "\"=\" EXPECTED AFTER ";
            err << literal(variable_name);
            err << " - FOUND ";
            err << literal(symbol);
            err << ".";
            err << NL;
          end if;
        else
          variable_name := get_name(symbol, line);
          if symbol = "=" then
            symbol := get_symbol(line);
            num1 := exec_expr(symbol, line);
            setNumericVar(variable_name, num1);
            line_marker;
            log << "LET ";
            log << variable_name;
            log << "=";
            log << num1;
            log << NL;
            flush(log);
          elsif variable_name[.. 3] = "REM" then
            (* When a name is starting with REM and is      *)
            (* not followed by "=" it is treated as remark. *)
            line_marker;
            log << "REM ";
            log << variable_name;
            log << " ";
            log << symbol;
            log << line;
            log << NL;
            flush(log);
            symbol := "";
          else
            error_marker;
            err << "\"=\" EXPECTED AFTER ";
            err << literal(variable_name);
            err << " - FOUND ";
            err << literal(symbol);
            err << ".";
            err << NL;
          end if;
        end if;
      end if;
      if symbol = ":" then
        symbol := get_symbol(line);
        process_next := TRUE;
      end if;
    until not process_next;
    if symbol = "REM" then
      line_marker;
      log << "REM ";
      log << line;
      log << NL;
      flush(log);
    elsif symbol = "'" then
      line_marker;
      log << "'";
      log << line;
      log << NL;
      flush(log);
    elsif symbol = "ELSE" then
      line_marker;
      log << "SKIP ELSE PART - CONTINUE AT NEXT LINE";
      log << NL;
      flush(log);
    elsif symbol <> "" then
      error_marker;
      err << "UNEXPECTED SYMBOL ";
      err << literal(symbol);
      err << ".";
      err << NL;
      repeat
        symbol := get_symbol(line);
      until endOfStatement(symbol);
      if symbol = ":" then
        symbol := get_symbol(line);
        result := exec_cmd(symbol, line);
      end if;
    end if;
  end func;


const proc: exec_lines is func
  local
    var boolean: running is TRUE;
    var string: symbol is "";
    var string: line is "";
  begin
    while running do
      if file_line_number > length(prg) then
        log << "END OF PROGRAM REACHED";
        log << NL;
        flush(log);
        running := FALSE;
      elsif prg[file_line_number].line <> "" then
        statement_label := prg[file_line_number].linenum;
        line := prg[file_line_number].line;
        (* write(file_line_number lpad 5);
        write(" ");
        write(prg[file_line_number].line);
        writeln; *)
        symbol := get_symbol(line);
        running := exec_cmd(symbol, line);
      end if;
      incr(file_line_number);
    end while;
  end func;


const proc: run_prog is func
  begin
    file_line_number := 1;
    exec_lines;
  end func;


const func boolean: not_allowed_as_label (in string: symbol) is
  return
      symbol = "BEEP"      or symbol = "CLEAR"     or symbol = "CLOSE"     or
      symbol = "CLS"       or symbol = "COLOR"     or symbol = "COMMON"    or
      symbol = "CONST"     or symbol = "DATA"      or symbol = "DECLARE"   or
      symbol = "DEF"       or symbol = "DEFDBL"    or symbol = "DEFINT"    or
      symbol = "DEFSNG"    or symbol = "DEFSTR"    or symbol = "DIM"       or
      symbol = "DO"        or symbol = "DRAW"      or symbol = "ELSE"      or
      symbol = "ELSEIF"    or symbol = "END"       or symbol = "ERASE"     or
      symbol = "EXIT"      or symbol = "GET"       or symbol = "IF"        or
      symbol = "INPUT"     or symbol = "KEY"       or symbol = "LET"       or
      symbol = "LOCATE"    or symbol = "LOOP"      or symbol = "NEXT"      or
      symbol = "OPEN"      or symbol = "OPTION"    or symbol = "OUT"       or
      symbol = "PAINT"     or symbol = "PALETTE"   or symbol = "PLAY"      or
      symbol = "POKE"      or symbol = "PRINT"     or symbol = "PUT"       or
      symbol = "RANDOMIZE" or symbol = "READ"      or symbol = "REDIM"     or
      symbol = "REM"       or symbol = "RESET"     or symbol = "RESTORE"   or
      symbol = "RESUME"    or symbol = "RETURN"    or symbol = "SCREEN"    or
      symbol = "SEEK"      or symbol = "SELECT"    or symbol = "SLEEP"     or
      symbol = "STOP"      or symbol = "SUB"       or symbol = "SYSTEM"    or
      symbol = "WEND"      or symbol = "WRITE";


const proc: log_line (in lineType: aLine) is func
  begin
    if aLine.linenum <> "" then
      log << aLine.linenum lpad 5;
      log << " ";
      if aLine.label <> "" then
        log << aLine.label;
        log << ": ";
      end if;
    elsif aLine.label <> "" then
      log << aLine.label & ":" rpad 5;
      log << " ";
    else
      log << "" lpad 5;
      log << " ";
    end if;
    log << aLine.line;
    log << NL;
  end func;


const func boolean: load_prog (in string: name) is func
  result
    var boolean: result is FALSE;
  local
    var file: infile is STD_NULL;
    var integer: file_line_number is 0;
    var string: symbol is "";
    var string: line_number is "";
    var string: line_label is "";
    var string: line is "";
    var string: help_line is "";
    var string: variable_name is "";
    var boolean: control_z is FALSE;
    var boolean: continuation_line is FALSE;
    var integer: number is 1;
    var integer: line_number_incr is 1;
  begin
    if lower(name[length(name) - 3 ..]) <> ".bas" then
      infile := basicOpen(name & ".bas", "r");
    end if;
    if infile = STD_NULL then
      infile := basicOpen(name, "r");
    end if;
    if infile <> STD_NULL then
      repeat
        line := getln(infile);
        for number range 1 to pred(line_number_incr) do
          prg &:= [] (lineType.value);
          log << NL;
        end for;
        file_line_number +:= line_number_incr;
        line_number_incr := 1;
        repeat
          if pos(line, "\Z") <> 0 then
            (* Control-Z is used sometimes as end of file marker *)
            line := line[.. pred(pos(line, "\Z"))];
            control_z := TRUE;
          end if;
          line := trim(line);
          if length(line) >= 2 and line[pred(length(line)) ..] = " _" then
            continuation_line := TRUE;
            line := line[.. pred(length(line))] & getln(infile);
            incr(line_number_incr);
          else
            continuation_line := FALSE;
          end if;
        until not continuation_line;
        if line <> "" then
          if line[1] in digit_char then
            line_number := getDigits(line);
            if line <> "" and line[1] = '.' then
              # Accept line numbers with decimal point
              line_number &:= ".";
              line := line[2 .. ];
              line_number &:= getDigits(line);
            end if;
            while line <> "" and line[1] = ' ' do
              line := line[2 .. ];
            end while;
            if line_number in label then
              err << " ***** LINE NUMBER ";
              err << line_number;
              err << " ALREADY DEFINED AS ";
              err << name;
              err << "(";
              err << label[line_number];
              err << ")";
              err << NL;
            else
              label @:= [line_number] succ(length(prg));
            end if;
          else
            line_number := "";
          end if;
          help_line := line;
          symbol := get_symbol(help_line);
          if symbol = "'" or symbol = "REM" then
            repeat
              symbol := get_symbol(help_line);
            until symbol = "" or symbol = "$";
            symbol := get_symbol(help_line);
            if symbol = "INCLUDE" then
              symbol := get_symbol(help_line);
              if symbol = ":" then
                symbol := get_symbol(help_line);
                if symbol = "'" then
                  symbol := help_line[.. pred(pos(help_line, '\''))];
                  if symbol <> "" then
                    prg &:= [] (lineType.value);
                    prg[length(prg)].fileName := name;
                    prg[length(prg)].fileLine := file_line_number;
                    prg[length(prg)].linenum := line_number;
                    prg[length(prg)].label := line_label;
                    prg[length(prg)].line := line;
                    log_line(prg[length(prg)]);
                    if not load_prog(symbol) then
                      err << " ***** INCLUDE FILE ";
                      err << literal(symbol);
                      err << " NOT FOUND.";
                      err << NL;
                    end if;
                  end if;
                end if;
              end if;
            end if;
          elsif symbol = "#" or symbol = "$" then
            symbol := get_symbol(help_line);
            if symbol = "INCLUDE" then
              symbol := get_symbol(help_line);
              if symbol <> "" and symbol[1] = '"' then
                symbol := symbol[2 ..];
                prg &:= [] (lineType.value);
                prg[length(prg)].fileName := name;
                prg[length(prg)].fileLine := file_line_number;
                prg[length(prg)].linenum := line_number;
                prg[length(prg)].label := line_label;
                prg[length(prg)].line := line;
                log_line(prg[length(prg)]);
                if not load_prog(symbol) then
                  err << " ***** INCLUDE FILE ";
                  err << literal(symbol);
                  err << " NOT FOUND.";
                  err << NL;
                end if;
              end if;
            end if;
          elsif symbol = "SUB" then
            symbol := get_symbol(help_line);
            if symbol in subprogram then
              err << " ***** SUB ";
              err << symbol;
              err << " ALREADY DEFINED AS ";
              err << name;
              err << "(";
              err << subprogram[symbol];
              err << ")";
              err << NL;
            else
              subprogram @:= [symbol] succ(length(prg));
            end if;
            line_label := "";
(*
          elsif symbol = "DEF" then
            symbol := get_symbol(help_line);
            if symbol = "SEG" then
              noop;
            else
              variable_name := symbol;
              if variable_name[1] >= 'A' and variable_name[1] <= 'Z' then
                define_function(variable_name, symbol, help_line, FALSE);
              end if;
            end if;
*)
          elsif symbol = "" or not_allowed_as_label(symbol) or
              symbol in declared then
            line_label := "";
          else
            line_label := symbol;
            symbol := get_symbol(help_line);
            if line_label[1] in letter_char and symbol = ":" then
              if line_label in label then
                err << " ***** LABEL ";
                err << line_label;
                err << " ALREADY DEFINED AS ";
                err << name;
                err << "(";
                err << label[line_label];
                err << ")";
                err << NL;
              else
                label @:= [line_label] succ(length(prg));
              end if;
              line := help_line;
              while line <> "" and line[1] = ' ' do
                line := line[2 .. ];
              end while;
            else
              line_label := "";
            end if;
          end if;
          prg &:= [] (lineType.value);
          prg[length(prg)].fileName := name;
          prg[length(prg)].fileLine := file_line_number;
          prg[length(prg)].linenum := line_number;
          prg[length(prg)].label := line_label;
          prg[length(prg)].line := line;
          log_line(prg[length(prg)]);
        else
          prg &:= [] (lineType.value);
          log << NL;
        end if;
      until eof(infile) or control_z;
      close(infile);
      result := TRUE;
    end if;
  end func;


const proc: main is func
  begin
    if length(argv(PROGRAM)) >= 1 then
      log := open("bas7.log", "w");
      if log = STD_NULL then
        writeln(" ***** Could not open log file.");
      end if;
      err := log;
      if load_prog(argv(PROGRAM)[1]) then
        log << "load_prog finished";
        log << NL;
        # list_prog;
        scr := open(SCREEN);
        cursor(scr, TRUE);
        win := open_window(scr, 1, 1, 35, 150);
        OUT := win;
        IN := KEYBOARD;
        IN := open_echo(IN, OUT);
        IN := open_line(IN);
        run_prog;
      else
        write(" ***** FILE ");
        write(literal(argv(PROGRAM)[1]));
        writeln(" NOT FOUND.");
      end if;
    end if;
  end func;
