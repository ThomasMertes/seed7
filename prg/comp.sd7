
(********************************************************************)
(*                                                                  *)
(*  comp.sd7      Compiler from Seed7 to C                          *)
(*  Copyright (C) 1990 - 1994, 2004, 2005  Thomas Mertes            *)
(*                                                                  *)
(*  This program is free software; you can redistribute it and/or   *)
(*  modify it under the terms of the GNU General Public License as  *)
(*  published by the Free Software Foundation; either version 2 of  *)
(*  the License, or (at your option) any later version.             *)
(*                                                                  *)
(*  This program is distributed in the hope that it will be useful, *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of  *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *)
(*  GNU General Public License for more details.                    *)
(*                                                                  *)
(*  You should have received a copy of the GNU General Public       *)
(*  License along with this program; if not, write to the Free      *)
(*  Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,  *)
(*  MA 02111-1307 USA                                               *)
(*                                                                  *)
(********************************************************************)


$ info off;
$ message "Compiling the compiler ...";
$ include "seed7_05.s7i";
include "float.s7i";
include "progs.s7i";

var program: prog is program.EMPTY;
var file: c_prog is STD_NULL;
var type: typetype is void;
var type: proctype is void;
var type: inttype is void;
var type: chartype is void;
var type: stritype is void;
var type: floattype is void;
var type: voidtype is void;

var ref_list: declared_types is ref_list.EMPTY;

const type: expr_type is new struct
  var integer: temp_num is 0;
  var string: temp_decls is "";
  var string: temp_assigns is "";
  var string: expr is "";
  var string: temp_frees is "";
end struct;

var integer: declaration_count is 1;
var array ref_list: object_value is 0 times ref_list.EMPTY;
var expr_type: global_init is expr_type.value;


const proc: process_action (in reference: procedure, in ref_list: params,
    inout expr_type: c_expr) is forward;
const proc: process_expr (in reference: current_expression, inout expr_type: c_expr) is forward;


const proc: count_declarations is func

  begin
    incr(declaration_count);
    OUT << declaration_count;
    OUT << " ";
    OUT << heapsize(PROGRAM);
    OUT << "     \r";
    flush(OUT);
  end func;


const proc: create_name (in reference: current_object, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= str(obj_number(current_object));
    c_expr.expr &:= "/*";
    c_expr.expr &:= str(current_object);
    c_expr.expr &:= "*/";
  end func;


const proc: process_type (in type: object_type, inout expr_type: c_expr) is func

  begin
    if object_type = typetype then
      c_expr.expr &:= "typetype";
    elsif object_type = inttype then
      c_expr.expr &:= "inttype";
    elsif object_type = chartype then
      c_expr.expr &:= "chartype";
    elsif object_type = stritype then
      c_expr.expr &:= "stritype";
    elsif object_type = floattype then
      c_expr.expr &:= "floattype";
    else
      c_expr.expr &:= "t_";
      c_expr.expr &:= str(type_number(object_type));
      c_expr.expr &:= "/*";
      c_expr.expr &:= str(object_type);
      c_expr.expr &:= "*/";
    end if;
  end func;


const func string: enum_value (in reference: current_object) is func

  result
    var string: result is "";
  local
    var string: object_name is "";
  begin
    object_name := str(current_object);
    if object_name = "FALSE" then
      result := "0";
    elsif object_name = "TRUE" then
      result := "1";
    else
      result := str(obj_number(current_object));
    end if;
  end func;


const proc: reference_value (in reference: current_value,
    inout expr_type: c_expr) is func

  begin
    if current_value = NIL then
      c_expr.expr &:= "NULL";
    else
      c_expr.expr &:= "&(";
      process_expr(current_value, c_expr);
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: ref_list_value (in ref_list: current_value,
    inout expr_type: c_expr) is func

  local
    var reference: element is NIL;
    var boolean: first_element is TRUE;
  begin
    if length(current_value) = 0 then
      c_expr.expr &:= "NULL";
    else
      c_expr.expr &:= "{";
      for element range current_value do
        if first_element then
          first_element := FALSE;
        else
          c_expr.expr &:= ", ";
        end if;
        c_expr.expr &:= "&(";
        process_expr(element, c_expr);
        c_expr.expr &:= ")";
      end for;
      c_expr.expr &:= "}";
    end if;
  end func;


const proc: process_object_value (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var string: objclass is "";
  begin
    objclass := obj_class(current_object);
    if objclass = "TYPEOBJECT" then
      c_expr.expr &:= "NULL";
    elsif objclass = "INTOBJECT" then
      c_expr.expr &:= str(integer value current_object);
    elsif objclass = "CHAROBJECT" then
      c_expr.expr &:= c_literal(char value current_object);
    elsif objclass = "STRIOBJECT" then
      c_expr.expr &:= "NULL";
    elsif objclass = "FLOATOBJECT" then
      c_expr.expr &:= str(float value current_object);
    elsif objclass = "REFOBJECT" then
      reference_value(reference value current_object, c_expr);
    elsif objclass = "REFLISTOBJECT" then
      ref_list_value(ref_list value current_object, c_expr);
    elsif objclass = "FILEOBJECT" then
      c_expr.expr &:= "NULL";
    elsif objclass = "ARRAYOBJECT" then
      c_expr.expr &:= "NULL";
    elsif objclass = "SETOBJECT" then
      c_expr.expr &:= "NULL";
    elsif objclass = "STRUCTOBJECT" then
      c_expr.expr &:= "NULL";
    elsif objclass = "CLASSOBJECT" then
      c_expr.expr &:= "NULL";
    elsif objclass = "WINOBJECT" then
      c_expr.expr &:= "NULL";
    elsif objclass = "CONSTENUMOBJECT" then
      c_expr.expr &:= enum_value(reference value current_object);
    elsif objclass = "VARENUMOBJECT" then
      c_expr.expr &:= enum_value(reference value current_object);
    elsif objclass = "ACTOBJECT" then
      c_expr.expr &:= "NULL";
    else
      c_expr.expr &:= "/* ";
      c_expr.expr &:= objclass;
      c_expr.expr &:= " */";
    end if;
  end func;


const proc: process_locals (in reference: current_object, inout expr_type: c_expr) is func

  local
    var ref_list: objects is ref_list.EMPTY;
    var reference: obj is NIL;
  begin
    objects := locals(current_object);
    for obj range objects do
      process_type(getType(obj), c_expr);
      c_expr.expr &:= " o_";
      create_name(obj, c_expr);
      c_expr.expr &:= "=";
      process_object_value(reference value obj, c_expr);
      c_expr.expr &:= ";\n";
    end for;
  end func;


const proc: declare_type_if_necessary (in type: aType, inout expr_type: c_expr) is func

  local
    var reference: type_obj is NIL;
(*
    var reference: expression is NIL;
    var reference: type_value is NIL;
    var string: objclass is "";
*)
  begin
    type_obj := match_obj(aType);
    if not type_obj in declared_types then
      if aType <> typetype and
          aType <> inttype and
          aType <> chartype and
          aType <> stritype and
          aType <> floattype then
(*
        expression := NIL;
        type_value := evaluate(prog, expression);
        objclass := obj_class(case_labels);
        if objclass = "STRUCTOBJECT" then
          noop;
        else
*)
          c_expr.expr &:= "typedef long ";
          process_type(aType, c_expr);
          c_expr.expr &:= ";\n\n";
(*
        end if;
*)
        incl(declared_types, type_obj);
      end if;
    end if;
  end func;


const proc: process_statements (in expr_type: statements, inout expr_type: c_expr) is func

  begin
    if statements.temp_num <> 0 then
      c_expr.expr &:= statements.temp_decls;
      c_expr.expr &:= statements.temp_assigns;
      c_expr.expr &:= statements.expr;
      c_expr.expr &:= ";";
      c_expr.expr &:= statements.temp_frees;
    else
      c_expr.expr &:= statements.expr;
    end if;
  end func;


const proc: process_else (in reference: else_part, inout expr_type: c_expr) is func

  local
    var string: objclass is "";
    var ref_list: params is ref_list.EMPTY;
    var reference: procedure is NIL;
    var expr_type: c_param2 is expr_type.value;
    var string: action_name is "";
  begin
    objclass := obj_class(else_part);
    if objclass = "MATCHOBJECT" then
      params := ref_list value else_part;
      procedure := params[1];
      params := params[2 ..];
      objclass := obj_class(procedure);
      if objclass = "CONSTENUMOBJECT" then
        process_expr(params[2], c_param2);
        c_expr.expr &:= "\n";
        c_expr.expr &:= "else {";
        process_statements(c_param2, c_expr);
        c_expr.expr &:= ";}";
      elsif objclass = "ACTOBJECT" then
        c_expr.expr &:= "\n";
        c_expr.expr &:= "else ";
        process_action(procedure, params, c_expr);
      else
        c_expr.expr &:= "/*!!! ";
        c_expr.expr &:= objclass;
        c_expr.expr &:= " ";
        c_expr.expr &:= str(procedure);
        c_expr.expr &:= " !!!*/";
      end if;
    else
      c_expr.expr &:= "/*!! ";
      c_expr.expr &:= objclass;
      c_expr.expr &:= " ";
      c_expr.expr &:= str(else_part);
      c_expr.expr &:= " !!*/";
    end if
  end func;


const proc: process_prc_if (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param2 is expr_type.value;
    var expr_type: c_param4 is expr_type.value;
  begin
    process_expr(params[2], c_param2);
    process_expr(params[4], c_param4);
    if c_param2.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param2.temp_decls;
      c_expr.expr &:= c_param2.temp_assigns;
      c_expr.expr &:= "if (";
      c_expr.expr &:= c_param2.expr;
      c_expr.expr &:= ") {\n";
      process_statements(c_param4, c_expr);
      c_expr.expr &:= ";}";
      c_expr.expr &:= c_param2.temp_frees;
      c_expr.expr &:= "}";
    else
      c_expr.expr &:= "if (";
      c_expr.expr &:= c_param2.expr;
      c_expr.expr &:= ") {\n";
      process_statements(c_param4, c_expr);
      c_expr.expr &:= ";}";
    end if;
  end func;


const proc: process_prc_if_elsif (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param2 is expr_type.value;
    var expr_type: c_param4 is expr_type.value;
    var expr_type: c_param5 is expr_type.value;
  begin
    process_expr(params[2], c_param2);
    process_expr(params[4], c_param4);
    c_param5.temp_num := c_param2.temp_num;
    process_else(params[5], c_param5);
    if c_param5.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param2.temp_decls;
      c_expr.expr &:= c_param5.temp_decls;
      c_expr.expr &:= c_param2.temp_assigns;
      c_expr.expr &:= c_param5.temp_assigns;
      c_expr.expr &:= "if (";
      c_expr.expr &:= c_param2.expr;
      c_expr.expr &:= ") {\n";
      process_statements(c_param4, c_expr);
      c_expr.expr &:= ";}";
      c_expr.expr &:= c_param5.expr;
      c_expr.expr &:= c_param2.temp_frees;
      c_expr.expr &:= c_param5.temp_frees;
      c_expr.expr &:= "}";
    else
      c_expr.expr &:= "if (";
      c_expr.expr &:= c_param2.expr;
      c_expr.expr &:= ") {\n";
      process_statements(c_param4, c_expr);
      c_expr.expr &:= ";}";
      c_expr.expr &:= c_param5.expr;
    end if;
  end func;


const proc: process_prc_while (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "while (";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ") {";
    c_expr.expr &:= "\n";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ";}";
  end func;


const proc: process_prc_repeat (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "do {";
    c_expr.expr &:= "\n";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ";} while (!(";
    process_expr(params[4], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_prc_for_downto (in ref_list: params, inout expr_type: c_expr) is func

  local
    var integer: temp_num is 0;
  begin
    incr(c_expr.temp_num);
    temp_num := c_expr.temp_num;
    c_expr.temp_decls &:= "inttype tmp_e_";
    c_expr.temp_decls &:= str(temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.expr &:= "{tmp_e_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "=(";
    process_expr(params[6], c_expr);
    c_expr.expr &:= ");\n";
    c_expr.expr &:= "for (";
    process_expr(params[2], c_expr);
    c_expr.expr &:= "=(";
    process_expr(params[4], c_expr);
    c_expr.expr &:= "); ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ">=tmp_e_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "; (";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")--) {\n";
    process_expr(params[8], c_expr);
    c_expr.expr &:= ";}}";
  end func;


const proc: process_prc_for_to (in ref_list: params, inout expr_type: c_expr) is func

  local
    var integer: temp_num is 0;
  begin
    incr(c_expr.temp_num);
    temp_num := c_expr.temp_num;
    c_expr.temp_decls &:= "inttype tmp_e_";
    c_expr.temp_decls &:= str(temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.expr &:= "{tmp_e_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "=(";
    process_expr(params[6], c_expr);
    c_expr.expr &:= ");\n";
    c_expr.expr &:= "for (";
    process_expr(params[2], c_expr);
    c_expr.expr &:= "=(";
    process_expr(params[4], c_expr);
    c_expr.expr &:= "); ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= "<=tmp_e_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "; (";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")++) {\n";
    process_expr(params[8], c_expr);
    c_expr.expr &:= ";}}";
  end func;


const proc: process_bitset (in bitset: currentSet, inout expr_type: c_expr) is func

  local
    var integer: number is 0;
  begin
    for number range min(currentSet) to max(currentSet) do
      if number in currentSet then
        c_expr.expr &:= "case ";
        c_expr.expr &:= str(number);
        c_expr.expr &:= ":\n";
      end if;
    end for;
  end func;


const proc: process_case_labels (in reference: current_expression, inout expr_type: c_expr) is func

  local
    var reference: case_labels is NIL;
    var string: objclass is "";
  begin
    case_labels := evaluate(prog, current_expression);
    objclass := obj_class(case_labels);
    if objclass = "SETOBJECT" then
      process_bitset(bitset value case_labels, c_expr);
    else
      c_expr.expr &:= "/* case ";
      c_expr.expr &:= objclass;
      c_expr.expr &:= " */";
    end if;
  end func;


const proc: process_when (in reference: when_expr, inout expr_type: c_expr) is func

  local
    var ref_list: params is ref_list.EMPTY;
    var reference: procedure is NIL;
  begin
    params := ref_list value when_expr;
    procedure := params[1];
    params := params[2 ..];
    process_case_labels(params[2], c_expr);
    process_expr(params[4], c_expr);
    c_expr.expr &:= ";break;\n";
    if length(params) >= 5 then
      process_when(params[5], c_expr);
    end if;
  end func;


const proc: process_prc_case (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "switch (";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ") {\n";
    process_when(params[4], c_expr);
    c_expr.expr &:= "}";
  end func;


const proc: process_prc_case_def (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "switch (";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ") {\n";
    process_when(params[4], c_expr);
    c_expr.expr &:= "default:\n";
    process_expr(params[7], c_expr);
    c_expr.expr &:= ";}";
  end func;


const proc: process_prc_block (in ref_list: params, inout expr_type: c_expr) is func

  begin
    process_expr(params[2], c_expr);
  end func;


const proc: process_procedure (in reference: procedure,
    in ref_list: formal_params, in ref_list: actual_params,
    inout expr_type: c_expr) is forward;


const proc: process_prc_dynamic (in reference: procedure, in ref_list: params,
    inout expr_type: c_expr) is func

  local
    var reference: obj is NIL;
    var string: objclass is "";
    var boolean: first_element is TRUE;
  begin
    process_procedure(procedure, params(procedure), params, c_expr);
  end func;


const proc: process_prc_exit (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "exit(0)";
  end func;


const proc: process_prc_semicol (in ref_list: params, inout expr_type: c_expr) is func

  begin
    process_expr(params[1], c_expr);
    c_expr.expr &:= ";";
    c_expr.expr &:= "\n";
    process_expr(params[3], c_expr);
  end func;


const proc: do_noop_param(in reference: formal_param, in reference: actual_param,
    inout expr_type: c_expr) is func

  local
    var string: objclass is "";
    var type: object_type is void;
  begin
    objclass := obj_class(actual_param);
    if objclass <> "SYMBOLOBJECT" then
      object_type := getType(formal_param);
      if is_func(object_type) or is_varfunc(object_type) then
        c_expr.expr &:= "/*expression*/";
(*
        if getType(formal_param) <> getType(actual_param) then
          PRINT("***###***\n");
        end if;
        object_type := result_type(object_type);
        TRACE(object_type); PRINT("\n");
        TRACE_OBJ(actual_param); PRINT("\n\n");
*)
      else
        process_expr(actual_param, c_expr);
        c_expr.expr &:= ";";
      end if;
    else
      c_expr.expr &:= "/*";
      c_expr.expr &:= str(actual_param);
      c_expr.expr &:= "*/";
    end if;
  end func;


const proc: noop_params (in ref_list: formal_params,
    in ref_list: actual_params, inout expr_type: c_expr) is func

  local
    var integer: number is 0;
  begin
    for number range 1 to length(formal_params) do
      if number <= length(actual_params) then
        do_noop_param(formal_params[number], actual_params[number], c_expr);
      end if;
    end for;
  end func;


const proc: process_prc_other_noop (in reference: procedure, in ref_list: params,
    inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "/*noop*/";
    noop_params(params(procedure), params, c_expr);
  end func;


const proc: process_prc_noop (in reference: procedure, in ref_list: params,
    inout expr_type: c_expr) is func

  begin
    if length(params) = 3 and str(params[2]) = ";" then
      process_prc_semicol(params, c_expr);
    else
      process_prc_other_noop(procedure, params, c_expr);
    end if;
  end func;


const proc: process_prc_args (in ref_list: params, inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.temp_decls &:= "arraytype tmp_";
    c_expr.temp_decls &:= str(c_expr.temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_frees &:= "arr_free(tmp_";
    c_expr.temp_frees &:= str(c_expr.temp_num);
    c_expr.temp_frees &:= ");\n";
    c_expr.expr &:= "(tmp_";
    c_expr.expr &:= str(c_expr.temp_num);
    c_expr.expr &:= "=prc_args())";
  end func;


const proc: process_prc_print (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "prc_print(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_act_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "=(";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= ");\n";
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}";
    else
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "=(";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process_act_str (in ref_list: params, inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.temp_decls &:= "stritype tmp_";
    c_expr.temp_decls &:= str(c_expr.temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_frees &:= "str_free(tmp_";
    c_expr.temp_frees &:= str(c_expr.temp_num);
    c_expr.temp_frees &:= ");\n";
    c_expr.expr &:= "(tmp_";
    c_expr.expr &:= str(c_expr.temp_num);
    c_expr.expr &:= "=act_str(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_act_value (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "act_value(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_arr_arrlit (in ref_list: params, inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.temp_decls &:= "arraytype tmp_";
    c_expr.temp_decls &:= str(c_expr.temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_frees &:= "arr_free(tmp_";
    c_expr.temp_frees &:= str(c_expr.temp_num);
    c_expr.temp_frees &:= ");\n";
    c_expr.expr &:= "(tmp_";
    c_expr.expr &:= str(c_expr.temp_num);
    c_expr.expr &:= "=arr_arrlit(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_arr_arrlit2 (in ref_list: params, inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.temp_decls &:= "arraytype tmp_";
    c_expr.temp_decls &:= str(c_expr.temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_frees &:= "arr_free(tmp_";
    c_expr.temp_frees &:= str(c_expr.temp_num);
    c_expr.temp_frees &:= ");\n";
    c_expr.expr &:= "(tmp_";
    c_expr.expr &:= str(c_expr.temp_num);
    c_expr.expr &:= "=arr_arrlit2(";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_arr_baselit (in ref_list: params, inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.temp_decls &:= "arraytype tmp_";
    c_expr.temp_decls &:= str(c_expr.temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_frees &:= "arr_free(tmp_";
    c_expr.temp_frees &:= str(c_expr.temp_num);
    c_expr.temp_frees &:= ");\n";
    c_expr.expr &:= "(tmp_";
    c_expr.expr &:= str(c_expr.temp_num);
    c_expr.expr &:= "=arr_baselit(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_arr_baselit2 (in ref_list: params, inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.temp_decls &:= "arraytype tmp_";
    c_expr.temp_decls &:= str(c_expr.temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_frees &:= "arr_free(tmp_";
    c_expr.temp_frees &:= str(c_expr.temp_num);
    c_expr.temp_frees &:= ");\n";
    c_expr.expr &:= "(tmp_";
    c_expr.expr &:= str(c_expr.temp_num);
    c_expr.expr &:= "=arr_baselit2(";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_arr_cat (in ref_list: params, inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.temp_decls &:= "arraytype tmp_";
    c_expr.temp_decls &:= str(c_expr.temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_frees &:= "arr_free(tmp_";
    c_expr.temp_frees &:= str(c_expr.temp_num);
    c_expr.temp_frees &:= ");\n";
    c_expr.expr &:= "(tmp_";
    c_expr.expr &:= str(c_expr.temp_num);
    c_expr.expr &:= "=arr_cat(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_arr_conv (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_arr_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
      c_expr.expr &:= "arr_cpy(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= ", ";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= ");\n";
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}";
    else
      c_expr.expr &:= "arr_cpy(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= ", ";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process_arr_extend (in ref_list: params, inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.temp_decls &:= "arraytype tmp_";
    c_expr.temp_decls &:= str(c_expr.temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_frees &:= "arr_free(tmp_";
    c_expr.temp_frees &:= str(c_expr.temp_num);
    c_expr.temp_frees &:= ");\n";
    c_expr.expr &:= "(tmp_";
    c_expr.expr &:= str(c_expr.temp_num);
    c_expr.expr &:= "=arr_extend(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_arr_gen (in ref_list: params, inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.temp_decls &:= "arraytype tmp_";
    c_expr.temp_decls &:= str(c_expr.temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_frees &:= "arr_free(tmp_";
    c_expr.temp_frees &:= str(c_expr.temp_num);
    c_expr.temp_frees &:= ");\n";
    c_expr.expr &:= "(tmp_";
    c_expr.expr &:= str(c_expr.temp_num);
    c_expr.expr &:= "=arr_gen(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_arr_head (in ref_list: params, inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.temp_decls &:= "arraytype tmp_";
    c_expr.temp_decls &:= str(c_expr.temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_frees &:= "arr_free(tmp_";
    c_expr.temp_frees &:= str(c_expr.temp_num);
    c_expr.temp_frees &:= ");\n";
    c_expr.expr &:= "(tmp_";
    c_expr.expr &:= str(c_expr.temp_num);
    c_expr.expr &:= "=arr_head(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_arr_idx (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "((arraytype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "))->arr[";
    process_expr(params[3], c_expr);
    c_expr.expr &:= "]";
  end func;


const proc: process_arr_lng (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "((arraytype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "))->size";
  end func;


const proc: process_arr_range (in ref_list: params, inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.temp_decls &:= "arraytype tmp_";
    c_expr.temp_decls &:= str(c_expr.temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_frees &:= "arr_free(tmp_";
    c_expr.temp_frees &:= str(c_expr.temp_num);
    c_expr.temp_frees &:= ");\n";
    c_expr.expr &:= "(tmp_";
    c_expr.expr &:= str(c_expr.temp_num);
    c_expr.expr &:= "=arr_range(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_arr_tail (in ref_list: params, inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.temp_decls &:= "arraytype tmp_";
    c_expr.temp_decls &:= str(c_expr.temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_frees &:= "arr_free(tmp_";
    c_expr.temp_frees &:= str(c_expr.temp_num);
    c_expr.temp_frees &:= ");\n";
    c_expr.expr &:= "(tmp_";
    c_expr.expr &:= str(c_expr.temp_num);
    c_expr.expr &:= "=arr_tail(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_arr_times (in ref_list: params, inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.temp_decls &:= "arraytype tmp_";
    c_expr.temp_decls &:= str(c_expr.temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_frees &:= "arr_free(tmp_";
    c_expr.temp_frees &:= str(c_expr.temp_num);
    c_expr.temp_frees &:= ");\n";
    c_expr.expr &:= "(tmp_";
    c_expr.expr &:= str(c_expr.temp_num);
    c_expr.expr &:= "=arr_times(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_bln_and (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") && (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_bln_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "=(";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= ");\n";
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}";
    else
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "=(";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process_bln_eq (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") == (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_bln_ge (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") >= (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_bln_gt (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") > (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_bln_iconv (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ") & 1";
  end func;


const proc: process_bln_le (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") <= (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_bln_lt (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") < (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_bln_ne (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") != (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_bln_not (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "!(";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_bln_or (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") || (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_bln_ord (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(inttype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_chr_chr (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(chartype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_chr_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "=(";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= ");\n";
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}";
    else
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "=(";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process_chr_decr (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "--(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_chr_eq (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") == (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_chr_ge (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") >= (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_chr_grow (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= " += (";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= ");\n";
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}";
    else
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= " += (";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process_chr_gt (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") > (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_chr_hashcode (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(inttype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_chr_iconv (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(chartype)(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_chr_incr (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "++(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_chr_le (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") <= (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_chr_low (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "tolower(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_chr_lt (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") < (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_chr_ne (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") != (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_chr_ord (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(inttype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_chr_pred (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")-1";
  end func;


const proc: process_chr_shrink (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= " -= (";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= ");\n";
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}";
    else
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= " -= (";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process_chr_str (in ref_list: params, inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.temp_decls &:= "stritype tmp_";
    c_expr.temp_decls &:= str(c_expr.temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_frees &:= "str_free(tmp_";
    c_expr.temp_frees &:= str(c_expr.temp_num);
    c_expr.temp_frees &:= ");\n";
    c_expr.expr &:= "(tmp_";
    c_expr.expr &:= str(c_expr.temp_num);
    c_expr.expr &:= "=chr_str(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_chr_succ (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")+1";
  end func;


const proc: process_chr_up (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "toupper(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_chr_value (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "chr_value(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_cls_conv2 (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_drw_arc (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwArc(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[6], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_drw_arc2 (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwArc2(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[6], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_drw_background (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwBackground(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_drw_circle (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwCircle(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_drw_clear (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwClear(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_drw_color (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwColor(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_drw_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
      c_expr.expr &:= "drw_cpy(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= ", ";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= ");\n";
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}";
    else
      c_expr.expr &:= "drw_cpy(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= ", ";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process_drw_eq (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") == (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_drw_farcchord (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwFArcChord(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[6], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_drw_farcpieslice(in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwFArcPieSlice(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[6], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_drw_fcircle (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwFCircle(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_drw_fellipse (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwFEllipse(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_drw_flush (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwFlush()";
  end func;


const proc: process_drw_get (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwGet(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_drw_height (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwHeight(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_drw_image (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwImage(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", 0, 0"; (* This is just a hack: This function will not work *)
    c_expr.expr &:= ")";
  end func;


const proc: process_drw_line (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwLine(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_drw_ne (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") != (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_drw_new_pixmap (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwNewPixmap(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_drw_open (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwOpen(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_drw_point (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwPoint(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_drw_ppoint (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwPPoint(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_drw_prect (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwPRect(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[6], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_drw_put (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwPut(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_drw_rect (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwRect(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_drw_rgbcol (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwRgbColor(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_drw_text (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwText(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_drw_width (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwWidth(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_enu_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "=(";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= ");\n";
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}";
    else
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "=(";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process_enu_eq (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") == (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_enu_ne (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") != (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_enu_value (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "enu_value(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_fil_close (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "fclose(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_fil_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "=(";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= ");\n";
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}";
    else
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "=(";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process_fil_getc (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "fgetc(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_fil_eq (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") == (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_fil_eof (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "feof((FILE *)";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_fil_flush (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "fflush(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_fil_l_rd (in ref_list: params, inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.temp_decls &:= "stritype tmp_";
    c_expr.temp_decls &:= str(c_expr.temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_frees &:= "str_free(tmp_";
    c_expr.temp_frees &:= str(c_expr.temp_num);
    c_expr.temp_frees &:= ");\n";
    c_expr.expr &:= "(tmp_";
    c_expr.expr &:= str(c_expr.temp_num);
    c_expr.expr &:= "=filLineRead(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_fil_lng (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "filLng(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_fil_ne (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") != (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_fil_nil (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "NULL";
  end func;


const proc: process_fil_open (in ref_list: params, inout expr_type: c_expr) is func

  local
    var integer: temp_num is 0;
  begin
    incr(c_expr.temp_num);
    temp_num := c_expr.temp_num;
    c_expr.temp_decls &:= "char *tmp_fname_";
    c_expr.temp_decls &:= str(temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_decls &:= "char *tmp_access_";
    c_expr.temp_decls &:= str(temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_frees &:= "free(tmp_fname_";
    c_expr.temp_frees &:= str(temp_num);
    c_expr.temp_frees &:= ");\n";
    c_expr.temp_frees &:= "free(tmp_access_";
    c_expr.temp_frees &:= str(temp_num);
    c_expr.temp_frees &:= ");\n";
    c_expr.expr &:= "fopen(tmp_fname_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "=str_to_cstri(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "), tmp_access_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "=str_to_cstri(";
    process_expr(params[2], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_fil_stri_read (in ref_list: params, inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.temp_decls &:= "stritype tmp_";
    c_expr.temp_decls &:= str(c_expr.temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_frees &:= "str_free(tmp_";
    c_expr.temp_frees &:= str(c_expr.temp_num);
    c_expr.temp_frees &:= ");\n";
    c_expr.expr &:= "(tmp_";
    c_expr.expr &:= str(c_expr.temp_num);
    c_expr.expr &:= "=filStriRead(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_fil_seek (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "fseek(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", (";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ") - 1, SEEK_SET)";
  end func;


const proc: process_fil_tell (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "ftell(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_fil_write (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "filWrite(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_fil_word_read (in ref_list: params, inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.temp_decls &:= "stritype tmp_";
    c_expr.temp_decls &:= str(c_expr.temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_frees &:= "str_free(tmp_";
    c_expr.temp_frees &:= str(c_expr.temp_num);
    c_expr.temp_frees &:= ");\n";
    c_expr.expr &:= "(tmp_";
    c_expr.expr &:= str(c_expr.temp_num);
    c_expr.expr &:= "=filWordRead(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_flt_a2tan (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "atan2(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_abs (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "fabs(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_add (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") + (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_acos (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "acos(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_asin (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "asin(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_atan (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "atan(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_ceil (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "ceil(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_cos (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "cos(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "=(";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= ");\n";
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}";
    else
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "=(";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process_flt_dgts (in ref_list: params, inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.temp_decls &:= "stritype tmp_";
    c_expr.temp_decls &:= str(c_expr.temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_frees &:= "str_free(tmp_";
    c_expr.temp_frees &:= str(c_expr.temp_num);
    c_expr.temp_frees &:= ");\n";
    c_expr.expr &:= "(tmp_";
    c_expr.expr &:= str(c_expr.temp_num);
    c_expr.expr &:= "=fltDgts(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_flt_div (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") / (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_eq (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") == (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_exp (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "exp(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_floor (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "floor(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_ge (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") >= (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_gt (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") > (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_iflt (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(float)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_ipow (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "fltIpow(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_le (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") <= (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_log (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "log(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_lt (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") < (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_minus (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "-(";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_mult (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") * (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_ne (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") != (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_parse (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "fltParse(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_pow (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "fltPow(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_rand (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "fltRand(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_round (in ref_list: params, inout expr_type: c_expr) is func

  local
    var integer: temp_num is 0;
  begin
    incr(c_expr.temp_num);
    temp_num := c_expr.temp_num;
    c_expr.temp_decls &:= "floattype tmp_a_";
    c_expr.temp_decls &:= str(temp_num);
    c_expr.temp_decls &:= ";\n";
    (* Formula used: (a<0.0?-((inttype)(0.5-a)):(inttype)(0.5+a)) *)
    c_expr.expr &:= "(tmp_a_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "=(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "),tmp_a_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "<0.0?-((inttype)(0.5-tmp_a_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= ")):(inttype)(0.5+tmp_a_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "))";
  end func;


const proc: process_flt_sbtr (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") - (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_sin (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "sin(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_sqrt (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "sqrt(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_str (in ref_list: params, inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.temp_decls &:= "stritype tmp_";
    c_expr.temp_decls &:= str(c_expr.temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_frees &:= "str_free(tmp_";
    c_expr.temp_frees &:= str(c_expr.temp_num);
    c_expr.temp_frees &:= ");\n";
    c_expr.expr &:= "(tmp_";
    c_expr.expr &:= str(c_expr.temp_num);
    c_expr.expr &:= "=fltStr(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_flt_tan (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "tan(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_trunc (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(inttype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_value (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "flt_value(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_gkb_getc (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "gkbGetc()";
  end func;


const proc: process_gkb_keypressed (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "gkbKeyPressed()";
  end func;


const proc: process_gkb_line_read (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "gkb_line_read(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_gkb_raw_getc (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "gkbRawGetc()";
  end func;


const proc: process_gkb_word_read (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "gkb_word_read(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_hsh_contains (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "hsh_contains(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_hsh_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param2 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param2.temp_num := c_param1.temp_num;
    process_expr(params[2], c_param2);
    if c_param2.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param2.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param2.temp_assigns;
      c_expr.expr &:= "hsh_cpy(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= ", ";
      c_expr.expr &:= c_param2.expr;
      c_expr.expr &:= ", ";
      process_expr(params[3], c_expr);
      c_expr.expr &:= ", ";
      process_expr(params[4], c_expr);
      c_expr.expr &:= ", ";
      process_expr(params[5], c_expr);
      c_expr.expr &:= ", ";
      process_expr(params[6], c_expr);
      c_expr.expr &:= ");\n";
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param2.temp_frees;
      c_expr.expr &:= "}";
    else
      c_expr.expr &:= "hsh_cpy(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= ", ";
      c_expr.expr &:= c_param2.expr;
      c_expr.expr &:= ", ";
      process_expr(params[3], c_expr);
      c_expr.expr &:= ", ";
      process_expr(params[4], c_expr);
      c_expr.expr &:= ", ";
      process_expr(params[5], c_expr);
      c_expr.expr &:= ", ";
      process_expr(params[6], c_expr);
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process_hsh_create (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param2 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param2.temp_num := c_param1.temp_num;
    process_expr(params[2], c_param2);
    if c_param2.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param2.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param2.temp_assigns;
      c_expr.expr &:= "hsh_create(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= ", ";
      c_expr.expr &:= c_param2.expr;
      c_expr.expr &:= ", ";
      process_expr(params[3], c_expr);
      c_expr.expr &:= ", ";
      process_expr(params[4], c_expr);
      c_expr.expr &:= ", ";
      process_expr(params[5], c_expr);
      c_expr.expr &:= ", ";
      process_expr(params[6], c_expr);
      c_expr.expr &:= ");\n";
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param2.temp_frees;
      c_expr.expr &:= "}";
    else
      c_expr.expr &:= "hsh_create(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= ", ";
      c_expr.expr &:= c_param2.expr;
      c_expr.expr &:= ", ";
      process_expr(params[3], c_expr);
      c_expr.expr &:= ", ";
      process_expr(params[4], c_expr);
      c_expr.expr &:= ", ";
      process_expr(params[5], c_expr);
      c_expr.expr &:= ", ";
      process_expr(params[6], c_expr);
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process_hsh_destr (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "hsh_destr(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_hsh_excl (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "hsh_excl(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[6], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_hsh_idx (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "hsh_idx(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_hsh_incl (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "hsh_incl(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[6], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[7], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[8], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_abs (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "labs(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_add (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") + (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_binom (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "intBinom(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_conv (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "=(";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= ");\n";
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}";
    else
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "=(";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process_int_decr (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "--(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_div (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") / (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_eq (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") == (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_fact (in ref_list: params, inout expr_type: c_expr) is func

  local
    var integer: temp_num is 0;
  begin
    incr(c_expr.temp_num);
    temp_num := c_expr.temp_num;
    c_expr.temp_decls &:= "inttype tmp_";
    c_expr.temp_decls &:= str(temp_num);
    c_expr.temp_decls &:= ";\n";
    (* Formula used: (i<0||i>12?0:fact[i]) *)
    c_expr.expr &:= "(tmp_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "=(";
    process_expr(params[2], c_expr);
    c_expr.expr &:= "),(tmp_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "<0||tmp_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= ">12?0:fact[tmp_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "]))";
  end func;


const proc: process_int_ge (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") >= (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_grow (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= " += (";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= ");\n";
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}";
    else
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= " += (";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process_int_gt (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") > (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_hashcode (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_hsize (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "int_hsize()";
  end func;


const proc: process_int_incr (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "++(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_ld (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "intLd(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_le (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") <= (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_lt (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") < (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_mdiv (in ref_list: params, inout expr_type: c_expr) is func

  local
    var integer: temp_num is 0;
  begin
    incr(c_expr.temp_num);
    temp_num := c_expr.temp_num;
    c_expr.temp_decls &:= "inttype tmp_a_";
    c_expr.temp_decls &:= str(temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_decls &:= "inttype tmp_b_";
    c_expr.temp_decls &:= str(temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_decls &:= "inttype tmp_c_";
    c_expr.temp_decls &:= str(temp_num);
    c_expr.temp_decls &:= ";\n";
    (* Formula used: (c=a/b,((a>0&&b<0)||(a<0&&b>0))&&a%b!=0?c-1:c) *)
    c_expr.expr &:= "(tmp_a_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "=(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "),tmp_b_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "=(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= "),tmp_c_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "=tmp_a_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "/tmp_b_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= ",((tmp_a_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= ">0&&tmp_b_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "<0)||(tmp_a_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "<0&&tmp_b_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= ">0))&&tmp_a_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "%tmp_b_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "!=0?tmp_c_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "-1:tmp_c_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_minus (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "-(";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_mod (in ref_list: params, inout expr_type: c_expr) is func

  local
    var integer: temp_num is 0;
  begin
    incr(c_expr.temp_num);
    temp_num := c_expr.temp_num;
    c_expr.temp_decls &:= "inttype tmp_a_";
    c_expr.temp_decls &:= str(temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_decls &:= "inttype tmp_b_";
    c_expr.temp_decls &:= str(temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_decls &:= "inttype tmp_c_";
    c_expr.temp_decls &:= str(temp_num);
    c_expr.temp_decls &:= ";\n";
    (* Formula used: (c=a%b,((a>0&&b<0)||(a<0&&b>0))&&c!=0?c+b:c) *)
    c_expr.expr &:= "(tmp_a_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "=(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "),tmp_b_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "=(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= "),tmp_c_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "=tmp_a_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "%tmp_b_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= ",((tmp_a_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= ">0&&tmp_b_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "<0)||(tmp_a_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "<0&&tmp_b_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= ">0))&&tmp_c_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "!=0?tmp_c_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "+tmp_b_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= ":tmp_c_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_mult (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") * (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_ne (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") != (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_odd (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")&1";
  end func;


const proc: process_int_ord (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_parse (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "intParse(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_pow (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "intPow(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_pred (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")-1";
  end func;


const proc: process_int_rand (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "intRand(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_rem (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") % (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_sbtr (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") - (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_shrink (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= " -= (";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= ");\n";
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}";
    else
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= " -= (";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process_int_sqrt (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "intSqrt(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_str (in ref_list: params, inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.temp_decls &:= "stritype tmp_";
    c_expr.temp_decls &:= str(c_expr.temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_frees &:= "str_free(tmp_";
    c_expr.temp_frees &:= str(c_expr.temp_num);
    c_expr.temp_frees &:= ");\n";
    c_expr.expr &:= "(tmp_";
    c_expr.expr &:= str(c_expr.temp_num);
    c_expr.expr &:= "=intStr(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_int_succ (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")+1";
  end func;


const proc: process_int_value (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "int_value(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_kbd_getc (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "kbdGetc()";
  end func;


const proc: process_kbd_keypressed (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "kbdKeyPressed()";
  end func;


const proc: process_kbd_line_read (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "kbd_line_read(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_kbd_raw_getc (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "kbdRawGetc()";
  end func;


const proc: process_kbd_word_read (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "kbd_word_read(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_prg_decl_objects (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "prg_decl_objects(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_prg_eq (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") == (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_prg_eval (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "prg_eval(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_prg_name (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "str_from_cstri(arg_v[0])";
  end func;


const proc: process_prg_ne (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") != (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_prg_sysvar (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "prg_sysvar(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_prg_value (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "prg_value(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_addr (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "ref_addr(";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_body (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "ref_body(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "=(";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= ");\n";
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}";
    else
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "=(";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process_ref_deref (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "ref_deref(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_eq (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") == (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_isvar (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "ref_isvar(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_locals (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "ref_locals(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_ne (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") != (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_num (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "ref_num(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_objclass (in ref_list: params, inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.temp_decls &:= "stritype tmp_";
    c_expr.temp_decls &:= str(c_expr.temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_frees &:= "str_free(tmp_";
    c_expr.temp_frees &:= str(c_expr.temp_num);
    c_expr.temp_frees &:= ");\n";
    c_expr.expr &:= "(tmp_";
    c_expr.expr &:= str(c_expr.temp_num);
    c_expr.expr &:= "=ref_objclass(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_ref_params (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "ref_params(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_resini (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "ref_resini(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_result (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "ref_result(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_select (in reference: procedure, in ref_list: params,
    inout expr_type: c_expr) is func

  begin
(*
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ").o_";
    create_name(params[3], c_expr);
*)
    if result_type(getType(procedure)) = floattype then
      c_expr.expr &:= "*ref_fselect(";
    else
      c_expr.expr &:= "*ref_select(";
    end if;
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    create_name(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_str (in ref_list: params, inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.temp_decls &:= "stritype tmp_";
    c_expr.temp_decls &:= str(c_expr.temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_frees &:= "str_free(tmp_";
    c_expr.temp_frees &:= str(c_expr.temp_num);
    c_expr.temp_frees &:= ");\n";
    c_expr.expr &:= "(tmp_";
    c_expr.expr &:= str(c_expr.temp_num);
    c_expr.expr &:= "=ref_str(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_ref_type (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "ref_type(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_value (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "ref_value(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_rfl_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
      c_expr.expr &:= "rfl_cpy(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= ", ";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= ");\n";
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}";
    else
      c_expr.expr &:= "rfl_cpy(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= ", ";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process_rfl_elem (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "rfl_elem(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_rfl_idx (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "rfl_idx(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_rfl_lng (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "rfl_lng(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_rfl_tail (in ref_list: params, inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.temp_decls &:= "listtype tmp_";
    c_expr.temp_decls &:= str(c_expr.temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_frees &:= "rfl_free(tmp_";
    c_expr.temp_frees &:= str(c_expr.temp_num);
    c_expr.temp_frees &:= ");\n";
    c_expr.expr &:= "(tmp_";
    c_expr.expr &:= str(c_expr.temp_num);
    c_expr.expr &:= "=rfl_tail(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_rfl_value (in ref_list: params, inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.temp_decls &:= "listtype tmp_";
    c_expr.temp_decls &:= str(c_expr.temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_frees &:= "list_free(tmp_";
    c_expr.temp_frees &:= str(c_expr.temp_num);
    c_expr.temp_frees &:= ");\n";
    c_expr.expr &:= "(tmp_";
    c_expr.expr &:= str(c_expr.temp_num);
    c_expr.expr &:= "=rfl_value(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_scr_clear (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "scrClear(";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_scr_height (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "scrHeight()";
  end func;


const proc: process_scr_open (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "scrOpen()";
  end func;


const proc: process_scr_width (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "scrWidth()";
  end func;


const proc: process_scr_write (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "scrWrite()";
  end func;


const proc: process_sct_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
      c_expr.expr &:= "sct_cpy(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= ", ";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= ");\n";
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}";
    else
      c_expr.expr &:= "sct_cpy(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= ", ";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= ");";
    end if;
  end func;


const proc: process_sct_select (in reference: procedure, in ref_list: params,
    inout expr_type: c_expr) is func

  begin
(*
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ").o_";
    create_name(params[3], c_expr);
*)
    if result_type(getType(procedure)) = floattype then
      c_expr.expr &:= "*sct_fselect(";
    else
      c_expr.expr &:= "*sct_select(";
    end if;
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    create_name(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_set_baselit (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "set_baselit(";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_set_card (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "setCard(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_set_conv (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_set_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
      c_expr.expr &:= "setCpy(&(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "), ";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= ");\n";
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}";
    else
      c_expr.expr &:= "setCpy(&(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "), ";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= ");";
    end if;
  end func;


const proc: process_set_diff (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "setDiff(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_set_eq (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "setEq(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_set_excl (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param2 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param2.temp_num := c_param1.temp_num;
    process_expr(params[2], c_param2);
    if c_param2.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param2.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param2.temp_assigns;
      c_expr.expr &:= "setExcl(&(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "), ";
      c_expr.expr &:= c_param2.expr;
      c_expr.expr &:= ");\n";
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param2.temp_frees;
      c_expr.expr &:= "}";
    else
      c_expr.expr &:= "setExcl(&(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "), ";
      c_expr.expr &:= c_param2.expr;
      c_expr.expr &:= ");";
    end if;
  end func;


const proc: process_set_elem (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "setElem(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_set_incl (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param2 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param2.temp_num := c_param1.temp_num;
    process_expr(params[2], c_param2);
    if c_param2.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param2.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param2.temp_assigns;
      c_expr.expr &:= "setIncl(&(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "), ";
      c_expr.expr &:= c_param2.expr;
      c_expr.expr &:= ");\n";
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param2.temp_frees;
      c_expr.expr &:= "}";
    else
      c_expr.expr &:= "setIncl(&(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "), ";
      c_expr.expr &:= c_param2.expr;
      c_expr.expr &:= ");";
    end if;
  end func;


const proc: process_set_intersect (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "setIntersect(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_set_max (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "setMax(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_set_min (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "setMin(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_set_ne (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "setNe(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_set_not_elem (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "setNotElem(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_set_union (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "setUnion(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_set_value (in ref_list: params, inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.temp_decls &:= "settype tmp_";
    c_expr.temp_decls &:= str(c_expr.temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_frees &:= "set_free(tmp_";
    c_expr.temp_frees &:= str(c_expr.temp_num);
    c_expr.temp_frees &:= ");\n";
    c_expr.expr &:= "(tmp_";
    c_expr.expr &:= str(c_expr.temp_num);
    c_expr.expr &:= "=set_value(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_str_append (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
      c_expr.expr &:= "strAppend(&(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "), ";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= ");\n";
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}";
    else
      c_expr.expr &:= "strAppend(&(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "), ";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process_str_cat (in ref_list: params, inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.temp_decls &:= "stritype tmp_";
    c_expr.temp_decls &:= str(c_expr.temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_frees &:= "str_free(tmp_";
    c_expr.temp_frees &:= str(c_expr.temp_num);
    c_expr.temp_frees &:= ");\n";
    c_expr.expr &:= "(tmp_";
    c_expr.expr &:= str(c_expr.temp_num);
    c_expr.expr &:= "=strConcat(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_str_clit (in ref_list: params, inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.temp_decls &:= "stritype tmp_";
    c_expr.temp_decls &:= str(c_expr.temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_frees &:= "str_free(tmp_";
    c_expr.temp_frees &:= str(c_expr.temp_num);
    c_expr.temp_frees &:= ");\n";
    c_expr.expr &:= "(tmp_";
    c_expr.expr &:= str(c_expr.temp_num);
    c_expr.expr &:= "=str_clit(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_str_cmp (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "strCompare(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_str_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
      c_expr.expr &:= "strCopy(&(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "), ";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= ");\n";
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}";
    else
      c_expr.expr &:= "strCopy(&(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "), ";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process_str_eq (in ref_list: params, inout expr_type: c_expr) is func

  local
    var integer: temp_num is 0;
  begin
    incr(c_expr.temp_num);
    temp_num := c_expr.temp_num;
    c_expr.temp_decls &:= "stritype tmp_a_";
    c_expr.temp_decls &:= str(temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_decls &:= "stritype tmp_b_";
    c_expr.temp_decls &:= str(temp_num);
    c_expr.temp_decls &:= ";\n";
    (* Formula used: (a->size==b->size&&memcmp(a->mem,b->mem,
                     a->size*sizeof(strelemtype))==0) *)
    c_expr.expr &:= "(tmp_a_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "=(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "),tmp_b_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "=(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= "),tmp_a_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "->size==tmp_b_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "->size&&memcmp(tmp_a_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "->mem,tmp_b_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "->mem,tmp_a_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "->size*sizeof(strelemtype))==0)";
  end func;


const proc: process_str_ge (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "strGe(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_str_gt (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "strGt(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_str_hashcode (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "strHashCode(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_str_head (in ref_list: params, inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.temp_decls &:= "stritype tmp_";
    c_expr.temp_decls &:= str(c_expr.temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_frees &:= "str_free(tmp_";
    c_expr.temp_frees &:= str(c_expr.temp_num);
    c_expr.temp_frees &:= ");\n";
    c_expr.expr &:= "(tmp_";
    c_expr.expr &:= str(c_expr.temp_num);
    c_expr.expr &:= "=str_head(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_str_idx (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "((stritype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "))->mem[";
    process_expr(params[3], c_expr);
    c_expr.expr &:= "-1]";
  end func;


const proc: process_str_ipos (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "strIpos(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_str_le (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "strLe(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_str_lit (in ref_list: params, inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.temp_decls &:= "stritype tmp_";
    c_expr.temp_decls &:= str(c_expr.temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_frees &:= "str_free(tmp_";
    c_expr.temp_frees &:= str(c_expr.temp_num);
    c_expr.temp_frees &:= ");\n";
    c_expr.expr &:= "(tmp_";
    c_expr.expr &:= str(c_expr.temp_num);
    c_expr.expr &:= "=str_lit(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_str_lng (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "((stritype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "))->size";
  end func;


const proc: process_str_low (in ref_list: params, inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.temp_decls &:= "stritype tmp_";
    c_expr.temp_decls &:= str(c_expr.temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_frees &:= "str_free(tmp_";
    c_expr.temp_frees &:= str(c_expr.temp_num);
    c_expr.temp_frees &:= ");\n";
    c_expr.expr &:= "(tmp_";
    c_expr.expr &:= str(c_expr.temp_num);
    c_expr.expr &:= "=strLow(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_str_lpad (in ref_list: params, inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.temp_decls &:= "stritype tmp_";
    c_expr.temp_decls &:= str(c_expr.temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_frees &:= "str_free(tmp_";
    c_expr.temp_frees &:= str(c_expr.temp_num);
    c_expr.temp_frees &:= ");\n";
    c_expr.expr &:= "(tmp_";
    c_expr.expr &:= str(c_expr.temp_num);
    c_expr.expr &:= "=strLpad(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_str_lt (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "strLt(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_str_mult (in ref_list: params, inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.temp_decls &:= "stritype tmp_";
    c_expr.temp_decls &:= str(c_expr.temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_frees &:= "str_free(tmp_";
    c_expr.temp_frees &:= str(c_expr.temp_num);
    c_expr.temp_frees &:= ");\n";
    c_expr.expr &:= "(tmp_";
    c_expr.expr &:= str(c_expr.temp_num);
    c_expr.expr &:= "=strMult(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_str_ne (in ref_list: params, inout expr_type: c_expr) is func

  local
    var integer: temp_num is 0;
  begin
    incr(c_expr.temp_num);
    temp_num := c_expr.temp_num;
    c_expr.temp_decls &:= "stritype tmp_a_";
    c_expr.temp_decls &:= str(temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_decls &:= "stritype tmp_b_";
    c_expr.temp_decls &:= str(temp_num);
    c_expr.temp_decls &:= ";\n";
    (* Formula used: (a->size!=b->size||memcmp(a->mem,b->mem,
                     a->size*sizeof(strelemtype))!=0) *)
    c_expr.expr &:= "(tmp_a_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "=(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "),tmp_b_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "=(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= "),tmp_a_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "->size!=tmp_b_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "->size||memcmp(tmp_a_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "->mem,tmp_b_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "->mem,tmp_a_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "->size*sizeof(strelemtype))!=0)";
  end func;


const proc: process_str_pos (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "strPos(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_str_range (in ref_list: params, inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.temp_decls &:= "stritype tmp_";
    c_expr.temp_decls &:= str(c_expr.temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_frees &:= "str_free(tmp_";
    c_expr.temp_frees &:= str(c_expr.temp_num);
    c_expr.temp_frees &:= ");\n";
    c_expr.expr &:= "(tmp_";
    c_expr.expr &:= str(c_expr.temp_num);
    c_expr.expr &:= "=str_range(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_str_repl (in ref_list: params, inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.temp_decls &:= "stritype tmp_";
    c_expr.temp_decls &:= str(c_expr.temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_frees &:= "str_free(tmp_";
    c_expr.temp_frees &:= str(c_expr.temp_num);
    c_expr.temp_frees &:= ");\n";
    c_expr.expr &:= "(tmp_";
    c_expr.expr &:= str(c_expr.temp_num);
    c_expr.expr &:= "=strRepl(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_str_rpad (in ref_list: params, inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.temp_decls &:= "stritype tmp_";
    c_expr.temp_decls &:= str(c_expr.temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_frees &:= "str_free(tmp_";
    c_expr.temp_frees &:= str(c_expr.temp_num);
    c_expr.temp_frees &:= ");\n";
    c_expr.expr &:= "(tmp_";
    c_expr.expr &:= str(c_expr.temp_num);
    c_expr.expr &:= "=strRpad(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_str_rpos (in ref_list: params, inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.temp_decls &:= "stritype tmp_";
    c_expr.temp_decls &:= str(c_expr.temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_frees &:= "str_free(tmp_";
    c_expr.temp_frees &:= str(c_expr.temp_num);
    c_expr.temp_frees &:= ");\n";
    c_expr.expr &:= "(tmp_";
    c_expr.expr &:= str(c_expr.temp_num);
    c_expr.expr &:= "=strRpos(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_str_substr (in ref_list: params, inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.temp_decls &:= "stritype tmp_";
    c_expr.temp_decls &:= str(c_expr.temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_frees &:= "str_free(tmp_";
    c_expr.temp_frees &:= str(c_expr.temp_num);
    c_expr.temp_frees &:= ");\n";
    c_expr.expr &:= "(tmp_";
    c_expr.expr &:= str(c_expr.temp_num);
    c_expr.expr &:= "=str_substr(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_str_tail (in ref_list: params, inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.temp_decls &:= "stritype tmp_";
    c_expr.temp_decls &:= str(c_expr.temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_frees &:= "str_free(tmp_";
    c_expr.temp_frees &:= str(c_expr.temp_num);
    c_expr.temp_frees &:= ");\n";
    c_expr.expr &:= "(tmp_";
    c_expr.expr &:= str(c_expr.temp_num);
    c_expr.expr &:= "=str_tail(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_str_up (in ref_list: params, inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.temp_decls &:= "stritype tmp_";
    c_expr.temp_decls &:= str(c_expr.temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_frees &:= "str_free(tmp_";
    c_expr.temp_frees &:= str(c_expr.temp_num);
    c_expr.temp_frees &:= ");\n";
    c_expr.expr &:= "(tmp_";
    c_expr.expr &:= str(c_expr.temp_num);
    c_expr.expr &:= "=strUp(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_str_value (in ref_list: params, inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.temp_decls &:= "stritype tmp_";
    c_expr.temp_decls &:= str(c_expr.temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_frees &:= "str_free(tmp_";
    c_expr.temp_frees &:= str(c_expr.temp_num);
    c_expr.temp_frees &:= ");\n";
    c_expr.expr &:= "(tmp_";
    c_expr.expr &:= str(c_expr.temp_num);
    c_expr.expr &:= "=str_value(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_tim_await (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "tim_await(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[6], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[7], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_tim_now (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "tim_now(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[6], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[7], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[8], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_typ_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "=(";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= ");\n";
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}";
    else
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "=(";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process_typ_eq (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") == (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_typ_isfunc (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "typ_isfunc(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_typ_isvarfunc (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "typ_isvarfunc(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_typ_matchobj (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "typ_matchobj(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_typ_ne (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") != (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_typ_num (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "typ_num(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_typ_result (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "typ_result(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_typ_str (in ref_list: params, inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.temp_decls &:= "stritype tmp_";
    c_expr.temp_decls &:= str(c_expr.temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_frees &:= "str_free(tmp_";
    c_expr.temp_frees &:= str(c_expr.temp_num);
    c_expr.temp_frees &:= ");\n";
    c_expr.expr &:= "(tmp_";
    c_expr.expr &:= str(c_expr.temp_num);
    c_expr.expr &:= "=typ_str(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_typ_value (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "typ_value(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_typ_varconv (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_unx_lng (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "unx_lng(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_unx_ls (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "unx_ls(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_unx_pwd (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "unx_pwd()";
  end func;


const proc: process_unx_sleep (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "sleep(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ut8_getc (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "ut8Getc(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ut8_l_rd (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "ut8LineRead(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ut8_seek (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "ut8Seek(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ut8_stri_read (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "ut8StriRead(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ut8_word_read (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "ut8WordRead(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ut8_write (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "ut8Write(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_action (in reference: procedure, in ref_list: params,
    inout expr_type: c_expr) is func

  local
    var ACTION: current_action is action "PRC_NOOP";
    var string: action_name is "";
  begin
    current_action := ACTION value procedure;
    action_name := str(current_action);
    if action_name = "ACT_CPY" then
      process_act_cpy(params, c_expr);
    elsif action_name = "ACT_STR" then
      process_act_str(params, c_expr);
    elsif action_name = "ACT_VALUE" then
      process_act_value(params, c_expr);
    elsif action_name = "ARR_ARRLIT" then
      process_arr_arrlit(params, c_expr);
    elsif action_name = "ARR_ARRLIT2" then
      process_arr_arrlit2(params, c_expr);
    elsif action_name = "ARR_BASELIT" then
      process_arr_baselit(params, c_expr);
    elsif action_name = "ARR_BASELIT2" then
      process_arr_baselit2(params, c_expr);
    elsif action_name = "ARR_CAT" then
      process_arr_cat(params, c_expr);
    elsif action_name = "ARR_CONV" then
      process_arr_conv(params, c_expr);
    elsif action_name = "ARR_CPY" then
      process_arr_cpy(params, c_expr);
    elsif action_name = "ARR_EXTEND" then
      process_arr_extend(params, c_expr);
    elsif action_name = "ARR_GEN" then
      process_arr_gen(params, c_expr);
    elsif action_name = "ARR_HEAD" then
      process_arr_head(params, c_expr);
    elsif action_name = "ARR_IDX" then
      process_arr_idx(params, c_expr);
    elsif action_name = "ARR_LNG" then
      process_arr_lng(params, c_expr);
    elsif action_name = "ARR_RANGE" then
      process_arr_range(params, c_expr);
    elsif action_name = "ARR_TIMES" then
      process_arr_times(params, c_expr);
    elsif action_name = "ARR_TAIL" then
      process_arr_tail(params, c_expr);
    elsif action_name = "BLN_AND" then
      process_bln_and(params, c_expr);
    elsif action_name = "BLN_CPY" then
      process_bln_cpy(params, c_expr);
    elsif action_name = "BLN_EQ" then
      process_bln_eq(params, c_expr);
    elsif action_name = "BLN_GE" then
      process_bln_ge(params, c_expr);
    elsif action_name = "BLN_GT" then
      process_bln_gt(params, c_expr);
    elsif action_name = "BLN_ICONV" then
      process_bln_iconv(params, c_expr);
    elsif action_name = "BLN_LE" then
      process_bln_le(params, c_expr);
    elsif action_name = "BLN_LT" then
      process_bln_lt(params, c_expr);
    elsif action_name = "BLN_NE" then
      process_bln_ne(params, c_expr);
    elsif action_name = "BLN_NOT" then
      process_bln_not(params, c_expr);
    elsif action_name = "BLN_OR" then
      process_bln_or(params, c_expr);
    elsif action_name = "BLN_ORD" then
      process_bln_ord(params, c_expr);
    elsif action_name = "CHR_CHR" then
      process_chr_chr(params, c_expr);
    elsif action_name = "CHR_CPY" then
      process_chr_cpy(params, c_expr);
    elsif action_name = "CHR_EQ" then
      process_chr_eq(params, c_expr);
    elsif action_name = "CHR_DECR" then
      process_chr_decr(params, c_expr);
    elsif action_name = "CHR_GE" then
      process_chr_ge(params, c_expr);
    elsif action_name = "CHR_GROW" then
      process_chr_grow(params, c_expr);
    elsif action_name = "CHR_GT" then
      process_chr_gt(params, c_expr);
    elsif action_name = "CHR_HASHCODE" then
      process_chr_hashcode(params, c_expr);
    elsif action_name = "CHR_ICONV" then
      process_chr_iconv(params, c_expr);
    elsif action_name = "CHR_INCR" then
      process_chr_incr(params, c_expr);
    elsif action_name = "CHR_LE" then
      process_chr_le(params, c_expr);
    elsif action_name = "CHR_LOW" then
      process_chr_low(params, c_expr);
    elsif action_name = "CHR_LT" then
      process_chr_lt(params, c_expr);
    elsif action_name = "CHR_NE" then
      process_chr_ne(params, c_expr);
    elsif action_name = "CHR_ORD" then
      process_chr_ord(params, c_expr);
    elsif action_name = "CHR_PRED" then
      process_chr_pred(params, c_expr);
    elsif action_name = "CHR_SHRINK" then
      process_chr_shrink(params, c_expr);
    elsif action_name = "CHR_STR" then
      process_chr_str(params, c_expr);
    elsif action_name = "CHR_SUCC" then
      process_chr_succ(params, c_expr);
    elsif action_name = "CHR_UP" then
      process_chr_up(params, c_expr);
    elsif action_name = "CHR_VALUE" then
      process_chr_value(params, c_expr);
    elsif action_name = "CLS_CONV2" then
      process_cls_conv2(params, c_expr);
    elsif action_name = "DRW_ARC" then
      process_drw_arc(params, c_expr);
    elsif action_name = "DRW_ARC2" then
      process_drw_arc2(params, c_expr);
    elsif action_name = "DRW_BACKGROUND" then
      process_drw_background(params, c_expr);
    elsif action_name = "DRW_CIRCLE" then
      process_drw_circle(params, c_expr);
    elsif action_name = "DRW_CLEAR" then
      process_drw_clear(params, c_expr);
    elsif action_name = "DRW_COLOR" then
      process_drw_color(params, c_expr);
    elsif action_name = "DRW_CPY" then
      process_drw_cpy(params, c_expr);
    elsif action_name = "DRW_EQ" then
      process_drw_eq(params, c_expr);
    elsif action_name = "DRW_FARCCHORD" then
      process_drw_farcchord(params, c_expr);
    elsif action_name = "DRW_FARCPIESLICE" then
      process_drw_farcpieslice(params, c_expr);
    elsif action_name = "DRW_FCIRCLE" then
      process_drw_fcircle(params, c_expr);
    elsif action_name = "DRW_FELLIPSE" then
      process_drw_fellipse(params, c_expr);
    elsif action_name = "DRW_FLUSH" then
      process_drw_flush(params, c_expr);
    elsif action_name = "DRW_GET" then
      process_drw_get(params, c_expr);
    elsif action_name = "DRW_HEIGHT" then
      process_drw_height(params, c_expr);
    elsif action_name = "DRW_IMAGE" then
      process_drw_image(params, c_expr);
    elsif action_name = "DRW_LINE" then
      process_drw_line(params, c_expr);
    elsif action_name = "DRW_NE" then
      process_drw_ne(params, c_expr);
    elsif action_name = "DRW_NEW_PIXMAP" then
      process_drw_new_pixmap(params, c_expr);
    elsif action_name = "DRW_OPEN" then
      process_drw_open(params, c_expr);
    elsif action_name = "DRW_POINT" then
      process_drw_point(params, c_expr);
    elsif action_name = "DRW_PPOINT" then
      process_drw_ppoint(params, c_expr);
    elsif action_name = "DRW_PRECT" then
      process_drw_prect(params, c_expr);
    elsif action_name = "DRW_PUT" then
      process_drw_put(params, c_expr);
    elsif action_name = "DRW_RECT" then
      process_drw_rect(params, c_expr);
    elsif action_name = "DRW_RGBCOL" then
      process_drw_rgbcol(params, c_expr);
    elsif action_name = "DRW_TEXT" then
      process_drw_text(params, c_expr);
    elsif action_name = "DRW_WIDTH" then
      process_drw_width(params, c_expr);
    elsif action_name = "ENU_CPY" then
      process_enu_cpy(params, c_expr);
    elsif action_name = "ENU_EQ" then
      process_enu_eq(params, c_expr);
    elsif action_name = "ENU_NE" then
      process_enu_ne(params, c_expr);
    elsif action_name = "ENU_VALUE" then
      process_enu_value(params, c_expr);
    elsif action_name = "FIL_CLOSE" then
      process_fil_close(params, c_expr);
    elsif action_name = "FIL_CPY" then
      process_fil_cpy(params, c_expr);
    elsif action_name = "FIL_GETC" then
      process_fil_getc(params, c_expr);
    elsif action_name = "FIL_EQ" then
      process_fil_eq(params, c_expr);
    elsif action_name = "FIL_EOF" then
      process_fil_eof(params, c_expr);
    elsif action_name = "FIL_FLUSH" then
      process_fil_flush(params, c_expr);
    elsif action_name = "FIL_L_RD" then
      process_fil_l_rd(params, c_expr);
    elsif action_name = "FIL_LNG" then
      process_fil_lng(params, c_expr);
    elsif action_name = "FIL_NE" then
      process_fil_ne(params, c_expr);
    elsif action_name = "FIL_NIL" then
      process_fil_nil(params, c_expr);
    elsif action_name = "FIL_OPEN" then
      process_fil_open(params, c_expr);
    elsif action_name = "FIL_STRI_READ" then
      process_fil_stri_read(params, c_expr);
    elsif action_name = "FIL_SEEK" then
      process_fil_seek(params, c_expr);
    elsif action_name = "FIL_TELL" then
      process_fil_tell(params, c_expr);
    elsif action_name = "FIL_WRITE" then
      process_fil_write(params, c_expr);
    elsif action_name = "FIL_WORD_READ" then
      process_fil_word_read(params, c_expr);
    elsif action_name = "FLT_A2TAN" then
      process_flt_a2tan(params, c_expr);
    elsif action_name = "FLT_ABS" then
      process_flt_abs(params, c_expr);
    elsif action_name = "FLT_ADD" then
      process_flt_add(params, c_expr);
    elsif action_name = "FLT_ACOS" then
      process_flt_acos(params, c_expr);
    elsif action_name = "FLT_ASIN" then
      process_flt_asin(params, c_expr);
    elsif action_name = "FLT_ATAN" then
      process_flt_atan(params, c_expr);
    elsif action_name = "FLT_COS" then
      process_flt_cos(params, c_expr);
    elsif action_name = "FLT_CPY" then
      process_flt_cpy(params, c_expr); 
    elsif action_name = "FLT_DGTS" then
      process_flt_dgts(params, c_expr);
    elsif action_name = "FLT_DIV" then
      process_flt_div(params, c_expr);
    elsif action_name = "FLT_EQ" then
      process_flt_eq(params, c_expr);
    elsif action_name = "FLT_EXP" then
      process_flt_exp(params, c_expr);
    elsif action_name = "FLT_FLOOR" then
      process_flt_floor(params, c_expr);
    elsif action_name = "FLT_GE" then
      process_flt_ge(params, c_expr);
    elsif action_name = "FLT_GT" then
      process_flt_gt(params, c_expr);
    elsif action_name = "FLT_IFLT" then
      process_flt_iflt(params, c_expr);
    elsif action_name = "FLT_IPOW" then
      process_flt_ipow(params, c_expr);
    elsif action_name = "FLT_LE" then
      process_flt_le(params, c_expr);
    elsif action_name = "FLT_LOG" then
      process_flt_log(params, c_expr);
    elsif action_name = "FLT_LT" then
      process_flt_lt(params, c_expr);
    elsif action_name = "FLT_MINUS" then
      process_flt_minus(params, c_expr);
    elsif action_name = "FLT_MULT" then
      process_flt_mult(params, c_expr);
    elsif action_name = "FLT_NE" then
      process_flt_ne(params, c_expr);
    elsif action_name = "FLT_PARSE" then
      process_flt_parse(params, c_expr);
    elsif action_name = "FLT_POW" then
      process_flt_pow(params, c_expr);
    elsif action_name = "FLT_RAND" then
      process_flt_rand(params, c_expr);
    elsif action_name = "FLT_ROUND" then
      process_flt_round(params, c_expr);
    elsif action_name = "FLT_SBTR" then
      process_flt_sbtr(params, c_expr);
    elsif action_name = "FLT_SIN" then
      process_flt_sin(params, c_expr);
    elsif action_name = "FLT_SQRT" then
      process_flt_sqrt(params, c_expr);
    elsif action_name = "FLT_STR" then
      process_flt_str(params, c_expr);
    elsif action_name = "FLT_TAN" then
      process_flt_tan(params, c_expr);
    elsif action_name = "FLT_TRUNC" then
      process_flt_trunc(params, c_expr);
    elsif action_name = "FLT_VALUE" then
      process_flt_value(params, c_expr);
    elsif action_name = "GKB_GETC" then
      process_gkb_getc(params, c_expr);
    elsif action_name = "GKB_KEYPRESSED" then
      process_gkb_keypressed(params, c_expr);
    elsif action_name = "GKB_LINE_READ" then
      process_gkb_line_read(params, c_expr);
    elsif action_name = "GKB_RAW_GETC" then
      process_gkb_raw_getc(params, c_expr);
    elsif action_name = "GKB_WORD_READ" then
      process_gkb_word_read(params, c_expr);
    elsif action_name = "HSH_CONTAINS" then
      process_hsh_contains(params, c_expr);
    elsif action_name = "HSH_CPY" then
      process_hsh_cpy(params, c_expr);
    elsif action_name = "HSH_CREATE" then
      process_hsh_create(params, c_expr);
    elsif action_name = "HSH_DESTR" then
      process_hsh_destr(params, c_expr);
    elsif action_name = "HSH_EXCL" then
      process_hsh_excl(params, c_expr);
    elsif action_name = "HSH_IDX" then
      process_hsh_idx(params, c_expr);
    elsif action_name = "HSH_INCL" then
      process_hsh_incl(params, c_expr);
    elsif action_name = "INT_ABS" then
      process_int_abs(params, c_expr);
    elsif action_name = "INT_ADD" then
      process_int_add(params, c_expr);
    elsif action_name = "INT_BINOM" then
      process_int_binom(params, c_expr);
    elsif action_name = "INT_CONV" then
      process_int_conv(params, c_expr);
    elsif action_name = "INT_CPY" then
      process_int_cpy(params, c_expr);
    elsif action_name = "INT_DECR" then
      process_int_decr(params, c_expr);
    elsif action_name = "INT_DIV" then
      process_int_div(params, c_expr);
    elsif action_name = "INT_EQ" then
      process_int_eq(params, c_expr);
    elsif action_name = "INT_FACT" then
      process_int_fact(params, c_expr);
    elsif action_name = "INT_GE" then
      process_int_ge(params, c_expr);
    elsif action_name = "INT_GROW" then
      process_int_grow(params, c_expr);
    elsif action_name = "INT_GT" then
      process_int_gt(params, c_expr);
    elsif action_name = "INT_HASHCODE" then
      process_int_hashcode(params, c_expr);
    elsif action_name = "INT_HSIZE" then
      process_int_hsize(params, c_expr);
    elsif action_name = "INT_INCR" then
      process_int_incr(params, c_expr);
    elsif action_name = "INT_LD" then
      process_int_ld(params, c_expr);
    elsif action_name = "INT_LE" then
      process_int_le(params, c_expr);
    elsif action_name = "INT_LT" then
      process_int_lt(params, c_expr);
    elsif action_name = "INT_MDIV" then
      process_int_mdiv(params, c_expr);
    elsif action_name = "INT_MINUS" then
      process_int_minus(params, c_expr);
    elsif action_name = "INT_MOD" then
      process_int_mod(params, c_expr);
    elsif action_name = "INT_MULT" then
      process_int_mult(params, c_expr);
    elsif action_name = "INT_NE" then
      process_int_ne(params, c_expr);
    elsif action_name = "INT_ODD" then
      process_int_odd(params, c_expr);
    elsif action_name = "INT_ORD" then
      process_int_ord(params, c_expr);
    elsif action_name = "INT_PARSE" then
      process_int_parse(params, c_expr);
    elsif action_name = "INT_RAND" then
      process_int_rand(params, c_expr);
    elsif action_name = "INT_POW" then
      process_int_pow(params, c_expr);
    elsif action_name = "INT_PRED" then
      process_int_pred(params, c_expr);
    elsif action_name = "INT_REM" then
      process_int_rem(params, c_expr);
    elsif action_name = "INT_SBTR" then
      process_int_sbtr(params, c_expr);
    elsif action_name = "INT_SHRINK" then
      process_int_shrink(params, c_expr);
    elsif action_name = "INT_SQRT" then
      process_int_sqrt(params, c_expr);
    elsif action_name = "INT_STR" then
      process_int_str(params, c_expr);
    elsif action_name = "INT_SUCC" then
      process_int_succ(params, c_expr);
    elsif action_name = "INT_VALUE" then
      process_int_value(params, c_expr);
    elsif action_name = "KBD_GETC" then
      process_kbd_getc(params, c_expr);
    elsif action_name = "KBD_KEYPRESSED" then
      process_kbd_keypressed(params, c_expr);
    elsif action_name = "KBD_LINE_READ" then
      process_kbd_line_read(params, c_expr);
    elsif action_name = "KBD_RAW_GETC" then
      process_kbd_raw_getc(params, c_expr);
    elsif action_name = "KBD_WORD_READ" then
      process_kbd_word_read(params, c_expr);
    elsif action_name = "PRC_ARGS" then
      process_prc_args(params, c_expr);
    elsif action_name = "PRC_BLOCK" then
      process_prc_block(params, c_expr);
    elsif action_name = "PRC_CASE" then
      process_prc_case(params, c_expr);
    elsif action_name = "PRC_CASE_DEF" then
      process_prc_case_def(params, c_expr);
    elsif action_name = "PRC_DYNAMIC" then
      process_prc_dynamic(procedure, params, c_expr);
    elsif action_name = "PRC_EXIT" then
      process_prc_exit(params, c_expr);
    elsif action_name = "PRC_FOR_DOWNTO" then
      process_prc_for_downto(params, c_expr);
    elsif action_name = "PRC_FOR_TO" then
      process_prc_for_to(params, c_expr);
    elsif action_name = "PRC_IF" then
      process_prc_if(params, c_expr);
    elsif action_name = "PRC_IF_ELSIF" then
      process_prc_if_elsif(params, c_expr);
    elsif action_name = "PRC_NOOP" then
      process_prc_noop(procedure, params, c_expr);
    elsif action_name = "PRC_PRINT" then
      process_prc_print(params, c_expr);
    elsif action_name = "PRC_REPEAT" then
      process_prc_repeat(params, c_expr);
    elsif action_name = "PRC_WHILE" then
      process_prc_while(params, c_expr);
    elsif action_name = "PRG_DECL_OBJECTS" then
      process_prg_decl_objects(params, c_expr);
    elsif action_name = "PRG_EQ" then
      process_prg_eq(params, c_expr);
    elsif action_name = "PRG_EVAL" then
      process_prg_eval(params, c_expr);
    elsif action_name = "PRG_NAME" then
      process_prg_name(params, c_expr);
    elsif action_name = "PRG_NE" then
      process_prg_ne(params, c_expr);
    elsif action_name = "PRG_SYSVAR" then
      process_prg_sysvar(params, c_expr);
    elsif action_name = "PRG_VALUE" then
      process_prg_value(params, c_expr);
    elsif action_name = "REF_ADDR" then
      process_ref_addr(params, c_expr);
    elsif action_name = "REF_BODY" then
      process_ref_body(params, c_expr);
    elsif action_name = "REF_CPY" then
      process_ref_cpy(params, c_expr);
    elsif action_name = "REF_DEREF" then
      process_ref_deref(params, c_expr);
    elsif action_name = "REF_EQ" then
      process_ref_eq(params, c_expr);
    elsif action_name = "REF_ISVAR" then
      process_ref_isvar(params, c_expr);
    elsif action_name = "REF_LOCALS" then
      process_ref_locals(params, c_expr);
    elsif action_name = "REF_NE" then
      process_ref_ne(params, c_expr);
    elsif action_name = "REF_NUM" then
      process_ref_num(params, c_expr);
    elsif action_name = "REF_OBJCLASS" then
      process_ref_objclass(params, c_expr);
    elsif action_name = "REF_PARAMS" then
      process_ref_params(params, c_expr);
    elsif action_name = "REF_RESINI" then
      process_ref_resini(params, c_expr);
    elsif action_name = "REF_RESULT" then
      process_ref_result(params, c_expr);
    elsif action_name = "REF_SELECT" then
      process_ref_select(procedure, params, c_expr);
    elsif action_name = "REF_STR" then
      process_ref_str(params, c_expr);
    elsif action_name = "REF_TYPE" then
      process_ref_type(params, c_expr);
    elsif action_name = "REF_VALUE" then
      process_ref_value(params, c_expr);
    elsif action_name = "RFL_CPY" then
      process_rfl_cpy(params, c_expr);
    elsif action_name = "RFL_ELEM" then
      process_rfl_elem(params, c_expr);
    elsif action_name = "RFL_IDX" then
      process_rfl_idx(params, c_expr);
    elsif action_name = "RFL_LNG" then
      process_rfl_lng(params, c_expr);
    elsif action_name = "RFL_TAIL" then
      process_rfl_tail(params, c_expr);
    elsif action_name = "RFL_VALUE" then
      process_rfl_value(params, c_expr);
    elsif action_name = "SCR_CLEAR" then
      process_scr_clear(params, c_expr);
    elsif action_name = "SCR_HEIGHT" then
      process_scr_height(params, c_expr);
    elsif action_name = "SCR_OPEN" then
      process_scr_open(params, c_expr);
    elsif action_name = "SCR_WIDTH" then
      process_scr_width(params, c_expr);
    elsif action_name = "SCR_WRITE" then
      process_scr_write(params, c_expr);
    elsif action_name = "SCT_CPY" then
      process_sct_cpy(params, c_expr);
    elsif action_name = "SCT_SELECT" then
      process_sct_select(procedure, params, c_expr);
    elsif action_name = "SET_BASELIT" then
      process_set_baselit(params, c_expr);
    elsif action_name = "SET_CARD" then
      process_set_card(params, c_expr);
    elsif action_name = "SET_CONV" then
      process_set_conv(params, c_expr);
    elsif action_name = "SET_CPY" then
      process_set_cpy(params, c_expr);
    elsif action_name = "SET_DIFF" then
      process_set_diff(params, c_expr);
    elsif action_name = "SET_ELEM" then
      process_set_elem(params, c_expr);
    elsif action_name = "SET_EQ" then
      process_set_eq(params, c_expr);
    elsif action_name = "SET_EXCL" then
      process_set_excl(params, c_expr);
    elsif action_name = "SET_INCL" then
      process_set_incl(params, c_expr);
    elsif action_name = "SET_INTERSECT" then
      process_set_intersect(params, c_expr);
    elsif action_name = "SET_MAX" then
      process_set_max(params, c_expr);
    elsif action_name = "SET_MIN" then
      process_set_min(params, c_expr);
    elsif action_name = "SET_NE" then
      process_set_ne(params, c_expr);
    elsif action_name = "SET_NOT_ELEM" then
      process_set_not_elem(params, c_expr);
    elsif action_name = "SET_UNION" then
      process_set_union(params, c_expr);
    elsif action_name = "SET_VALUE" then
      process_set_value(params, c_expr);
    elsif action_name = "STR_APPEND" then
      process_str_append(params, c_expr);
    elsif action_name = "STR_CAT" then
      process_str_cat(params, c_expr);
    elsif action_name = "STR_CLIT" then
      process_str_clit(params, c_expr);
    elsif action_name = "STR_CMP" then
      process_str_cmp(params, c_expr);
    elsif action_name = "STR_CPY" then
      process_str_cpy(params, c_expr);
    elsif action_name = "STR_EQ" then
      process_str_eq(params, c_expr);
    elsif action_name = "STR_GE" then
      process_str_ge(params, c_expr);
    elsif action_name = "STR_GT" then
      process_str_gt(params, c_expr);
    elsif action_name = "STR_HASHCODE" then
      process_str_hashcode(params, c_expr);
    elsif action_name = "STR_HEAD" then
      process_str_head(params, c_expr);
    elsif action_name = "STR_IDX" then
      process_str_idx(params, c_expr);
    elsif action_name = "STR_IPOS" then
      process_str_ipos(params, c_expr);
    elsif action_name = "STR_LE" then
      process_str_le(params, c_expr);
    elsif action_name = "STR_LIT" then
      process_str_lit(params, c_expr);
    elsif action_name = "STR_LNG" then
      process_str_lng(params, c_expr);
    elsif action_name = "STR_LOW" then
      process_str_low(params, c_expr);
    elsif action_name = "STR_LPAD" then
      process_str_lpad(params, c_expr);
    elsif action_name = "STR_LT" then
      process_str_lt(params, c_expr);
    elsif action_name = "STR_MULT" then
      process_str_mult(params, c_expr);
    elsif action_name = "STR_NE" then
      process_str_ne(params, c_expr);
    elsif action_name = "STR_POS" then
      process_str_pos(params, c_expr);
    elsif action_name = "STR_RANGE" then
      process_str_range(params, c_expr);
    elsif action_name = "STR_REPL" then
      process_str_repl(params, c_expr);
    elsif action_name = "STR_RPAD" then
      process_str_rpad(params, c_expr);
    elsif action_name = "STR_RPOS" then
      process_str_rpos(params, c_expr);
    elsif action_name = "STR_SUBSTR" then
      process_str_substr(params, c_expr);
    elsif action_name = "STR_TAIL" then
      process_str_tail(params, c_expr);
    elsif action_name = "STR_UP" then
      process_str_up(params, c_expr);
    elsif action_name = "STR_VALUE" then
      process_str_value(params, c_expr);
    elsif action_name = "TIM_AWAIT" then
      process_tim_await(params, c_expr);
    elsif action_name = "TIM_NOW" then
      process_tim_now(params, c_expr);
    elsif action_name = "TYP_CPY" then
      process_typ_cpy(params, c_expr);
    elsif action_name = "TYP_EQ" then
      process_typ_eq(params, c_expr);
    elsif action_name = "TYP_ISFUNC" then
      process_typ_isfunc(params, c_expr);
    elsif action_name = "TYP_ISVARFUNC" then
      process_typ_isvarfunc(params, c_expr);
    elsif action_name = "TYP_MATCHOBJ" then
      process_typ_matchobj(params, c_expr);
    elsif action_name = "TYP_NE" then
      process_typ_ne(params, c_expr);
    elsif action_name = "TYP_NUM" then
      process_typ_num(params, c_expr);
    elsif action_name = "TYP_RESULT" then
      process_typ_result(params, c_expr);
    elsif action_name = "TYP_STR" then
      process_typ_str(params, c_expr);
    elsif action_name = "TYP_VALUE" then
      process_typ_value(params, c_expr);
    elsif action_name = "TYP_VARCONV" then
      process_typ_varconv(params, c_expr);
    elsif action_name = "UNX_LNG" then
      process_unx_lng(params, c_expr);
    elsif action_name = "UNX_LS" then
      process_unx_ls(params, c_expr);
    elsif action_name = "UNX_PWD" then
      process_unx_pwd(params, c_expr);
    elsif action_name = "UNX_SLEEP" then
      process_unx_sleep(params, c_expr);
    elsif action_name = "UT8_GETC" then
      process_ut8_getc(params, c_expr);
    elsif action_name = "UT8_L_RD" then
      process_ut8_l_rd(params, c_expr);
    elsif action_name = "UT8_SEEK" then
      process_ut8_seek(params, c_expr);
    elsif action_name = "UT8_STRI_READ" then
      process_ut8_stri_read(params, c_expr);
    elsif action_name = "UT8_WORD_READ" then
      process_ut8_word_read(params, c_expr);
    elsif action_name = "UT8_WRITE" then
      process_ut8_write(params, c_expr);
    else
      c_expr.expr &:= "/* ACTOBJECT { ";
      c_expr.expr &:= action_name;
      c_expr.expr &:= " }*/";
    end if;
  end func;


const proc: process_constenumobject (in reference: procedure, in ref_list: params,
    inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "/*constenumobject*/";
    noop_params(params(procedure), params, c_expr);
  end func;


const func boolean: param_list_okay (in ref_list: formal_params) is func

  result
    var boolean: okay is TRUE;
  local
    var reference: obj is NIL;
    var string: objclass is "";
  begin
    for obj range formal_params do
      objclass := obj_class(obj);
      if objclass <> "SYMBOLOBJECT" and objclass <> "TYPEOBJECT" then
        if getType(obj) = typetype or
            getType(obj) = proctype then
          okay := FALSE;
        end if;
      end if;
    end for;
  end func;


const proc: push_object_value (in reference: obj, in reference: value) is func

  local
    var integer: length is 0;
    var integer: number is 0;
  begin
    length := length(object_value);
    number := obj_number(obj);
    if length < number then
      object_value := object_value & number - length times ref_list.EMPTY;
    end if;
    incl(object_value[number], value);
  end func;


const proc: pop_object_value (in reference: obj) is func

  local
    var integer: length is 0;
    var integer: number is 0;
  begin
    number := obj_number(obj);
    object_value[number] := object_value[number][2 ..];
  end func;


const proc: push_macro_param (in reference: formal_param,
    in reference: actual_param, inout expr_type: c_expr) is func

  local
    var string: objclass is "";
    var type: param_type is void;
    var integer: temp_num is 0;
  begin
    objclass := obj_class(formal_param);
    if objclass <> "SYMBOLOBJECT" then
      param_type := getType(formal_param);
      if param_type = proctype then
        c_expr.expr &:= "/* proc param o_";
        c_expr.expr &:= str(obj_number(formal_param));
        c_expr.expr &:= " ";
        c_expr.expr &:= str(formal_param);
        c_expr.expr &:= "*/\n";
        push_object_value(formal_param, actual_param);
(*
      elsif param_type = typetype then
        c_expr.expr &:= "/* type param o_";
        c_expr.expr &:= str(obj_number(formal_param));
        c_expr.expr &:= " ";
        c_expr.expr &:= str(formal_param);
        c_expr.expr &:= "*/\n";
*)
      else
        process_type(param_type, c_expr);
        if objclass = "REFPARAMOBJECT" then
          c_expr.expr &:= " *o_";
          create_name(formal_param, c_expr);
          c_expr.expr &:= "=";
          if obj_class(actual_param) = "REFPARAMOBJECT" then
            c_expr.expr &:= "o_";
            create_name(actual_param, c_expr);
            c_expr.expr &:= ";\n";
          elsif obj_class(actual_param) = "RESULTOBJECT" or
              obj_class(actual_param) = "LOCALVOBJECT" then
            c_expr.expr &:= "&(";
            process_expr(actual_param, c_expr);
            c_expr.expr &:= ");\n";
          else
            incr(c_expr.temp_num);
            temp_num := c_expr.temp_num;
            c_expr.temp_decls &:= "long tmp_";
            c_expr.temp_decls &:= str(temp_num);
            c_expr.temp_decls &:= ";\n";
            c_expr.temp_frees &:= "any_free(tmp_";
            c_expr.temp_frees &:= str(temp_num);
            c_expr.temp_frees &:= ");\n";
            c_expr.expr &:= "(tmp_";
            c_expr.expr &:= str(temp_num);
            c_expr.expr &:= "=";
            process_expr(actual_param, c_expr);
            c_expr.expr &:= ", &tmp_";
            c_expr.expr &:= str(temp_num);
            c_expr.expr &:= ");\n";
          end if;
        else
          c_expr.expr &:= " o_";
          create_name(formal_param, c_expr);
          c_expr.expr &:= "=";
          process_expr(actual_param, c_expr);
          c_expr.expr &:= ";\n";
        end if;
      end if;
    end if;
  end func;


const proc: push_macro_params (in ref_list: formal_params,
    in ref_list: actual_params, inout expr_type: c_expr) is func

  local
    var integer: number is 0;
  begin
    for number range 1 to length(formal_params) do
      push_macro_param(formal_params[number], actual_params[number], c_expr);
    end for;
  end func;


const proc: pop_macro_param (in reference: formal_param,
    inout expr_type: c_expr) is func

  local
    var string: objclass is "";
    var type: param_type is void;
  begin
    objclass := obj_class(formal_param);
    if objclass <> "SYMBOLOBJECT" then
      param_type := getType(formal_param);
      if param_type = proctype then
        c_expr.expr &:= "/* end proc param o_";
        c_expr.expr &:= str(obj_number(formal_param));
        c_expr.expr &:= " ";
        c_expr.expr &:= str(formal_param);
        c_expr.expr &:= "*/\n";
        pop_object_value(formal_param);
      end if;
    end if;
  end func;


const proc: pop_macro_params (in ref_list: formal_params,
    inout expr_type: c_expr) is func

  local
    var integer: number is 0;
  begin
    for number range 1 to length(formal_params) do
      pop_macro_param(formal_params[number], c_expr);
    end for;
  end func;


const proc: process_macro (in reference: procedure,
    in ref_list: formal_params, in ref_list: actual_params,
    inout expr_type: c_expr) is func

  local
    var type: result_type is void;
    var expr_type: macro_decls is expr_type.value;
    var reference: result_object is NIL;
  begin
    result_type := result_type(getType(procedure));
    if result_type = voidtype then
      c_expr.expr &:= "/* macro o_";
      c_expr.expr &:= str(obj_number(procedure));
      c_expr.expr &:= " ";
      c_expr.expr &:= str(procedure);
      c_expr.expr &:= "*/ {\n";
      c_expr.expr &:= "/* macro params */\n";
      push_macro_params(formal_params, actual_params, c_expr);
      c_expr.expr &:= "/* macro locals */\n";
      process_locals(procedure, c_expr);
      c_expr.expr &:= "/* macro body */\n";
      process_expr(body(procedure), c_expr);
      pop_macro_params(formal_params, c_expr);
      c_expr.expr &:= "\n;} /* macro o_";
      c_expr.expr &:= str(obj_number(procedure));
      c_expr.expr &:= " ";
      c_expr.expr &:= str(procedure);
      c_expr.expr &:= "*/\n";
    else
      c_expr.expr &:= "/* macro o_";
      c_expr.expr &:= str(obj_number(procedure));
      c_expr.expr &:= " ";
      c_expr.expr &:= str(procedure);
      c_expr.expr &:= "*/ (\n";
      push_macro_params(formal_params, actual_params, macro_decls);
      process_locals(procedure, macro_decls);
      result_object := func_result(procedure);
      if result_object <> NIL then
        process_type(getType(result_object), macro_decls);
        macro_decls.expr &:= " o_";
        create_name(result_object, macro_decls);
        macro_decls.expr &:= ";\n";
      end if;
      incr(c_expr.temp_num);
      c_expr.temp_decls &:= macro_decls.temp_decls;
      c_expr.temp_assigns &:= macro_decls.temp_assigns;
      c_expr.temp_assigns &:= macro_decls.expr;
      c_expr.temp_frees &:= macro_decls.temp_frees;
      process_expr(body(procedure), c_expr);
      pop_macro_params(formal_params, c_expr);
      c_expr.expr &:= "\n) /* macro o_";
      c_expr.expr &:= str(obj_number(procedure));
      c_expr.expr &:= " ";
      c_expr.expr &:= str(procedure);
      c_expr.expr &:= "*/\n";
    end if;
  end func;


const proc: call_params (in ref_list: formal_params,
    in ref_list: actual_params, inout expr_type: c_expr) is func

  local
    var integer: number is 0;
    var reference: formal_param is NIL;
    var reference: actual_param is NIL;
    var string: objclass is "";
    var boolean: first_element is TRUE;
    var integer: temp_num is 0;
  begin
    for number range 1 to length(formal_params) do
      formal_param := formal_params[number];
      actual_param := actual_params[number];
      objclass := obj_class(formal_param);
      if objclass <> "SYMBOLOBJECT" then
        if objclass = "TYPEOBJECT" then
          c_expr.expr &:= "/* attr t_";
          c_expr.expr &:= str(type_number(type value formal_param));
          c_expr.expr &:= " ";
          c_expr.expr &:= str(type value formal_param);
          c_expr.expr &:= "*/ ";
        else
          if first_element then
            first_element := FALSE;
          else
            c_expr.expr &:= ", ";
          end if;
          if objclass = "REFPARAMOBJECT" then
            if obj_class(actual_param) = "REFPARAMOBJECT" then
              c_expr.expr &:= "o_";
              create_name(actual_param, c_expr);
            elsif obj_class(actual_param) = "RESULTOBJECT" or
              obj_class(actual_param) = "LOCALVOBJECT" then
              c_expr.expr &:= "&(";
              process_expr(actual_param, c_expr);
              c_expr.expr &:= ")";
            else
              incr(c_expr.temp_num);
              temp_num := c_expr.temp_num;
              c_expr.temp_decls &:= "long tmp_";
              c_expr.temp_decls &:= str(temp_num);
              c_expr.temp_decls &:= ";\n";
              c_expr.temp_frees &:= "any_free(tmp_";
              c_expr.temp_frees &:= str(temp_num);
              c_expr.temp_frees &:= ");\n";
              c_expr.expr &:= "(tmp_";
              c_expr.expr &:= str(temp_num);
              c_expr.expr &:= "=";
              process_expr(actual_param, c_expr);
              c_expr.expr &:= ", &tmp_";
              c_expr.expr &:= str(temp_num);
              c_expr.expr &:= ")";
            end if;
          else
            process_expr(actual_param, c_expr);
          end if;
        end if;
      end if;
    end for;
  end func;


const proc: process_procedure (in reference: procedure,
    in ref_list: formal_params, in ref_list: actual_params,
    inout expr_type: c_expr) is func

  begin
    if is_varfunc(getType(procedure)) then
      c_expr.expr &:= "*o_";
    else
      c_expr.expr &:= "o_";
    end if;
    create_name(procedure, c_expr);
    c_expr.expr &:= "(";
    call_params(formal_params, actual_params, c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_call (in reference: current_expression, inout expr_type: c_expr) is func

  local
    var ref_list: params is ref_list.EMPTY;
    var reference: procedure is NIL;
    var string: objclass is "";
    var type: result_type is void;
    var ref_list: formal_params is ref_list.EMPTY;
    var reference: obj is NIL;
    var boolean: first_element is TRUE;
  begin
    params := ref_list value current_expression;
    procedure := params[1];
    params := params[2 ..];
    objclass := obj_class(procedure);
    if objclass = "ACTOBJECT" then
      process_action(procedure, params, c_expr);
    elsif objclass = "BLOCKOBJECT" then
      result_type := result_type(getType(procedure));
      formal_params := params(procedure);
      if result_type <> typetype then
        if param_list_okay(formal_params) then
          process_procedure(procedure, formal_params, params, c_expr);
        else
          process_macro(procedure, formal_params, params, c_expr);
        end if;
      else
        process_macro(procedure, formal_params, params, c_expr);
      end if;
    elsif objclass = "REFPARAMOBJECT" then
      c_expr.expr &:= "/* body o_";
      c_expr.expr &:= str(obj_number(procedure));
      c_expr.expr &:= " ";
      c_expr.expr &:= str(procedure);
      c_expr.expr &:= "*/ {\n";
      if obj_number(procedure) <= length(object_value) then
        process_expr(object_value[obj_number(procedure)][1], c_expr);
      else
        c_expr.expr &:= "/* object ";
        c_expr.expr &:= str(obj_number(procedure));
        c_expr.expr &:= " not defined */";
      end if;
      c_expr.expr &:= "\n;} /* body o_";
      c_expr.expr &:= str(obj_number(procedure));
      c_expr.expr &:= " ";
      c_expr.expr &:= str(procedure);
      c_expr.expr &:= "*/\n";
    elsif objclass = "CONSTENUMOBJECT" then
      (* process_constenumobject(procedure, params, c_expr); *)
      process_expr(procedure, c_expr);
    elsif objclass = "INTOBJECT" then
      process_expr(procedure, c_expr);
    elsif objclass = "CHAROBJECT" then
      process_expr(procedure, c_expr);
    elsif objclass = "STRIOBJECT" then
      process_expr(procedure, c_expr);
    elsif objclass = "SETOBJECT" then
      process_expr(procedure, c_expr);
    elsif objclass = "STRUCTOBJECT" then
      process_expr(procedure, c_expr);
    elsif objclass = "WINOBJECT" then
      process_expr(procedure, c_expr);
    elsif objclass = "PROGOBJECT" then
      process_expr(procedure, c_expr);
    elsif objclass = "ENUMLITERALOBJECT" then
      process_expr(procedure, c_expr);
    elsif objclass = "REFOBJECT" then
      c_expr.expr &:= "o_";
      create_name(procedure, c_expr);
    elsif objclass = "REFLISTOBJECT" then
      c_expr.expr &:= "o_";
      create_name(procedure, c_expr);
    else
      c_expr.expr &:= "/*[ ";
      c_expr.expr &:= objclass;
      c_expr.expr &:= " ]*/";
      c_expr.expr &:= "o_";
      create_name(procedure, c_expr);
      c_expr.expr &:= "(";
      for obj range params do
        objclass := obj_class(obj);
        if objclass <> "SYMBOLOBJECT" then
          if first_element then
            first_element := FALSE;
          else
            c_expr.expr &:= ", ";
          end if;
          process_expr(obj, c_expr);
        end if;
      end for;
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process_expr (in reference: current_expression, inout expr_type: c_expr) is func

  local
    var string: objclass is "";
    var reference: obj is NIL;
  begin
    objclass := obj_class(current_expression);
    if objclass = "MATCHOBJECT" then
      process_call(current_expression, c_expr);
    elsif objclass = "CALLOBJECT" then
      process_call(current_expression, c_expr);
    elsif objclass = "BLOCKOBJECT" then
      c_expr.expr &:= "o_";
      create_name(current_expression, c_expr);
      c_expr.expr &:= "()";
    elsif objclass = "ACTOBJECT" then
      process_action(current_expression, ref_list.EMPTY, c_expr);
    elsif objclass = "LOCALVOBJECT" then
      c_expr.expr &:= "o_";
      create_name(current_expression, c_expr);
    elsif objclass = "VALUEPARAMOBJECT" then
      c_expr.expr &:= "o_";
      create_name(current_expression, c_expr);
    elsif objclass = "REFPARAMOBJECT" then
      if obj_number(current_expression) <= length(object_value) and
          length(object_value[obj_number(current_expression)]) > 0 then
        c_expr.expr &:= "/* body o_";
        c_expr.expr &:= str(obj_number(current_expression));
        c_expr.expr &:= " ";
        c_expr.expr &:= str(current_expression);
        c_expr.expr &:= "*/ {\n";
        process_expr(object_value[obj_number(current_expression)][1], c_expr);
        c_expr.expr &:= "\n;} /* body o_";
        c_expr.expr &:= str(obj_number(current_expression));
        c_expr.expr &:= " ";
        c_expr.expr &:= str(current_expression);
        c_expr.expr &:= "*/\n";
      else
        c_expr.expr &:= "(*o_";
        create_name(current_expression, c_expr);
        c_expr.expr &:= ")";
      end if;
    elsif objclass = "RESULTOBJECT" then
      c_expr.expr &:= "o_";
      create_name(current_expression, c_expr);
    elsif objclass = "TYPEOBJECT" then
      if is_var(current_expression) then
        c_expr.expr &:= "o_";
        create_name(current_expression, c_expr);
      else
        process_type(type value current_expression, c_expr);
      end if;
    elsif objclass = "INTOBJECT" then
      if is_var(current_expression) then
        c_expr.expr &:= "o_";
        create_name(current_expression, c_expr);
      else
        c_expr.expr &:= str(integer value current_expression);
      end if;
    elsif objclass = "FLOATOBJECT" then
      if is_var(current_expression) then
        c_expr.expr &:= "o_";
        create_name(current_expression, c_expr);
      else
        c_expr.expr &:= str(float value current_expression);
      end if;
    elsif objclass = "CHAROBJECT" then
      if is_var(current_expression) then
        c_expr.expr &:= "o_";
        create_name(current_expression, c_expr);
      else
        c_expr.expr &:= c_literal(char value current_expression);
      end if;
    elsif objclass = "STRIOBJECT" then
      if is_var(current_expression) then
        c_expr.expr &:= "o_";
        create_name(current_expression, c_expr);
      else
        c_expr.expr &:= "str_from_cstri(";
        c_expr.expr &:= c_literal(string value current_expression);
        c_expr.expr &:= ")";
      end if;
    elsif objclass = "REFOBJECT" then
      if is_var(current_expression) then
        c_expr.expr &:= "o_";
        create_name(current_expression, c_expr);
      else
        if reference value current_expression = NIL then
          c_expr.expr &:= "NULL";
        else
          c_expr.expr &:= "&(";
          process_expr(reference value current_expression, c_expr);
          c_expr.expr &:= ")";
        end if;
      end if;
    elsif objclass = "REFLISTOBJECT" then
      c_expr.expr &:= "o_";
      create_name(current_expression, c_expr);
    elsif objclass = "ARRAYOBJECT" then
      c_expr.expr &:= "o_";
      create_name(current_expression, c_expr);
    elsif objclass = "HASHOBJECT" then
      c_expr.expr &:= "o_";
      create_name(current_expression, c_expr);
    elsif objclass = "SETOBJECT" then
      c_expr.expr &:= "o_";
      create_name(current_expression, c_expr);
    elsif objclass = "STRUCTOBJECT" then
      c_expr.expr &:= "o_";
      create_name(current_expression, c_expr);
    elsif objclass = "CLASSOBJECT" then
      c_expr.expr &:= "o_";
      create_name(current_expression, c_expr);
    elsif objclass = "WINOBJECT" then
      if is_var(current_expression) then
        c_expr.expr &:= "o_";
        create_name(current_expression, c_expr);
      else
        c_expr.expr &:= "/*WINOBJECT*/ NULL";
      end if;
    elsif objclass = "PROGOBJECT" then
      if is_var(current_expression) then
        c_expr.expr &:= "o_";
        create_name(current_expression, c_expr);
      else
        if program value current_expression = program.EMPTY then
          c_expr.expr &:= "/*program.EMPTY*/NULL";
        else
          c_expr.expr &:= "o_";
          create_name(current_expression, c_expr);
        end if;
      end if;
    elsif objclass = "CONSTENUMOBJECT" then
      c_expr.expr &:= "o_";
      create_name(current_expression, c_expr);
    elsif objclass = "VARENUMOBJECT" then
      c_expr.expr &:= "o_";
      create_name(current_expression, c_expr);
    elsif objclass = "ENUMLITERALOBJECT" then
      c_expr.expr &:= "o_";
      create_name(current_expression, c_expr);
    elsif objclass = "EXPROBJECT" then
      c_expr.expr &:= "o_";
      create_name(current_expression, c_expr);
    elsif objclass = "SYMBOLOBJECT" then
      c_expr.expr &:= "/* SYMBOLOBJECT ";
      c_expr.expr &:= str(current_expression);
      c_expr.expr &:= " */";
    else
      c_expr.expr &:= "/* ";
      c_expr.expr &:= objclass;
      c_expr.expr &:= " */";
    end if;
  end func;


const proc: process_params (in ref_list: formal_params, inout expr_type: c_expr) is func

  local
    var reference: formal_param is NIL;
    var string: objclass is "";
    var boolean: first_element is TRUE;
  begin
    for formal_param range formal_params do
      objclass := obj_class(formal_param);
      if objclass <> "SYMBOLOBJECT" then
        if objclass = "TYPEOBJECT" then
          c_expr.expr &:= "/* attr t_";
          c_expr.expr &:= str(type_number(type value formal_param));
          c_expr.expr &:= " ";
          c_expr.expr &:= str(type value formal_param);
          c_expr.expr &:= "*/ ";
        else
          if first_element then
            first_element := FALSE;
          else
            c_expr.expr &:= ", ";
          end if;
          process_type(getType(formal_param), c_expr);
          if objclass = "REFPARAMOBJECT" then
            c_expr.expr &:= " *o_";
          else
            c_expr.expr &:= " o_";
          end if;
          create_name(formal_param, c_expr);
        end if;
      end if;
    end for;
    if first_element then
      c_expr.expr &:= "void";
    end if;
  end func;


const proc: process_prototype_params (in ref_list: param_list, inout expr_type: c_expr) is func

  local
    var reference: obj is NIL;
    var string: objclass is "";
    var boolean: first_element is TRUE;
  begin
    for obj range param_list do
      objclass := obj_class(obj);
      if objclass <> "SYMBOLOBJECT" then
        if objclass = "TYPEOBJECT" then
          c_expr.expr &:= " /* attr ";
          process_type(type value obj, c_expr);
          c_expr.expr &:= " */ ";
        else
          if first_element then
            first_element := FALSE;
          else
            c_expr.expr &:= ", ";
          end if;
          process_type(getType(obj), c_expr);
          (* c_expr.expr &:= " o_"; *)
          (* create_name(obj, c_expr); *)
        end if;
      else
        c_expr.expr &:= " /* ";
        c_expr.expr &:= str(obj);
        c_expr.expr &:= " */ ";
      end if;
    end for;
    if first_element then
      c_expr.expr &:= "void";
    end if;
  end func;


const proc: process_result (in reference: result_object, in reference: result_init,
    inout expr_type: c_expr) is func

  begin
    if result_object <> NIL then
      process_type(getType(result_object), c_expr);
      c_expr.expr &:= " o_";
      create_name(result_object, c_expr);
      c_expr.expr &:= "=";
      process_expr(result_init, c_expr);
      c_expr.expr &:= ";\n";
    end if;
  end func;


const proc: process_return (in reference: result_object,
    inout expr_type: c_expr) is func

  begin
    if result_object <> NIL then
      c_expr.expr &:= "return(o_";
      create_name(result_object, c_expr);
      c_expr.expr &:= ");\n";
    end if;
  end func;


const proc: process_proc_declaration (in reference: procedure,
    inout expr_type: c_expr) is func

  local
    var expr_type: c_proc_body is expr_type.value;
    var type: procedure_type is void;
    var type: result_type is void;
    var ref_list: param_list is ref_list.EMPTY;
    var reference: result_object is NIL;
    var reference: result_init is NIL;
  begin
    procedure_type := getType(procedure);
    result_type := result_type(procedure_type);
    if result_type <> typetype then
      param_list := params(procedure);
      if param_list_okay(param_list) then
        process_type(result_type, c_expr);
        if is_varfunc(getType(procedure)) then
          c_expr.expr &:= " *o_";
        else
          c_expr.expr &:= " o_";
        end if;
        create_name(procedure, c_expr);
        c_expr.expr &:= " (";
        process_params(param_list, c_expr);
        c_expr.expr &:= ")\n";
        c_expr.expr &:= "{\n";
        result_object := func_result(procedure);
        if procedure_type <> proctype and result_object = NIL then
          process_expr(body(procedure), c_proc_body);
          if c_proc_body.temp_num <> 0 then
            process_type(result_type, c_expr);
            c_expr.expr &:= " result;\n";
            c_expr.expr &:= c_proc_body.temp_decls;
            c_expr.expr &:= c_proc_body.temp_assigns;
            c_expr.expr &:= "result=(";
            c_expr.expr &:= c_proc_body.expr;
            c_expr.expr &:= ");\n";
            c_expr.expr &:= c_proc_body.temp_frees;
            c_expr.expr &:= "return(result);\n";
          else
            c_expr.expr &:= "return(";
            c_expr.expr &:= c_proc_body.expr;
            c_expr.expr &:= ");\n";
          end if;
        else
          result_init := func_res_init(procedure);
          process_result(result_object, result_init, c_expr);
          process_locals(procedure, c_expr);
          process_expr(body(procedure), c_proc_body);
          c_expr.expr &:= c_proc_body.temp_decls;
          c_expr.expr &:= c_proc_body.temp_assigns;
          c_expr.expr &:= c_proc_body.expr;
          c_expr.expr &:= ";\n";
          c_expr.expr &:= c_proc_body.temp_frees;
          process_return(result_object, c_expr);
        end if;
        c_expr.expr &:= "}\n\n";
        count_declarations;
      end if;
    end if;
  end func;


const proc: process_type_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var type: aType is void;
  begin
    if is_var(current_object) then
      c_expr.expr &:= "typetype o_";
      create_name(current_object, c_expr);
      c_expr.expr &:= "=NULL";
      c_expr.expr &:= ";\n\n";
    else
      aType := type value current_object;
      declare_type_if_necessary(aType, c_expr);
    end if;
    count_declarations;
  end func;


const proc: process_int_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  begin
    if is_var(current_object) then
      c_expr.expr &:= "inttype o_";
      create_name(current_object, c_expr);
      c_expr.expr &:= "=";
      c_expr.expr &:= str(integer value current_object);
      c_expr.expr &:= ";\n\n";
      count_declarations;
    end if;
  end func;


const proc: process_char_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  begin
    if is_var(current_object) then
      c_expr.expr &:= "chartype o_";
      create_name(current_object, c_expr);
      c_expr.expr &:= "=";
      c_expr.expr &:= c_literal(char value current_object);
      c_expr.expr &:= ";\n\n";
      count_declarations;
    end if;
  end func;


const proc: process_stri_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  begin
    if is_var(current_object) then
      c_expr.expr &:= "stritype o_";
      create_name(current_object, c_expr);
      c_expr.expr &:= ";\n";
      global_init.expr &:= "o_";
      create_name(current_object, global_init);
      global_init.expr &:= "=str_from_cstri(";
      global_init.expr &:= c_literal(string value current_object);
      global_init.expr &:= ");\n\n";
      count_declarations;
    end if;
  end func;


const proc: process_float_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  begin
    if is_var(current_object) then
      c_expr.expr &:= "floattype o_";
      create_name(current_object, c_expr);
      c_expr.expr &:= "=";
      c_expr.expr &:= str(float value current_object);
      c_expr.expr &:= ";\n\n";
      count_declarations;
    end if;
  end func;


const proc: action_address (in reference: procedure, inout expr_type: c_expr) is func

  local
    var ACTION: current_action is action "PRC_NOOP";
    var string: action_name is "";
  begin
    current_action := ACTION value procedure;
    action_name := str(current_action);
    if action_name = "BLN_CPY" then
      c_expr.expr &:= "&blnCpy";
    elsif action_name = "BLN_CREATE" then
      c_expr.expr &:= "&blnCreate";
    elsif action_name = "CHR_CMP" then
      c_expr.expr &:= "&chrCmp";
    elsif action_name = "CHR_CREATE" then
      c_expr.expr &:= "&chrCreate";
    elsif action_name = "FLT_CPY" then
      c_expr.expr &:= "&fltCpy";
    elsif action_name = "FLT_CREATE" then
      c_expr.expr &:= "&fltCreate";
    elsif action_name = "INT_CPY" then
      c_expr.expr &:= "&intCpy";
    elsif action_name = "INT_CREATE" then
      c_expr.expr &:= "&intCreate";
    elsif action_name = "PRC_NOOP" then
      c_expr.expr &:= "&prcNoop";
    elsif action_name = "SCT_CPY" then
      c_expr.expr &:= "&sctCpy";
    elsif action_name = "SCT_CREATE" then
      c_expr.expr &:= "&sctCreate";
    elsif action_name = "SCT_DESTR" then
      c_expr.expr &:= "&sctDestr";
    elsif action_name = "SET_CPY" then
      c_expr.expr &:= "&setCpy";
    elsif action_name = "SET_CREATE" then
      c_expr.expr &:= "&setCreate";
    elsif action_name = "SET_DESTR" then
      c_expr.expr &:= "&setDestr";
    elsif action_name = "STR_CREATE" then
      c_expr.expr &:= "&strCreate";
    elsif action_name = "STR_CMP" then
      c_expr.expr &:= "&strCompare";
    elsif action_name = "STR_CPY" then
      c_expr.expr &:= "&strCopy";
    elsif action_name = "STR_DESTR" then
      c_expr.expr &:= "&strDestr";
    else
      c_expr.expr &:= "NULL /* ACTOBJECT { ";
      c_expr.expr &:= action_name;
      c_expr.expr &:= " }*/";
    end if;
  end func;


const proc: process_reference_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var reference: curr_expr is NIL;
    var string: objclass is "";
  begin
    (* if is_var(current_object) then *)
      c_expr.expr &:= "void *o_";
      create_name(current_object, c_expr);
      c_expr.expr &:= "=";
      if reference value current_object = NIL then
        c_expr.expr &:= "NULL";
      else
        curr_expr := reference value current_object;
        objclass := obj_class(curr_expr);
        if objclass = "ACTOBJECT" then
          action_address(curr_expr, c_expr);
        elsif objclass = "BLOCKOBJECT" then
          c_expr.expr &:= "&o_";
          create_name(curr_expr, c_expr);
        else
          c_expr.expr &:= "/* ";
          c_expr.expr &:= objclass;
          c_expr.expr &:= " */";
          block
            c_expr.expr &:= "&(";
            process_expr(reference value current_object, c_expr);
            c_expr.expr &:= ")";
          exception
            catch RANGE_ERROR:
              c_expr.expr &:= "/*RANGE_ERROR*/";
              curr_expr := reference value current_object;
              writeln("] ");
              TRACE(curr_expr);
              writeln;
          end block;
        end if;
      end if;
      c_expr.expr &:= ";\n\n";
      count_declarations;
    (* end if; *)
  end func;


const proc: process_ref_list_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var reference: element is NIL;
    var boolean: first_element is TRUE;
  begin
    if TRUE then
      c_expr.expr &:= "void *o_";
      create_name(current_object, c_expr);
      c_expr.expr &:= "=";
      if length(ref_list value current_object) = 0 then
        c_expr.expr &:= "NULL";
      else
        c_expr.expr &:= "{";
        for element range ref_list value current_object do
          if first_element then
            first_element := FALSE;
          else
            c_expr.expr &:= ", ";
          end if;
          c_expr.expr &:= "&(";
          process_expr(element, c_expr);
          c_expr.expr &:= ")";
        end for;
        c_expr.expr &:= "}";
      end if;
      c_expr.expr &:= ";\n\n";
      count_declarations;
    end if;
  end func;


const proc: process_array_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "arraytype o_";
    create_name(current_object, c_expr);
    c_expr.expr &:= "=NULL";
    c_expr.expr &:= ";\n\n";
    count_declarations;
  end func;


const proc: process_hash_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "hashtype o_";
    create_name(current_object, c_expr);
    c_expr.expr &:= "=NULL";
    c_expr.expr &:= ";\n\n";
    count_declarations;
  end func;


const proc: process_set_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "settype o_";
    create_name(current_object, c_expr);
    c_expr.expr &:= "=NULL";
    c_expr.expr &:= ";\n\n";
    count_declarations;
  end func;


const proc: process_struct_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "structtype o_";
    create_name(current_object, c_expr);
    c_expr.expr &:= "=NULL";
    c_expr.expr &:= ";\n\n";
    count_declarations;
  end func;


const proc: process_class_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "structtype o_";
    create_name(current_object, c_expr);
    c_expr.expr &:= "=NULL";
    c_expr.expr &:= ";\n\n";
    count_declarations;
  end func;


const proc: process_win_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  begin
    if is_var(current_object) then
      c_expr.expr &:= "wintype o_";
      create_name(current_object, c_expr);
      c_expr.expr &:= "=";
      c_expr.expr &:= "NULL";
      c_expr.expr &:= ";\n\n";
      count_declarations;
    end if;
  end func;


const proc: process_prog_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  begin
    if is_var(current_object) then
      c_expr.expr &:= "progtype o_";
      create_name(current_object, c_expr);
      c_expr.expr &:= "=";
      c_expr.expr &:= "NULL";
      c_expr.expr &:= ";\n\n";
      count_declarations;
    end if;
  end func;


const proc: process_enum_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  begin
    if is_var(current_object) then
      declare_type_if_necessary(getType(current_object), c_expr);
      process_type(getType(current_object), c_expr);
      c_expr.expr &:= " o_";
      create_name(current_object, c_expr);
      c_expr.expr &:= "=";
      c_expr.expr &:= enum_value(reference value current_object);
      c_expr.expr &:= ";\n\n";
    else
      declare_type_if_necessary(getType(current_object), c_expr);
      process_type(getType(current_object), c_expr);
      c_expr.expr &:= " o_";
      create_name(current_object, c_expr);
      c_expr.expr &:= "=";
      c_expr.expr &:= enum_value(reference value current_object);
      c_expr.expr &:= ";\n\n";
    end if;
    count_declarations;
  end func;


const proc: process_enum_literal (in reference: current_object,
    inout expr_type: c_expr) is func

  begin
    declare_type_if_necessary(getType(current_object), c_expr);
    process_type(getType(current_object), c_expr);
    c_expr.expr &:= " o_";
    create_name(current_object, c_expr);
    c_expr.expr &:= "=";
    c_expr.expr &:= enum_value(current_object);
    c_expr.expr &:= ";\n\n";
    count_declarations;
  end func;


const proc: process_dynamic_decision (in ref_list: formal_params,
    inout expr_type: c_expr) is func

  local
    var reference: formal_param is NIL;
    var string: objclass is "";
    var type: param_type is void;
  begin
    for formal_param range formal_params do
      objclass := obj_class(formal_param);
      if objclass <> "SYMBOLOBJECT" then
        if objclass = "TYPEOBJECT" then
          c_expr.expr &:= "/* attr t_";
          c_expr.expr &:= str(type_number(type value formal_param));
          c_expr.expr &:= " ";
          c_expr.expr &:= str(type value formal_param);
          c_expr.expr &:= "*/ ";
        else
          param_type := getType(formal_param);
          if objclass = "REFPARAMOBJECT" then
            c_expr.expr &:= " *o_";
          else
            c_expr.expr &:= " o_";
          end if;
          create_name(formal_param, c_expr);
        end if;
      end if;
    end for;
  end func;


const proc: print_parameter_list (in ref_list: formal_params,
    inout expr_type: c_expr) is func

  local
    var reference: formal_param is NIL;
    var string: objclass is "";
    var boolean: first_element is TRUE;
    var type: param_type is void;
  begin
    for formal_param range formal_params do
      objclass := obj_class(formal_param);
      if objclass <> "SYMBOLOBJECT" then
        if first_element then
          first_element := FALSE;
        else
          c_expr.expr &:= " printf(\", \");\n";
        end if;
        c_expr.expr &:= "printf(";
        c_expr.expr &:= c_literal(objclass & " ");
        c_expr.expr &:= "); ";
        param_type := getType(formal_param);
        if param_type = stritype then
          c_expr.expr &:= "printf(\"stritype \"); ";
          c_expr.expr &:= "prc_print(";
        elsif param_type = chartype then
          c_expr.expr &:= "printf(\"chartype \"); ";
          c_expr.expr &:= "printf(\"%c\", ";
        elsif param_type = inttype then
          c_expr.expr &:= "printf(\"inttype \"); ";
          c_expr.expr &:= "printf(\"%ld\", ";
        elsif param_type = floattype then
          c_expr.expr &:= "printf(\"floattype \"); ";
          c_expr.expr &:= "printf(\"%f\", ";
        elsif param_type = typetype then
          c_expr.expr &:= "printf(\"typetype \"); ";
          c_expr.expr &:= "printf(\"%X\", ";
        elsif param_type = proctype then
          c_expr.expr &:= "printf(\"proctype \"); ";
          c_expr.expr &:= "printf(\"%X\", ";
        elsif param_type = voidtype then
          c_expr.expr &:= "printf(\"voidtype \"); ";
          c_expr.expr &:= "printf(\"%X\", ";
        else
          c_expr.expr &:= "printf(\"";
          c_expr.expr &:= "t_";
          c_expr.expr &:= str(type_number(param_type));
          c_expr.expr &:= "/*";
          c_expr.expr &:= str(param_type);
          c_expr.expr &:= "*/ \"); ";
          c_expr.expr &:= "printf(\"%X\", ";
        end if;
        if objclass = "REFPARAMOBJECT" then
          c_expr.expr &:= "(o_";
          create_name(formal_param, c_expr);
          c_expr.expr &:= "?*o_";
          create_name(formal_param, c_expr);
          c_expr.expr &:= ":0)";
        else
          c_expr.expr &:= "o_";
          create_name(formal_param, c_expr);
        end if;
        c_expr.expr &:= ");";
      end if;
    end for;
  end func;


const proc: process_dynamic_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var type: object_type is void;
    var type: result_type is void;
    var ref_list: param_list is ref_list.EMPTY;
  begin
    object_type := getType(current_object);
    if is_func(object_type) or is_varfunc(object_type) then
      result_type := result_type(object_type);
      if result_type <> typetype then
        c_expr.expr &:= "/* DYNAMIC */ ";
        process_type(result_type, c_expr);
        if is_varfunc(object_type) then
          c_expr.expr &:= " *o_";
        else
          c_expr.expr &:= " o_";
        end if;
        create_name(current_object, c_expr);
        param_list := params(current_object);
        c_expr.expr &:= " (";
        process_params(param_list, c_expr);
        c_expr.expr &:= ")\n";
        c_expr.expr &:= "{\n";
        c_expr.expr &:= "printf(\"o_";
        create_name(current_object, c_expr);
        c_expr.expr &:= "(\");\n";
        print_parameter_list(param_list, c_expr);
        c_expr.expr &:= "printf(\")\\n\");\n";
        c_expr.expr &:= "}\n\n";
      end if;
    end if;
  end func;


const proc: process_action_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var ACTION: current_action is action "PRC_NOOP";
    var string: action_name is "";
  begin
    current_action := ACTION value current_object;
    action_name := str(current_action);
    if action_name = "PRC_DYNAMIC" then
      process_dynamic_declaration(current_object, c_expr);
      count_declarations;
(*
    else
      c_expr.expr &:= "/* ACTION ";
      c_expr.expr &:= action_name;
      c_expr.expr &:= " */";
*)
    end if;
  end func;


const proc: process_object_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var string: objclass is "";
  begin
    objclass := obj_class(current_object);
    if objclass = "BLOCKOBJECT" then
      process_proc_declaration(current_object, c_expr);
    elsif objclass = "TYPEOBJECT" then
      process_type_declaration(current_object, c_expr);
    elsif objclass = "INTOBJECT" then
      process_int_declaration(current_object, c_expr);
    elsif objclass = "CHAROBJECT" then
      process_char_declaration(current_object, c_expr);
    elsif objclass = "STRIOBJECT" then
      process_stri_declaration(current_object, c_expr);
    elsif objclass = "FLOATOBJECT" then
      process_float_declaration(current_object, c_expr);
    elsif objclass = "REFOBJECT" then
      process_reference_declaration(current_object, c_expr);
    elsif objclass = "REFLISTOBJECT" then
      process_ref_list_declaration(current_object, c_expr);
    elsif objclass = "ARRAYOBJECT" then
      process_array_declaration(current_object, c_expr);
    elsif objclass = "HASHOBJECT" then
      process_hash_declaration(current_object, c_expr);
    elsif objclass = "SETOBJECT" then
      process_set_declaration(current_object, c_expr);
    elsif objclass = "STRUCTOBJECT" then
      process_struct_declaration(current_object, c_expr);
    elsif objclass = "CLASSOBJECT" then
      process_class_declaration(current_object, c_expr);
    elsif objclass = "WINOBJECT" then
      process_win_declaration(current_object, c_expr);
    elsif objclass = "PROGOBJECT" then
      process_prog_declaration(current_object, c_expr);
    elsif objclass = "CONSTENUMOBJECT" then
      process_enum_declaration(current_object, c_expr);
    elsif objclass = "VARENUMOBJECT" then
      process_enum_declaration(current_object, c_expr);
    elsif objclass = "ENUMLITERALOBJECT" then
      process_enum_literal(current_object, c_expr);
    elsif objclass = "ACTOBJECT" then
      process_action_declaration(current_object, c_expr);
    else
      c_expr.expr &:= "/* ";
      c_expr.expr &:= objclass;
      c_expr.expr &:= " */\n";
    end if;
  end func;


const proc: process_object (in reference: current_object) is func

  local
    var expr_type: c_expr is expr_type.value;
  begin
    process_object_declaration(current_object, c_expr);
    c_prog << c_expr.expr;
  end func;


const proc: write_file_head is func

  begin
    c_prog << "#include <stdlib.h>\n";
    c_prog << "#include <stdio.h>\n";
    c_prog << "int arg_c;\n";
    c_prog << "char **arg_v;\n";
    c_prog << "typedef long typetype;\n";
    c_prog << "typedef long int inttype;\n";
    c_prog << "typedef unsigned long int chartype;\n";
    c_prog << "typedef unsigned long int strelemtype;\n";
    c_prog << "typedef unsigned long int bitsettype;\n";
    c_prog << "typedef FILE *filetype;\n";
    c_prog << "typedef struct list {\n";
    c_prog << "  struct list *next;\n";
    c_prog << "  long obj;\n";
    c_prog << "} *listtype;\n";
    c_prog << "typedef struct stri {\n";
    c_prog << "  unsigned long int size;\n";
    c_prog << "  strelemtype mem[1];\n";
    c_prog << "} *stritype;\n";
    c_prog << "typedef struct {\n";
    c_prog << "  unsigned long int size;\n";
    c_prog << "  long arr[1];\n";
    c_prog << "} *arraytype;\n";
    c_prog << "typedef unsigned long int hashtype;\n";
    c_prog << "typedef struct {\n";
    c_prog << "  inttype min_position;\n";
    c_prog << "  inttype max_position;\n";
    c_prog << "  bitsettype bitset[1];\n";
    c_prog << "} *settype;\n";
    c_prog << "typedef struct {\n";
    c_prog << "  unsigned long int size;\n";
    c_prog << "  long arr[1];\n";
    c_prog << "} *structtype;\n";
    c_prog << "typedef float floattype;\n";
    c_prog << "typedef inttype wintype;\n";
    c_prog << "typedef inttype progtype;\n";
    c_prog << "unsigned long int hs;\n";
    c_prog << "\n";
    c_prog << "static inttype fact[] = {\n";
    c_prog << "    1, 1, 2, 6, 24, 120, 720, 5040, 40320,\n";
    c_prog << "    362880, 3628800, 39916800, 479001600\n";
    c_prog << "  };\n";
    c_prog << "#define any_free(x)\n";
    c_prog << "stritype  act_str (void *a)                             {printf(\"act_str\\n\");}\n";
    c_prog << "arraytype arr_arrlit (arraytype a)                      {printf(\"arr_arrlit\\n\");}\n";
    c_prog << "arraytype arr_arrlit2 (inttype a, arraytype b)          {printf(\"arr_arrlit2\\n\");}\n";
    c_prog << "arraytype arr_baselit (long a)                          {printf(\"arr_baselit\\n\");}\n";
    c_prog << "arraytype arr_baselit2 (inttype a, long b)              {printf(\"arr_baselit2\\n\");}\n";
    c_prog << "arraytype arr_cat (arraytype a, arraytype b)            {printf(\"arr_cat\\n\");}\n";
    c_prog << "void      arr_cpy (arraytype a, arraytype b)            {printf(\"arr_cpy\\n\");}\n";
    c_prog << "void      arr_free (arraytype a)                        {printf(\"arr_free\\n\");}\n";
    c_prog << "arraytype arr_extend (arraytype a, inttype b)           {printf(\"arr_extend\\n\");}\n";
    c_prog << "arraytype arr_gen (inttype a, inttype b)                {printf(\"arr_gen\\n\");}\n";
    c_prog << "arraytype arr_head (arraytype a, inttype b)             {printf(\"arr_head\\n\");}\n";
    c_prog << "arraytype arr_range (arraytype a, inttype b, inttype c) {printf(\"arr_range\\n\");}\n";
    c_prog << "arraytype arr_tail (arraytype a, inttype b)             {printf(\"arr_tail\\n\");}\n";
    c_prog << "arraytype arr_times (inttype a, long b)                 {printf(\"arr_times\\n\");}\n";
    c_prog << "stritype  chr_str (chartype a)                          {printf(\"chr_str\\n\");}\n";
    c_prog << "void      drwArc (wintype, inttype, inttype, inttype, floattype, floattype);\n";
    c_prog << "void      drwArc2 (wintype, inttype, inttype, inttype, inttype, inttype);\n";
    c_prog << "void      drwCircle (wintype, inttype, inttype, inttype);\n";
    c_prog << "void      drwClear (wintype);\n";
    c_prog << "void      drwColor (inttype);\n";
    c_prog << "void      drwFArcChord (wintype, inttype, inttype, inttype, floattype, floattype);\n";
    c_prog << "void      drwFArcPieSlice (wintype, inttype, inttype, inttype, floattype, floattype);\n";
    c_prog << "void      drwFCircle (wintype, inttype, inttype, inttype);\n";
    c_prog << "void      drwFEllipse (wintype, inttype, inttype, inttype, inttype);\n";
    c_prog << "void      drwFlush (void);\n";
    c_prog << "wintype   drwGet (wintype, inttype, inttype, inttype, inttype);\n";
    c_prog << "inttype   drwHeight (wintype);\n";
    c_prog << "wintype   drwImage (wintype, inttype *, inttype, inttype);\n";
    c_prog << "void      drwLine (wintype, inttype, inttype, inttype, inttype);\n";
    c_prog << "wintype   drwOpen (inttype, inttype, inttype, inttype, stritype);\n";
    c_prog << "void      drwPoint (wintype, inttype, inttype);\n";
    c_prog << "void      drwPPoint (wintype, inttype, inttype, inttype);\n";
    c_prog << "void      drwPRect (wintype, inttype, inttype, inttype, inttype, inttype);\n";
    c_prog << "void      drwPut (wintype, wintype, inttype, inttype);\n";
    c_prog << "void      drwRect (wintype, inttype, inttype, inttype, inttype);\n";
    c_prog << "inttype   drwRgbColor (inttype, inttype, inttype);\n";
    c_prog << "void      drwText (wintype, inttype, inttype, stritype);\n";
    c_prog << "inttype   drwWidth (wintype);\n";
    c_prog << "void      drw_cpy (void *a, void *b)                    {printf(\"drw_cpy\\n\");}\n";
    c_prog << "inttype   enu_value (void *a)                           {printf(\"enu_value\\n\");}\n";
    c_prog << "stritype  filLineRead (filetype, chartype *);\n";
    c_prog << "inttype   filLng (filetype );\n";
    c_prog << "stritype  filStriRead (filetype, inttype);\n";
    c_prog << "stritype  filWordRead (filetype, chartype *);\n";
    c_prog << "void      filWrite (filetype, stritype);\n";
    c_prog << "void      fltCpy (floattype *, floattype);\n";
    c_prog << "void      fltCreate (floattype *, floattype);\n";
    c_prog << "stritype  fltDgts (floattype, inttype);\n";
    c_prog << "floattype fltIpow (floattype, inttype);\n";
    c_prog << "floattype fltParse (stritype);\n";
    c_prog << "floattype fltPow (floattype, floattype);\n";
    c_prog << "floattype fltRand (floattype, floattype);\n";
    c_prog << "stritype  fltStr (floattype);\n";
    c_prog << "chartype  gkbGetc (void);\n";
    c_prog << "inttype   gkbKeyPressed (void);\n";
    c_prog << "chartype  gkbRawGetc (void);\n";
    c_prog << "stritype  gkb_line_read(void *a, chartype *b)           {printf(\"gkb_line_read\\n\");}\n";
    c_prog << "stritype  gkb_word_read(void *a, chartype *b)           {printf(\"gkb_word_read\\n\");}\n";
    c_prog << "inttype   intBinom (inttype, inttype);\n";
    c_prog << "void      intCpy (inttype *, inttype);\n";
    c_prog << "void      intCreate (inttype *, inttype);\n";
    c_prog << "inttype   int_hsize (void)                              {printf(\"int_hsize\\n\");}\n";
    c_prog << "inttype   intLd (inttype);\n";
    c_prog << "inttype   intParse (stritype);\n";
    c_prog << "inttype   intPow (inttype, inttype);\n";
    c_prog << "inttype   intRand (inttype, inttype);\n";
    c_prog << "inttype   intSqrt (inttype);\n";
    c_prog << "stritype  intStr (inttype);\n";
    c_prog << "chartype  kbdGetc (void);\n";
    c_prog << "inttype   kbdKeyPressed (void);\n";
    c_prog << "chartype  kbdRawGetc (void);\n";
    c_prog << "stritype  kbd_line_read(void *a, chartype *b)           {printf(\"kbd_line_read\\n\");}\n";
    c_prog << "stritype  kbd_word_read(void *a, chartype *b)           {printf(\"kbd_word_read\\n\");}\n";
    c_prog << "arraytype prc_args (void)                               {printf(\"prc_args\\n\");}\n";
    c_prog << "void      prcNoop (void)                                {printf(\"prcNoop\\n\");}\n";
    c_prog << "void      prc_print (stritype stri) {\n\
              \char *str1;\n\
              \str1 = cp_to_cstri(stri);\n\
              \if (str1 != NULL) {\n\
              \  fputs(str1, stdout);\n\
              \  fflush(stdout);\n\
              \  free(str1);\n\
              \}\n\
              \}\n";
    c_prog << "long *    ref_select (void *a, inttype b)               {printf(\"ref_select\\n\");}\n";
    c_prog << "float *   ref_fselect (void *a, inttype b)              {printf(\"ref_fselect\\n\");}\n";
    c_prog << "stritype  ref_str (void *a)                             {printf(\"ref_str\\n\");}\n";
    c_prog << "void      rfl_cpy (void *a, void *b)                    {printf(\"rfl_cpy\\n\");}\n";
    c_prog << "inttype   rfl_elem (void *a, void *b)                   {printf(\"rfl_elem\\n\");}\n";
    c_prog << "void *    rfl_idx (void *a, inttype b)                  {printf(\"rfl_idx\\n\");}\n";
    c_prog << "inttype   rfl_lng (void *a)                             {printf(\"rfl_lng\\n\");}\n";
    c_prog << "void      sct_cpy (structtype a, structtype b)          {printf(\"sct_cpy\\n\");}\n";
    c_prog << "long *    sct_select (void *a, inttype b)               {printf(\"sct_select\\n\");}\n";
    c_prog << "float *   sct_fselect (void *a, inttype b)              {printf(\"sct_fselect\\n\");}\n";
    c_prog << "settype   set_baselit (inttype a)                       {printf(\"set_baselit\\n\");}\n";
    c_prog << "inttype   setCard (settype);\n";
    c_prog << "void      setCpy (settype *, settype);\n";
    c_prog << "settype   setDiff (settype, settype);\n";
    c_prog << "inttype   setElem (inttype, settype);\n";
    c_prog << "void      setExcl (settype *, inttype);\n";
    c_prog << "void      setIncl (settype *, inttype);\n";
    c_prog << "settype   setIntersect (settype, settype);\n";
    c_prog << "inttype   setMax (settype);\n";
    c_prog << "inttype   setMin (settype);\n";
    c_prog << "inttype   setNe (settype, settype);\n";
    c_prog << "inttype   setNotElem (inttype, settype);\n";
    c_prog << "settype   setUnion (settype, settype);\n";
    c_prog << "void      strAppend (stritype *, stritype);\n";
    c_prog << "stritype  strConcat (stritype, stritype);\n";
    c_prog << "stritype  str_clit (stritype a)                         {printf(\"str_clit\\n\");}\n";
    c_prog << "inttype   strCompare (stritype, stritype);\n";
    c_prog << "void      strCopy (stritype *, stritype);\n";
    c_prog << "void      strCreate (stritype *, stritype);\n";
    c_prog << "void      strDestr (stritype);\n";
    c_prog << "#define   str_free(stri) free(stri)\n";
    c_prog << "inttype   strGe (stritype, stritype);\n";
    c_prog << "inttype   strGt (stritype, stritype);\n";
    c_prog << "inttype   strHashCode (stritype);\n";
    c_prog << "stritype  str_head (stritype a, inttype b)              {printf(\"str_head\\n\");}\n";
    c_prog << "stritype  str_lit (stritype a)                          {printf(\"str_lit\\n\");}\n";
    c_prog << "stritype  strLpad (stritype, inttype);\n";
    c_prog << "inttype   strLe (stritype, stritype);\n";
    c_prog << "stritype  strLow (stritype);\n";
    c_prog << "inttype   strLt (stritype, stritype);\n";
    c_prog << "stritype  strMult (stritype, inttype);\n";
    c_prog << "inttype   strPos (stritype, stritype);\n";
    c_prog << "stritype  str_range (stritype a, inttype b, inttype c)  {printf(\"str_range\\n\");}\n";
    c_prog << "stritype  strRepl (stritype, stritype, stritype);\n";
    c_prog << "stritype  strRpad (stritype, inttype);\n";
    c_prog << "inttype   strRpos (stritype, stritype);\n";
    c_prog << "stritype  str_substr (stritype a, inttype b, inttype c) {printf(\"str_substr\\n\");}\n";
    c_prog << "stritype  str_tail (stritype a, inttype b)              {printf(\"str_tail\\n\");}\n";
    c_prog << "stritype  strUp (stritype);\n";
    c_prog << "stritype  str_from_cstri (char *cstri) {\n\
              \size_t len;\n\
              \stritype result;\n\
              \len = strlen(cstri);\n\
              \if (result = (stritype) malloc(sizeof(struct stri) - sizeof(strelemtype) + len * sizeof(strelemtype))) {\n\
              \  result->size = len;\n\
              \  stri_expand(result->mem, cstri, len * sizeof(char));\n\
              \  return(result);\n\
              \}\n\
              \return(NULL);\n\
              \}\n";
    c_prog << "char *    str_to_cstri (stritype a)                     {printf(\"str_to_cstri\\n\");}\n";
    c_prog << "void      tim_await (inttype a, inttype b, inttype c, \
         \inttype d, inttype e, inttype f, inttype g)                  {printf(\"tim_await\\n\");}\n";
    c_prog << "void      tim_now (inttype a, inttype b, inttype c, \
         \inttype d, inttype e, inttype f, inttype g, inttype h)       {printf(\"tim_now\\n\");}\n";
    c_prog << "inttype   unx_lng (stritype a)                          {printf(\"unx_lng\\n\");}\n";
    c_prog << "arraytype unx_ls (stritype a)                           {printf(\"unx_ls\\n\");}\n";
    c_prog << "stritype  unx_pwd (void)                                {printf(\"unx_pwd\\n\");}\n";
    c_prog << "void      raise_error (int a)                           {printf(\"raise_error\\n\");}\n";
(*
    c_prog << "stritype  act_str (void * );\n";
    c_prog << "arraytype arr_arrlit (arraytype);\n";
    c_prog << "arraytype arr_arrlit2 (inttype, arraytype);\n";
    c_prog << "arraytype arr_baselit (long);\n";
    c_prog << "arraytype arr_baselit2 (inttype, long);\n";
    c_prog << "arraytype arr_cat (arraytype, arraytype);\n";
    c_prog << "void      arr_cpy (arraytype, arraytype);\n";
    c_prog << "void      arr_free (arraytype);\n";
    c_prog << "arraytype arr_extend (arraytype, inttype);\n";
    c_prog << "arraytype arr_gen (inttype, inttype);\n";
    c_prog << "arraytype arr_head (arraytype, inttype);\n";
    c_prog << "arraytype arr_range (arraytype, inttype, inttype);\n";
    c_prog << "arraytype arr_tail (arraytype, inttype);\n";
    c_prog << "arraytype arr_times (inttype, long);\n";
    c_prog << "stritype  chr_str (chartype);\n";
    c_prog << "void      drw_cpy (void *, void * );\n";
    c_prog << "inttype   enu_value (void * );\n";
    c_prog << "stritype  filLineRead (filetype a, chartype *b)         {printf(\"filLineRead\\n\");}\n";
    c_prog << "inttype   filLng (filetype a)                           {printf(\"filLng\\n\");}\n";
    c_prog << "stritype  filStriRead (filetype a, inttype b)           {printf(\"filStriRead\\n\");}\n";
    c_prog << "stritype  filWordRead (filetype a, chartype *b)         {printf(\"filWordRead\\n\");}\n";
    c_prog << "void      filWrite (filetype a, stritype b)             {printf(\"filWrite\\n\");}\n";
    c_prog << "void      fltCpy (floattype *a, floattype b)            {printf(\"fltCpy\\n\");}\n";
    c_prog << "void      fltCreate (floattype *a, floattype b)         {printf(\"fltCreate\\n\");}\n";
    c_prog << "stritype  fltDgts (floattype a, inttype b)              {printf(\"fltDgts\\n\");}\n";
    c_prog << "floattype fltIpow (floattype a, inttype b)              {printf(\"fltIpow\\n\");}\n";
    c_prog << "floattype fltParse (stritype a)                         {printf(\"fltParse\\n\");}\n";
    c_prog << "floattype fltPow (floattype a, floattype b)             {printf(\"fltPow\\n\");}\n";
    c_prog << "floattype fltRand (floattype a, floattype b)            {printf(\"fltRand\\n\");}\n";
    c_prog << "stritype  fltStr (floattype a)                          {printf(\"fltStr\\n\");}\n";
    c_prog << "int       gkbGetc (void);                               {printf(\"gkbGetc\\n\");}\n";
    c_prog << "inttype   gkbKeyPressed (void);                         {printf(\"gkbKeyPressed\\n\");}\n";
    c_prog << "inttype   intBinom (inttype a, inttype b)               {printf(\"intBinom\\n\");}\n";
    c_prog << "void      intCpy (inttype *a, inttypeb)                 {printf(\"intCpy\\n\");}\n";
    c_prog << "void      intCreate (inttype *a, inttypeb)              {printf(\"intCreate\\n\");}\n";
    c_prog << "inttype   int_hsize (void);\n";
    c_prog << "inttype   intLd (inttype a) {\n\
              \if (a < 0) {\n\
              \  raise_error(2);\n\
              \  return(0);\n\
              \} else {\n\
              \  return(most_significant_bit(a));\n\
              \}\n\
              \}\n";
    c_prog << "inttype   intParse (stritype a)                         {printf(\"intParse\\n\");}\n";
    c_prog << "inttype   intPow (inttype a, inttype b)                 {printf(\"intPow\\n\");}\n";
    c_prog << "inttype   intRand (inttype a, inttype b)                {printf(\"intRand\\n\");}\n";
    c_prog << "inttype   intSqrt (inttype a)                           {printf(\"intSqrt\\n\");}\n";
    c_prog << "stritype  intStr (inttype a)                            {printf(\"intStr\\n\");}\n";
    c_prog << "chartype  kbdGetc (void)                                {printf(\"kbdGetc\\n\");}\n";
    c_prog << "inttype   kbdKeyPressed (void)                          {printf(\"kbdKeyPressed\\n\");}\n";
    c_prog << "chartype  kbdRawGetc (void)                             {printf(\"kbdRawGetc\\n\");}\n";
    c_prog << "arraytype prc_args (void);\n";
    c_prog << "void      prcNoop (void);\n";
    c_prog << "long *    ref_select (void *, inttype);\n";
    c_prog << "float *   ref_fselect (void *, inttype);\n";
    c_prog << "stritype  ref_str (void * );\n";
    c_prog << "void      rfl_cpy (void *, void * );\n";
    c_prog << "inttype   rfl_elem (void *, void * );\n";
    c_prog << "void *    rfl_idx (void, inttype);\n";
    c_prog << "inttype   rfl_lng (void * );\n";
    c_prog << "void      sct_cpy (structtype, structtype);\n";
    c_prog << "long *    sct_select (void *, inttype);\n";
    c_prog << "float *   sct_fselect (void *, inttype);\n";
    c_prog << "settype   set_baselit (inttype);\n";
    c_prog << "inttype   setCard (settype a)                           {printf(\"setCard\\n\");}\n";
    c_prog << "void      setCpy (settype *a, settype b)                {printf(\"setCpy\\n\");}\n";
    c_prog << "settype   setDiff (settype a, settype b)                {printf(\"setDiff\\n\");}\n";
    c_prog << "inttype   setElem (inttype a, settype b)                {printf(\"setElem\\n\");}\n";
    c_prog << "void      setExcl (settype *a, inttype b)               {printf(\"setExcl\\n\");}\n";
    c_prog << "void      setIncl (settype *a, inttype b)               {printf(\"setIncl\\n\");}\n";
    c_prog << "settype   setIntersect (settype a, settype b)           {printf(\"setIntersect\\n\");}\n";
    c_prog << "inttype   setMax (settype a)                            {printf(\"setMax\\n\");}\n";
    c_prog << "inttype   setMin (settype a)                            {printf(\"setMin\\n\");}\n";
    c_prog << "inttype   setNe (settype, settype)                      {printf(\"setNe\\n\");}\n";
    c_prog << "inttype   setNotElem (inttype a, settype b)             {printf(\"setNotElem\\n\");}\n";
    c_prog << "settype   setUnion (settype a, settype b)               {printf(\"setUnion\\n\");}\n";
    c_prog << "void      strAppend (stritype *a, stritype b)           {printf(\"strAppend\\n\");}\n";
    c_prog << "stritype  strConcat (stritype a, stritype b)            {printf(\"strConcat\\n\");}\n";
    c_prog << "stritype  str_clit (stritype);\n";
    c_prog << "inttype   strCompare (stritype a, stritypeb)            {printf(\"strCompare\\n\");}\n";
    c_prog << "void      strCopy (stritype *a, stritype b)             {printf(\"strCopy\\n\");}\n";
    c_prog << "void      strCreate (stritype *a, stritype b)           {printf(\"strCreate\\n\");}\n";
    c_prog << "void      strDestr (stritype a)                         {printf(\"strDestr\\n\");}\n";
    c_prog << "void      str_free (stritype);\n";
    c_prog << "inttype   strGe (stritype a, stritype b)                {printf(\"strGe\\n\");}\n";
    c_prog << "inttype   strGt (stritype a, stritype b)                {printf(\"strGt\\n\");}\n";
    c_prog << "inttype   strHashCode (stritype a)                      {printf(\"strHashCode\\n\");}\n";
    c_prog << "stritype  str_head (stritype, inttype);\n";
    c_prog << "stritype  str_lit (stritype);\n";
    c_prog << "stritype  strLpad (stritype a, inttype b)               {printf(\"strLpad\\n\");}\n";
    c_prog << "inttype   strLe (stritype a, stritype b)                {printf(\"strLe\\n\");}\n";
    c_prog << "stritype  strLow (stritype a)                           {printf(\"strLow\\n\");}\n";
    c_prog << "inttype   strLt (stritype a, stritype b)                {printf(\"strLt\\n\");}\n";
    c_prog << "stritype  strMult (stritype a, inttype b)               {printf(\"strMult\\n\");}\n";
    c_prog << "inttype   strPos (stritype a, stritype b)               {printf(\"strPos\\n\");}\n";
    c_prog << "stritype  str_range (stritype, inttype, inttype);\n";
    c_prog << "stritype  strRepl (stritype a, stritype b, stritype c)  {printf(\"strRepl\\n\");}\n";
    c_prog << "stritype  strRpad (stritype a, inttype b)               {printf(\"strRpad\\n\");}\n";
    c_prog << "inttype   strRpos (stritype a, stritype b)              {printf(\"strRpos\\n\");}\n";
    c_prog << "stritype  str_substr (stritype, inttype, inttype);\n";
    c_prog << "stritype  str_tail (stritype, inttype);\n";
    c_prog << "stritype  strUp (stritype a)                            {printf(\"strUp\\n\");}\n";
    c_prog << "stritype  str_from_cstri (char * );\n";
    c_prog << "char *    str_to_cstri (stritype);\n";
    c_prog << "void      tim_await (inttype, inttype, inttype, inttype, inttype, inttype, inttype);\n";
    c_prog << "void      tim_now (inttype, inttype, inttype, inttype, inttype, inttype, inttype, inttype);\n";
    c_prog << "inttype   unx_lng (stritype);\n";
    c_prog << "arraytype unx_ls (stritype);\n";
    c_prog << "stritype  unx_pwd (void);\n";
*)
    c_prog << "\n";
    c_prog << "\n";
  end func;


const proc: write_call_of_main (in program: prog, inout expr_type: c_expr) is func

  local
    var reference: main_obj is NIL;
  begin
    main_obj := sys_var(prog, "main");
    if main_obj <> NIL then
      c_expr.expr &:= "o_";
      create_name(main_obj, c_expr);
      c_expr.expr &:= "();\n";
    else
      writeln(" *** MAIN not declared.\n");
    end if;
  end func;


const proc: generate_main (in program: prog) is func

  local
    var expr_type: c_expr is expr_type.value;
  begin
    c_expr.expr &:= "int main (int argc, char **argv)\n";
    c_expr.expr &:= "\n";
    c_expr.expr &:= "{\n";
    c_expr.expr &:= global_init.temp_decls;
    c_expr.expr &:= global_init.temp_assigns;
    c_expr.expr &:= global_init.expr;
    c_expr.expr &:= "arg_c = argc;\n";
    c_expr.expr &:= "arg_v = argv;\n";
    write_call_of_main(prog, c_expr);
    c_expr.expr &:= global_init.temp_frees;
    c_expr.expr &:= "}\n";
    c_prog << c_expr.expr;
    count_declarations;
  end func;


const proc: init_systypes (in program: prog) is func

  local
    var reference: type_ref is NIL;
    var reference: ref_to_empty is NIL;
  begin
    type_ref := sys_var(prog, "type");
    if type_ref <> NIL then
      typetype := type value type_ref;
    end if;
    type_ref := sys_var(prog, "proc");
    if type_ref <> NIL then
      proctype := type value type_ref;
    end if;
    type_ref := sys_var(prog, "integer");
    if type_ref <> NIL then
      inttype := type value type_ref;
    end if;
    type_ref := sys_var(prog, "char");
    if type_ref <> NIL then
      chartype := type value type_ref;
    end if;
    type_ref := sys_var(prog, "string");
    if type_ref <> NIL then
      stritype := type value type_ref;
    end if;
    type_ref := sys_var(prog, "float");
    if type_ref <> NIL then
      floattype := type value type_ref;
    end if;
    ref_to_empty := sys_var(prog, "empty");
    if ref_to_empty <> NIL then
      voidtype := getType(ref_to_empty);
    end if;
  end func;


const func string: temp_name (in string: source) is func
  result
    var string: result is "";
  begin
    if rpos(source, "/") = 0 then
      result := "tmp_" & source;
    else
      result := source[.. rpos(source, "/")] &
          "tmp_" & source[succ(rpos(source, "/")) ..];
    end if;
  end func;


const proc: pass_1 (in string: source, inout program: prog,
    inout boolean: okay) is func

  begin
    if source <> "" then
      writeln("Compiling the program ...");
      prog := analyze(source);
      if prog = program.EMPTY then
        okay := FALSE;
      end if;
    else
      okay := FALSE;
    end if;
  end func;


const proc: pass_2 (in string: source, in program: prog,
    inout boolean: okay) is func

  local
    var reference: main_object is NIL;
    var ref_list: declared_objects is ref_list.EMPTY;
    var reference: obj is NIL;
  begin
    if okay then
      main_object := sys_var(prog, "main");
      if main_object <> NIL then
        writeln("Generating code ...");
        c_prog := open(temp_name(source) & ".c", "w");
        if c_prog <> STD_NULL then
          init_systypes(prog);
          write_file_head();
          (* process_proc_declaration(sys_var(prog, "main")); *)
          declared_objects := declared_objects(prog);
          for obj range declared_objects do
            process_object(obj);
          end for;
          generate_main(prog);
          close(c_prog);
          writeln;
        else
          write("*** cannot open temp file ");
          write(literal(temp_name(source) & ".c"));
          writeln(".");
          okay := FALSE;
        end if;
      else
        writeln("*** main not found.");
        okay := FALSE;
      end if;
    end if;
  end func;


const proc: pass_3 (in string: source, in program: prog,
    inout boolean: okay) is func

  begin
    if okay then
      writeln("Calling the C compiler ...");
      remove(temp_name(source) & ".o");
      (* unx_sh("gcc " & temp_name(source) & ".c -o " & source); *)
      (* unx_sh("gcc " & temp_name(source) & ".o -o " & source); *)
      unx_sh("gcc -c " & temp_name(source) & ".c -o " & temp_name(source) & ".o 2> " & temp_name(source) & ".cerrs");
      writeln("Calling the linker ...");
      unx_sh("gcc -L /usr/lib " & temp_name(source) & ".o \
             \../src/seed7_05.a \
             \-lncurses -lm \
             \/usr/X11R6/lib/libX11.so -o " & source);
    end if;
  end func;


const proc: main is func

  local
    var string: source is "";
    var boolean: okay is TRUE;

  begin
    writeln("SEED7 COMPILER Version 2.0  Copyright (c) 1993-2005 Thomas Mertes");
    if length(argv(PROGRAM)) >= 1 then
      source := argv(PROGRAM)[1];
      write("Source: ");
      writeln(source);
    else
      write("Source? ");
      readln(source);
    end if;
    if lower(source[length(source) - 3 ..]) = ".sd7" then
      source := source[.. length(source) - 4];
    end if;
    pass_1(source, prog, okay);
    pass_2(source, prog, okay);
    pass_3(source, prog, okay);
  end func;

$ system "main" is main;
