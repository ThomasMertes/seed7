
(********************************************************************)
(*                                                                  *)
(*  comp.sd7      Compiler from Seed7 to C                          *)
(*  Copyright (C) 1990 - 1994, 2004 - 2009  Thomas Mertes           *)
(*                                                                  *)
(*  This program is free software; you can redistribute it and/or   *)
(*  modify it under the terms of the GNU General Public License as  *)
(*  published by the Free Software Foundation; either version 2 of  *)
(*  the License, or (at your option) any later version.             *)
(*                                                                  *)
(*  This program is distributed in the hope that it will be useful, *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of  *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *)
(*  GNU General Public License for more details.                    *)
(*                                                                  *)
(*  You should have received a copy of the GNU General Public       *)
(*  License along with this program; if not, write to the           *)
(*  Free Software Foundation, Inc., 51 Franklin Street,             *)
(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)
(*                                                                  *)
(********************************************************************)


$ info off;
$ message "Compiling the compiler ...";
$ include "seed7_05.s7i";
  include "scanstri.s7i";
  include "bigint.s7i";
  include "float.s7i";
  include "progs.s7i";
  include "shell.s7i";

const string: temp_marker is "/* Seed7 compiler temp file */";

const boolean: WITH_STRI_CAPACITY      is boolean parse configValue("WITH_STRI_CAPACITY");
const boolean: RSHIFT_DOES_SIGN_EXTEND is boolean parse configValue("RSHIFT_DOES_SIGN_EXTEND");
const boolean: USE_SIGSETJMP           is boolean parse configValue("USE_SIGSETJMP");
const boolean: TWOS_COMPLEMENT_INTTYPE is boolean parse configValue("TWOS_COMPLEMENT_INTTYPE");
const boolean: FLOAT_ZERO_DIV_ERROR    is boolean parse configValue("FLOAT_ZERO_DIV_ERROR");
const boolean: INTTYPE_64BIT           is boolean parse configValue("INTTYPE_64BIT");
const boolean: ISNAN_WITH_UNDERLINE    is boolean parse configValue("ISNAN_WITH_UNDERLINE");
const boolean: CHECK_INT_DIV_BY_ZERO   is boolean parse configValue("CHECK_INT_DIV_BY_ZERO");
const string:  INTTYPE_LITERAL_SUFFIX  is configValue("INTTYPE_LITERAL_SUFFIX");

const type: option_hash is hash [string] string;

var option_hash: compiler_option is option_hash.value;

var boolean: array_range_check is TRUE;

var boolean: compilerLibraryUsed is FALSE;
var boolean: compDataLibraryUsed is FALSE;

var integer: countOptimizations is 0;

var program: prog is program.EMPTY;
var file: c_prog is STD_NULL;
var type: typetype is void;
var type: proctype is void;
var type: inttype is void;
var type: biginttype is void;
var type: chartype is void;
var type: stritype is void;
var type: floattype is void;
var type: voidtype is void;
var type: wintype is void;

var ref_list: declared_types is ref_list.EMPTY;

const type: expr_type is new struct
  var integer: temp_num is 0;
  var string: temp_decls is "";
  var string: temp_assigns is "";
  var string: expr is "";
  var string: temp_frees is "";
  var string: result_decl is "";
  var string: result_free is "";
  var string: result_intro is "";
  var string: result_expr is "";
  var string: result_finish is "";
end struct;

var expr_type: global_c_expr is expr_type.value;

var integer: declaration_count is 1;
var array ref_list: object_value is 0 times ref_list.EMPTY;
var expr_type: global_init is expr_type.value;

const type: bigint_table_hash is hash [bigInteger] integer;
const type: bigint_index_hash is hash [integer] array bigInteger;

var bigint_table_hash: bigint_const_table is bigint_table_hash.EMPTY_HASH;

const type: stri_table_hash is hash [string] integer;
const type: stri_index_hash is hash [integer] array string;

var stri_table_hash: stri_const_table is stri_table_hash.EMPTY_HASH;

const type: set_table_hash is hash [bitset] integer;
const type: set_index_hash is hash [integer] array bitset;

var set_table_hash: set_const_table is set_table_hash.EMPTY_HASH;

const type: const_table_hash is hash [reference] integer;
const type: const_index_hash is hash [integer] array reference;

var const_table_hash: const_table is const_table_hash.EMPTY_HASH;

const type: type_hash is hash [type] type;
const type: element_number_hash is hash [reference] integer;
const type: number_element_hash is hash [integer] array reference;
const type: element_type_hash is hash [reference] type;
const type: struct_elements_hash is hash [type] element_number_hash;
const type: struct_element_type_hash is hash [type] element_type_hash;
const type: boolean_type_hash is hash [type] boolean;
const type: boolean_obj_hash is hash [reference] boolean;
const type: implements_hash is hash [type] array type;
const type: interface_hash is hash [type] array type;
const type: enum_literal_hash is hash [type] element_number_hash;
const type: string_type_hash is hash [type] string;
const type: variable_to_param_hash is hash [reference] reference;
const type: additional_params_hash is hash [reference] variable_to_param_hash;
const type: setOfCategory is set of category;

var type_hash: array_element is type_hash.EMPTY_HASH;
var type_hash: array_type is type_hash.EMPTY_HASH;
var struct_elements_hash: struct_elements is struct_elements_hash.EMPTY_HASH;
var struct_element_type_hash: struct_element_type is struct_element_type_hash.EMPTY_HASH;
var boolean_type_hash: create_declared is boolean_type_hash.EMPTY_HASH;
var boolean_type_hash: destr_declared is boolean_type_hash.EMPTY_HASH;
var boolean_type_hash: cpy_declared is boolean_type_hash.EMPTY_HASH;
var boolean_obj_hash: prototype_declared is boolean_obj_hash.EMPTY_HASH;
var boolean_obj_hash: return_ref_to_value is boolean_obj_hash.EMPTY_HASH;
var boolean_type_hash: simple_pod_type is boolean_type_hash.EMPTY_HASH;
var boolean_obj_hash: function_declared is boolean_obj_hash.EMPTY_HASH;
var boolean_obj_hash: function_pointer_declared is boolean_obj_hash.EMPTY_HASH;
var ref_list: dynamic_functions is ref_list.EMPTY;
var implements_hash: implements is implements_hash.EMPTY_HASH;
var interface_hash: interfaceOfType is interface_hash.EMPTY_HASH;
var boolean_type_hash: isInterfaceType is boolean_type_hash.EMPTY_HASH;
var boolean_type_hash: isHashType is boolean_type_hash.EMPTY_HASH;
var string_type_hash: parametersOfHshCreate is string_type_hash.EMPTY_HASH;
var string_type_hash: parametersOfHshDestr is string_type_hash.EMPTY_HASH;
var string_type_hash: parametersOfHshCpy is string_type_hash.EMPTY_HASH;
var enum_literal_hash: enum_literal is enum_literal_hash.EMPTY_HASH;
var boolean_type_hash: int_types is boolean_type_hash.EMPTY_HASH;
var boolean_type_hash: enum_types is boolean_type_hash.EMPTY_HASH;
var boolean_type_hash: ref_list_types is boolean_type_hash.EMPTY_HASH;
var boolean_type_hash: set_types is boolean_type_hash.EMPTY_HASH;
var boolean_type_hash: bstri_types is boolean_type_hash.EMPTY_HASH;
var additional_params_hash: additional_params is additional_params_hash.EMPTY_HASH;

var boolean: write_object_declaration is TRUE;


const proc: process_action (in reference: function, in ref_list: params,
    inout expr_type: c_expr) is forward;
const proc: process_expr (in reference: current_expression, inout expr_type: c_expr) is forward;


const proc: count_declarations is func

  begin
    incr(declaration_count);
    write(OUT, declaration_count);
    write(OUT, " ");
    write(OUT, heapsize(PROGRAM));
    write(OUT, "     \r");
    flush(OUT);
  end func;


const proc: create_name (in reference: current_object, inout string: expr) is func

  local
    var string: raw_name is "";
    var string: name is "";
  begin
    raw_name := str(current_object);
    name := getName(raw_name);
    expr &:= str(obj_number(current_object));
    if name <> "" then
      expr &:= "_";
      expr &:= name;
    end if;
    if raw_name <> "" then
      expr &:= "/*";
      expr &:= raw_name;
      expr &:= "*/";
    end if;
  end func;


const proc: create_name2 (in reference: current_object, inout string: expr) is func

  local
    var string: raw_name is "";
    var string: name is "";
  begin
    raw_name := str(current_object);
    name := getName(raw_name);
    expr &:= str(obj_number(current_object));
    if name <> "" then
      expr &:= "_";
      expr &:= name;
    end if;
    if raw_name <> "" then
      expr &:= "**";
      expr &:= raw_name;
    end if;
  end func;


const func string: type_name (in type: object_type) is func

  result
    var string: result is "";
  begin
    if object_type = typetype then
      result := "typetype";
    elsif object_type = inttype then
      result := "inttype";
    elsif object_type = biginttype then
      result := "biginttype";
    elsif object_type = chartype then
      result := "chartype";
    elsif object_type = stritype then
      result := "stritype";
    elsif object_type = floattype then
      result := "floattype";
    elsif object_type = wintype then
      result := "wintype";
    else
      result := "t_";
      result &:= str(type_number(object_type));
      result &:= "/*";
      result &:= str(object_type);
      result &:= "*/";
    end if;
  end func;


const proc: declare_type_if_necessary (in type: aType, inout expr_type: c_expr) is func

  local
    var reference: type_obj is NIL;
    var type: metaType is void;
(*
    var reference: expression is NIL;
    var reference: type_value is NIL;
*)
  begin
    type_obj := match_obj(aType);
    if not type_obj in declared_types then
      if aType <> typetype and
          aType <> inttype and
          aType <> biginttype and
          aType <> chartype and
          aType <> stritype and
          aType <> floattype then
(*
        expression := NIL;
        type_value := evaluate(prog, expression);
        if category(case_labels) = STRUCTOBJECT then
          noop;
        else
*)
          c_expr.expr &:= "typedef generictype ";
          c_expr.expr &:= type_name(aType);
          c_expr.expr &:= ";\n\n";
          if is_derived(aType) then
            metaType := meta(aType);
            if metaType in int_types then
              if aType not in int_types then
                int_types @:= [aType] TRUE;
              end if;
            elsif metaType in enum_types then
              if aType not in enum_types then
                enum_types @:= [aType] TRUE;
              end if;
            elsif metaType in ref_list_types then
              if aType not in ref_list_types then
                ref_list_types @:= [aType] TRUE;
              end if;
            elsif metaType in set_types then
              if aType not in set_types then
                set_types @:= [aType] TRUE;
              end if;
            elsif metaType in bstri_types then
              if aType not in bstri_types then
                bstri_types @:= [aType] TRUE;
              end if;
            end if;
          end if;
(*
        end if;
*)
        incl(declared_types, type_obj);
      end if;
    end if;
  end func;


const func type: getExprResultType (in reference: aReference) is func
  result
    var type: result is void;
  begin
    result := getType(aReference);
    while is_func(result) or is_varfunc(result) do
      result := result_type(result);
    end while;
  end func;


const func string: select_value_from_rtlObjectstruct (in type: typeWanted) is func
  result
    var string: result is "";
  begin
    if typeWanted = typetype then
      result := ".value.typevalue";
    elsif typeWanted = floattype then
      result := ".value.floatvalue";
    elsif typeWanted = stritype then
      result := ".value.strivalue";
    elsif typeWanted = biginttype then
      result := ".value.bigintvalue";
    elsif typeWanted = wintype then
      result := ".value.winvalue";
    else
      result := ".value.intvalue";
    end if;
  end func;


const proc: process_raise_error (in string: exceptionName, in reference: function, inout expr_type: c_expr) is func
  begin
    if function <> NIL then
      c_expr.expr &:= "(raise_error2(";
      c_expr.expr &:= exceptionName;
      c_expr.expr &:= ", ";
      c_expr.expr &:= c_literal(file(function));
      c_expr.expr &:= ", ";
      c_expr.expr &:= str(line(function));
      c_expr.expr &:= "),0)";
    else
      c_expr.expr &:= "(raise_error(";
      c_expr.expr &:= exceptionName;
      c_expr.expr &:= "),0)";
    end if;
  end func;


const proc: process_create_declaration (in type: object_type,
    inout expr_type: c_expr) is forward;


const proc: process_create_call (in type: object_type,
    in string: param_b, inout string: expr) is forward;


const proc: process_arr_create_declaration (in type: object_type,
    inout expr_type: c_expr) is func

  local
    var string: select_value is "";
  begin
    select_value := select_value_from_rtlObjectstruct(array_element[object_type]);
    process_create_declaration(array_element[object_type], c_expr);
    c_expr.expr &:= "static ";
    c_expr.expr &:= type_name(object_type);
    c_expr.expr &:= " create_";
    c_expr.expr &:= str(type_number(object_type));
    c_expr.expr &:= " (";
    c_expr.expr &:= type_name(object_type);
    c_expr.expr &:= " b)\n";
    c_expr.expr &:= "{\n";
    c_expr.expr &:= type_name(object_type);
    c_expr.expr &:= " a;\n";
    c_expr.expr &:= "unsigned long i;\n";
    c_expr.expr &:= "unsigned long size = ((arraytype)b)->max_position - ((arraytype)b)->min_position + 1;\n";
    c_expr.expr &:= "a=malloc(sizeof(struct arraystruct) - sizeof(rtlObjecttype) +\n";
    c_expr.expr &:= "  size * sizeof(rtlObjecttype));\n";
#!    c_expr.expr &:= "ALLOC_RTL_ARRAY(a,size);\n";
    c_expr.expr &:= "if (a == NULL) {\n";
    c_expr.expr &:= "raise_error(MEMORY_ERROR);\n";
    c_expr.expr &:= "} else {\n";
    c_expr.expr &:= "((arraytype)a)->min_position = ((arraytype)b)->min_position;\n";
    c_expr.expr &:= "((arraytype)a)->max_position = ((arraytype)b)->max_position;\n";
    c_expr.expr &:= "for (i = 0; i < size; i++) {\n";
    c_expr.expr &:= "((arraytype)a)->arr[i]";
    c_expr.expr &:= select_value;
    c_expr.expr &:= "=";
    process_create_call(array_element[object_type],
        "((arraytype)b)->arr[i]" & select_value, c_expr.expr);
    c_expr.expr &:= ";\n";
    c_expr.expr &:= "}\n";
    c_expr.expr &:= "}\n";
    c_expr.expr &:= "return(a);\n";
    c_expr.expr &:= "}\n\n";
    create_declared @:= [object_type] TRUE;
  end func;


const proc: process_sct_create_declaration (in type: object_type,
    inout expr_type: c_expr) is func

  local
    var number_element_hash: elements is number_element_hash.EMPTY_HASH;
    var integer: number is 0;
    var reference: struct_elem is NIL;
    var string: select_value is "";
  begin
    elements := flip(struct_elements[object_type]);
    for number range 0 to pred(length(elements)) do
      struct_elem := elements[number][1];
      process_create_declaration(struct_element_type[object_type][struct_elem], c_expr);
    end for;
    c_expr.expr &:= "static ";
    c_expr.expr &:= type_name(object_type);
    c_expr.expr &:= " create_";
    c_expr.expr &:= str(type_number(object_type));
    c_expr.expr &:= " (";
    c_expr.expr &:= type_name(object_type);
    c_expr.expr &:= " b)\n";
    c_expr.expr &:= "{\n";
    c_expr.expr &:= type_name(object_type);
    c_expr.expr &:= " a;\n";
    c_expr.expr &:= "a=malloc(sizeof(struct structstruct) - sizeof(rtlObjecttype) + \n  ";
    c_expr.expr &:= str(length(elements));
    c_expr.expr &:= " * sizeof(rtlObjecttype));\n";
    c_expr.expr &:= "if (a == NULL) {\n";
    c_expr.expr &:= "raise_error(MEMORY_ERROR);\n";
    c_expr.expr &:= "} else {\n";
    c_expr.expr &:= "((structtype)a)->type_num = ((structtype)b)->type_num;\n";
    for number range 0 to pred(length(elements)) do
      struct_elem := elements[number][1];
      select_value := select_value_from_rtlObjectstruct(struct_element_type[object_type][struct_elem]);
      c_expr.expr &:= "((structtype)a)->stru[" & str(number) & "]" & select_value & "=";
      process_create_call(struct_element_type[object_type][struct_elem],
          "((structtype)b)->stru[" & str(number) & "]" & select_value, c_expr.expr);
      c_expr.expr &:= ";\n";
    end for;
    c_expr.expr &:= "}\n";
    c_expr.expr &:= "return(a);\n";
    c_expr.expr &:= "}\n\n";
    create_declared @:= [object_type] TRUE;
  end func;


const proc: process_hsh_create_declaration (in type: object_type,
    inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "static ";
    c_expr.expr &:= type_name(object_type);
    c_expr.expr &:= " create_";
    c_expr.expr &:= str(type_number(object_type));
    c_expr.expr &:= " (";
    c_expr.expr &:= type_name(object_type);
    c_expr.expr &:= " b)\n";
    c_expr.expr &:= "{\n";
    c_expr.expr &:= "return hshCreate((hashtype)(b)";
    c_expr.expr &:= parametersOfHshCreate[object_type];
    c_expr.expr &:= ");\n";
    c_expr.expr &:= "}\n\n";
    create_declared @:= [object_type] TRUE;
  end func;


const proc: process_create_declaration (in type: object_type,
    inout expr_type: c_expr) is func

  begin
    if object_type not in create_declared then
      if object_type in array_element then
        process_arr_create_declaration(object_type, c_expr);
      elsif object_type in struct_elements then
        process_sct_create_declaration(object_type, c_expr);
      elsif object_type in parametersOfHshCreate then
        process_hsh_create_declaration(object_type, c_expr);
      elsif object_type = typetype or
          object_type = inttype or
          object_type = biginttype or
          object_type = chartype or
          object_type = stritype or
          object_type = floattype or
          object_type = wintype or
          object_type in int_types or
          object_type in enum_types or
          object_type in ref_list_types or
          object_type in set_types or
          object_type in bstri_types or
          object_type in simple_pod_type then
        create_declared @:= [object_type] TRUE;
      else
        declare_type_if_necessary(object_type, c_expr);
        c_expr.expr &:= "static ";
        c_expr.expr &:= type_name(object_type);
        c_expr.expr &:= " create_";
        c_expr.expr &:= str(type_number(object_type));
        c_expr.expr &:= " (";
        c_expr.expr &:= type_name(object_type);
        c_expr.expr &:= ");\n\n";
      end if;
    end if;
  end func;


const proc: process_create_call (in type: object_type,
    in string: param_b, inout string: expr) is func

  begin
    if object_type = typetype then
      expr &:= "typCreate(" & param_b & ")";
    elsif object_type = inttype then
      expr &:= param_b;
    elsif object_type = biginttype then
      expr &:= "bigCreate((biginttype)(" & param_b & "))";
    elsif object_type = chartype then
      expr &:= param_b;
    elsif object_type = stritype then
      expr &:= "strCreate((stritype)(" & param_b & "))";
    elsif object_type in bstri_types then
      expr &:= "bstCreate(" & param_b & ")";
    elsif object_type = floattype then
      expr &:= param_b;
    elsif object_type = wintype then
      expr &:= "drwCreate(" & param_b & ")";
    elsif object_type in int_types then
      expr &:= param_b;
    elsif object_type in enum_types then
      expr &:= param_b;
    elsif object_type in ref_list_types then
      expr &:= "rflCreate((listtype)(" & param_b & "))";
    elsif object_type in set_types then
      expr &:= "setCreate((settype)(" & param_b & "))";
    elsif object_type in simple_pod_type then
      expr &:= param_b;
    elsif object_type in parametersOfHshCreate then
      expr &:= "create_";
      expr &:= str(type_number(object_type));
      expr &:= "((";
      expr &:= type_name(object_type);
      expr &:= ")(";
      expr &:= param_b;
      expr &:= "))";
    elsif object_type in array_element then
      expr &:= "create_";
      expr &:= str(type_number(object_type));
      expr &:= "((";
      expr &:= type_name(object_type);
      expr &:= ")(";
      expr &:= param_b;
      expr &:= "))";
    elsif object_type in struct_elements then
      expr &:= "create_";
      expr &:= str(type_number(object_type));
      expr &:= "((";
      expr &:= type_name(object_type);
      expr &:= ")(";
      expr &:= param_b;
      expr &:= "))";
    elsif object_type in isInterfaceType then
      expr &:= param_b;
    else
      expr &:= "create_";
      expr &:= str(type_number(object_type));
      expr &:= "(";
      expr &:= param_b;
      expr &:= ")";
    end if;
  end func;


const proc: process_destr_declaration (in type: object_type,
    inout expr_type: c_expr) is forward;


const proc: process_destr_call (in type: object_type,
    in string: param_b, inout string: expr) is forward;


const proc: process_arr_destr_declaration (in type: object_type,
    inout expr_type: c_expr) is func

  local
    var string: select_value is "";
  begin
    select_value := select_value_from_rtlObjectstruct(array_element[object_type]);
    process_destr_declaration(array_element[object_type], c_expr);
    c_expr.expr &:= "static void destr_";
    c_expr.expr &:= str(type_number(object_type));
    c_expr.expr &:= " (";
    c_expr.expr &:= type_name(object_type);
    c_expr.expr &:= " b)\n";
    c_expr.expr &:= "{\n";
    c_expr.expr &:= "unsigned long i;\n";
    c_expr.expr &:= "unsigned long size;\n";
    c_expr.expr &:= "if (b != NULL) {\n";
    c_expr.expr &:= "size = ((arraytype)b)->max_position - ((arraytype)b)->min_position + 1;\n";
    c_expr.expr &:= "for (i = 0; i < size; i++) {\n";
    process_destr_call(array_element[object_type],
        "((arraytype)b)->arr[i]" & select_value, c_expr.expr);
    c_expr.expr &:= "}\n";
    c_expr.expr &:= "free((void *)(b));\n";
#!    c_expr.expr &:= "FREE_RTL_ARRAY(b, size);\n";
    c_expr.expr &:= "}\n";
    c_expr.expr &:= "}\n\n";
    destr_declared @:= [object_type] TRUE;
  end func;


const proc: process_sct_destr_declaration (in type: object_type,
    inout expr_type: c_expr) is func

  local
    var number_element_hash: elements is number_element_hash.EMPTY_HASH;
    var integer: number is 0;
    var reference: struct_elem is NIL;
    var string: select_value is "";
  begin
    elements := flip(struct_elements[object_type]);
    for number range 0 to pred(length(elements)) do
      struct_elem := elements[number][1];
      process_destr_declaration(struct_element_type[object_type][struct_elem], c_expr);
    end for;
    c_expr.expr &:= "static void destr_";
    c_expr.expr &:= str(type_number(object_type));
    c_expr.expr &:= " (";
    c_expr.expr &:= type_name(object_type);
    c_expr.expr &:= " b)\n";
    c_expr.expr &:= "{\n";
    c_expr.expr &:= "if (b != NULL) {\n";
    for number range 0 to pred(length(elements)) do
      struct_elem := elements[number][1];
      select_value := select_value_from_rtlObjectstruct(struct_element_type[object_type][struct_elem]);
      process_destr_call(struct_element_type[object_type][struct_elem],
          "((structtype)b)->stru[" & str(number) & "]" & select_value, c_expr.expr);
    end for;
    c_expr.expr &:= "free((void *)(b));\n";
    c_expr.expr &:= "}\n";
    c_expr.expr &:= "}\n\n";
    destr_declared @:= [object_type] TRUE;
  end func;


const proc: process_hsh_destr_declaration (in type: object_type,
    inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "static void destr_";
    c_expr.expr &:= str(type_number(object_type));
    c_expr.expr &:= " (";
    c_expr.expr &:= type_name(object_type);
    c_expr.expr &:= " b)\n";
    c_expr.expr &:= "{\n";
    c_expr.expr &:= "hshDestr((hashtype)(b)";
    c_expr.expr &:= parametersOfHshDestr[object_type];
    c_expr.expr &:= ");\n";
    c_expr.expr &:= "}\n\n";
    destr_declared @:= [object_type] TRUE;
  end func;


const proc: process_destr_declaration (in type: object_type,
    inout expr_type: c_expr) is func

  begin
    if object_type not in destr_declared then
      if object_type in array_element then
        process_arr_destr_declaration(object_type, c_expr);
      elsif object_type in struct_elements then
        process_sct_destr_declaration(object_type, c_expr);
      elsif object_type in parametersOfHshDestr then
        process_hsh_destr_declaration(object_type, c_expr);
      elsif object_type = typetype or
          object_type = inttype or
          object_type = biginttype or
          object_type = chartype or
          object_type = stritype or
          object_type = floattype or
          object_type = wintype or
          object_type in int_types or
          object_type in enum_types or
          object_type in ref_list_types or
          object_type in set_types or
          object_type in bstri_types or
          object_type in simple_pod_type then
        destr_declared @:= [object_type] TRUE;
      else
        c_expr.expr &:= "/* destr_";
        c_expr.expr &:= str(type_number(object_type));
        c_expr.expr &:= " declaration for type t_";
        c_expr.expr &:= str(type_number(object_type));
        c_expr.expr &:= "**";
        c_expr.expr &:= str(object_type);
        c_expr.expr &:= "*/\n\n";
      end if;
    end if;
  end func;


const proc: process_destr_call (in type: object_type,
    in string: param_b, inout string: expr) is func

  begin
    if object_type = typetype then
      noop;
    elsif object_type = inttype then
      noop;
    elsif object_type = biginttype then
      expr &:= "bigDestr((biginttype)(" & param_b & "));\n";
    elsif object_type = chartype then
      noop;
    elsif object_type = stritype then
      expr &:= "strDestr((stritype)(" & param_b & "));\n";
    elsif object_type in bstri_types then
      expr &:= "bstDestr(" & param_b & ");\n";
    elsif object_type = floattype then
      noop;
    elsif object_type = wintype then
      expr &:= "drwDestr(" & param_b & ");\n";
    elsif object_type in int_types then
      noop;
    elsif object_type in enum_types then
      noop;
    elsif object_type in ref_list_types then
      expr &:= "rflDestr(" & param_b & ");\n";
    elsif object_type in set_types then
      expr &:= "setDestr((settype)(" & param_b & "));\n";
    elsif object_type in simple_pod_type then
      noop;
    elsif object_type in parametersOfHshDestr then
      expr &:= "destr_";
      expr &:= str(type_number(object_type));
      expr &:= "((";
      expr &:= type_name(object_type);
      expr &:= ")(";
      expr &:= param_b;
      expr &:= "));\n";
    elsif object_type in array_element then
      expr &:= "destr_";
      expr &:= str(type_number(object_type));
      expr &:= "((";
      expr &:= type_name(object_type);
      expr &:= ")(";
      expr &:= param_b;
      expr &:= "));\n";
    elsif object_type in struct_elements then
      expr &:= "destr_";
      expr &:= str(type_number(object_type));
      expr &:= "((";
      expr &:= type_name(object_type);
      expr &:= ")(";
      expr &:= param_b;
      expr &:= "));\n";
    elsif object_type in isInterfaceType then
      noop;
    else
      expr &:= param_b & " /* destr_";
      expr &:= str(type_number(object_type));
      expr &:= " for type t_";
      expr &:= str(type_number(object_type));
      expr &:= "**";
      expr &:= str(object_type);
      expr &:= "*/;\n";
    end if;
  end func;


const proc: process_cpy_declaration (in type: object_type,
    inout expr_type: c_expr) is forward;


const proc: process_cpy_call (in type: object_type,
    in string: param_a, in string: param_b, inout string: expr) is forward;


const proc: process_arr_cpy_declaration (in type: object_type,
    inout expr_type: c_expr) is func

  local
    var string: select_value is "";
  begin
    select_value := select_value_from_rtlObjectstruct(array_element[object_type]);
    process_create_declaration(array_element[object_type], c_expr);
    process_destr_declaration(array_element[object_type], c_expr);
    process_cpy_declaration(array_element[object_type], c_expr);
    c_expr.expr &:= "static void cpy_";
    c_expr.expr &:= str(type_number(object_type));
    c_expr.expr &:= " (";
    c_expr.expr &:= type_name(object_type);
    c_expr.expr &:= " *a, ";
    c_expr.expr &:= type_name(object_type);
    c_expr.expr &:= " b)\n";
    c_expr.expr &:= "{\n";
    c_expr.expr &:= "unsigned long i;\n";
    c_expr.expr &:= "unsigned long size_a = ((arraytype)*a)->max_position - ((arraytype)*a)->min_position + 1;\n";
    c_expr.expr &:= "unsigned long size_b = ((arraytype)b)->max_position - ((arraytype)b)->min_position + 1;\n";
    c_expr.expr &:= "unsigned long size;\n";
    c_expr.expr &:= "((arraytype)*a)->min_position = ((arraytype)b)->min_position;\n";
    c_expr.expr &:= "((arraytype)*a)->max_position = ((arraytype)b)->max_position;\n";
    c_expr.expr &:= "if (size_a == size_b) {\n";
    c_expr.expr &:= "size = size_a;\n";
    c_expr.expr &:= "} else {\n";
    c_expr.expr &:= "if (size_a < size_b) {\n";
    c_expr.expr &:= "*a=realloc((void *)(*a), sizeof(struct arraystruct) - sizeof(rtlObjecttype) +\n";
    c_expr.expr &:= "  size_b * sizeof(rtlObjecttype));\n";
    c_expr.expr &:= "size = size_a;\n";
    c_expr.expr &:= "for (i = size_a; i < size_b; i++) {\n";
    c_expr.expr &:= "((arraytype)*a)->arr[i]";
    c_expr.expr &:= select_value;
    c_expr.expr &:= "=";
    process_create_call(array_element[object_type],
        "((arraytype)b)->arr[i]" & select_value, c_expr.expr);
    c_expr.expr &:= ";\n";
    c_expr.expr &:= "}\n";
    c_expr.expr &:= "} else /* size_a > size_b */ {\n";
    c_expr.expr &:= "size = size_b;\n";
    c_expr.expr &:= "for (i = size_b; i < size_a; i++) {\n";
    process_destr_call(array_element[object_type],
        "((arraytype)*a)->arr[i]" & select_value, c_expr.expr);
    c_expr.expr &:= "}\n";
    c_expr.expr &:= "*a=realloc((void *)(*a), sizeof(struct arraystruct) - sizeof(rtlObjecttype) +\n";
    c_expr.expr &:= "  size_b * sizeof(rtlObjecttype));\n";
    c_expr.expr &:= "}\n";
    c_expr.expr &:= "}\n";
    c_expr.expr &:= "for (i = 0; i < size; i++) {\n";
    process_cpy_call(array_element[object_type],
        "((arraytype)*a)->arr[i]" & select_value,
        "((arraytype)b)->arr[i]" & select_value, c_expr.expr);
    c_expr.expr &:= ";\n";
    c_expr.expr &:= "}\n";
    c_expr.expr &:= "}\n\n";
    cpy_declared @:= [object_type] TRUE;
  end func;


const proc: process_sct_cpy_declaration (in type: object_type,
    inout expr_type: c_expr) is func

  local
    var number_element_hash: elements is number_element_hash.EMPTY_HASH;
    var integer: number is 0;
    var reference: struct_elem is NIL;
    var string: select_value is "";
  begin
    elements := flip(struct_elements[object_type]);
    for number range 0 to pred(length(elements)) do
      struct_elem := elements[number][1];
      process_cpy_declaration(struct_element_type[object_type][struct_elem], c_expr);
    end for;
    c_expr.expr &:= "static void cpy_";
    c_expr.expr &:= str(type_number(object_type));
    c_expr.expr &:= " (";
    c_expr.expr &:= type_name(object_type);
    c_expr.expr &:= " a, ";
    c_expr.expr &:= type_name(object_type);
    c_expr.expr &:= " b)\n";
    c_expr.expr &:= "{\n";
    # The dynamic type of a struct cannot change with a deep copy.
    # c_expr.expr &:= "((structtype)a)->type_num = ((structtype)b)->type_num;\n";
    for number range 0 to pred(length(elements)) do
      struct_elem := elements[number][1];
      select_value := select_value_from_rtlObjectstruct(struct_element_type[object_type][struct_elem]);
      process_cpy_call(struct_element_type[object_type][struct_elem],
          "((structtype)a)->stru[" & str(number) & "]" & select_value,
          "((structtype)b)->stru[" & str(number) & "]" & select_value, c_expr.expr);
      c_expr.expr &:= ";\n";
    end for;
    c_expr.expr &:= "}\n\n";
    cpy_declared @:= [object_type] TRUE;
  end func;


const proc: process_hsh_cpy_declaration (in type: object_type,
    inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "static void cpy_";
    c_expr.expr &:= str(type_number(object_type));
    c_expr.expr &:= " (";
    c_expr.expr &:= type_name(object_type);
    c_expr.expr &:= " *a, ";
    c_expr.expr &:= type_name(object_type);
    c_expr.expr &:= " b)\n";
    c_expr.expr &:= "{\n";
    c_expr.expr &:= "hshCpy((hashtype *)(a), (hashtype)(b)";
    c_expr.expr &:= parametersOfHshCpy[object_type];
    c_expr.expr &:= ");\n";
    c_expr.expr &:= "}\n\n";
    cpy_declared @:= [object_type] TRUE;
  end func;


const proc: process_cpy_declaration (in type: object_type,
    inout expr_type: c_expr) is func

  begin
    if object_type not in cpy_declared then
      if object_type in array_element then
        process_arr_cpy_declaration(object_type, c_expr);
      elsif object_type in struct_elements then
        process_sct_cpy_declaration(object_type, c_expr);
      elsif object_type in parametersOfHshCpy then
        process_hsh_cpy_declaration(object_type, c_expr);
      elsif object_type = typetype or
          object_type = inttype or
          object_type = biginttype or
          object_type = chartype or
          object_type = stritype or
          object_type = floattype or
          object_type = wintype or
          object_type in int_types or
          object_type in enum_types or
          object_type in ref_list_types or
          object_type in set_types or
          object_type in bstri_types or
          object_type in simple_pod_type then
        cpy_declared @:= [object_type] TRUE;
      else
        c_expr.expr &:= "/* cpy_";
        c_expr.expr &:= str(type_number(object_type));
        c_expr.expr &:= " declaration for type t_";
        c_expr.expr &:= str(type_number(object_type));
        c_expr.expr &:= "**";
        c_expr.expr &:= str(object_type);
        c_expr.expr &:= "*/\n\n";
      end if;
    end if;
  end func;


const proc: process_cpy_call (in type: object_type,
    in string: param_a, in string: param_b, inout string: expr) is func

  begin
    if object_type = typetype then
      expr &:= param_a & "=" & param_b;
    elsif object_type = inttype then
      expr &:= param_a & "=" & param_b;
    elsif object_type = biginttype then
      expr &:= "bigCpy(&(" & param_a & "), (biginttype)(" & param_b & "))";
    elsif object_type = chartype then
      expr &:= param_a & "=" & param_b;
    elsif object_type = stritype then
      expr &:= "strCopy(&(" & param_a & "), (stritype)(" & param_b & "))";
    elsif object_type in bstri_types then
      expr &:= "bstCpy(&(" & param_a & "), " & param_b & ")";
    elsif object_type = floattype then
      # expr &:= param_a & "=(" & param_b & ")";
      # expr &:= "*((float *) &(" & param_a & "))=(" & param_b & ")";
      expr &:= "memcpy(&(";
      expr &:= param_a;
      expr &:= "), &(";
      expr &:= param_b;
      expr &:= "), sizeof(float))"; # Assuming that sizeof(float) == sizeof(long)
    elsif object_type = wintype then
      expr &:= "drwCpy(&(" & param_a & "), " & param_b & ")";
    elsif object_type in int_types then
      expr &:= param_a & "=" & param_b;
    elsif object_type in enum_types then
      expr &:= param_a & "=" & param_b;
    elsif object_type in ref_list_types then
      expr &:= "rflCpy(&(" & param_a & "), (listtype)(" & param_b & "))";
    elsif object_type in set_types then
      expr &:= "setCpy(&(" & param_a & "), (settype)(" & param_b & "))";
    elsif object_type in simple_pod_type then
      expr &:= param_a & "=" & param_b;
    elsif object_type in parametersOfHshCpy then
      expr &:= "cpy_";
      expr &:= str(type_number(object_type));
      expr &:= "((";
      expr &:= type_name(object_type);
      expr &:= " *)&(";
      expr &:= param_a;
      expr &:= "), (";
      expr &:= type_name(object_type);
      expr &:= ")(";
      expr &:= param_b;
      expr &:= "))";
    elsif object_type in array_element then
      expr &:= "cpy_";
      expr &:= str(type_number(object_type));
      expr &:= "((";
      expr &:= type_name(object_type);
      expr &:= " *)&(";
      expr &:= param_a;
      expr &:= "), (";
      expr &:= type_name(object_type);
      expr &:= ")(";
      expr &:= param_b;
      expr &:= "))";
    elsif object_type in struct_elements then
      expr &:= "cpy_";
      expr &:= str(type_number(object_type));
      expr &:= "((";
      expr &:= type_name(object_type);
      expr &:= ")(";
      expr &:= param_a;
      expr &:= "), (";
      expr &:= type_name(object_type);
      expr &:= ")(";
      expr &:= param_b;
      expr &:= "))";
    elsif object_type in isInterfaceType then
      expr &:= param_a & "=" & param_b;
    else
      expr &:= param_b & " /* cpy_";
      expr &:= str(type_number(object_type));
      expr &:= " for type t_";
      expr &:= str(type_number(object_type));
      expr &:= "**";
      expr &:= str(object_type);
      expr &:= "*/";
    end if;
  end func;


const proc: declare_prototype_if_necessary (in reference: function,
    inout expr_type: c_expr) is func

  local
    var ref_list: params is ref_list.EMPTY;
    var type: result_type is void;
    var type: object_type is void;
    var integer: number is 0;
    var reference: struct_elem is NIL;
  begin
    if function not in prototype_declared then
      result_type := result_type(getType(function));
      params := params(function);
      object_type := getType(params[3]);
      process_create_declaration(object_type, c_expr);
      # c_expr.expr &:= type_name(result_type);
      c_expr.expr &:= "arraytype times_";
      c_expr.expr &:= str(type_number(result_type));
      c_expr.expr &:= " (inttype, ";
      c_expr.expr &:= type_name(object_type);
      c_expr.expr &:= ");\n";
      prototype_declared @:= [function] TRUE;
    end if;
  end func;



const proc: declare_func_pointer_if_necessary (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var ref_list: params is ref_list.EMPTY;
    var reference: func_pointer is NIL;
  begin
    if category(current_object) = CALLOBJECT then
      params := getValue(current_object, ref_list);
      if length(params) >= 1 then
        func_pointer := params[1];
        if category(func_pointer) = REFOBJECT then
          if func_pointer not in function_pointer_declared then
            c_expr.expr &:= "objreftype o_";
            create_name(func_pointer, c_expr.expr);
            c_expr.expr &:= ";\n\n";
            function_pointer_declared @:= [func_pointer] TRUE;
          end if;
        end if;
      end if;
    end if;
  end func;


const proc: process_str_create_call (in string: stri, inout string: expr) is func

  begin
    if stri = "" then
      incr(countOptimizations);
      expr &:= "strEmpty(); /* \"\" */\n";
    elsif length(stri) = 1 then
      incr(countOptimizations);
      expr &:= "chrStr(";
      expr &:= c_literal(stri[1]);
      expr &:= "); /* ";
      expr &:= literal(stri);
      expr &:= " */\n";
    else
      if stri not in stri_const_table then
        stri_const_table @:= [stri] length(stri_const_table);
      end if;
      expr &:= "strCreate(str[";
      expr &:= str(stri_const_table[stri]);
      expr &:= "] /* ";
      expr &:= replace(literal(stri), "*/", "*\\/");
      expr &:= " */);\n";
    end if;
  end func;


const func boolean: has_temp_values (in expr_type: c_expr) is
  return c_expr.temp_num >= 2 or
      (c_expr.temp_num = 1 and c_expr.result_expr = "");


const proc: prepare_array_result (in type: array_type, inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.result_decl := type_name(array_type);
    c_expr.result_decl &:= " tmp_";
    c_expr.result_decl &:= str(c_expr.temp_num);
    c_expr.result_decl &:= " = (";
    c_expr.result_decl &:= type_name(array_type);
    c_expr.result_decl &:= ")(NULL);\n";
    process_destr_declaration(array_type, global_c_expr);
    process_destr_call(array_type, "tmp_" & str(c_expr.temp_num), c_expr.result_free);
    c_expr.result_intro := "(tmp_";
    c_expr.result_intro &:= str(c_expr.temp_num);
    c_expr.result_intro &:= "=(";
    c_expr.result_intro &:= type_name(array_type);
    c_expr.result_intro &:= ")(";
    c_expr.result_finish := "))";
  end func;


const proc: prepare_bigint_result (inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.result_decl := "biginttype tmp_";
    c_expr.result_decl &:= str(c_expr.temp_num);
    c_expr.result_decl &:= " = NULL;\n";
    c_expr.result_free := "bigDestr(tmp_";
    c_expr.result_free &:= str(c_expr.temp_num);
    c_expr.result_free &:= ");\n";
    c_expr.result_intro := "(tmp_";
    c_expr.result_intro &:= str(c_expr.temp_num);
    c_expr.result_intro &:= "=";
    c_expr.result_finish := ")";
  end func;


const proc: prepare_list_result (inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.result_decl := "listtype tmp_";
    c_expr.result_decl &:= str(c_expr.temp_num);
    c_expr.result_decl &:= " = NULL;\n";
    c_expr.result_free := "rflDestr(tmp_";
    c_expr.result_free &:= str(c_expr.temp_num);
    c_expr.result_free &:= ");\n";
    c_expr.result_intro := "(tmp_";
    c_expr.result_intro &:= str(c_expr.temp_num);
    c_expr.result_intro &:= "=";
    c_expr.result_finish := ")";
  end func;


const proc: prepare_set_result (inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.result_decl := "settype tmp_";
    c_expr.result_decl &:= str(c_expr.temp_num);
    c_expr.result_decl &:= " = NULL;\n";
    c_expr.result_free := "setDestr(tmp_";
    c_expr.result_free &:= str(c_expr.temp_num);
    c_expr.result_free &:= ");\n";
    c_expr.result_intro := "(tmp_";
    c_expr.result_intro &:= str(c_expr.temp_num);
    c_expr.result_intro &:= "=";
    c_expr.result_finish := ")";
  end func;


const proc: prepare_stri_result (inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.result_decl := "stritype tmp_";
    c_expr.result_decl &:= str(c_expr.temp_num);
    c_expr.result_decl &:= " = NULL;\n";
    c_expr.result_free := "strDestr(tmp_";
    c_expr.result_free &:= str(c_expr.temp_num);
    c_expr.result_free &:= ");\n";
    c_expr.result_intro := "(tmp_";
    c_expr.result_intro &:= str(c_expr.temp_num);
    c_expr.result_intro &:= "=";
    c_expr.result_finish := ")";
  end func;


const proc: prepare_bstri_result (inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.result_decl := "bstritype tmp_";
    c_expr.result_decl &:= str(c_expr.temp_num);
    c_expr.result_decl &:= " = NULL;\n";
    c_expr.result_free := "bstDestr(tmp_";
    c_expr.result_free &:= str(c_expr.temp_num);
    c_expr.result_free &:= ");\n";
    c_expr.result_intro := "(tmp_";
    c_expr.result_intro &:= str(c_expr.temp_num);
    c_expr.result_intro &:= "=";
    c_expr.result_finish := ")";
  end func;


const proc: prepare_struct_result (in type: struct_type, inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.result_decl := type_name(struct_type);
    c_expr.result_decl &:= " tmp_";
    c_expr.result_decl &:= str(c_expr.temp_num);
    c_expr.result_decl &:= " = (";
    c_expr.result_decl &:= type_name(struct_type);
    c_expr.result_decl &:= ")(NULL);\n";
    process_destr_declaration(struct_type, global_c_expr);
    process_destr_call(struct_type, "tmp_" & str(c_expr.temp_num), c_expr.result_free);
    c_expr.result_intro := "(tmp_";
    c_expr.result_intro &:= str(c_expr.temp_num);
    c_expr.result_intro &:= "=(";
    c_expr.result_intro &:= type_name(struct_type);
    c_expr.result_intro &:= ")(";
    c_expr.result_finish := "))";
  end func;


const proc: prepare_win_result (inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.result_decl := "wintype tmp_";
    c_expr.result_decl &:= str(c_expr.temp_num);
    c_expr.result_decl &:= " = NULL;\n";
    c_expr.result_free := "winDestr(tmp_";
    c_expr.result_free &:= str(c_expr.temp_num);
    c_expr.result_free &:= ");\n";
    c_expr.result_intro := "(tmp_";
    c_expr.result_intro &:= str(c_expr.temp_num);
    c_expr.result_intro &:= "=";
    c_expr.result_finish := ")";
  end func;


const proc: prepare_typed_result (in type: aType, inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.result_decl := type_name(aType);
    c_expr.result_decl &:= " tmp_";
    c_expr.result_decl &:= str(c_expr.temp_num);
    c_expr.result_decl &:= " = NULL;\n";
    process_destr_declaration(aType, global_c_expr);
    process_destr_call(aType, "tmp_" & str(c_expr.temp_num), c_expr.result_free);
    c_expr.result_intro := "(tmp_";
    c_expr.result_intro &:= str(c_expr.temp_num);
    c_expr.result_intro &:= "=";
    c_expr.result_finish := ")";
  end func;


const proc: prepareAnyParamTemporarys (in reference: aParam,
    inout expr_type: c_param, inout expr_type: c_expr) is func

  begin
    c_param.temp_num := c_expr.temp_num;
    process_expr(aParam, c_param);
    c_expr.temp_num := c_param.temp_num;
    c_expr.temp_decls &:= c_param.temp_decls;
    c_expr.temp_assigns &:= c_param.temp_assigns;
    c_expr.temp_frees &:= c_param.temp_frees;
  end func;


const proc: getAnyParamToExpr (in reference: aParam, inout expr_type: c_expr) is func

  local
    var expr_type: c_param is expr_type.value;
  begin
    prepareAnyParamTemporarys(aParam, c_param, c_expr);
    if c_param.result_expr <> "" then
      c_expr.temp_decls &:= c_param.result_decl;
      c_expr.temp_frees &:= c_param.result_free;
      c_expr.expr &:= c_param.result_intro;
      c_expr.expr &:= c_param.result_expr;
      c_expr.expr &:= c_param.result_finish;
    else
      c_expr.expr &:= c_param.expr;
    end if;
  end func;


const proc: getAnyParamToResultExpr (in reference: aParam, inout expr_type: c_expr) is func

  local
    var expr_type: c_param is expr_type.value;
  begin
    prepareAnyParamTemporarys(aParam, c_param, c_expr);
    if c_param.result_expr <> "" then
      c_expr.temp_decls &:= c_param.result_decl;
      c_expr.temp_frees &:= c_param.result_free;
      c_expr.result_expr &:= c_param.result_intro;
      c_expr.result_expr &:= c_param.result_expr;
      c_expr.result_expr &:= c_param.result_finish;
    else
      c_expr.result_expr &:= c_param.expr;
    end if;
  end func;


const proc: getStdParamToResultExpr (in reference: aParam, inout expr_type: c_expr) is func

  local
    var expr_type: c_param is expr_type.value;
  begin
    prepareAnyParamTemporarys(aParam, c_param, c_expr);
    c_expr.result_expr &:= c_param.expr;
  end func;


const proc: process_cast_from_float_expr (in reference: current_expression,
    inout expr_type: c_expr) is func

  local
    var integer: temp_num is 0;
  begin
    if getExprResultType(current_expression) = floattype then
      incr(c_expr.temp_num);
      temp_num := c_expr.temp_num;
      c_expr.temp_decls &:= "float2int tmp_";
      c_expr.temp_decls &:= str(temp_num);
      c_expr.temp_decls &:= ";\n";
      c_expr.expr &:= "(tmp_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= ".floatvalue=(";
      process_expr(current_expression, c_expr);
      c_expr.expr &:= "),tmp_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= ".intvalue)";
    else
      process_expr(current_expression, c_expr);
    end if;
  end func;


const proc: getTemporaryToResultExpr (in reference: aParam, inout expr_type: c_expr) is func

  local
    var expr_type: c_param is expr_type.value;
    var type: param_type is void;
  begin
    c_param.temp_num := c_expr.temp_num;
    process_cast_from_float_expr(aParam, c_param);
    c_expr.temp_num := c_param.temp_num;
    c_expr.temp_decls &:= c_param.temp_decls;
    c_expr.temp_assigns &:= c_param.temp_assigns;
    c_expr.temp_frees &:= c_param.temp_frees;
    if c_param.result_expr <> "" then
      c_expr.result_expr &:= c_param.result_expr;
    else
      param_type := getExprResultType(aParam);
      process_create_declaration(param_type, global_c_expr);
      process_create_call(param_type, c_param.expr, c_expr.result_expr);
    end if;
  end func;


const func string: enum_value (in reference: current_object) is func

  result
    var string: result is "";
  local
    var string: object_name is "";
    var type: enum_type is void;
  begin
    object_name := str(current_object);
    if object_name = "FALSE" then
      result := "0/*FALSE*/";
    elsif object_name = "TRUE" then
      result := "1/*TRUE*/";
    else
      result := "/*" & str(current_object) & "*/";
      enum_type := getType(current_object);
      if enum_type in enum_literal and
          current_object in enum_literal[enum_type] then
        result &:= str(enum_literal[enum_type][current_object]);
      else
        result &:= str(obj_number(current_object));
      end if;
    end if;
  end func;


const proc: reference_value (in reference: current_value,
    inout expr_type: c_expr) is func

  begin
    if current_value = NIL then
      c_expr.expr &:= "NULL";
    else
      c_expr.expr &:= "&(";
      process_expr(current_value, c_expr);
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: ref_list_value (in ref_list: current_value,
    inout expr_type: c_expr) is func

  local
    var reference: element is NIL;
    var boolean: first_element is TRUE;
  begin
    if length(current_value) = 0 then
      c_expr.expr &:= "NULL";
    else
      c_expr.expr &:= "{";
      for element range current_value do
        if first_element then
          first_element := FALSE;
        else
          c_expr.expr &:= ", ";
        end if;
        c_expr.expr &:= "&(";
        process_expr(element, c_expr);
        c_expr.expr &:= ")";
      end for;
      c_expr.expr &:= "}";
    end if;
  end func;


const func boolean: isActionExpression (in reference: current_expression, in string: actionName) is func

  result
    var boolean: result is FALSE;
  local
    var ref_list: params is ref_list.EMPTY;
  begin
    if category(current_expression) = CALLOBJECT then
      params := getValue(current_expression, ref_list);
      if category(params[1]) = ACTOBJECT and str(getValue(params[1], ACTION)) = actionName then
        result := TRUE;
      end if;
    end if;
  end func;


const func boolean: isConstant (in reference: current_expression) is forward;


const func boolean: isConstantCall (in reference: current_expression) is func

  result
    var boolean: result is FALSE;
  local
    var ref_list: params is ref_list.EMPTY;
    var reference: function is NIL;
    var category: functionCategory is category.value;
    var string: action_name is "";
    var reference: obj is NIL;
  begin
    params := getValue(current_expression, ref_list);
    function := params[1];
    params := params[2 ..];
    functionCategory := category(function);
    if functionCategory = ACTOBJECT then
      action_name := str(getValue(function, ACTION));
      if action_name in {"FIL_PRINT", "PRC_RAISE", "TYP_GENTYPE"} then
        result := FALSE;
      else
        result := TRUE;
        for obj range params do
          if not isConstant(obj) then
            result := FALSE;
          end if;
        end for;
        if result then
          writeln(action_name);
        end if;
      end if;
    end if;
  end func;


const func boolean: isConstant (in reference: current_expression) is func

  result
    var boolean: result is FALSE;
  local
    var category: exprCategory is category.value;
  begin
    if not isVar(current_expression) then
      exprCategory := category(current_expression);
      if exprCategory in {INTOBJECT, BIGINTOBJECT, CHAROBJECT,
          STRIOBJECT, BSTRIOBJECT, ARRAYOBJECT, HASHOBJECT, STRUCTOBJECT,
          SETOBJECT, FILEOBJECT, SOCKETOBJECT, LISTOBJECT, FLOATOBJECT,
          WINOBJECT, ENUMLITERALOBJECT, SYMBOLOBJECT} then
        result := TRUE;
      elsif exprCategory = MATCHOBJECT then
        result := isConstantCall(current_expression);
      elsif exprCategory = CALLOBJECT then
        result := isConstantCall(current_expression);
      elsif exprCategory = BLOCKOBJECT then
        result := TRUE;
      elsif exprCategory = ACTOBJECT then
        result := TRUE;
      end if;
    end if;
  end func;


const proc: process_statements (in expr_type: statements, inout expr_type: c_expr) is func

  begin
    if statements.temp_num <> 0 then
      c_expr.expr &:= statements.temp_decls;
      c_expr.expr &:= statements.temp_assigns;
      c_expr.expr &:= statements.expr;
      c_expr.expr &:= statements.temp_frees;
    else
      c_expr.expr &:= statements.expr;
    end if;
  end func;


const proc: process_else (in reference: else_part, inout expr_type: c_expr) is func

  local
    var category: functionCategory is category.value;
    var ref_list: params is ref_list.EMPTY;
    var reference: function is NIL;
    var expr_type: c_param2 is expr_type.value;
    var string: action_name is "";
  begin
    if category(else_part) = MATCHOBJECT then
      params := getValue(else_part, ref_list);
      function := params[1];
      params := params[2 ..];
      functionCategory := category(function);
      if functionCategory = CONSTENUMOBJECT then
        process_expr(params[2], c_param2);
        c_expr.expr &:= "else {\n";
        process_statements(c_param2, c_expr);
        c_expr.expr &:= "}\n";
      elsif functionCategory = ACTOBJECT then
        c_expr.expr &:= "else ";
        process_action(function, params, c_expr);
      else
        c_expr.expr &:= "/*!!! ";
        c_expr.expr &:= str(functionCategory);
        c_expr.expr &:= " ";
        c_expr.expr &:= str(function);
        c_expr.expr &:= " !!!*/";
      end if;
    else
      c_expr.expr &:= "/*!! ";
      c_expr.expr &:= str(category(else_part));
      c_expr.expr &:= " ";
      c_expr.expr &:= str(else_part);
      c_expr.expr &:= " !!*/";
    end if
  end func;


const proc: process_prc_if (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param2 is expr_type.value;
    var expr_type: c_param4 is expr_type.value;
  begin
    process_expr(params[2], c_param2);
    process_expr(params[4], c_param4);
    if c_param2.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param2.temp_decls;
      c_expr.expr &:= c_param2.temp_assigns;
    end if;
    c_expr.expr &:= "if (";
    c_expr.expr &:= c_param2.expr;
    c_expr.expr &:= ") {\n";
    process_statements(c_param4, c_expr);
    c_expr.expr &:= "}\n";
    if c_param2.temp_num <> 0 then
      c_expr.expr &:= c_param2.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_prc_if_elsif (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param2 is expr_type.value;
    var expr_type: c_param4 is expr_type.value;
    var expr_type: c_param5 is expr_type.value;
  begin
    process_expr(params[2], c_param2);
    process_expr(params[4], c_param4);
    c_param5.temp_num := c_param2.temp_num;
    process_else(params[5], c_param5);
    if c_param5.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param2.temp_decls;
      c_expr.expr &:= c_param5.temp_decls;
      c_expr.expr &:= c_param2.temp_assigns;
      c_expr.expr &:= c_param5.temp_assigns;
    end if;
    c_expr.expr &:= "if (";
    c_expr.expr &:= c_param2.expr;
    c_expr.expr &:= ") {\n";
    process_statements(c_param4, c_expr);
    c_expr.expr &:= "} ";
    c_expr.expr &:= c_param5.expr;
    if c_param5.temp_num <> 0 then
      c_expr.expr &:= c_param2.temp_frees;
      c_expr.expr &:= c_param5.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_prc_while (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param2 is expr_type.value;
    var expr_type: c_param4 is expr_type.value;
  begin
    process_expr(params[2], c_param2);
    c_param4.temp_num := c_param2.temp_num;
    process_expr(params[4], c_param4);
    if c_param2.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param2.temp_decls;
      c_expr.expr &:= c_param2.temp_assigns;
    end if;
    c_expr.expr &:= "while (";
    c_expr.expr &:= c_param2.expr;
    c_expr.expr &:= ") {\n";
    if c_param2.temp_num <> 0 then
      c_expr.expr &:= c_param2.temp_frees;
    end if;
    process_statements(c_param4, c_expr);
    c_expr.expr &:= "}\n";
    if c_param2.temp_num <> 0 then
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_prc_repeat (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "do {\n";
    process_expr(params[2], c_expr);
    c_expr.expr &:= "} while (!(";
    process_expr(params[4], c_expr);
    c_expr.expr &:= "));\n";
  end func;


const proc: process_prc_for_downto (in ref_list: params, inout expr_type: c_expr) is func

  local
    var integer: temp_num is 0;
  begin
    incr(c_expr.temp_num);
    temp_num := c_expr.temp_num;
    c_expr.temp_decls &:= "inttype tmp_e_";
    c_expr.temp_decls &:= str(temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.expr &:= "{\ntmp_e_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "=(";
    process_expr(params[6], c_expr);
    c_expr.expr &:= ");\n";
    c_expr.expr &:= "for (";
    process_expr(params[2], c_expr);
    c_expr.expr &:= "=(";
    process_expr(params[4], c_expr);
    c_expr.expr &:= "); ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ">=tmp_e_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "; (";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")--) {\n";
    process_expr(params[8], c_expr);
    c_expr.expr &:= "}\n}\n";
  end func;


const proc: process_prc_for_to (in ref_list: params, inout expr_type: c_expr) is func

  local
    var integer: temp_num is 0;
  begin
    incr(c_expr.temp_num);
    temp_num := c_expr.temp_num;
    c_expr.temp_decls &:= "inttype tmp_e_";
    c_expr.temp_decls &:= str(temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.expr &:= "{\ntmp_e_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "=(";
    process_expr(params[6], c_expr);
    c_expr.expr &:= ");\n";
    c_expr.expr &:= "for (";
    process_expr(params[2], c_expr);
    c_expr.expr &:= "=(";
    process_expr(params[4], c_expr);
    c_expr.expr &:= "); ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= "<=tmp_e_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "; (";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")++) {\n";
    process_expr(params[8], c_expr);
    c_expr.expr &:= "}\n}\n";
  end func;


const proc: process_bitset (in bitset: currentSet, inout expr_type: c_expr) is func

  local
    var integer: number is 0;
  begin
    for number range min(currentSet) to max(currentSet) do
      if number in currentSet then
        c_expr.expr &:= "case ";
        c_expr.expr &:= str(number);
        c_expr.expr &:= ":\n";
      end if;
    end for;
  end func;


const proc: process_case_labels (in reference: current_expression, inout expr_type: c_expr) is func

  local
    var reference: case_labels is NIL;
    var category: labelCategory is category.value;
  begin
    case_labels := evaluate(prog, current_expression);
    labelCategory := category(case_labels);
    if labelCategory = SETOBJECT then
      process_bitset(getValue(case_labels, bitset), c_expr);
    else
      c_expr.expr &:= "/* case ";
      c_expr.expr &:= str(labelCategory);
      c_expr.expr &:= " */";
    end if;
  end func;


const proc: process_when (in reference: when_expr, inout expr_type: c_expr) is func

  local
    var ref_list: params is ref_list.EMPTY;
    var reference: function is NIL;
  begin
    params := getValue(when_expr, ref_list);
    function := params[1];
    params := params[2 ..];
    process_case_labels(params[2], c_expr);
    process_expr(params[4], c_expr);
    c_expr.expr &:= "break;\n";
    if length(params) >= 5 then
      process_when(params[5], c_expr);
    end if;
  end func;


const proc: process_prc_case (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "switch (";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ") {\n";
    process_when(params[4], c_expr);
    c_expr.expr &:= "}\n";
  end func;


const proc: process_prc_case_def (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "switch (";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ") {\n";
    process_when(params[4], c_expr);
    c_expr.expr &:= "default:\n";
    process_expr(params[7], c_expr);
    c_expr.expr &:= "break;\n";
    c_expr.expr &:= "}\n";
  end func;


const proc: process_prc_block (in ref_list: params, inout expr_type: c_expr) is func

  local
    var reference: current_catch is NIL;
    var ref_list: catch_expr is ref_list.EMPTY;
    var reference: catch_value is NIL;
  begin
    c_expr.expr &:= "{\n";
    c_expr.expr &:= "int fail_value;\n";
    c_expr.expr &:= "catch_stack_pos++;\n";
    c_expr.expr &:= "if (catch_stack_pos >= max_catch_stack) {\n";
    c_expr.expr &:= "  resize_catch_stack();\n";
    c_expr.expr &:= "}\n";
    if USE_SIGSETJMP then
      c_expr.expr &:= "if ((fail_value = sigsetjmp(catch_stack[catch_stack_pos], -1)) == 0) {\n";
    else
      c_expr.expr &:= "if ((fail_value = setjmp(catch_stack[catch_stack_pos])) == 0) {\n";
    end if;
    process_expr(params[2], c_expr);
    c_expr.expr &:= "} else {\n";
    # c_expr.expr &:= "printf(\"catch %d\\n\", fail_value);\n";
    current_catch := params[4];
    catch_expr := getValue(current_catch, ref_list);
    while current_catch <> NIL and
        category(current_catch) = MATCHOBJECT and
        length(catch_expr) >= 5 do
      catch_value := catch_expr[3];
      c_expr.expr &:= "if (";
      process_expr(catch_value, c_expr);
      c_expr.expr &:= " == fail_value - 1) {\n";
      process_expr(catch_expr[5], c_expr);
      if length(catch_expr) >= 6 then
        c_expr.expr &:= "} else ";
        current_catch := catch_expr[6];
        catch_expr := getValue(current_catch, ref_list);
      else
        c_expr.expr &:= "} else {\n";
        c_expr.expr &:= "  catch_stack_pos--;\n";
        c_expr.expr &:= "  raise_error(fail_value);\n";
        current_catch := NIL;
      end if;
    end while;
    c_expr.expr &:= "}\n";
    c_expr.expr &:= "}\n";
    c_expr.expr &:= "catch_stack_pos--;\n";
    c_expr.expr &:= "}\n";
  end func;


const proc: process_function (in reference: function,
    in ref_list: formal_params, in ref_list: actual_params,
    inout expr_type: c_expr) is forward;


const proc: process_prc_dynamic (in reference: function, in ref_list: params,
    inout expr_type: c_expr) is func

  local
    var reference: obj is NIL;
    var boolean: first_element is TRUE;
  begin
    process_function(function, params(function), params, c_expr);
  end func;


const proc: process_prc_exit (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "exit(0);\n";
  end func;


const proc: process_prc_hsize (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "heapsize()";
  end func;


const proc: process_prc_semicol (in ref_list: params, inout expr_type: c_expr) is func

  begin
    process_expr(params[1], c_expr);
    # c_expr.expr &:= ";";
    # c_expr.expr &:= "\n";
    process_expr(params[3], c_expr);
  end func;


const proc: do_noop_param(in reference: formal_param, in reference: actual_param,
    inout expr_type: c_expr) is func

  local
    var category: paramCategory is category.value;
    var type: object_type is void;
  begin
    paramCategory := category(actual_param);
    if paramCategory <> SYMBOLOBJECT and
        category(formal_param) <> SYMBOLOBJECT then
      object_type := getType(formal_param);
      if is_func(object_type) or is_varfunc(object_type) then
        c_expr.expr &:= "/*expression*/";
(*
        if getType(formal_param) <> getType(actual_param) then
          PRINT("***###***\n");
        end if;
        object_type := result_type(object_type);
        TRACE(object_type); PRINT("\n");
        TRACE_OBJ(actual_param); PRINT("\n\n");
*)
      else
        c_expr.expr &:= "/* ";
        c_expr.expr &:= str(paramCategory);
        if paramCategory = CALLOBJECT then
          paramCategory := category(getValue(actual_param, ref_list)[1]);
          c_expr.expr &:= " ";
          c_expr.expr &:= str(paramCategory);
          if paramCategory = ACTOBJECT then
            c_expr.expr &:= " ";
            c_expr.expr &:= str(getValue(getValue(actual_param, ref_list)[1], ACTION));
          end if
        end if;
        c_expr.expr &:= " */";
        getAnyParamToExpr(actual_param, c_expr);
        c_expr.expr &:= ";";
      end if;
    else
      c_expr.expr &:= "/*";
      c_expr.expr &:= str(actual_param);
      c_expr.expr &:= "*/";
    end if;
  end func;


const proc: noop_params (in ref_list: formal_params,
    in ref_list: actual_params, inout expr_type: c_expr) is func

  local
    var integer: number is 0;
  begin
    for number range 1 to length(formal_params) do
      if number <= length(actual_params) then
        do_noop_param(formal_params[number], actual_params[number], c_expr);
      end if;
    end for;
  end func;


const proc: process_prc_other_noop (in reference: function, in ref_list: params,
    inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "/*noop*/";
    noop_params(params(function), params, c_expr);
    c_expr.expr &:= "\n";
  end func;


const proc: process_prc_noop (in reference: function, in ref_list: params,
    inout expr_type: c_expr) is func

  begin
    if length(params) = 3 and str(params[2]) = ";" then
      process_prc_semicol(params, c_expr);
    else
      process_prc_other_noop(function, params, c_expr);
    end if;
  end func;


const proc: process_prc_args (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "arg_v";
  end func;


const proc: process_prc_raise (in reference: function, in ref_list: params,
    inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "raise_error2(";
    getAnyParamToExpr(params[2], c_expr);
    c_expr.expr &:= "+1, ";
    c_expr.expr &:= c_literal(file(function));
    c_expr.expr &:= ", ";
    c_expr.expr &:= str(line(function));
    c_expr.expr &:= ");\n";
  end func;


const proc: process_act_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "=(";
    if c_param3.result_expr <> "" then
      c_expr.expr &:= c_param3.result_expr;
    else
      c_expr.expr &:= c_param3.expr;
    end if;
    c_expr.expr &:= ");\n";
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_act_str (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compilerLibraryUsed := TRUE;
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "actStr(";
    getStdParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_act_value (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compDataLibraryUsed := TRUE;
    c_expr.expr &:= "actValue(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_arr_append (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    getTemporaryToResultExpr(params[3], c_param3);
    if has_temp_values(c_param3) then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    c_expr.expr &:= "arrAppend(&(";
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "), ";
    c_expr.expr &:= c_param3.result_expr;
    c_expr.expr &:= ");\n";
    if has_temp_values(c_param3) then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_arr_arrlit (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_array_result(getExprResultType(params[3]), c_expr);
    c_expr.result_expr := "arrArrlit((arraytype)(";
    getTemporaryToResultExpr(params[3], c_expr);
    c_expr.result_expr &:= "))";
  end func;


const proc: process_arr_arrlit2 (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_array_result(getExprResultType(params[4]), c_expr);
    c_expr.result_expr := "arrArrlit2(";
    getStdParamToResultExpr(params[2], c_expr);
    c_expr.result_expr &:= ", (arraytype)(";
    getTemporaryToResultExpr(params[4], c_expr);
    c_expr.result_expr &:= "))";
  end func;


const proc: process_arr_baselit (in reference: function, in ref_list: params,
    inout expr_type: c_expr) is func

  begin
    prepare_array_result(result_type(getType(function)), c_expr);
    c_expr.result_expr := "arrBaselit((long)(";
    getTemporaryToResultExpr(params[3], c_expr);
    c_expr.result_expr &:= "))";
  end func;


const proc: process_arr_baselit2 (in reference: function, in ref_list: params,
    inout expr_type: c_expr) is func

  begin
    prepare_array_result(result_type(getType(function)), c_expr);
    c_expr.result_expr := "arrBaselit2(";
    getStdParamToResultExpr(params[2], c_expr);
    c_expr.result_expr &:= ", (long)(";
    getTemporaryToResultExpr(params[4], c_expr);
    c_expr.result_expr &:= "))";
  end func;


const proc: process_arr_cat (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_array_result(getExprResultType(params[1]), c_expr);
    c_expr.result_expr := "arrCat((arraytype)(";
    getTemporaryToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= "), (arraytype)(";
    getTemporaryToResultExpr(params[3], c_expr);
    c_expr.result_expr &:= "))";
  end func;


const proc: process_arr_conv (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_arr_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if has_temp_values(c_param3) then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    if c_param3.result_expr <> "" then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= "arraytype *array_ptr=&(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= ");\n";
      c_expr.expr &:= "arraytype old_array=*array_ptr;\n";
      c_expr.expr &:= "*array_ptr=(arraytype)(";
      c_expr.expr &:= c_param3.result_expr;
      c_expr.expr &:= ");\n";
      process_destr_declaration(getExprResultType(params[1]), global_c_expr);
      process_destr_call(getExprResultType(params[1]),
          "old_array", c_expr.expr);
      c_expr.expr &:= "}\n";
    else
      process_cpy_declaration(getExprResultType(params[1]), global_c_expr);
      process_cpy_call(getExprResultType(params[1]),
          c_param1.expr, c_param3.expr, c_expr.expr);
      c_expr.expr &:= ";\n";
    end if;
    if has_temp_values(c_param3) then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_arr_create (in reference: function, in ref_list: params,
    inout expr_type: c_expr) is func

  begin
    process_create_declaration(result_type(getType(function)), global_c_expr);
    process_expr(params[1], c_expr);
    c_expr.expr &:= "=create_";
    c_expr.expr &:= str(type_number(result_type(getType(function))));
    c_expr.expr &:= "(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_arr_destr (in reference: function, in ref_list: params,
    inout expr_type: c_expr) is func

  begin
    process_destr_declaration(result_type(getType(function)), global_c_expr);
    c_expr.expr &:= "destr_";
    c_expr.expr &:= str(type_number(result_type(getType(function))));
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_arr_extend (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_array_result(getExprResultType(params[1]), c_expr);
    c_expr.result_expr := "arrExtend(";
    getTemporaryToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ", (inttype)(";
    getTemporaryToResultExpr(params[3], c_expr);
    c_expr.result_expr &:= "))";
  end func;


const proc: process_arr_gen (in reference: function, in ref_list: params,
    inout expr_type: c_expr) is func

  begin
    prepare_array_result(result_type(getType(function)), c_expr);
    c_expr.result_expr := "arrGen((inttype)(";
    getTemporaryToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= "), (inttype)(";
    getTemporaryToResultExpr(params[3], c_expr);
    c_expr.result_expr &:= "))";
  end func;


const proc: process_arr_head (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_array_result(getExprResultType(params[1]), c_expr);
    c_expr.result_expr := "arrHead((arraytype)(";
    getTemporaryToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= "), ";
    getStdParamToResultExpr(params[4], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_const_arr_idx (in reference: function, in reference: anArray,
    in reference: param3, inout expr_type: c_expr) is func

  local
    var integer: index is 0;
    var integer: index_temp_num is 0;
  begin
    incr(countOptimizations);
    if anArray not in const_table then
      const_table @:= [anArray] length(const_table);
    end if;
    if category(param3) = INTOBJECT and not isVar(param3) then
      index := getValue(param3, integer);
      if index < array_min_index(anArray) or index > array_max_index(anArray) then
        process_raise_error("RANGE_ERROR", function, c_expr);
      else
        c_expr.expr &:= "arr[";
        c_expr.expr &:= str(const_table[anArray]);
        c_expr.expr &:= "]->arr[";
        c_expr.expr &:= str(index - array_min_index(anArray));
        c_expr.expr &:= "]";
        c_expr.expr &:= select_value_from_rtlObjectstruct(result_type(getType(function)));
      end if;
    else
      c_expr.expr &:= "arr[";
      c_expr.expr &:= str(const_table[anArray]);
      c_expr.expr &:= "]->arr[";
      if array_range_check then
        incr(c_expr.temp_num);
        index_temp_num := c_expr.temp_num;
        if TWOS_COMPLEMENT_INTTYPE then
          c_expr.temp_decls &:= "memsizetype tmp_";
        else
          c_expr.temp_decls &:= "inttype tmp_";
        end if;
        c_expr.temp_decls &:= str(index_temp_num);
        c_expr.temp_decls &:= ";\n";
        c_expr.expr &:= "(tmp_";
        c_expr.expr &:= str(index_temp_num);
        c_expr.expr &:= "=(";
        process_expr(param3, c_expr);
        c_expr.expr &:= ")-";
        c_expr.expr &:= str(array_min_index(anArray));
        c_expr.expr &:= ", tmp_";
        if not TWOS_COMPLEMENT_INTTYPE then
          c_expr.expr &:= str(index_temp_num);
          c_expr.expr &:= "<0 || tmp_";
        end if;
        c_expr.expr &:= str(index_temp_num);
        c_expr.expr &:= ">=";
        c_expr.expr &:= str(succ(array_max_index(anArray) - array_min_index(anArray)));
        c_expr.expr &:= " ? ";
        process_raise_error("RANGE_ERROR", function, c_expr);
        c_expr.expr &:= " : 0, tmp_";
        c_expr.expr &:= str(index_temp_num);
        c_expr.expr &:= ")";
      else
        c_expr.expr &:= "(";
        process_expr(param3, c_expr);
        c_expr.expr &:= ")-";
        c_expr.expr &:= str(array_min_index(anArray));
      end if;
      c_expr.expr &:= "]";
      c_expr.expr &:= select_value_from_rtlObjectstruct(result_type(getType(function)));
    end if;
  end func;


const proc: process_const_arr_idx (in reference: function, in reference: param1,
    in integer: index, inout expr_type: c_expr) is func

  local
    var integer: array_temp_num is 0;
  begin
    incr(countOptimizations);
    incr(c_expr.temp_num);
    array_temp_num := c_expr.temp_num;
    c_expr.temp_decls &:= "arraytype tmp_";
    c_expr.temp_decls &:= str(array_temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.expr &:= "(*(tmp_";
    c_expr.expr &:= str(array_temp_num);
    c_expr.expr &:= "=(arraytype)(";
    getAnyParamToExpr(param1, c_expr);
    c_expr.expr &:= "), &tmp_";
    c_expr.expr &:= str(array_temp_num);
    c_expr.expr &:= "->arr[";
    if array_range_check then
      c_expr.expr &:= "(";
      c_expr.expr &:= str(index);
      c_expr.expr &:= "<tmp_";
      c_expr.expr &:= str(array_temp_num);
      c_expr.expr &:= "->min_position || ";
      c_expr.expr &:= str(index);
      c_expr.expr &:= ">tmp_";
      c_expr.expr &:= str(array_temp_num);
      c_expr.expr &:= "->max_position ? ";
      process_raise_error("RANGE_ERROR", function, c_expr);
      c_expr.expr &:= " : 0, ";
      c_expr.expr &:= str(index);
      c_expr.expr &:= "-tmp_";
      c_expr.expr &:= str(array_temp_num);
      c_expr.expr &:= "->min_position)";
    else
      c_expr.expr &:= str(index);
      c_expr.expr &:= "-tmp_";
      c_expr.expr &:= str(array_temp_num);
      c_expr.expr &:= "->min_position";
    end if;
    c_expr.expr &:= "]";
    c_expr.expr &:= select_value_from_rtlObjectstruct(result_type(getType(function)));
    c_expr.expr &:= "))";
  end func;


const proc: process_arr_idx (in reference: function, in ref_list: params,
    inout expr_type: c_expr) is func

  local
    var integer: array_temp_num is 0;
    var integer: index_temp_num is 0;
  begin
    if category(params[1]) = ARRAYOBJECT and not isVar(params[1]) then
      process_const_arr_idx(function, params[1], params[3], c_expr);
    elsif category(params[3]) = INTOBJECT and not isVar(params[3]) then
      process_const_arr_idx(function, params[1], getValue(params[3], integer), c_expr);
    else
      incr(c_expr.temp_num);
      array_temp_num := c_expr.temp_num;
      c_expr.temp_decls &:= "arraytype tmp_";
      c_expr.temp_decls &:= str(array_temp_num);
      c_expr.temp_decls &:= ";\n";
      c_expr.expr &:= "(*(tmp_";
      c_expr.expr &:= str(array_temp_num);
      c_expr.expr &:= "=(arraytype)(";
      getAnyParamToExpr(params[1], c_expr);
      c_expr.expr &:= "), &tmp_";
      c_expr.expr &:= str(array_temp_num);
      c_expr.expr &:= "->arr[";
      if array_range_check then
        incr(c_expr.temp_num);
        index_temp_num := c_expr.temp_num;
        c_expr.temp_decls &:= "inttype tmp_";
        c_expr.temp_decls &:= str(index_temp_num);
        c_expr.temp_decls &:= ";\n";
        c_expr.expr &:= "(tmp_";
        c_expr.expr &:= str(index_temp_num);
        c_expr.expr &:= "=";
        process_expr(params[3], c_expr);
        c_expr.expr &:= ", tmp_";
        c_expr.expr &:= str(index_temp_num);
        c_expr.expr &:= " < tmp_";
        c_expr.expr &:= str(array_temp_num);
        c_expr.expr &:= "->min_position || tmp_";
        c_expr.expr &:= str(index_temp_num);
        c_expr.expr &:= " > tmp_";
        c_expr.expr &:= str(array_temp_num);
        c_expr.expr &:= "->max_position ? ";
        process_raise_error("RANGE_ERROR", function, c_expr);
        c_expr.expr &:= " : 0, tmp_";
        c_expr.expr &:= str(index_temp_num);
        c_expr.expr &:= "-tmp_";
        c_expr.expr &:= str(array_temp_num);
        c_expr.expr &:= "->min_position)";
      else
        c_expr.expr &:= "(";
        process_expr(params[3], c_expr);
        c_expr.expr &:= ")-tmp_";
        c_expr.expr &:= str(array_temp_num);
        c_expr.expr &:= "->min_position";
      end if;
      c_expr.expr &:= "]";
      c_expr.expr &:= select_value_from_rtlObjectstruct(result_type(getType(function)));
      c_expr.expr &:= "))";
    end if;
  end func;


const proc: process_arr_lng (in ref_list: params, inout expr_type: c_expr) is func

  local
    var integer: temp_num is 0;
  begin
    if category(params[1]) = ARRAYOBJECT and not isVar(params[1]) then
      incr(countOptimizations);
      if params[1] not in const_table then
        const_table @:= [params[1]] length(const_table);
      end if;
      c_expr.expr &:= str(array_max_index(params[1]) - array_min_index(params[1]) + 1);
      c_expr.expr &:= " /* length(arr[";
      c_expr.expr &:= str(const_table[params[1]]);
      c_expr.expr &:= "]) */";
    else
      incr(c_expr.temp_num);
      temp_num := c_expr.temp_num;
      c_expr.temp_decls &:= "arraytype tmp_";
      c_expr.temp_decls &:= str(temp_num);
      c_expr.temp_decls &:= ";\n";
      c_expr.expr &:= "(tmp_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "=(arraytype)(";
      getAnyParamToExpr(params[1], c_expr);
      c_expr.expr &:= "), tmp_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "->max_position - tmp_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "->min_position + 1)";
    end if;
  end func;


const proc: process_arr_maxidx (in ref_list: params, inout expr_type: c_expr) is func

  local
    var integer: temp_num is 0;
  begin
    if category(params[1]) = ARRAYOBJECT and not isVar(params[1]) then
      incr(countOptimizations);
      if params[1] not in const_table then
        const_table @:= [params[1]] length(const_table);
      end if;
      c_expr.expr &:= str(array_max_index(params[1]));
      c_expr.expr &:= " /* maxIdx(arr[";
      c_expr.expr &:= str(const_table[params[1]]);
      c_expr.expr &:= "]) */";
    else
      c_expr.expr &:= "((arraytype)(";
      getAnyParamToExpr(params[1], c_expr);
      c_expr.expr &:= "))->max_position";
    end if;
  end func;


const proc: process_arr_minidx (in ref_list: params, inout expr_type: c_expr) is func

  local
    var integer: temp_num is 0;
  begin
    if category(params[1]) = ARRAYOBJECT and not isVar(params[1]) then
      incr(countOptimizations);
      if params[1] not in const_table then
        const_table @:= [params[1]] length(const_table);
      end if;
      c_expr.expr &:= str(array_min_index(params[1]));
      c_expr.expr &:= " /* minIdx(arr[";
      c_expr.expr &:= str(const_table[params[1]]);
      c_expr.expr &:= "]) */";
    else
      c_expr.expr &:= "((arraytype)(";
      getAnyParamToExpr(params[1], c_expr);
      c_expr.expr &:= "))->min_position";
    end if;
  end func;


const proc: process_arr_range (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_array_result(getExprResultType(params[1]), c_expr);
    c_expr.result_expr := "arrRange(";
    getTemporaryToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    getStdParamToResultExpr(params[3], c_expr);
    c_expr.result_expr &:= ", ";
    getStdParamToResultExpr(params[5], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_arr_remove (in reference: function, in ref_list: params,
    inout expr_type: c_expr) is func

  local
    var type: proc_type is void;
    var type: result_type is void;
    var integer: temp_num is 0;
  begin
    proc_type := getType(function);
    result_type := result_type(proc_type);
    prepare_typed_result(result_type, c_expr);
    if result_type = floattype then
      incr(c_expr.temp_num);
      temp_num := c_expr.temp_num;
      c_expr.temp_decls &:= "float2int tmp_";
      c_expr.temp_decls &:= str(temp_num);
      c_expr.temp_decls &:= ";\n";
      c_expr.result_expr &:= "(tmp_";
      c_expr.result_expr &:= str(temp_num);
      c_expr.result_expr &:= ".intvalue=(";
    end if;
    c_expr.result_expr := "arrRemove(&(";
    getStdParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= "), ";
    getStdParamToResultExpr(params[2], c_expr);
    c_expr.result_expr &:= ")";
    if result_type = floattype then
      c_expr.result_expr &:= "),tmp_";
      c_expr.result_expr &:= str(temp_num);
      c_expr.result_expr &:= ".floatvalue)";
    end if;
  end func;


const proc: process_arr_sort (in ref_list: params, inout expr_type: c_expr) is func

  begin
    declare_func_pointer_if_necessary(params[2], global_c_expr);
    prepare_array_result(getExprResultType(params[1]), c_expr);
    c_expr.result_expr := "arrSort((arraytype)(";
    getTemporaryToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= "), (comparetype)(";
    getStdParamToResultExpr(params[2], c_expr);
    c_expr.result_expr &:= "))";
  end func;


const proc: process_arr_tail (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_array_result(getExprResultType(params[1]), c_expr);
    c_expr.result_expr := "arrTail((arraytype)(";
    getTemporaryToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= "), ";
    getStdParamToResultExpr(params[3], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_arr_times (in reference: function, in ref_list: params,
    inout expr_type: c_expr) is func

  begin
    declare_prototype_if_necessary(function, global_c_expr);
    prepare_array_result(result_type(getType(function)), c_expr);
    c_expr.result_expr &:= "times_";
    c_expr.result_expr &:= str(type_number(result_type(getType(function))));
    c_expr.result_expr &:= "(";
    getStdParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ", (";
    c_expr.result_expr &:= type_name(getType(params(function)[3]));
    c_expr.result_expr &:= ")(";
    getAnyParamToResultExpr(params[3], c_expr);
    c_expr.result_expr &:= "))";
  end func;


const proc: process_big_abs (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_bigint_result(c_expr);
    c_expr.result_expr := "bigAbs(";
    getAnyParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ")";
  end func;


(**
 *  Produces code for the big integer addition.
 *  When the first or the second parameter is a temporary value
 *  the addition is done with bigAddTemp. The bigAddTemp function
 *  returns the first parameter as result of the addition. That
 *  way the temporary value of a parameter must not be freed.
 *)
const proc: process_big_add (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    prepare_bigint_result(c_expr);
    prepareAnyParamTemporarys(params[1], c_param1, c_expr);
    if c_param1.result_expr <> "" then
      c_expr.result_expr := "bigAddTemp(";
      c_expr.result_expr &:= c_param1.result_expr;
      c_expr.result_expr &:= ", ";
      getAnyParamToResultExpr(params[3], c_expr);
      c_expr.result_expr &:= ")";
    else
      prepareAnyParamTemporarys(params[3], c_param3, c_expr);
      if c_param3.result_expr <> "" then
        c_expr.result_expr := "bigAddTemp(";
        c_expr.result_expr &:= c_param3.result_expr;
        c_expr.result_expr &:= ", ";
        c_expr.result_expr &:= c_param1.expr;
        c_expr.result_expr &:= ")";
      else
        c_expr.result_expr := "bigAdd(";
        c_expr.result_expr &:= c_param1.expr;
        c_expr.result_expr &:= ", ";
        c_expr.result_expr &:= c_param3.expr;
        c_expr.result_expr &:= ")";
      end if;
    end if;
  end func;


const proc: process_big_bit_length (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "bigBitLength(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_big_clit (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "bigCLit(";
    getAnyParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_const_big_cmp (in reference: param1, in bigInteger: number,
    inout expr_type: c_expr) is func

  begin
    if category(param1) = BIGINTOBJECT and not isVar(param1) then
      incr(countOptimizations);
      c_expr.expr &:= str(compare(getValue(param1, bigInteger), number));
    elsif abs(number) <= 127_ then
      incr(countOptimizations);
      c_expr.expr &:= "bigCmpSignedDigit(";
      getAnyParamToExpr(param1, c_expr);
      c_expr.expr &:= ", ";
      c_expr.expr &:= str(number);
      c_expr.expr &:= INTTYPE_LITERAL_SUFFIX;
      c_expr.expr &:= ")";
    else
      c_expr.expr &:= "bigCmp(";
      getAnyParamToExpr(param1, c_expr);
      c_expr.expr &:= ", ";
      if number not in bigint_const_table then
        bigint_const_table @:= [number] length(bigint_const_table);
      end if;
      c_expr.expr &:= "big[";
      c_expr.expr &:= str(bigint_const_table[number]);
      c_expr.expr &:= "] /* ";
      c_expr.expr &:= str(number);
      c_expr.expr &:= " */)";
    end if;
  end func;


const proc: process_const_big_cmp (in bigInteger: number, in reference: param2,
    inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "-";
    process_const_big_cmp(param2, number, c_expr);
  end func;


const proc: process_big_cmp (in ref_list: params, inout expr_type: c_expr) is func

  begin
    if category(params[2]) = BIGINTOBJECT and not isVar(params[2]) then
      process_const_big_cmp(params[1], getValue(params[2], bigInteger), c_expr);
    elsif category(params[1]) = BIGINTOBJECT and not isVar(params[1]) then
      process_const_big_cmp(getValue(params[1], bigInteger), params[2], c_expr);
    else
      c_expr.expr &:= "bigCmp(";
      getAnyParamToExpr(params[1], c_expr);
      c_expr.expr &:= ", ";
      getAnyParamToExpr(params[2], c_expr);
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process_big_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if has_temp_values(c_param3) then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    if c_param3.result_expr <> "" then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= "biginttype *big_ptr=&(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= ");\n";
      c_expr.expr &:= "biginttype old_big=*big_ptr;\n";
      c_expr.expr &:= "*big_ptr=";
      c_expr.expr &:= c_param3.result_expr;
      c_expr.expr &:= ";\n";
      c_expr.expr &:= "bigDestr(old_big);\n";
      c_expr.expr &:= "}\n";
    else
      c_expr.expr &:= "bigCpy(&(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "), ";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= ");\n";
    end if;
    if has_temp_values(c_param3) then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_big_decr (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "bigDecr(&(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= "));\n";
  end func;


const proc: process_big_div (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_bigint_result(c_expr);
    c_expr.result_expr := "bigDiv(";
    getAnyParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    getAnyParamToResultExpr(params[3], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_big_eq (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "bigEq(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ", ";
    getAnyParamToExpr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_big_gcd (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_bigint_result(c_expr);
    c_expr.result_expr := "bigGcd(";
    getAnyParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    getAnyParamToResultExpr(params[2], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_big_ge (in ref_list: params, inout expr_type: c_expr) is func

  begin
    if category(params[3]) = BIGINTOBJECT and not isVar(params[3]) then
      process_const_big_cmp(params[1], getValue(params[3], bigInteger), c_expr);
    elsif category(params[1]) = BIGINTOBJECT and not isVar(params[1]) then
      process_const_big_cmp(getValue(params[1], bigInteger), params[3], c_expr);
    else
      c_expr.expr &:= "bigCmp(";
      getAnyParamToExpr(params[1], c_expr);
      c_expr.expr &:= ", ";
      getAnyParamToExpr(params[3], c_expr);
      c_expr.expr &:= ")";
    end if;
    c_expr.expr &:= " >= 0";
  end func;


const proc: process_big_grow (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if has_temp_values(c_param3) or c_param3.result_expr <> "" then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param3.result_decl;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    c_expr.expr &:= "bigGrow(&(";
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "), ";
    if c_param3.result_expr <> "" then
      c_expr.expr &:= c_param3.result_intro;
      c_expr.expr &:= c_param3.result_expr;
      c_expr.expr &:= c_param3.result_finish;
    else
      c_expr.expr &:= c_param3.expr;
    end if;
    c_expr.expr &:= ");\n";
    if has_temp_values(c_param3) or c_param3.result_expr <> "" then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= c_param3.result_free;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_big_gt (in ref_list: params, inout expr_type: c_expr) is func

  begin
    if category(params[3]) = BIGINTOBJECT and not isVar(params[3]) then
      process_const_big_cmp(params[1], getValue(params[3], bigInteger), c_expr);
    elsif category(params[1]) = BIGINTOBJECT and not isVar(params[1]) then
      process_const_big_cmp(getValue(params[1], bigInteger), params[3], c_expr);
    else
      c_expr.expr &:= "bigCmp(";
      getAnyParamToExpr(params[1], c_expr);
      c_expr.expr &:= ", ";
      getAnyParamToExpr(params[3], c_expr);
      c_expr.expr &:= ")";
    end if;
    c_expr.expr &:= " > 0";
  end func;


const proc: process_big_hashcode (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "bigHashCode(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_big_iconv (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_bigint_result(c_expr);
    c_expr.result_expr := "bigIConv(";
    getStdParamToResultExpr(params[3], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_big_incr (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "bigIncr(&(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= "));\n";
  end func;


const proc: process_const_big_ipow (in reference: param1, in integer: exponent,
    inout expr_type: c_expr) is func

  local
    var bigInteger: bigNumber is 0_;
    var integer: temp_num is 0;
  begin
    if exponent < 0 then
      incr(countOptimizations);
      c_expr.expr &:= "(biginttype)(raise_error(NUMERIC_ERROR),NULL)";
    elsif category(param1) = BIGINTOBJECT and not isVar(param1) then
      incr(countOptimizations);
      bigNumber := getValue(param1, bigInteger) ** exponent;
      if bigNumber not in bigint_const_table then
        bigint_const_table @:= [bigNumber] length(bigint_const_table);
      end if;
      c_expr.expr &:= "big[";
      c_expr.expr &:= str(bigint_const_table[bigNumber]);
      c_expr.expr &:= "] /* ";
      c_expr.expr &:= str(bigNumber);
      c_expr.expr &:= " */";
    elsif exponent = 0 then
      incr(countOptimizations);
      if 1_ not in bigint_const_table then
        bigint_const_table @:= [1_] length(bigint_const_table);
      end if;
      c_expr.expr &:= "big[";
      c_expr.expr &:= str(bigint_const_table[1_]);
      c_expr.expr &:= "] /* ";
      c_expr.expr &:= str(1_);
      c_expr.expr &:= " */";
    elsif exponent = 1 then
      incr(countOptimizations);
      process_expr(param1, c_expr);
    elsif exponent = 2 then
      incr(countOptimizations);
      incr(c_expr.temp_num);
      temp_num := c_expr.temp_num;
      c_expr.temp_decls &:= "biginttype tmp_";
      c_expr.temp_decls &:= str(temp_num);
      c_expr.temp_decls &:= ";\n";
      prepare_bigint_result(c_expr);
      c_expr.result_expr := "(tmp_";
      c_expr.result_expr &:= str(temp_num);
      c_expr.result_expr &:= "=(";
      getAnyParamToResultExpr(param1, c_expr);
      c_expr.result_expr &:= "),";
      c_expr.result_expr &:= "bigMult(tmp_";
      c_expr.result_expr &:= str(temp_num);
      c_expr.result_expr &:= ",tmp_";
      c_expr.result_expr &:= str(temp_num);
      c_expr.result_expr &:= "))";
    else
      prepare_bigint_result(c_expr);
      c_expr.result_expr := "bigIPow(";
      getAnyParamToResultExpr(param1, c_expr);
      c_expr.result_expr &:= ", ";
      c_expr.result_expr &:= str(exponent);
      c_expr.result_expr &:= ")";
    end if;
  end func;


const proc: process_const_big_ipow (in bigInteger: base, in reference: param3,
    inout expr_type: c_expr) is func

  local
    var integer: temp_num is 0;
    var integer: log2base is 0;
  begin
    if base = -1_ then
      incr(c_expr.temp_num);
      if 1_ not in bigint_const_table then
        bigint_const_table @:= [1_] length(bigint_const_table);
      end if;
      if -1_ not in bigint_const_table then
        bigint_const_table @:= [-1_] length(bigint_const_table);
      end if;
      temp_num := c_expr.temp_num;
      c_expr.temp_decls &:= "inttype tmp_";
      c_expr.temp_decls &:= str(temp_num);
      c_expr.temp_decls &:= ";\n";
      c_expr.expr := "(tmp_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "=(";
      process_expr(param3, c_expr);
      c_expr.expr &:= "),tmp_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "<0?(biginttype)(raise_error(NUMERIC_ERROR),NULL):((tmp_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= ")&1?big[";
      c_expr.expr &:= str(bigint_const_table[-1_]);
      c_expr.expr &:= "] /* -1 */:big[";
      c_expr.expr &:= str(bigint_const_table[1_]);
      c_expr.expr &:= "] /* 1 */))";
    elsif base = 1_ then
      incr(countOptimizations);
      c_expr.expr &:= "((";
      process_expr(param3, c_expr);
      c_expr.expr &:= ")<0?(biginttype)(raise_error(NUMERIC_ERROR),NULL):";
      if 1_ not in bigint_const_table then
        bigint_const_table @:= [1_] length(bigint_const_table);
      end if;
      c_expr.expr &:= "big[";
      c_expr.expr &:= str(bigint_const_table[1_]);
      c_expr.expr &:= "] /* 1 */)";
    elsif base = 2_ then
      incr(countOptimizations);
      if 1_ not in bigint_const_table then
        bigint_const_table @:= [1_] length(bigint_const_table);
      end if;
      prepare_bigint_result(c_expr);
      c_expr.result_expr := "bigLShift(big[";
      c_expr.result_expr &:= str(bigint_const_table[1_]);
      c_expr.result_expr &:= "] /* 1 */, ";
      getStdParamToResultExpr(param3, c_expr);
      c_expr.result_expr &:= ")";
    elsif base > 0_ and log2(base) <= 2147483647_ and
        2_ ** ord(log2(base)) = base then
      incr(countOptimizations);
      log2base := ord(log2(base));
      if 1_ not in bigint_const_table then
        bigint_const_table @:= [1_] length(bigint_const_table);
      end if;
      if base not in bigint_const_table then
        bigint_const_table @:= [base] length(bigint_const_table);
      end if;
      incr(c_expr.temp_num);
      temp_num := c_expr.temp_num;
      c_expr.temp_decls &:= "inttype tmp_";
      c_expr.temp_decls &:= str(temp_num);
      c_expr.temp_decls &:= ";\n";
      prepare_bigint_result(c_expr);
      c_expr.result_expr := "(tmp_";
      c_expr.result_expr &:= str(temp_num);
      c_expr.result_expr &:= "=(";
      getAnyParamToResultExpr(param3, c_expr);
      c_expr.result_expr &:= "),tmp_";
      c_expr.result_expr &:= str(temp_num);
      c_expr.result_expr &:= "<";
      c_expr.result_expr &:= str(2147483647 div log2base);
      c_expr.result_expr &:= "?bigLShift(big[";
      c_expr.result_expr &:= str(bigint_const_table[1_]);
      c_expr.result_expr &:= "] /* 1 */, ";
      c_expr.result_expr &:= str(log2base);
      c_expr.result_expr &:= "*tmp_";
      c_expr.result_expr &:= str(temp_num);
      c_expr.result_expr &:= "):bigIPow(big[";
      c_expr.result_expr &:= str(bigint_const_table[base]);
      c_expr.result_expr &:= "] /* ";
      c_expr.result_expr &:= str(base);
      c_expr.result_expr &:= " */, tmp_";
      c_expr.result_expr &:= str(temp_num);
      c_expr.result_expr &:= "))";
    else
      if base not in bigint_const_table then
        bigint_const_table @:= [base] length(bigint_const_table);
      end if;
      prepare_bigint_result(c_expr);
      c_expr.result_expr := "bigIPow(big[";
      c_expr.result_expr &:= str(bigint_const_table[base]);
      c_expr.result_expr &:= "] /* ";
      c_expr.result_expr &:= str(base);
      c_expr.result_expr &:= " */, ";
      getStdParamToResultExpr(param3, c_expr);
      c_expr.result_expr &:= ")";
    end if
  end func;


const proc: process_big_ipow (in ref_list: params, inout expr_type: c_expr) is func

  local
    var reference: evaluatedParam1 is NIL;
  begin
    if category(params[3]) = INTOBJECT and not isVar(params[3]) then
      process_const_big_ipow(params[1], getValue(params[3], integer), c_expr);
    elsif category(params[1]) = BIGINTOBJECT and not isVar(params[1]) then
      process_const_big_ipow(getValue(params[1], bigInteger), params[3], c_expr);
    elsif isConstant(params[1]) then
      evaluatedParam1 := evaluate(prog, params[1]);
      if category(evaluatedParam1) = BIGINTOBJECT then
        process_const_big_ipow(getValue(evaluatedParam1, bigInteger), params[3], c_expr);
      else
        c_expr.expr &:= "/* bigIPow ";
        c_expr.expr &:= str(category(evaluatedParam1));
        c_expr.expr &:= " */";
      end if;
    else
      prepare_bigint_result(c_expr);
      c_expr.result_expr := "bigIPow(";
      getAnyParamToResultExpr(params[1], c_expr);
      c_expr.result_expr &:= ", ";
      getStdParamToResultExpr(params[3], c_expr);
      c_expr.result_expr &:= ")";
    end if;
  end func;


const proc: process_big_le (in ref_list: params, inout expr_type: c_expr) is func

  begin
    if category(params[3]) = BIGINTOBJECT and not isVar(params[3]) then
      process_const_big_cmp(params[1], getValue(params[3], bigInteger), c_expr);
    elsif category(params[1]) = BIGINTOBJECT and not isVar(params[1]) then
      process_const_big_cmp(getValue(params[1], bigInteger), params[3], c_expr);
    else
      c_expr.expr &:= "bigCmp(";
      getAnyParamToExpr(params[1], c_expr);
      c_expr.expr &:= ", ";
      getAnyParamToExpr(params[3], c_expr);
      c_expr.expr &:= ")";
    end if;
    c_expr.expr &:= " <= 0";
  end func;


const proc: process_big_log2 (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "bigLog2(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_big_lowest_set_bit (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "bigLowestSetBit(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_big_lshift (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_bigint_result(c_expr);
    c_expr.result_expr := "bigLShift(";
    getAnyParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    getStdParamToResultExpr(params[3], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_big_lshift_assign (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if has_temp_values(c_param3) then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    c_expr.expr &:= "bigLShiftAssign(&(";
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "), ";
    if c_param3.result_expr <> "" then
      c_expr.expr &:= c_param3.result_expr;
    else
      c_expr.expr &:= c_param3.expr;
    end if;
    c_expr.expr &:= ");\n";
    if has_temp_values(c_param3) then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_big_lt (in ref_list: params, inout expr_type: c_expr) is func

  begin
    if category(params[3]) = BIGINTOBJECT and not isVar(params[3]) then
      process_const_big_cmp(params[1], getValue(params[3], bigInteger), c_expr);
    elsif category(params[1]) = BIGINTOBJECT and not isVar(params[1]) then
      process_const_big_cmp(getValue(params[1], bigInteger), params[3], c_expr);
    else
      c_expr.expr &:= "bigCmp(";
      getAnyParamToExpr(params[1], c_expr);
      c_expr.expr &:= ", ";
      getAnyParamToExpr(params[3], c_expr);
      c_expr.expr &:= ")";
    end if;
    c_expr.expr &:= " < 0";
  end func;


const proc: process_const_big_mdiv (in reference: param1, in bigInteger: divisor,
    inout expr_type: c_expr) is func

  local
    var bigInteger: bigNumber is 0_;
    var integer: temp_num is 0;
  begin
    incr(countOptimizations);
    if divisor = 0_ then
      c_expr.expr &:= "(biginttype)(raise_error(NUMERIC_ERROR),NULL)";
    elsif category(param1) = BIGINTOBJECT and not isVar(param1) then
      bigNumber := getValue(param1, bigInteger) mdiv divisor;
      if bigNumber not in bigint_const_table then
        bigint_const_table @:= [bigNumber] length(bigint_const_table);
      end if;
      c_expr.expr &:= "big[";
      c_expr.expr &:= str(bigint_const_table[bigNumber]);
      c_expr.expr &:= "] /* ";
      c_expr.expr &:= str(bigNumber);
      c_expr.expr &:= " */";
    elsif divisor = 1_ then
      c_expr.expr &:= "(";
      process_expr(param1, c_expr);
      c_expr.expr &:= ")";
    elsif divisor = -1_ then
      prepare_bigint_result(c_expr);
      c_expr.result_expr := "bigMinus(";
      getAnyParamToResultExpr(param1, c_expr);
      c_expr.result_expr &:= ")";
    elsif divisor > 0_ and log2(divisor) <= 2147483647_ and
        2_ ** ord(log2(divisor)) = divisor then
      prepare_bigint_result(c_expr);
      c_expr.result_expr := "bigRShift(";
      getAnyParamToResultExpr(param1, c_expr);
      c_expr.result_expr &:= ", ";
      c_expr.result_expr &:= str(log2(divisor));
      c_expr.result_expr &:= INTTYPE_LITERAL_SUFFIX;
      c_expr.result_expr &:= ")";
    else
      prepare_bigint_result(c_expr);
      c_expr.result_expr := "bigMDiv(";
      getAnyParamToResultExpr(param1, c_expr);
      c_expr.result_expr &:= ", ";
      if divisor not in bigint_const_table then
        bigint_const_table @:= [divisor] length(bigint_const_table);
      end if;
      c_expr.result_expr &:= "big[";
      c_expr.result_expr &:= str(bigint_const_table[divisor]);
      c_expr.result_expr &:= "] /* ";
      c_expr.result_expr &:= str(divisor);
      c_expr.result_expr &:= " */";
      c_expr.result_expr &:= ")";
    end if;
  end func;


const proc: process_big_mdiv (in ref_list: params, inout expr_type: c_expr) is func

  begin
    if category(params[3]) = BIGINTOBJECT and not isVar(params[3]) then
      process_const_big_mdiv(params[1], getValue(params[3], bigInteger), c_expr);
    else
      prepare_bigint_result(c_expr);
      c_expr.result_expr := "bigMDiv(";
      getAnyParamToResultExpr(params[1], c_expr);
      c_expr.result_expr &:= ", ";
      getAnyParamToResultExpr(params[3], c_expr);
      c_expr.result_expr &:= ")";
    end if;
  end func;


const proc: process_big_minus (in ref_list: params, inout expr_type: c_expr) is func

  local
    var bigInteger: bigNumber is 0_;
  begin
    if category(params[2]) = BIGINTOBJECT and not isVar(params[2]) then
      incr(countOptimizations);
      bigNumber := -getValue(params[2], bigInteger);
      if bigNumber not in bigint_const_table then
        bigint_const_table @:= [bigNumber] length(bigint_const_table);
      end if;
      c_expr.expr &:= "big[";
      c_expr.expr &:= str(bigint_const_table[bigNumber]);
      c_expr.expr &:= "] /* ";
      c_expr.expr &:= str(bigNumber);
      c_expr.expr &:= " */";
    else
      prepare_bigint_result(c_expr);
      c_expr.result_expr := "bigMinus(";
      getAnyParamToResultExpr(params[2], c_expr);
      c_expr.result_expr &:= ")";
    end if;
  end func;


const proc: process_big_mod (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_bigint_result(c_expr);
    c_expr.result_expr := "bigMod(";
    getAnyParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    getAnyParamToResultExpr(params[3], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_const_big_mult (in reference: param1, in bigInteger: number,
    inout expr_type: c_expr) is func

  local
    var bigInteger: bigNumber is 0_;
    var integer: log2base is 0;
  begin
    if category(param1) = BIGINTOBJECT and not isVar(param1) then
      incr(countOptimizations);
      bigNumber := getValue(param1, bigInteger) * number;
      if bigNumber not in bigint_const_table then
        bigint_const_table @:= [bigNumber] length(bigint_const_table);
      end if;
      c_expr.expr &:= "big[";
      c_expr.expr &:= str(bigint_const_table[bigNumber]);
      c_expr.expr &:= "] /* ";
      c_expr.expr &:= str(bigNumber);
      c_expr.expr &:= " */";
    elsif number = 0_ then
      incr(countOptimizations);
      if 0_ not in bigint_const_table then
        bigint_const_table @:= [0_] length(bigint_const_table);
      end if;
      c_expr.expr &:= "big[";
      c_expr.expr &:= str(bigint_const_table[0_]);
      c_expr.expr &:= "] /* ";
      c_expr.expr &:= str(0_);
      c_expr.expr &:= " */";
    elsif number = 1_ then
      incr(countOptimizations);
      process_expr(param1, c_expr);
    elsif number > 1_ and log2(number) <= 2147483647_ and
        2_ ** ord(log2(number)) = number then
      incr(countOptimizations);
      log2base := ord(log2(number));
      prepare_bigint_result(c_expr);
      c_expr.result_expr := "bigLShift(";
      getAnyParamToResultExpr(param1, c_expr);
      c_expr.result_expr &:= ", ";
      c_expr.result_expr &:= str(log2base);
      c_expr.result_expr &:= INTTYPE_LITERAL_SUFFIX;
      c_expr.result_expr &:= ")";
    else
      if number not in bigint_const_table then
        bigint_const_table @:= [number] length(bigint_const_table);
      end if;
      prepare_bigint_result(c_expr);
      c_expr.result_expr := "bigMult(";
      getAnyParamToResultExpr(param1, c_expr);
      c_expr.result_expr &:= ", big[";
      c_expr.result_expr &:= str(bigint_const_table[number]);
      c_expr.result_expr &:= "] /* ";
      c_expr.result_expr &:= str(number);
      c_expr.result_expr &:= " */)";
    end if;
  end func;


const proc: process_big_mult (in ref_list: params, inout expr_type: c_expr) is func

  begin
    if category(params[3]) = BIGINTOBJECT and not isVar(params[3]) then
      process_const_big_mult(params[1], getValue(params[3], bigInteger), c_expr);
    elsif category(params[1]) = BIGINTOBJECT and not isVar(params[1]) then
      process_const_big_mult(params[3], getValue(params[1], bigInteger), c_expr);
    else
      prepare_bigint_result(c_expr);
      c_expr.result_expr := "bigMult(";
      getAnyParamToResultExpr(params[1], c_expr);
      c_expr.result_expr &:= ", ";
      getAnyParamToResultExpr(params[3], c_expr);
      c_expr.result_expr &:= ")";
    end if;
  end func;


const proc: process_big_mult_assign (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if has_temp_values(c_param3) or c_param3.result_expr <> "" then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param3.result_decl;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    c_expr.expr &:= "bigMultAssign(&(";
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "), ";
    if c_param3.result_expr <> "" then
      c_expr.expr &:= c_param3.result_intro;
      c_expr.expr &:= c_param3.result_expr;
      c_expr.expr &:= c_param3.result_finish;
    else
      c_expr.expr &:= c_param3.expr;
    end if;
    c_expr.expr &:= ");\n";
    if has_temp_values(c_param3) or c_param3.result_expr <> "" then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= c_param3.result_free;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_big_ne (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "bigNe(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ", ";
    getAnyParamToExpr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_big_odd (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "bigOdd(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_big_ord (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "bigOrd(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_big_parse (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_bigint_result(c_expr);
    c_expr.result_expr := "bigParse(";
    getAnyParamToResultExpr(params[3], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_big_plus (in ref_list: params, inout expr_type: c_expr) is func

  begin
    process_expr(params[2], c_expr);
  end func;


const proc: process_big_pred (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
  begin
    prepare_bigint_result(c_expr);
    prepareAnyParamTemporarys(params[1], c_param1, c_expr);
    if c_param1.result_expr <> "" then
      c_expr.result_expr := "bigPredTemp(";
      c_expr.result_expr &:= c_param1.result_expr;
    else
      c_expr.result_expr := "bigPred(";
      c_expr.result_expr &:= c_param1.expr;
    end if;
    c_expr.result_expr &:= ")";
  end func;


const proc: process_big_rand (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_bigint_result(c_expr);
    c_expr.result_expr := "bigRand(";
    getAnyParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    getAnyParamToResultExpr(params[2], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_big_rem (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_bigint_result(c_expr);
    c_expr.result_expr := "bigRem(";
    getAnyParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    getAnyParamToResultExpr(params[3], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_big_rshift (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_bigint_result(c_expr);
    c_expr.result_expr := "bigRShift(";
    getAnyParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    getStdParamToResultExpr(params[3], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_big_rshift_assign (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if has_temp_values(c_param3) then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    c_expr.expr &:= "bigRShiftAssign(&(";
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "), ";
    if c_param3.result_expr <> "" then
      c_expr.expr &:= c_param3.result_expr;
    else
      c_expr.expr &:= c_param3.expr;
    end if;
    c_expr.expr &:= ");\n";
    if has_temp_values(c_param3) then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


(**
 *  Produces code for the big integer subtraction.
 *  When the first parameter is a temporary value the subtraction
 *  is done with bigSbtrTemp. The bigSbtrTemp function returns
 *  the first parameter as result of the subtraction. That way the
 *  temporary of the first parameter must not be freed.
 *)
const proc: process_big_sbtr (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
  begin
    prepare_bigint_result(c_expr);
    prepareAnyParamTemporarys(params[1], c_param1, c_expr);
    if c_param1.result_expr <> "" then
      c_expr.result_expr := "bigSbtrTemp(";
      c_expr.result_expr &:= c_param1.result_expr;
    else
      c_expr.result_expr := "bigSbtr(";
      c_expr.result_expr &:= c_param1.expr;
    end if;
    c_expr.result_expr &:= ", ";
    getAnyParamToResultExpr(params[3], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_big_shrink (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if has_temp_values(c_param3) or c_param3.result_expr <> "" then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param3.result_decl;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    c_expr.expr &:= "bigShrink(&(";
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "), ";
    if c_param3.result_expr <> "" then
      c_expr.expr &:= c_param3.result_intro;
      c_expr.expr &:= c_param3.result_expr;
      c_expr.expr &:= c_param3.result_finish;
    else
      c_expr.expr &:= c_param3.expr;
    end if;
    c_expr.expr &:= ");\n";
    if has_temp_values(c_param3) or c_param3.result_expr <> "" then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= c_param3.result_free;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_big_str (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "bigStr(";
    getAnyParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_big_succ (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
  begin
    prepare_bigint_result(c_expr);
    prepareAnyParamTemporarys(params[1], c_param1, c_expr);
    if c_param1.result_expr <> "" then
      c_expr.result_expr := "bigSuccTemp(";
      c_expr.result_expr &:= c_param1.result_expr;
    else
      c_expr.result_expr := "bigSucc(";
      c_expr.result_expr &:= c_param1.expr;
    end if;
    c_expr.result_expr &:= ")";
  end func;


const proc: process_big_value (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_bigint_result(c_expr);
    c_expr.result_expr &:= "bigValue(";
    getStdParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_bln_and (in ref_list: params, inout expr_type: c_expr) is func

  begin
    if isActionExpression(params[1], "BLN_AND") then
      process_expr(params[1], c_expr);
    else
      c_expr.expr &:= "(";
      process_expr(params[1], c_expr);
      c_expr.expr &:= ")";
    end if;
    c_expr.expr &:= " &&\n(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_bln_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "=(";
    if c_param3.result_expr <> "" then
      c_expr.expr &:= c_param3.result_expr;
    else
      c_expr.expr &:= c_param3.expr;
    end if;
    c_expr.expr &:= ");\n";
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_bln_eq (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") == (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_bln_ge (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") >= (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_bln_gt (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") > (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_bln_iconv (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ") & 1";
  end func;


const proc: process_bln_le (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") <= (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_bln_lt (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") < (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_bln_ne (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") != (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_bln_not (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "!(";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_bln_or (in ref_list: params, inout expr_type: c_expr) is func

  begin
    if isActionExpression(params[1], "BLN_OR") then
      process_expr(params[1], c_expr);
    else
      c_expr.expr &:= "(";
      process_expr(params[1], c_expr);
      c_expr.expr &:= ")";
    end if;
    c_expr.expr &:= " ||\n(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_bln_ord (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(inttype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_bst_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if has_temp_values(c_param3) then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    if c_param3.result_expr <> "" then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= "bstritype *bstri_ptr=&(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= ");\n";
      c_expr.expr &:= "bstritype old_bstri=*bstri_ptr;\n";
      c_expr.expr &:= "*bstri_ptr=";
      c_expr.expr &:= c_param3.result_expr;
      c_expr.expr &:= ";\n";
      c_expr.expr &:= "bstDestr(old_bstri);\n";
      c_expr.expr &:= "}\n";
    else
      c_expr.expr &:= "bstCpy(&(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "), ";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= ");\n";
    end if;
    if has_temp_values(c_param3) then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_const_chr_chr (in reference: function, in integer: number, inout expr_type: c_expr) is func

  local
    var integer: temp_num is 0;
  begin
    incr(countOptimizations);
    if number < pred(-2147483647) or number > 2147483647 then
      process_raise_error("RANGE_ERROR", function, c_expr);
    else
      c_expr.expr &:= "(chartype)";
      c_expr.expr &:= str(number);
    end if;
  end func;


const proc: process_chr_chr (in reference: function, in ref_list: params, inout expr_type: c_expr) is func

  local
    var integer: temp_num is 0;
  begin
    if category(params[1]) = INTOBJECT and not isVar(params[1]) then
      process_const_chr_chr(function, getValue(params[1], integer), c_expr);
    elsif INTTYPE_64BIT then
      incr(c_expr.temp_num);
      temp_num := c_expr.temp_num;
      c_expr.temp_decls &:= "inttype tmp_";
      c_expr.temp_decls &:= str(temp_num);
      c_expr.temp_decls &:= ";\n";
      c_expr.expr &:= "(tmp_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "=(";
      process_expr(params[1], c_expr);
      c_expr.expr &:= "),tmp_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "< -2147483648||tmp_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= ">2147483647?";
      process_raise_error("RANGE_ERROR", function, c_expr);
      c_expr.expr &:= ":(chartype)tmp_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= ")";
    else
      c_expr.expr &:= "(chartype)(";
      process_expr(params[1], c_expr);
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process_chr_conv (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_chr_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "=(";
    if c_param3.result_expr <> "" then
      c_expr.expr &:= c_param3.result_expr;
    else
      c_expr.expr &:= c_param3.expr;
    end if;
    c_expr.expr &:= ");\n";
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_chr_decr (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "--(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_chr_eq (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") == (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_chr_ge (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "((chartype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")) >= ((chartype)(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_chr_grow (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "+=(";
    c_expr.expr &:= c_param3.expr;
    c_expr.expr &:= ");\n";
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_chr_gt (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "((chartype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")) > ((chartype)(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_chr_hashcode (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(inttype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_chr_iconv (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(chartype)(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_chr_incr (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "++(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_chr_le (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "((chartype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")) <= ((chartype)(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_chr_low (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "chrLow(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_chr_lt (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "((chartype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")) < ((chartype)(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_chr_ne (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") != (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_chr_ord (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(inttype)((schartype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_chr_pred (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")-1";
  end func;


const proc: process_chr_shrink (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "-=(";
    c_expr.expr &:= c_param3.expr;
    c_expr.expr &:= ");\n";
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_chr_str (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "chrStr(";
    getStdParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_chr_succ (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")+1";
  end func;


const proc: process_chr_up (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "chrUp(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_chr_value (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "chrValue(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_cmd_big_filesize (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_bigint_result(c_expr);
    c_expr.result_expr := "cmdBigFileSize(";
    getAnyParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_cmd_chdir (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "cmdChdir(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_cmd_config_value (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "cmdConfigValue(";
    getAnyParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_cmd_clone_file (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "cmdCloneFile(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ", ";
    getAnyParamToExpr(params[2], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_cmd_copy_file (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "cmdCopyFile(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ", ";
    getAnyParamToExpr(params[2], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_cmd_filesize (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "cmdFileSize(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_cmd_filetype (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "cmdFileType(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_cmd_getcwd (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "cmdGetcwd()";
  end func;


const proc: process_cmd_get_atime (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "cmdGetATime(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ", &(";
    process_expr(params[2], c_expr);
    c_expr.expr &:= "), &(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= "), &(";
    process_expr(params[4], c_expr);
    c_expr.expr &:= "), &(";
    process_expr(params[5], c_expr);
    c_expr.expr &:= "), &(";
    process_expr(params[6], c_expr);
    c_expr.expr &:= "), &(";
    process_expr(params[7], c_expr);
    c_expr.expr &:= "), &(";
    process_expr(params[8], c_expr);
    c_expr.expr &:= "), &(";
    process_expr(params[9], c_expr);
    c_expr.expr &:= "), &(";
    process_expr(params[10], c_expr);
    c_expr.expr &:= "));\n";
  end func;


const proc: process_cmd_get_mtime (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "cmdGetMTime(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ", &(";
    process_expr(params[2], c_expr);
    c_expr.expr &:= "), &(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= "), &(";
    process_expr(params[4], c_expr);
    c_expr.expr &:= "), &(";
    process_expr(params[5], c_expr);
    c_expr.expr &:= "), &(";
    process_expr(params[6], c_expr);
    c_expr.expr &:= "), &(";
    process_expr(params[7], c_expr);
    c_expr.expr &:= "), &(";
    process_expr(params[8], c_expr);
    c_expr.expr &:= "), &(";
    process_expr(params[9], c_expr);
    c_expr.expr &:= "), &(";
    process_expr(params[10], c_expr);
    c_expr.expr &:= "));\n";
  end func;


const proc: process_cmd_ls (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_array_result(array_type[getExprResultType(params[1])], c_expr);
    c_expr.result_expr := "cmdLs(";
    getAnyParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_cmd_mkdir (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "cmdMkdir(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_cmd_move (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "cmdMove(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ", ";
    getAnyParamToExpr(params[2], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_cmd_readlink (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr := "cmdReadlink(";
    getAnyParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_cmd_remove (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "cmdRemove(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_cmd_remove_any_file (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "cmdRemoveAnyFile(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_cmd_set_atime (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "cmdSetATime(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[6], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[7], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[8], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[9], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_cmd_set_mtime (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "cmdSetMTime(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[6], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[7], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[8], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[9], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_cmd_shell (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "cmdShell(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_drw_arc (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwArc(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[6], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_drw_arc2 (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwArc2(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[6], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_drw_background (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwBackground(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_drw_circle (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwCircle(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_drw_clear (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwClear(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_drw_color (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwColor(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_drw_copyarea (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwCopyArea(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ", ";
    getAnyParamToExpr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[6], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[7], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[8], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_drw_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if has_temp_values(c_param3) then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    if c_param3.result_expr <> "" then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= "wintype *win_ptr=&(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= ");\n";
      c_expr.expr &:= "wintype old_win=*win_ptr;\n";
      c_expr.expr &:= "*win_ptr=";
      c_expr.expr &:= c_param3.result_expr;
      c_expr.expr &:= ";\n";
      c_expr.expr &:= "drwDestr(old_win);\n";
      c_expr.expr &:= "}\n";
    else
      c_expr.expr &:= "drwCpy(&(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "), ";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= ");\n";
    end if;
    if has_temp_values(c_param3) then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_drw_eq (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ") == (";
    getAnyParamToExpr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_drw_farcchord (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwFArcChord(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[6], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_drw_farcpieslice(in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwFArcPieSlice(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[6], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_drw_fcircle (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwFCircle(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_drw_fellipse (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwFEllipse(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_drw_flush (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwFlush();\n";
  end func;


const proc: process_drw_fpolyline (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwFPolyLine(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    getAnyParamToExpr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_drw_genpointlist (in ref_list: params, inout expr_type: c_expr) is func

  local
    var integer: temp_num is 0;
  begin
    prepare_bstri_result(c_expr);
    incr(c_expr.temp_num);
    temp_num := c_expr.temp_num;
    c_expr.temp_decls &:= "arraytype tmp_";
    c_expr.temp_decls &:= str(temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.result_expr &:= "(tmp_";
    c_expr.result_expr &:= str(temp_num);
    c_expr.result_expr &:= "=(arraytype)(";
    getAnyParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= "), drwGenPointList(";
    c_expr.result_expr &:= "tmp_";
    c_expr.result_expr &:= str(temp_num);
    c_expr.result_expr &:= "->arr, tmp_";
    c_expr.result_expr &:= str(temp_num);
    c_expr.result_expr &:= "->max_position - tmp_";
    c_expr.result_expr &:= str(temp_num);
    c_expr.result_expr &:= "->min_position + 1))";
  end func;


const proc: process_drw_get (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_win_result(c_expr);
    c_expr.result_expr &:= "drwGet(";
    getAnyParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    getStdParamToResultExpr(params[2], c_expr);
    c_expr.result_expr &:= ", ";
    getStdParamToResultExpr(params[3], c_expr);
    c_expr.result_expr &:= ", ";
    getStdParamToResultExpr(params[4], c_expr);
    c_expr.result_expr &:= ", ";
    getStdParamToResultExpr(params[5], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_drw_height (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwHeight(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_drw_image (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_win_result(c_expr);
    c_expr.result_expr &:= "drwImage(";
    getAnyParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ", (inttype *)(";
    getStdParamToResultExpr(params[2], c_expr);
    c_expr.result_expr &:= "), 0, 0"; (* This is just a hack: This function will not work *)
    c_expr.result_expr &:= ")";
  end func;


const proc: process_drw_line (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwLine(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_drw_ne (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ") != (";
    getAnyParamToExpr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_drw_new_pixmap (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_win_result(c_expr);
    c_expr.result_expr &:= "drwNewPixmap(";
    getAnyParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    getStdParamToResultExpr(params[2], c_expr);
    c_expr.result_expr &:= ", ";
    getStdParamToResultExpr(params[3], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_drw_open (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_win_result(c_expr);
    c_expr.result_expr &:= "drwOpen(";
    getStdParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    getStdParamToResultExpr(params[2], c_expr);
    c_expr.result_expr &:= ", ";
    getStdParamToResultExpr(params[3], c_expr);
    c_expr.result_expr &:= ", ";
    getStdParamToResultExpr(params[4], c_expr);
    c_expr.result_expr &:= ", ";
    getStdParamToResultExpr(params[5], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_drw_parc (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwPArc(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[6], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[7], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_drw_pcircle (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwPCircle(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_drw_pfarcchord (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwPFArcChord(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[6], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[7], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_drw_pfarcpieslice (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwFArcPieSlice(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[6], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_drw_pfcircle (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwPFCircle(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_drw_pfellipse (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwPFEllipse(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[6], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_drw_pline (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwPLine(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[6], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_drw_point (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwPoint(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_drw_polyline (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwPolyLine(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    getAnyParamToExpr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_drw_ppoint (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwPPoint(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_drw_prect (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwPRect(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[6], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_drw_put (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwPut(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_drw_rect (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwRect(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_drw_rgbcol (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwRgbColor(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_drw_setTransparentColor (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwSetTransparentColor(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_drw_text (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwText(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    getAnyParamToExpr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[6], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_drw_width (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwWidth(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_enu_conv (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_enu_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "=(";
    if c_param3.result_expr <> "" then
      c_expr.expr &:= c_param3.result_expr;
    else
      c_expr.expr &:= c_param3.expr;
    end if;
    c_expr.expr &:= ");\n";
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_enu_eq (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") == (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_enu_iconv2 (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_enu_ne (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") != (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_enu_ord2 (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_enu_value (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "enuValue(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_fil_big_lng (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_bigint_result(c_expr);
    c_expr.result_expr &:= "filBigLng((filetype)(";
    getStdParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= "))";
  end func;


const proc: process_fil_big_seek (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "filBigSeek((filetype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "), ";
    getAnyParamToExpr(params[2], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_fil_big_tell (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_bigint_result(c_expr);
    c_expr.result_expr &:= "filBigTell((filetype)(";
    getStdParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= "))";
  end func;


const proc: process_fil_close (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "fclose((filetype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "));\n";
  end func;


const proc: process_fil_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "=(";
    if c_param3.result_expr <> "" then
      c_expr.expr &:= c_param3.result_expr;
    else
      c_expr.expr &:= c_param3.expr;
    end if;
    c_expr.expr &:= ");\n";
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_fil_eof (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "feof((filetype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_fil_eq (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "((filetype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")) == ((filetype)(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_fil_err (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "stderr";
  end func;


const proc: process_fil_flush (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "fflush((filetype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "));\n";
  end func;


const proc: process_fil_getc (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "fgetc((filetype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_fil_gets (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "filGets((filetype)(";
    getStdParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= "), ";
    getStdParamToResultExpr(params[2], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_fil_has_next (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "filHasNext((filetype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_fil_in (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "stdin";
  end func;


const proc: process_fil_line_read (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "filLineRead((filetype)(";
    getStdParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= "), &(";
    getStdParamToResultExpr(params[2], c_expr);
    c_expr.result_expr &:= "))";
  end func;


const proc: process_fil_lit (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "filLit(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_fil_lng (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "filLng((filetype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_fil_ne (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "((filetype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")) != ((filetype)(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_fil_nil (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "NULL";
  end func;


const proc: process_fil_open (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "filOpen(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_fil_out (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "stdout";
  end func;


const proc: process_fil_popen (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "filPopen(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_fil_print (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "filPrint(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_fil_seek (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "filSeek((filetype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "), ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_fil_setbuf (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "filSetbuf((filetype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "), ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_fil_tell (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "filTell((filetype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_fil_value (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "filValue(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_fil_write (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "filWrite((filetype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "), ";
    getAnyParamToExpr(params[2], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_fil_word_read (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "filWordRead((filetype)(";
    getStdParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= "), &(";
    getStdParamToResultExpr(params[2], c_expr);
    c_expr.result_expr &:= "))";
  end func;


const proc: process_flt_a2tan (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "atan2(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_abs (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "fabs(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_acos (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "acos(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_add (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") + (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_asin (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "asin(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_atan (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "atan(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_cast (in ref_list: params, inout expr_type: c_expr) is func

  local
    var integer: temp_num is 0;
  begin
    incr(c_expr.temp_num);
    temp_num := c_expr.temp_num;
    c_expr.temp_decls &:= "float2int tmp_";
    c_expr.temp_decls &:= str(temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.expr &:= "(tmp_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= ".floatvalue=(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= "),tmp_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= ".intvalue)";
  end func;


const proc: process_flt_ceil (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "ceil(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_cmp (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "fltCmp(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ", ";
    getAnyParamToExpr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_cos (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "cos(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_cosh (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "cosh(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "=(";
    if c_param3.result_expr <> "" then
      c_expr.expr &:= c_param3.result_expr;
    else
      c_expr.expr &:= c_param3.expr;
    end if;
    c_expr.expr &:= ");\n";
(*
    c_expr.expr &:= "*((float * ) &(" & c_param1.expr;
    c_expr.expr &:= "))=(";
    c_expr.expr &:= c_param3.expr;
    c_expr.expr &:= ");\n";

    c_expr.expr &:= "memcpy(&(";
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "), &(";
    c_expr.expr &:= c_param3.expr;
    c_expr.expr &:= "), sizeof(float));\n";  # Assuming that sizeof(float) == sizeof(long)
*)
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_flt_dgts (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "fltDgts(";
    getStdParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    getStdParamToResultExpr(params[3], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_const_flt_div (in reference: param1, in float: divisor,
    inout expr_type: c_expr) is func

  local
    var float: dividend is 0.0;
    var integer: temp_num is 0;
  begin
    incr(countOptimizations);
    if divisor = 0.0 and FLOAT_ZERO_DIV_ERROR then
      if category(param1) = FLOATOBJECT and not isVar(param1) then
        dividend := getValue(param1, float);
        if dividend < 0.0 then
          c_expr.expr &:= "f_const[2].floatvalue /* -1.0/0.0 */";
        elsif dividend > 0.0 then
          c_expr.expr &:= "f_const[1].floatvalue /* 1.0/0.0 */";
        else
          c_expr.expr &:= "f_const[0].floatvalue /* 0.0/0.0 */";
        end if;
      else
        incr(c_expr.temp_num);
        temp_num := c_expr.temp_num;
        c_expr.temp_decls &:= "floattype tmp_";
        c_expr.temp_decls &:= str(temp_num);
        c_expr.temp_decls &:= ";\n";
        c_expr.expr &:= "(tmp_";
        c_expr.expr &:= str(temp_num);
        c_expr.expr &:= "=";
        process_expr(param1, c_expr);
        c_expr.expr &:= ",tmp_";
        c_expr.expr &:= str(temp_num);
        c_expr.expr &:= " < 0.0 ? f_const[2].floatvalue /* -1.0/0.0 */ : (tmp_";
        c_expr.expr &:= str(temp_num);
        c_expr.expr &:= " > 0.0 ? f_const[1].floatvalue /* 1.0/0.0 */ :\
                                \ f_const[0].floatvalue /* 0.0/0.0 */))";
      end if;
    else
      c_expr.expr &:= "(";
      process_expr(param1, c_expr);
      c_expr.expr &:= ") / ";
      c_expr.expr &:= str(divisor);
    end if;
  end func;


const proc: process_flt_div (in ref_list: params, inout expr_type: c_expr) is func

  begin
    if category(params[3]) = FLOATOBJECT and not isVar(params[3]) then
      process_const_flt_div(params[1], getValue(params[3], float), c_expr);
    else
      c_expr.expr &:= "(";
      process_expr(params[1], c_expr);
      c_expr.expr &:= ") / (";
      process_expr(params[3], c_expr);
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process_flt_div_assign (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "/=(";
    c_expr.expr &:= c_param3.expr;
    c_expr.expr &:= ");\n";
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_flt_eq (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") == (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_exp (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "exp(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_floor (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "floor(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_ge (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") >= (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_grow (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "+=(";
    c_expr.expr &:= c_param3.expr;
    c_expr.expr &:= ");\n";
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_flt_gt (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") > (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_hashcode (in ref_list: params, inout expr_type: c_expr) is func

  local
    var integer: temp_num is 0;
  begin
    incr(c_expr.temp_num);
    temp_num := c_expr.temp_num;
    c_expr.temp_decls &:= "float2int tmp_";
    c_expr.temp_decls &:= str(temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.expr &:= "(tmp_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= ".floatvalue=(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "),tmp_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= ".intvalue)";
  end func;


const proc: process_flt_icast (in ref_list: params, inout expr_type: c_expr) is func

  local
    var integer: temp_num is 0;
  begin
    incr(c_expr.temp_num);
    temp_num := c_expr.temp_num;
    c_expr.temp_decls &:= "float2int tmp_";
    c_expr.temp_decls &:= str(temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.expr &:= "(tmp_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= ".intvalue=(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= "),tmp_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= ".floatvalue)";
  end func;


const proc: process_flt_iconv (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(float)(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_iflt (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(float)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_ipow (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "fltIPow(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_isnan (in ref_list: params, inout expr_type: c_expr) is func

  begin
    if ISNAN_WITH_UNDERLINE then
      c_expr.expr &:= "_isnan(";
    else
      c_expr.expr &:= "isnan(";
    end if;
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_le (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") <= (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_log (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "log(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_log10 (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "log10(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_lt (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") < (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_minus (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "-(";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_mult (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") * (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_mult_assign (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "*=(";
    c_expr.expr &:= c_param3.expr;
    c_expr.expr &:= ");\n";
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_flt_ne (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") != (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_parse (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "fltParse(";
    getAnyParamToExpr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_plus (in ref_list: params, inout expr_type: c_expr) is func

  begin
    process_expr(params[2], c_expr);
  end func;


const proc: process_flt_pow (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "pow(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_rand (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "fltRand(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_round (in ref_list: params, inout expr_type: c_expr) is func

  local
    var integer: temp_num is 0;
  begin
    incr(c_expr.temp_num);
    temp_num := c_expr.temp_num;
    c_expr.temp_decls &:= "floattype tmp_a_";
    c_expr.temp_decls &:= str(temp_num);
    c_expr.temp_decls &:= ";\n";
    (* Formula used: (a<0.0?-((inttype)(0.5-a)):(inttype)(0.5+a)) *)
    c_expr.expr &:= "(tmp_a_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "=(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "),tmp_a_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "<0.0?-((inttype)(0.5-tmp_a_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= ")):(inttype)(0.5+tmp_a_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "))";
  end func;


const proc: process_flt_sbtr (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") - (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_shrink (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "-=(";
    c_expr.expr &:= c_param3.expr;
    c_expr.expr &:= ");\n";
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_flt_sin (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "sin(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_sinh (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "sinh(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_sqrt (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "sqrt(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_str (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "fltStr(";
    getStdParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_flt_tan (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "tan(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_tanh (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "tanh(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_trunc (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(inttype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_value (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "fltValue(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_gkb_busy_getc (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(gkbKeyPressed() ? gkbGetc() : 512)";
  end func;


const proc: process_gkb_getc (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "gkbGetc()";
  end func;


const proc: process_gkb_gets (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "gkbGets(";
    getStdParamToResultExpr(params[2], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_gkb_keypressed (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "gkbKeyPressed()";
  end func;


const proc: process_gkb_line_read (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "gkbLineRead(&(";
    getStdParamToResultExpr(params[2], c_expr);
    c_expr.result_expr &:= "))";
  end func;


const proc: process_gkb_raw_getc (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "gkbRawGetc()";
  end func;


const proc: process_gkb_window (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_win_result(c_expr);
    c_expr.result_expr &:= "gkbWindow()";
  end func;


const proc: process_gkb_word_read (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "gkbWordRead(&(";
    getStdParamToResultExpr(params[2], c_expr);
    c_expr.result_expr &:= "))";
  end func;


const proc: process_gkb_xpos (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "gkbXpos()";
  end func;


const proc: process_gkb_ypos (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "gkbYpos()";
  end func;


const proc: process_hsh_contains (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "hshContains((hashtype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "), (generictype)(";
    process_cast_from_float_expr(params[2], c_expr);
    c_expr.expr &:= "), ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", (comparetype)(";
    process_expr(params[4], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_hsh_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var type: param_type is void;
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param2 is expr_type.value;
    var expr_type: c_param3_6 is expr_type.value;
  begin
    param_type := getExprResultType(params[2]);
    process_expr(params[1], c_param1);
    c_param2.temp_num := c_param1.temp_num;
    process_expr(params[2], c_param2);
    if has_temp_values(c_param2) then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param2.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param2.temp_assigns;
    end if;
    if c_param2.result_expr <> "" then
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "=(";
      c_expr.expr &:= c_param2.result_expr;
      c_expr.expr &:= ");\n";
    else
      c_param3_6.expr &:= ", (createfunctype)(";
      process_expr(params[3], c_param3_6);
      c_param3_6.expr &:= "), (destrfunctype)(";
      process_expr(params[4], c_param3_6);
      c_param3_6.expr &:= "), (createfunctype)(";
      process_expr(params[5], c_param3_6);
      c_param3_6.expr &:= "), (destrfunctype)(";
      process_expr(params[6], c_param3_6);
      c_param3_6.expr &:= ")";
      if param_type not in parametersOfHshCpy then
        parametersOfHshCpy @:= [param_type] c_param3_6.expr;
      end if;
      c_expr.expr &:= "hshCpy(&(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "), (hashtype)(";
      c_expr.expr &:= c_param2.expr;
      c_expr.expr &:= ")";
      c_expr.expr &:= c_param3_6.expr;
      c_expr.expr &:= ");\n";
    end if;
    if has_temp_values(c_param2) then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param2.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_hsh_create (in ref_list: params, inout expr_type: c_expr) is func

  local
    var type: param_type is void;
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param2 is expr_type.value;
    var expr_type: c_param3_6 is expr_type.value;
  begin
    param_type := getExprResultType(params[2]);
    process_expr(params[1], c_param1);
    c_param2.temp_num := c_param1.temp_num;
    process_expr(params[2], c_param2);
    if c_param2.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param2.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param2.temp_assigns;
    end if;
    c_param3_6.expr &:= ", (createfunctype)(";
    process_expr(params[3], c_param3_6);
    c_param3_6.expr &:= "), (destrfunctype)(";
    process_expr(params[4], c_param3_6);
    c_param3_6.expr &:= "), (createfunctype)(";
    process_expr(params[5], c_param3_6);
    c_param3_6.expr &:= "), (destrfunctype)(";
    process_expr(params[6], c_param3_6);
    c_param3_6.expr &:= ")";
    if param_type not in parametersOfHshCreate then
      parametersOfHshCreate @:= [param_type] c_param3_6.expr;
    end if;
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "=";
    c_expr.expr &:= "hshCreate((hashtype)(";
    c_expr.expr &:= c_param2.expr;
    c_expr.expr &:= ")";
    c_expr.expr &:= c_param3_6.expr;
    c_expr.expr &:= ");\n";
    if c_param2.temp_num <> 0 then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param2.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_hsh_destr (in ref_list: params, inout expr_type: c_expr) is func

  local
    var type: param_type is void;
    var expr_type: c_param2_3 is expr_type.value;
  begin
    param_type := getExprResultType(params[1]);
    c_param2_3.expr &:= ", (destrfunctype)(";
    process_expr(params[2], c_param2_3);
    c_param2_3.expr &:= "), (destrfunctype)(";
    process_expr(params[3], c_param2_3);
    c_param2_3.expr &:= ")";
    if param_type not in parametersOfHshDestr then
      parametersOfHshDestr @:= [param_type] c_param2_3.expr;
    end if;
    c_expr.expr &:= "hshDestr((hashtype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
    c_expr.expr &:= c_param2_3.expr;
    c_expr.expr &:= ");\n";
  end func;


const proc: process_hsh_excl (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "hshExcl((hashtype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "), (generictype)(";
    process_cast_from_float_expr(params[2], c_expr);
    c_expr.expr &:= "), ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", (comparetype)(";
    process_expr(params[4], c_expr);
    c_expr.expr &:= "), (destrfunctype)(";
    process_expr(params[5], c_expr);
    c_expr.expr &:= "), (destrfunctype)(";
    process_expr(params[6], c_expr);
    c_expr.expr &:= "));\n";
  end func;


const proc: process_hsh_for_generic (in reference: forDataVariable,
  in reference: forKeyVariable, in reference: hashTable,
  in reference: statement, in reference: dataCopyFunc,
  in reference: keyCopyFunc, inout expr_type: c_expr) is func

  local
    var integer: hash_temp_num is 0;
    var integer: counter_temp_num is 0;
    var integer: table_elem_temp_num is 0;
    var integer: helem_temp_num is 0;
    var integer: stack_temp_num is 0;
  begin
    incr(c_expr.temp_num);
    hash_temp_num := c_expr.temp_num;
    incr(c_expr.temp_num);
    counter_temp_num := c_expr.temp_num;
    incr(c_expr.temp_num);
    table_elem_temp_num := c_expr.temp_num;
    incr(c_expr.temp_num);
    helem_temp_num := c_expr.temp_num;
    incr(c_expr.temp_num);
    stack_temp_num := c_expr.temp_num;
    c_expr.expr &:= "/* hsh_for */ {\n";
    c_expr.expr &:= "hashtype hash_";
    c_expr.expr &:= str(hash_temp_num);
    c_expr.expr &:= "=(hashtype)(";
    process_expr(hashTable, c_expr);
    c_expr.expr &:= ");\n";
    c_expr.expr &:= "memsizetype counter_";
    c_expr.expr &:= str(counter_temp_num);
    c_expr.expr &:= "=hash_";
    c_expr.expr &:= str(hash_temp_num);
    c_expr.expr &:= "->table_size;\n";
    c_expr.expr &:= "helemtype *table_elem_";
    c_expr.expr &:= str(table_elem_temp_num);
    c_expr.expr &:= "=&hash_";
    c_expr.expr &:= str(hash_temp_num);
    c_expr.expr &:= "->table[0];\n";
    c_expr.expr &:= "helemtype helem_";
    c_expr.expr &:= str(helem_temp_num);
    c_expr.expr &:= ";\n";
    c_expr.expr &:= "listtype stack_";
    c_expr.expr &:= str(stack_temp_num);
    c_expr.expr &:= "=NULL;\n";

    c_expr.expr &:= "while (counter_";
    c_expr.expr &:= str(counter_temp_num);
    c_expr.expr &:= " > 0) {\n";

    c_expr.expr &:= "helem_";
    c_expr.expr &:= str(helem_temp_num);
    c_expr.expr &:= "=*table_elem_";
    c_expr.expr &:= str(table_elem_temp_num);
    c_expr.expr &:= ";\n";

    c_expr.expr &:= "while (helem_";
    c_expr.expr &:= str(helem_temp_num);
    c_expr.expr &:= " != NULL) {\n";

    c_expr.expr &:= "if (helem_";
    c_expr.expr &:= str(helem_temp_num);
    c_expr.expr &:= "->next_greater != NULL) {\n";
    c_expr.expr &:= "push_stack(stack_";
    c_expr.expr &:= str(stack_temp_num);
    c_expr.expr &:= ", helem_";
    c_expr.expr &:= str(helem_temp_num);
    c_expr.expr &:= "->next_greater);\n";
    c_expr.expr &:= "} /* if */\n";

    if forDataVariable <> NIL then
      c_expr.expr &:= "((copyfunctype)";
      process_expr(dataCopyFunc, c_expr);
      c_expr.expr &:= ")(&(";
      process_expr(forDataVariable, c_expr);
      c_expr.expr &:= "), helem_";
      c_expr.expr &:= str(helem_temp_num);
      c_expr.expr &:= "->data.value.genericvalue);\n";
    end if;

    if forKeyVariable <> NIL then
      c_expr.expr &:= "((copyfunctype)";
      process_expr(keyCopyFunc, c_expr);
      c_expr.expr &:= ")(&(";
      process_expr(forKeyVariable, c_expr);
      c_expr.expr &:= "), helem_";
      c_expr.expr &:= str(helem_temp_num);
      c_expr.expr &:= "->key.value.genericvalue);\n";
    end if;

    process_expr(statement, c_expr);

    c_expr.expr &:= "if (helem_";
    c_expr.expr &:= str(helem_temp_num);
    c_expr.expr &:= "->next_less != NULL) {";
    c_expr.expr &:= "helem_";
    c_expr.expr &:= str(helem_temp_num);
    c_expr.expr &:= "=helem_";
    c_expr.expr &:= str(helem_temp_num);
    c_expr.expr &:= "->next_less;\n";
    c_expr.expr &:= "} else {\n";
    c_expr.expr &:= "pop_stack(stack_";
    c_expr.expr &:= str(stack_temp_num);
    c_expr.expr &:= ", helem_";
    c_expr.expr &:= str(helem_temp_num);
    c_expr.expr &:= ");\n";
    c_expr.expr &:= "} /* if */\n";

    c_expr.expr &:= "} /* while */\n";

    c_expr.expr &:= "counter_";
    c_expr.expr &:= str(counter_temp_num);
    c_expr.expr &:= "--;\n";
    c_expr.expr &:= "table_elem_";
    c_expr.expr &:= str(table_elem_temp_num);
    c_expr.expr &:= "++;\n";
    c_expr.expr &:= "} /* while */\n";
    c_expr.expr &:= "} /* hsh_for */\n";
  end func;


const proc: process_hsh_for (in ref_list: params, inout expr_type: c_expr) is func

  begin
    process_hsh_for_generic(params[1], NIL, params[2], params[3], params[4], NIL, c_expr);
  end func;


const proc: process_hsh_for_data_key (in ref_list: params, inout expr_type: c_expr) is func

  begin
    process_hsh_for_generic(params[1], params[2], params[3], params[4], params[5], params[6], c_expr);
  end func;


const proc: process_hsh_for_key (in ref_list: params, inout expr_type: c_expr) is func

  begin
    process_hsh_for_generic(NIL, params[1], params[2], params[3], NIL, params[4], c_expr);
  end func;


const proc: process_hsh_idx (in reference: function, in ref_list: params,
    inout expr_type: c_expr) is func

  local
    var type: proc_type is void;
    var type: result_type is void;
  begin
    proc_type := getType(function);
    result_type := result_type(proc_type);
    if result_type = floattype then
#     c_expr.expr &:= "*(floattype *)hshIdxAddr(";
      c_expr.expr &:= "hshIdxAddr(";
    elsif result_type = typetype then
      c_expr.expr &:= "hshIdxAddr(";
    elsif is_varfunc(proc_type) then
      c_expr.expr &:= "*hshIdxAddr(";
    else
      c_expr.expr &:= "(";
      c_expr.expr &:= type_name(result_type);
      c_expr.expr &:= ")";
      c_expr.expr &:= "hshIdx(";
    end if;
    c_expr.expr &:= "(hashtype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "), (generictype)(";
    process_cast_from_float_expr(params[2], c_expr);
    c_expr.expr &:= "), ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", (comparetype)(";
    process_expr(params[4], c_expr);
    c_expr.expr &:= "))";
if result_type = floattype then
    c_expr.expr &:= "->value.floatvalue";
elsif result_type = typetype then
    c_expr.expr &:= "->value.typevalue";
end if;
  end func;


const proc: process_hsh_incl (in ref_list: params, inout expr_type: c_expr) is func

  begin
    declare_func_pointer_if_necessary(params[5], global_c_expr);
    declare_func_pointer_if_necessary(params[6], global_c_expr);
    declare_func_pointer_if_necessary(params[7], global_c_expr);
    declare_func_pointer_if_necessary(params[8], global_c_expr);
    c_expr.expr &:= "hshIncl((hashtype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "), (generictype)(";
    process_cast_from_float_expr(params[2], c_expr);
    c_expr.expr &:= "), (generictype)(";
    process_cast_from_float_expr(params[3], c_expr);
    c_expr.expr &:= "), ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", (comparetype)(";
    process_expr(params[5], c_expr);
    c_expr.expr &:= "), (createfunctype)(";
    process_expr(params[6], c_expr);
    c_expr.expr &:= "), (createfunctype)(";
    process_expr(params[7], c_expr);
    c_expr.expr &:= "), (copyfunctype)(";
    process_expr(params[8], c_expr);
    c_expr.expr &:= "));\n";
  end func;


const proc: process_hsh_keys (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "hshKeys((hashtype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "), (createfunctype)(";
    process_expr(params[2], c_expr);
    c_expr.expr &:= "), (destrfunctype)(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_hsh_lng (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(inttype)((hashtype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "))->size";
  end func;


const proc: process_hsh_values (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "hshValues((hashtype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "), (createfunctype)(";
    process_expr(params[2], c_expr);
    c_expr.expr &:= "), (destrfunctype)(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_int_abs (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "labs(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_add (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") + (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_binom (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "intBinom(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_bit_length (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "intBitLength(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_cmp (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "intCmp(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ", ";
    getAnyParamToExpr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_conv (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "=(";
    if c_param3.result_expr <> "" then
      c_expr.expr &:= c_param3.result_expr;
    else
      c_expr.expr &:= c_param3.expr;
    end if;
    c_expr.expr &:= ");\n";
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_int_decr (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "--(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_const_int_div (in reference: param1, in integer: divisor,
    inout expr_type: c_expr) is func

  begin
    incr(countOptimizations);
    if divisor = 0 then
      c_expr.expr &:= "(raise_error(NUMERIC_ERROR),0)";
    elsif category(param1) = INTOBJECT and not isVar(param1) then
      c_expr.expr &:= str(getValue(param1, integer) div divisor);
    elsif divisor = 1 then
      c_expr.expr &:= "(";
      process_expr(param1, c_expr);
      c_expr.expr &:= ")";
    elsif divisor = -1 then
      c_expr.expr &:= "-(";
      process_expr(param1, c_expr);
      c_expr.expr &:= ")";
    else
      c_expr.expr &:= "(";
      process_expr(param1, c_expr);
      c_expr.expr &:= ") / ";
      c_expr.expr &:= str(divisor);
    end if;
  end func;


const proc: process_int_div (in ref_list: params, inout expr_type: c_expr) is func

  local
    var integer: temp_num is 0;
  begin
    if category(params[3]) = INTOBJECT and not isVar(params[3]) then
      process_const_int_div(params[1], getValue(params[3], integer), c_expr);
    elsif CHECK_INT_DIV_BY_ZERO then
      incr(c_expr.temp_num);
      temp_num := c_expr.temp_num;
      c_expr.temp_decls &:= "inttype tmp_b_";
      c_expr.temp_decls &:= str(temp_num);
      c_expr.temp_decls &:= ";\n";
      c_expr.expr &:= "(tmp_b_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "=(";
      process_expr(params[3], c_expr);
      c_expr.expr &:= "),tmp_b_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "==0?(raise_error(NUMERIC_ERROR),0):(";
      process_expr(params[1], c_expr);
      c_expr.expr &:= ") / tmp_b_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= ")";
    else
      c_expr.expr &:= "(";
      process_expr(params[1], c_expr);
      c_expr.expr &:= ") / (";
      process_expr(params[3], c_expr);
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process_int_eq (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") == (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_fact (in ref_list: params, inout expr_type: c_expr) is func

  local
    var integer: temp_num is 0;
  begin
    incr(c_expr.temp_num);
    temp_num := c_expr.temp_num;
    c_expr.temp_decls &:= "inttype tmp_";
    c_expr.temp_decls &:= str(temp_num);
    c_expr.temp_decls &:= ";\n";
    (* Formula used: (i<0||i>12?NUMERIC_ERROR:fact[i]) *)
    c_expr.expr &:= "(tmp_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "=(";
    process_expr(params[2], c_expr);
    c_expr.expr &:= "),(tmp_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "<0||tmp_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= ">12?(raise_error(NUMERIC_ERROR),0):fact[tmp_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "]))";
  end func;


const proc: process_int_ge (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") >= (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_grow (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "+=(";
    c_expr.expr &:= c_param3.expr;
    c_expr.expr &:= ");\n";
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_int_gt (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") > (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_hashcode (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_incr (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "++(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_int_le (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") <= (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_log2 (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "intLog2(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_lowest_set_bit (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "intLowestSetBit(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_lpad0 (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "intLpad0(";
    getStdParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ",";
    getStdParamToResultExpr(params[3], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_const_int_lshift (in reference: param1, in integer: number,
    inout expr_type: c_expr) is func

  begin
    incr(countOptimizations);
    if number < 0 then
      c_expr.expr &:= "(raise_error(NUMERIC_ERROR),0)";
    elsif number >= 32 then
      c_expr.expr &:= "0";
    else
      c_expr.expr &:= "(";
      process_expr(param1, c_expr);
      c_expr.expr &:= ") << ";
      c_expr.expr &:= str(number);
    end if;
  end func;


const proc: process_int_lshift (in ref_list: params, inout expr_type: c_expr) is func

  begin
    if category(params[3]) = INTOBJECT and not isVar(params[3]) then
      process_const_int_lshift(params[1], getValue(params[3], integer), c_expr);
    else
      c_expr.expr &:= "(";
      process_expr(params[1], c_expr);
      c_expr.expr &:= ") << (";
      process_expr(params[3], c_expr);
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process_int_lshift_assign (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "<<=(";
    if c_param3.result_expr <> "" then
      c_expr.expr &:= c_param3.result_expr;
    else
      c_expr.expr &:= c_param3.expr;
    end if;
    c_expr.expr &:= ");\n";
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_int_lt (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") < (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_const_int_mdiv (in reference: param1, in integer: divisor,
    inout expr_type: c_expr) is func

  local
    var integer: temp_num is 0;
  begin
    incr(countOptimizations);
    if divisor = 0 then
      c_expr.expr &:= "(raise_error(NUMERIC_ERROR),0)";
    elsif category(param1) = INTOBJECT and not isVar(param1) then
      c_expr.expr &:= str(getValue(param1, integer) mdiv divisor);
    elsif divisor = 1 then
      c_expr.expr &:= "(";
      process_expr(param1, c_expr);
      c_expr.expr &:= ")";
    elsif divisor = -1 then
      c_expr.expr &:= "-(";
      process_expr(param1, c_expr);
      c_expr.expr &:= ")";
    elsif divisor > 0 and 2 ** log2(divisor) = divisor then
      if RSHIFT_DOES_SIGN_EXTEND then
        c_expr.expr &:= "(";
        process_expr(param1, c_expr);
        c_expr.expr &:= ") >> ";
        c_expr.expr &:= str(log2(divisor));
      else
        incr(c_expr.temp_num);
        temp_num := c_expr.temp_num;
        c_expr.temp_decls &:= "inttype tmp_a_";
        c_expr.temp_decls &:= str(temp_num);
        c_expr.temp_decls &:= ";\n";
        (* Formula used: a<0?~(~a>>b):a>>b *)
        c_expr.expr &:= "(tmp_a_";
        c_expr.expr &:= str(temp_num);
        c_expr.expr &:= "=(";
        process_expr(param1, c_expr);
        c_expr.expr &:= "),tmp_a_";
        c_expr.expr &:= str(temp_num);
        c_expr.expr &:= "<0?~(~tmp_a_";
        c_expr.expr &:= str(temp_num);
        c_expr.expr &:= " >> ";
        c_expr.expr &:= str(log2(divisor));
        c_expr.expr &:= "):tmp_a_";
        c_expr.expr &:= str(temp_num);
        c_expr.expr &:= " >> ";
        c_expr.expr &:= str(log2(divisor));
        c_expr.expr &:= ")";
      end if;
    else
      incr(c_expr.temp_num);
      temp_num := c_expr.temp_num;
      c_expr.temp_decls &:= "inttype tmp_a_";
      c_expr.temp_decls &:= str(temp_num);
      c_expr.temp_decls &:= ";\n";
      c_expr.expr &:= "(tmp_a_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "=(";
      process_expr(param1, c_expr);
      c_expr.expr &:= "),";
      c_expr.expr &:= "tmp_a_";
      c_expr.expr &:= str(temp_num);
      if divisor > 0 then
        (* Formula used: a<0?(a+1)/b-1:a/b *)
        c_expr.expr &:= "<0?(tmp_a_";
        c_expr.expr &:= str(temp_num);
        c_expr.expr &:= "+1)/";
      else # divisor < 0
        (* Formula used: a>0?(a-1)/b-1:a/b *)
        c_expr.expr &:= ">0?(tmp_a_";
        c_expr.expr &:= str(temp_num);
        c_expr.expr &:= "-1)/";
      end if;
      c_expr.expr &:= str(divisor);
      c_expr.expr &:= "-1:tmp_a_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "/";
      c_expr.expr &:= str(divisor);
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process_const_int_mdiv (in integer: dividend, in reference: param3,
    inout expr_type: c_expr) is func

  local
    var integer: temp_num is 0;
  begin
    incr(countOptimizations);
    if dividend = 0 then
      c_expr.expr &:= "((";
      process_expr(param3, c_expr);
      c_expr.expr &:= ")==0?(raise_error(NUMERIC_ERROR),0):0)";
    else
      incr(c_expr.temp_num);
      temp_num := c_expr.temp_num;
      c_expr.temp_decls &:= "inttype tmp_b_";
      c_expr.temp_decls &:= str(temp_num);
      c_expr.temp_decls &:= ";\n";
      c_expr.expr &:= "(tmp_b_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "=(";
      process_expr(param3, c_expr);
      c_expr.expr &:= "),tmp_b_";
      c_expr.expr &:= str(temp_num);
      if dividend > 0 then
        (* Formula used: b<0?(a-1)/b-1:a/b *)
        c_expr.expr &:= "<0?";
        c_expr.expr &:= str(pred(dividend));
      else # dividend < 0
        (* Formula used: b>0?(a+1)/b-1:a/b *)
        c_expr.expr &:= ">0?";
        c_expr.expr &:= str(succ(dividend));
      end if;
      c_expr.expr &:= "/tmp_b_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "-1:";
      if CHECK_INT_DIV_BY_ZERO then
        c_expr.expr &:= "tmp_b_";
        c_expr.expr &:= str(temp_num);
        c_expr.expr &:= "==0?(raise_error(NUMERIC_ERROR),0):";
      end if;
      c_expr.expr &:= str(dividend);
      c_expr.expr &:= "/tmp_b_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process_int_mdiv (in ref_list: params, inout expr_type: c_expr) is func

  local
    var integer: temp_num is 0;
  begin
    if category(params[3]) = INTOBJECT and not isVar(params[3]) then
      process_const_int_mdiv(params[1], getValue(params[3], integer), c_expr);
    elsif category(params[1]) = INTOBJECT and not isVar(params[1]) then
      process_const_int_mdiv(getValue(params[1], integer), params[3], c_expr);
    else
      incr(c_expr.temp_num);
      temp_num := c_expr.temp_num;
      c_expr.temp_decls &:= "inttype tmp_a_";
      c_expr.temp_decls &:= str(temp_num);
      c_expr.temp_decls &:= ";\n";
      c_expr.temp_decls &:= "inttype tmp_b_";
      c_expr.temp_decls &:= str(temp_num);
      c_expr.temp_decls &:= ";\n";
      (* Formula used: a>0&&b<0?(a-1)/b-1:a<0&&b>0?(a+1)/b-1:a/b *)
      c_expr.expr &:= "(tmp_a_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "=(";
      process_expr(params[1], c_expr);
      c_expr.expr &:= "),tmp_b_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "=(";
      process_expr(params[3], c_expr);
      c_expr.expr &:= "),";
      c_expr.expr &:= "tmp_a_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= ">0&&tmp_b_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "<0?(tmp_a_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "-1)/tmp_b_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "-1:tmp_a_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "<0&&tmp_b_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= ">0?(tmp_a_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "+1)/tmp_b_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "-1:";
      if CHECK_INT_DIV_BY_ZERO then
        c_expr.expr &:= "tmp_b_";
        c_expr.expr &:= str(temp_num);
        c_expr.expr &:= "==0?(raise_error(NUMERIC_ERROR),0):";
      end if;
      c_expr.expr &:= "tmp_a_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "/tmp_b_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process_int_minus (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "-(";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_const_int_mod (in reference: param1, in integer: divisor,
    inout expr_type: c_expr) is func

  local
    var integer: temp_num is 0;
  begin
    incr(countOptimizations);
    if divisor = 0 then
      c_expr.expr &:= "(raise_error(NUMERIC_ERROR),0)";
    elsif category(param1) = INTOBJECT and not isVar(param1) then
      c_expr.expr &:= str(getValue(param1, integer) mod divisor);
    elsif divisor = 1 or divisor = -1 then
      c_expr.expr &:= "0";
    elsif divisor > 0 and 2 ** log2(divisor) = divisor then
      c_expr.expr &:= "(";
      process_expr(param1, c_expr);
      c_expr.expr &:= ")&";
      c_expr.expr &:= str(pred(divisor));
    else
      incr(c_expr.temp_num);
      temp_num := c_expr.temp_num;
      c_expr.temp_decls &:= "inttype tmp_a_";
      c_expr.temp_decls &:= str(temp_num);
      c_expr.temp_decls &:= ";\n";
      c_expr.temp_decls &:= "inttype tmp_c_";
      c_expr.temp_decls &:= str(temp_num);
      c_expr.temp_decls &:= ";\n";
      (* Formula used: c=a%b,((a>0&&b<0)||(a<0&&b>0))&&c!=0?c+b:c *)
      c_expr.expr &:= "(tmp_a_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "=(";
      process_expr(param1, c_expr);
      c_expr.expr &:= "),tmp_c_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "=tmp_a_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "%";
      c_expr.expr &:= str(divisor);
      c_expr.expr &:= ",tmp_a_";
      c_expr.expr &:= str(temp_num);
      if divisor > 0 then
        (* Formula used: c=a%b,a<0&&c!=0?c+b:c *)
        c_expr.expr &:= "<0";
      else # divisor < 0
        (* Formula used: c=a%b,a>0&&c!=0?c+b:c *)
        c_expr.expr &:= ">0";
      end if;
      c_expr.expr &:= "&&tmp_c_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "!=0?tmp_c_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "+";
      c_expr.expr &:= str(divisor);
      c_expr.expr &:= ":tmp_c_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process_const_int_mod (in integer: dividend, in reference: param3,
    inout expr_type: c_expr) is func

  local
    var integer: temp_num is 0;
  begin
    incr(countOptimizations);
    if dividend = 0 then
      c_expr.expr &:= "((";
      process_expr(param3, c_expr);
      c_expr.expr &:= ")==0?(raise_error(NUMERIC_ERROR),0):0)";
    else
      incr(c_expr.temp_num);
      temp_num := c_expr.temp_num;
      c_expr.temp_decls &:= "inttype tmp_b_";
      c_expr.temp_decls &:= str(temp_num);
      c_expr.temp_decls &:= ";\n";
      c_expr.temp_decls &:= "inttype tmp_c_";
      c_expr.temp_decls &:= str(temp_num);
      c_expr.temp_decls &:= ";\n";
      (* Formula used: c=a%b,((a>0&&b<0)||(a<0&&b>0))&&c!=0?c+b:c *)
      c_expr.expr &:= "(tmp_b_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "=(";
      process_expr(param3, c_expr);
      c_expr.expr &:= "),";
      if CHECK_INT_DIV_BY_ZERO then
        c_expr.expr &:= "tmp_b_";
        c_expr.expr &:= str(temp_num);
        c_expr.expr &:= "==0?(raise_error(NUMERIC_ERROR),0):(";
      end if;
      c_expr.expr &:= "tmp_c_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "=";
      c_expr.expr &:= str(dividend);
      c_expr.expr &:= "%tmp_b_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= ",tmp_b_";
      c_expr.expr &:= str(temp_num);
      if dividend > 0 then
        (* Formula used: c=a%b,b<0&&c!=0?c+b:c *)
        c_expr.expr &:= "<0";
      else # dividend < 0 then
        (* Formula used: c=a%b,b>0&&c!=0?c+b:c *)
        c_expr.expr &:= ">0";
      end if;
      c_expr.expr &:= "&&tmp_c_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "!=0?tmp_c_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "+tmp_b_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= ":tmp_c_";
      c_expr.expr &:= str(temp_num);
      if CHECK_INT_DIV_BY_ZERO then
        c_expr.expr &:= ")";
      end if;
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process_int_mod (in ref_list: params, inout expr_type: c_expr) is func

  local
    var integer: temp_num is 0;
  begin
    if category(params[3]) = INTOBJECT and not isVar(params[3]) then
      process_const_int_mod(params[1], getValue(params[3], integer), c_expr);
    elsif category(params[1]) = INTOBJECT and not isVar(params[1]) then
      process_const_int_mod(getValue(params[1], integer), params[3], c_expr);
    else
      incr(c_expr.temp_num);
      temp_num := c_expr.temp_num;
      c_expr.temp_decls &:= "inttype tmp_a_";
      c_expr.temp_decls &:= str(temp_num);
      c_expr.temp_decls &:= ";\n";
      c_expr.temp_decls &:= "inttype tmp_b_";
      c_expr.temp_decls &:= str(temp_num);
      c_expr.temp_decls &:= ";\n";
      c_expr.temp_decls &:= "inttype tmp_c_";
      c_expr.temp_decls &:= str(temp_num);
      c_expr.temp_decls &:= ";\n";
      (* Formula used: c=a%b,((a>0&&b<0)||(a<0&&b>0))&&c!=0?c+b:c *)
      c_expr.expr &:= "(tmp_a_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "=(";
      process_expr(params[1], c_expr);
      c_expr.expr &:= "),tmp_b_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "=(";
      process_expr(params[3], c_expr);
      c_expr.expr &:= "),";
      if CHECK_INT_DIV_BY_ZERO then
        c_expr.expr &:= "tmp_b_";
        c_expr.expr &:= str(temp_num);
        c_expr.expr &:= "==0?(raise_error(NUMERIC_ERROR),0):(";
      end if;
      c_expr.expr &:= "tmp_c_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "=tmp_a_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "%tmp_b_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= ",((tmp_a_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= ">0&&tmp_b_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "<0)||(tmp_a_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "<0&&tmp_b_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= ">0))&&tmp_c_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "!=0?tmp_c_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "+tmp_b_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= ":tmp_c_";
      c_expr.expr &:= str(temp_num);
      if CHECK_INT_DIV_BY_ZERO then
        c_expr.expr &:= ")";
      end if;
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process_int_mult (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") * (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_mult_assign (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "*=(";
    c_expr.expr &:= c_param3.expr;
    c_expr.expr &:= ");\n";
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_int_ne (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") != (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_odd (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")&1";
  end func;


const proc: process_int_ord (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_parse (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "intParse((stritype)(";
    getAnyParamToExpr(params[3], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_int_plus (in ref_list: params, inout expr_type: c_expr) is func

  begin
    process_expr(params[2], c_expr);
  end func;


const proc: process_const_int_pow (in reference: param1, in integer: exponent,
    inout expr_type: c_expr) is func

  local
    var integer: temp_num is 0;
  begin
    if exponent < 0 then
      incr(countOptimizations);
      c_expr.expr &:= "(raise_error(NUMERIC_ERROR),0)";
    elsif category(param1) = INTOBJECT and not isVar(param1) then
      incr(countOptimizations);
      c_expr.expr &:= str(getValue(param1, integer) ** exponent);
    elsif exponent = 0 then
      incr(countOptimizations);
      c_expr.expr &:= "1";
    elsif exponent = 1 then
      incr(countOptimizations);
      process_expr(param1, c_expr);
    elsif exponent = 2 then
      incr(countOptimizations);
      incr(c_expr.temp_num);
      temp_num := c_expr.temp_num;
      c_expr.temp_decls &:= "inttype tmp_";
      c_expr.temp_decls &:= str(temp_num);
      c_expr.temp_decls &:= ";\n";
      c_expr.expr &:= "(tmp_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "=(";
      process_expr(param1, c_expr);
      c_expr.expr &:= "),";
      c_expr.expr &:= "tmp_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "*tmp_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= ")";
    else
      c_expr.expr &:= "intPow(";
      process_expr(param1, c_expr);
      c_expr.expr &:= ", ";
      c_expr.expr &:= str(exponent);
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process_const_int_pow (in integer: base, in reference: param3,
    inout expr_type: c_expr) is func

  begin
    if base = 1 then
      incr(countOptimizations);
      c_expr.expr &:= "((";
      process_expr(param3, c_expr);
      c_expr.expr &:= ")<0?(raise_error(NUMERIC_ERROR),0):1)";
    elsif base = 2 then
      incr(countOptimizations);
      c_expr.expr &:= "1" & INTTYPE_LITERAL_SUFFIX <& "<<(";
      process_expr(param3, c_expr);
      c_expr.expr &:= ")";
    elsif base > 0 and 2 ** log2(base) = base then
      incr(countOptimizations);
      c_expr.expr &:= "1" & INTTYPE_LITERAL_SUFFIX <& "<<";
      c_expr.expr &:= str(log2(base));
      c_expr.expr &:= "*(";
      process_expr(param3, c_expr);
      c_expr.expr &:= ")";
    else
      c_expr.expr &:= "intPow(";
      c_expr.expr &:= str(base);
      c_expr.expr &:= ", ";
      process_expr(param3, c_expr);
      c_expr.expr &:= ")";
    end if
  end func;


const proc: process_int_pow (in ref_list: params, inout expr_type: c_expr) is func

  begin
    if category(params[3]) = INTOBJECT and not isVar(params[3]) then
      process_const_int_pow(params[1], getValue(params[3], integer), c_expr);
    elsif category(params[1]) = INTOBJECT and not isVar(params[1]) then
      process_const_int_pow(getValue(params[1], integer), params[3], c_expr);
    else
      c_expr.expr &:= "intPow(";
      process_expr(params[1], c_expr);
      c_expr.expr &:= ", ";
      process_expr(params[3], c_expr);
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process_int_pred (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")-1";
  end func;


const proc: process_int_rand (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "intRand(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_const_int_rem (in reference: param1, in integer: divisor,
    inout expr_type: c_expr) is func

  local
    var integer: temp_num is 0;
  begin
    incr(countOptimizations);
    if divisor = 0 then
      c_expr.expr &:= "(raise_error(NUMERIC_ERROR),0)";
    elsif category(param1) = INTOBJECT and not isVar(param1) then
      c_expr.expr &:= str(getValue(param1, integer) mod divisor);
    elsif divisor = 1 or divisor = -1 then
      c_expr.expr &:= "0";
    else
      c_expr.expr &:= "(";
      process_expr(param1, c_expr);
      c_expr.expr &:= ") % ";
      c_expr.expr &:= str(divisor);
    end if;
  end func;


const proc: process_const_int_rem (in integer: dividend, in reference: param3,
    inout expr_type: c_expr) is func

  local
    var integer: temp_num is 0;
  begin
    incr(countOptimizations);
    if dividend = 0 then
      c_expr.expr &:= "((";
      process_expr(param3, c_expr);
      c_expr.expr &:= ")==0?(raise_error(NUMERIC_ERROR),0):0)";
    elsif CHECK_INT_DIV_BY_ZERO then
      incr(c_expr.temp_num);
      temp_num := c_expr.temp_num;
      c_expr.temp_decls &:= "inttype tmp_b_";
      c_expr.temp_decls &:= str(temp_num);
      c_expr.temp_decls &:= ";\n";
      c_expr.expr &:= "(tmp_b_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "=(";
      process_expr(param3, c_expr);
      c_expr.expr &:= "),tmp_b_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "==0?(raise_error(NUMERIC_ERROR),0):";
      c_expr.expr &:= str(dividend);
      c_expr.expr &:= " % tmp_b_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= ")";
    else
      c_expr.expr &:= str(dividend);
      c_expr.expr &:= " % (";
      process_expr(param3, c_expr);
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process_int_rem (in ref_list: params, inout expr_type: c_expr) is func

  local
    var integer: temp_num is 0;
  begin
    if category(params[3]) = INTOBJECT and not isVar(params[3]) then
      process_const_int_rem(params[1], getValue(params[3], integer), c_expr);
    elsif category(params[1]) = INTOBJECT and not isVar(params[1]) then
      process_const_int_rem(getValue(params[1], integer), params[3], c_expr);
    elsif CHECK_INT_DIV_BY_ZERO then
      incr(c_expr.temp_num);
      temp_num := c_expr.temp_num;
      c_expr.temp_decls &:= "inttype tmp_b_";
      c_expr.temp_decls &:= str(temp_num);
      c_expr.temp_decls &:= ";\n";
      c_expr.expr &:= "(tmp_b_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "=(";
      process_expr(params[3], c_expr);
      c_expr.expr &:= "),tmp_b_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "==0?(raise_error(NUMERIC_ERROR),0):(";
      process_expr(params[1], c_expr);
      c_expr.expr &:= ") % tmp_b_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= ")";
    else
      c_expr.expr &:= "(";
      process_expr(params[1], c_expr);
      c_expr.expr &:= ") % (";
      process_expr(params[3], c_expr);
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process_const_int_rshift (in reference: param1, in integer: number,
    inout expr_type: c_expr) is func

  local
    var integer: temp_num is 0;
  begin
    incr(countOptimizations);
    if number < 0 then
      c_expr.expr &:= "(raise_error(NUMERIC_ERROR),0)";
    elsif number >= 32 then
      c_expr.expr &:= "((";
      process_expr(param1, c_expr);
      c_expr.expr &:= ")<0?-1:0)";
    else
      if RSHIFT_DOES_SIGN_EXTEND then
        c_expr.expr &:= "(";
        process_expr(param1, c_expr);
        c_expr.expr &:= ") >> ";
        c_expr.expr &:= str(number);
      else
        incr(c_expr.temp_num);
        temp_num := c_expr.temp_num;
        c_expr.temp_decls &:= "inttype tmp_";
        c_expr.temp_decls &:= str(temp_num);
        c_expr.temp_decls &:= ";\n";
        (* Formula used: (a<0?~(~a>>b):a>>b) *)
        c_expr.expr &:= "(tmp_";
        c_expr.expr &:= str(temp_num);
        c_expr.expr &:= "=(";
        process_expr(param1, c_expr);
        c_expr.expr &:= "),tmp_";
        c_expr.expr &:= str(temp_num);
        c_expr.expr &:= "<0?~(~tmp_";
        c_expr.expr &:= str(temp_num);
        c_expr.expr &:= " >> ";
        c_expr.expr &:= str(number);
        c_expr.expr &:= "):tmp_";
        c_expr.expr &:= str(temp_num);
        c_expr.expr &:= " >> ";
        c_expr.expr &:= str(number);
        c_expr.expr &:= ")";
      end if;
    end if;
  end func;


const proc: process_int_rshift (in ref_list: params, inout expr_type: c_expr) is func

  local
    var integer: temp_num is 0;
  begin
    if category(params[3]) = INTOBJECT and not isVar(params[3]) then
      process_const_int_rshift(params[1], getValue(params[3], integer), c_expr);
    else
      if RSHIFT_DOES_SIGN_EXTEND then
        c_expr.expr &:= "(";
        process_expr(params[1], c_expr);
        c_expr.expr &:= ") >> (";
        process_expr(params[3], c_expr);
        c_expr.expr &:= ")";
      else
        incr(c_expr.temp_num);
        temp_num := c_expr.temp_num;
        c_expr.temp_decls &:= "inttype tmp_";
        c_expr.temp_decls &:= str(temp_num);
        c_expr.temp_decls &:= ";\n";
        (* Formula used: (a<0?~(~a>>b):a>>b) *)
        c_expr.expr &:= "(tmp_";
        c_expr.expr &:= str(temp_num);
        c_expr.expr &:= "=(";
        process_expr(params[1], c_expr);
        c_expr.expr &:= "),tmp_";
        c_expr.expr &:= str(temp_num);
        c_expr.expr &:= "<0?~(~tmp_";
        c_expr.expr &:= str(temp_num);
        c_expr.expr &:= " >> (";
        process_expr(params[3], c_expr);
        c_expr.expr &:= ")):tmp_";
        c_expr.expr &:= str(temp_num);
        c_expr.expr &:= " >> (";
        process_expr(params[3], c_expr);
        c_expr.expr &:= "))";
      end if;
    end if;
  end func;


const proc: process_int_rshift_assign (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
    var integer: temp_num is 0;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 or
        not RSHIFT_DOES_SIGN_EXTEND then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      if not RSHIFT_DOES_SIGN_EXTEND then
        temp_num := succ(c_param3.temp_num);
        c_expr.expr &:= "inttype tmp_";
        c_expr.expr &:= str(temp_num);
        c_expr.expr &:= ";\n";
      end if;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    if RSHIFT_DOES_SIGN_EXTEND then
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= ">>=(";
      if c_param3.result_expr <> "" then
        c_expr.expr &:= c_param3.result_expr;
      else
        c_expr.expr &:= c_param3.expr;
      end if;
      c_expr.expr &:= ");\n";
    else
      (* Formula used: if (a<0) a= ~(~a>>b); else a>>=b; *)
      c_expr.expr &:= "tmp_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "=(";
      process_expr(params[1], c_expr);
      c_expr.expr &:= ");\n";
      c_expr.expr &:= "if (tmp_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "<0) ";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "= ~(~tmp_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= " >> (";
      process_expr(params[3], c_expr);
      c_expr.expr &:= ")); else ";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= " >>= (";
      process_expr(params[3], c_expr);
      c_expr.expr &:= ");";
    end if;
    if c_param3.temp_num <> 0 or
        not RSHIFT_DOES_SIGN_EXTEND then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_int_sbtr (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") - (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_shrink (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "-=(";
    c_expr.expr &:= c_param3.expr;
    c_expr.expr &:= ");\n";
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_int_sqrt (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "intSqrt(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_str (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "intStr(";
    getStdParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_const_int_str_based (in reference: param1, in integer: base,
    inout expr_type: c_expr) is func

  begin
    if base < 2 or base > 36 then
      c_expr.expr &:= "(raise_error(NUMERIC_ERROR),0)";
    elsif base = 10 then
      prepare_stri_result(c_expr);
      c_expr.result_expr &:= "intStr(";
      getStdParamToResultExpr(param1, c_expr);
      c_expr.result_expr &:= ")";
    elsif base = 16 then
      prepare_stri_result(c_expr);
      c_expr.result_expr &:= "intStrHex(";
      getStdParamToResultExpr(param1, c_expr);
      c_expr.result_expr &:= ")";
    else
      prepare_stri_result(c_expr);
      c_expr.result_expr &:= "intStrBased(";
      getStdParamToResultExpr(param1, c_expr);
      c_expr.result_expr &:= ", ";
      c_expr.result_expr &:= str(base);
      c_expr.result_expr &:= ")";
    end if;
  end func;


const proc: process_int_str_based (in ref_list: params, inout expr_type: c_expr) is func

  begin
    if category(params[2]) = INTOBJECT and not isVar(params[2]) then
      process_const_int_str_based(params[1], getValue(params[2], integer), c_expr);
    else
      prepare_stri_result(c_expr);
      c_expr.result_expr &:= "intStrBased(";
      getStdParamToResultExpr(params[1], c_expr);
      c_expr.result_expr &:= ", ";
      getStdParamToResultExpr(params[2], c_expr);
      c_expr.result_expr &:= ")";
    end if;
  end func;


const proc: process_int_succ (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")+1";
  end func;


const proc: process_int_value (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "intValue(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_itf_conv2 (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_itf_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if has_temp_values(c_param3) then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "=(";
    if c_param3.result_expr <> "" then
      c_expr.expr &:= c_param3.result_expr;
    else
      c_expr.expr &:= c_param3.expr;
    end if;
    c_expr.expr &:= ");\n";
    if has_temp_values(c_param3) then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_itf_cpy2 (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if has_temp_values(c_param3) then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    if c_param3.result_expr <> "" then
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "=";
      c_expr.expr &:= c_param3.result_expr;
      c_expr.expr &:= ";\n";
    else
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "=";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= ";\n";
    end if;
    if has_temp_values(c_param3) then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_itf_eq (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "((generictype)(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ")) == ((generictype)(";
    getAnyParamToExpr(params[3], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_itf_ne (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "((generictype)(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ")) != ((generictype)(";
    getAnyParamToExpr(params[3], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_kbd_busy_getc (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(kbdKeyPressed() ? kbdGetc() : 512)";
  end func;


const proc: process_kbd_getc (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "kbdGetc()";
  end func;


const proc: process_kbd_gets (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "kbdGets(";
    getStdParamToResultExpr(params[2], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_kbd_keypressed (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "kbdKeyPressed()";
  end func;


const proc: process_kbd_line_read (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "kbdLineRead(&(";
    getStdParamToResultExpr(params[2], c_expr);
    c_expr.result_expr &:= "))";
  end func;


const proc: process_kbd_raw_getc (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "kbdRawGetc()";
  end func;


const proc: process_kbd_word_read (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "kbdWordRead(&(";
    getStdParamToResultExpr(params[2], c_expr);
    c_expr.result_expr &:= "))";
  end func;


const proc: process_prg_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    compilerLibraryUsed := TRUE;
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if has_temp_values(c_param3) then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    if c_param3.result_expr <> "" then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= "progtype *prg_ptr=&(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= ");\n";
      c_expr.expr &:= "progtype old_prog=*prg_ptr;\n";
      c_expr.expr &:= "*prg_ptr=";
      c_expr.expr &:= c_param3.result_expr;
      c_expr.expr &:= ";\n";
      c_expr.expr &:= "prgDestr(old_prog);\n";
      c_expr.expr &:= "}\n";
    else
      c_expr.expr &:= "prgCpy(&(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "), ";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= ");\n";
    end if;
    if has_temp_values(c_param3) then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_prg_decl_objects (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compilerLibraryUsed := TRUE;
    c_expr.expr &:= "prgDeclObjects(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_prg_eq (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") == (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_prg_error_count (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compilerLibraryUsed := TRUE;
    c_expr.expr &:= "prgErrorCount(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_prg_eval (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compilerLibraryUsed := TRUE;
    c_expr.expr &:= "prgEval(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_prg_exec (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compilerLibraryUsed := TRUE;
    c_expr.expr &:= "prgExec(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_prg_fil_parse (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compilerLibraryUsed := TRUE;
    c_expr.expr &:= "prgFilParse(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_prg_match (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compilerLibraryUsed := TRUE;
    c_expr.expr &:= "prgMatch(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_prg_match_expr (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compilerLibraryUsed := TRUE;
    c_expr.expr &:= "prgMatchExpr(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_prg_name (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "arg_0";
  end func;


const proc: process_prg_ne (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") != (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_prg_str_parse (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compilerLibraryUsed := TRUE;
    c_expr.expr &:= "prgStrParse(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_prg_syobject (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compilerLibraryUsed := TRUE;
    c_expr.expr &:= "prgSyobject(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_prg_sysvar (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compilerLibraryUsed := TRUE;
    c_expr.expr &:= "prgSysvar((progtype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "), ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_prg_value (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compilerLibraryUsed := TRUE;
    c_expr.expr &:= "prgValue(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_addr (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "&(";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_alloc (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compDataLibraryUsed := TRUE;
    c_expr.expr &:= "refAlloc(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_arrmaxidx (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compDataLibraryUsed := TRUE;
    c_expr.expr &:= "refArrmaxidx(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_arrminidx (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compDataLibraryUsed := TRUE;
    c_expr.expr &:= "refArrminidx(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_arrtolist (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compDataLibraryUsed := TRUE;
    c_expr.expr &:= "refArrtolist(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_body (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compDataLibraryUsed := TRUE;
    c_expr.expr &:= "refBody(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_category (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compDataLibraryUsed := TRUE;
    c_expr.expr &:= "refCategory(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_cat_parse (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compDataLibraryUsed := TRUE;
    c_expr.expr &:= "refCatParse(";
    getAnyParamToExpr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_cat_str (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compDataLibraryUsed := TRUE;
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "refCatStr(";
    getStdParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_ref_conv (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "=(";
    if c_param3.result_expr <> "" then
      c_expr.expr &:= c_param3.result_expr;
    else
      c_expr.expr &:= c_param3.expr;
    end if;
    c_expr.expr &:= ");\n";
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_ref_deref (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "/*ref_deref*/ *((long *)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_ref_eq (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") == (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_file (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compDataLibraryUsed := TRUE;
    c_expr.expr &:= "refFile(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_hashcode (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(inttype)(((uinttype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")) >> 6)";
  end func;


const proc: process_ref_hshdatatolist (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compDataLibraryUsed := TRUE;
    c_expr.expr &:= "refHshDataToList(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_hshkeytolist (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compDataLibraryUsed := TRUE;
    c_expr.expr &:= "refHshKeyToList(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_isvar (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compDataLibraryUsed := TRUE;
    c_expr.expr &:= "refIsVar(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_itftosct (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compDataLibraryUsed := TRUE;
    c_expr.expr &:= "refItftosct(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_line (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compDataLibraryUsed := TRUE;
    c_expr.expr &:= "refLine(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_local_consts (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compDataLibraryUsed := TRUE;
    c_expr.expr &:= "refLocalConsts(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_local_vars (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compDataLibraryUsed := TRUE;
    c_expr.expr &:= "refLocalVars(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_ne (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") != (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_num (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compDataLibraryUsed := TRUE;
    c_expr.expr &:= "refNum(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_params (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compDataLibraryUsed := TRUE;
    c_expr.expr &:= "refParams(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_resini (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compDataLibraryUsed := TRUE;
    c_expr.expr &:= "refResini(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_result (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compDataLibraryUsed := TRUE;
    c_expr.expr &:= "refResult(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_scttolist (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compDataLibraryUsed := TRUE;
    c_expr.expr &:= "refScttolist(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_select (in reference: function, in ref_list: params,
    inout expr_type: c_expr) is func

  local
    var type: object_type is void;
    var reference: params1 is NIL;
  begin
    object_type := getExprResultType(params[1]);
    if object_type in struct_elements and params[3] in struct_elements[object_type] then
      c_expr.expr &:= "(*((structtype *)(";
      getAnyParamToExpr(params[1], c_expr);
      c_expr.expr &:= ")))->stru[";
      c_expr.expr &:= str(struct_elements[object_type][params[3]]);
      c_expr.expr &:= "]";
      c_expr.expr &:= select_value_from_rtlObjectstruct(result_type(getType(function)));
      c_expr.expr &:= "/*->o_";
      create_name2(params[3], c_expr.expr);
      c_expr.expr &:= "*/";
    else
      if result_type(getType(function)) = floattype then
        c_expr.expr &:= "*refFSelect(";
      else
        c_expr.expr &:= "*refSelect(";
      end if;
      getAnyParamToExpr(params[1], c_expr);
      c_expr.expr &:= ", ";
      create_name(params[3], c_expr.expr);
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process_ref_setcategory (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compDataLibraryUsed := TRUE;
    c_expr.expr &:= "refSetCategory(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_ref_setparams (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compDataLibraryUsed := TRUE;
    c_expr.expr &:= "refSetParams(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    getAnyParamToExpr(params[2], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_ref_settype (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compDataLibraryUsed := TRUE;
    c_expr.expr &:= "refSetType(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_ref_setvar (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compDataLibraryUsed := TRUE;
    c_expr.expr &:= "refSetVar(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_ref_str (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compDataLibraryUsed := TRUE;
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "refStr((objreftype)(";
    getStdParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= "))";
  end func;


const proc: process_ref_trace (in ref_list: params, inout expr_type: c_expr) is func

  local
    var reference: traceParam is NIL;
    var type: object_type is void;
  begin
    traceParam := params[1];
    object_type := getExprResultType(traceParam);
    if isVar(traceParam) then
      c_expr.expr &:= "printf(\"var %s: %s is \", ";
    else
      c_expr.expr &:= "printf(\"const %s: %s is \", ";
    end if;
    c_expr.expr &:= c_literal(str(object_type));
    c_expr.expr &:= ", ";
    c_expr.expr &:= c_literal(str(traceParam));
    c_expr.expr &:= ");\n";
    if object_type = inttype then
      c_expr.expr &:= "printf(\"<INTOBJECT> %ld\", ";
      process_expr(traceParam, c_expr);
      c_expr.expr &:= ")";
    elsif object_type = biginttype then
      c_expr.expr &:= "printf(\"<BIGINTOBJECT>\")";
    elsif object_type = chartype then
      c_expr.expr &:= "printf(\"<CHAROBJECT> %c\", ";
      process_expr(traceParam, c_expr);
      c_expr.expr &:= ")";
    elsif object_type = stritype then
      c_expr.expr &:= "printf(\"<STRIOBJECT>\"); ";
      c_expr.expr &:= "filPrint(";
      process_expr(traceParam, c_expr);
      c_expr.expr &:= ")";
    elsif object_type in bstri_types then
      c_expr.expr &:= "printf(\"<BSTRIOBJECT>\")";
    elsif object_type = floattype then
      c_expr.expr &:= "printf(\"<FLOATOBJECT> %f\", ";
      process_expr(traceParam, c_expr);
      c_expr.expr &:= ")";
    elsif object_type = typetype then
      c_expr.expr &:= "printf(\"<TYPEOBJECT> %X\", ";
      process_expr(traceParam, c_expr);
      c_expr.expr &:= ")";
    elsif object_type = proctype then
      c_expr.expr &:= "printf(\"<CALLOBJECT> %X\", ";
      process_expr(traceParam, c_expr);
      c_expr.expr &:= ")";
    elsif object_type = wintype then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= "wintype win = (wintype)(";
      process_expr(traceParam, c_expr);
      c_expr.expr &:= ");\n";
      c_expr.expr &:= "printf(\"<WINOBJECT>\");\n";
      c_expr.expr &:= "if (win == NULL) {\n";
      c_expr.expr &:= "printf(\" *NULL_WINDOW* \");\n";
      c_expr.expr &:= "} else {\n";
      c_expr.expr &:= "printf(\" window [%lu] %lu\", win->usage_count, win);\n";
      c_expr.expr &:= "}\n";
      c_expr.expr &:= "}\n";
    elsif object_type in int_types then
      c_expr.expr &:= "printf(\"<INTOBJECT> %ld\", ";
      process_expr(traceParam, c_expr);
      c_expr.expr &:= ")";
    elsif object_type in enum_types then
      c_expr.expr &:= "printf(\"<ENUMOBJECT>\")";
    elsif object_type in ref_list_types then
      c_expr.expr &:= "printf(\"<REFLISTOBJECT>\")";
    elsif object_type in set_types then
      c_expr.expr &:= "printf(\"<SETOBJECT>\")";
    elsif object_type in simple_pod_type then
      c_expr.expr &:= "printf(\"<simple_pod_type>\")";
    elsif object_type in array_element then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= "arraytype arr = (arraytype)(";
      process_expr(traceParam, c_expr);
      c_expr.expr &:= ");\n";
      c_expr.expr &:= "printf(\"<ARRAYOBJECT>\");\n";
      c_expr.expr &:= "if (arr == NULL) {\n";
      c_expr.expr &:= "printf(\" *NULL_ARRAY* \");\n";
      c_expr.expr &:= "} else {\n";
      c_expr.expr &:= "printf(\" array[%ld .. %ld]\", arr->min_position, arr->max_position);\n";
      c_expr.expr &:= "}\n";
      c_expr.expr &:= "}\n";
    elsif object_type in isHashType then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= "hashtype hsh = (hashtype)(";
      process_expr(traceParam, c_expr);
      c_expr.expr &:= ");\n";
      c_expr.expr &:= "printf(\"<HASHOBJECT>\");\n";
      c_expr.expr &:= "if (hsh == NULL) {\n";
      c_expr.expr &:= "printf(\" *NULL_HASH* \");\n";
      c_expr.expr &:= "} else {\n";
      c_expr.expr &:= "printf(\" hash[%ld]\", hsh->size);\n";
      c_expr.expr &:= "}\n";
      c_expr.expr &:= "}\n";
    elsif object_type in struct_elements then
      c_expr.expr &:= "printf(\"<STRUCTOBJECT>\")";
    elsif object_type in isInterfaceType then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= "interfacetype itf = (interfacetype)(";
      process_expr(traceParam, c_expr);
      c_expr.expr &:= ");\n";
      c_expr.expr &:= "printf(\"<INTERFACEOBJECT>\");\n";
      c_expr.expr &:= "if (itf == NULL) {\n";
      c_expr.expr &:= "printf(\" *NULL_INTERFACE* \");\n";
      c_expr.expr &:= "} else {\n";
      c_expr.expr &:= "printf(\" type_num=%lu %lx\", itf->type_num, itf);\n";
      c_expr.expr &:= "}\n";
      c_expr.expr &:= "}\n";
    else
      c_expr.expr &:= "printf(\"< ?? >\")";
    end if;
    c_expr.expr &:= ";";
  end func;


const proc: process_ref_type (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compDataLibraryUsed := TRUE;
    c_expr.expr &:= "refType((objreftype)";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_value (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compDataLibraryUsed := TRUE;
    c_expr.expr &:= "refValue(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_rfl_append (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    compDataLibraryUsed := TRUE;
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    getTemporaryToResultExpr(params[3], c_param3);
    if has_temp_values(c_param3) then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    c_expr.expr &:= "rflAppend(&(";
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "), ";
    c_expr.expr &:= c_param3.result_expr;
    c_expr.expr &:= ");\n";
    if has_temp_values(c_param3) then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_rfl_cat (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compDataLibraryUsed := TRUE;
    prepare_list_result(c_expr);
    c_expr.result_expr := "rflCat(";
    getTemporaryToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    getTemporaryToResultExpr(params[3], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_rfl_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    compDataLibraryUsed := TRUE;
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if has_temp_values(c_param3) then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    if c_param3.result_expr <> "" then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= "listtype *rfl_ptr=&(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= ");\n";
      c_expr.expr &:= "listtype old_rfl=*rfl_ptr;\n";
      c_expr.expr &:= "*rfl_ptr=";
      c_expr.expr &:= c_param3.result_expr;
      c_expr.expr &:= ";\n";
      c_expr.expr &:= "rflDestr(old_rfl);\n";
      c_expr.expr &:= "}\n";
    else
      c_expr.expr &:= "rflCpy(&(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "), (listtype)(";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= "));\n";
    end if;
    if has_temp_values(c_param3) then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_rfl_elem (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compDataLibraryUsed := TRUE;
    c_expr.expr &:= "rflElem(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", (listtype)(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_rfl_elemcpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param4 is expr_type.value;
    var expr_type: c_param6 is expr_type.value;
  begin
    compDataLibraryUsed := TRUE;
    process_expr(params[1], c_param1);
    c_param4.temp_num := c_param1.temp_num;
    process_expr(params[4], c_param4);
    c_param6.temp_num := c_param4.temp_num;
    process_expr(params[6], c_param6);
    if c_param6.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param4.temp_decls;
      c_expr.expr &:= c_param6.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param4.temp_assigns;
      c_expr.expr &:= c_param6.temp_assigns;
    end if;
    c_expr.expr &:= "rflElemcpy(";
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= ", ";
    c_expr.expr &:= c_param4.expr;
    c_expr.expr &:= ", ";
    c_expr.expr &:= c_param6.expr;
    c_expr.expr &:= ");\n";
    if c_param6.temp_num <> 0 then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param4.temp_frees;
      c_expr.expr &:= c_param6.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_rfl_eq (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compDataLibraryUsed := TRUE;
    c_expr.expr &:= "rflEq((listtype)(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= "), (listtype)(";
    getAnyParamToExpr(params[3], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_rfl_for (in ref_list: params, inout expr_type: c_expr) is func

  local
    var integer: temp_num is 0;
  begin
    incr(c_expr.temp_num);
    temp_num := c_expr.temp_num;
    c_expr.temp_decls &:= "listtype tmp_elem_";
    c_expr.temp_decls &:= str(temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.expr &:= "{\nfor (tmp_elem_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= " = (listtype)(";
    process_expr(params[4], c_expr);
    c_expr.expr &:= "); tmp_elem_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= " != NULL; tmp_elem_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= " = tmp_elem_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "->next) {\n";
    process_expr(params[2], c_expr);
    c_expr.expr &:= " = tmp_elem_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "->obj;\n";
    process_expr(params[6], c_expr);
    c_expr.expr &:= "}\n}\n";
  end func;


const proc: process_rfl_head (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compDataLibraryUsed := TRUE;
    prepare_list_result(c_expr);
    c_expr.result_expr := "rflHead(";
    getStdParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    getStdParamToResultExpr(params[4], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_rfl_idx (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compDataLibraryUsed := TRUE;
    c_expr.expr &:= "rflIdx((listtype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "), ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_rfl_incl (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param2 is expr_type.value;
  begin
    compDataLibraryUsed := TRUE;
    process_expr(params[1], c_param1);
    c_param2.temp_num := c_param1.temp_num;
    process_expr(params[2], c_param2);
    if c_param2.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param2.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param2.temp_assigns;
    end if;
    c_expr.expr &:= "rflIncl(&(";
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "), ";
    c_expr.expr &:= c_param2.expr;
    c_expr.expr &:= ");\n";
    if c_param2.temp_num <> 0 then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param2.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_rfl_ipos (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compDataLibraryUsed := TRUE;
    c_expr.expr &:= "rflIpos(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_rfl_lng (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compDataLibraryUsed := TRUE;
    c_expr.expr &:= "rflLng((listtype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_rfl_mklist (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compDataLibraryUsed := TRUE;
    prepare_list_result(c_expr);
    c_expr.result_expr := "rflMklist(";
    getStdParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_rfl_ne (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compDataLibraryUsed := TRUE;
    c_expr.expr &:= "rflNe((listtype)(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= "), (listtype)(";
    getAnyParamToExpr(params[3], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_rfl_not_elem (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compDataLibraryUsed := TRUE;
    c_expr.expr &:= "!rflElem(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", (listtype)(";
    process_expr(params[4], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_rfl_pos (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compDataLibraryUsed := TRUE;
    c_expr.expr &:= "rflPos(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_rfl_setvalue (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compDataLibraryUsed := TRUE;
    c_expr.expr &:= "rflSetvalue(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    getAnyParamToExpr(params[2], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_rfl_tail (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compDataLibraryUsed := TRUE;
    prepare_list_result(c_expr);
    c_expr.result_expr := "rflTail(";
    getStdParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    getStdParamToResultExpr(params[3], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_rfl_value (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compDataLibraryUsed := TRUE;
    incr(c_expr.temp_num);
    c_expr.temp_decls &:= "listtype tmp_";
    c_expr.temp_decls &:= str(c_expr.temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_frees &:= "rflDestr(tmp_";
    c_expr.temp_frees &:= str(c_expr.temp_num);
    c_expr.temp_frees &:= ");\n";
    c_expr.expr &:= "(tmp_";
    c_expr.expr &:= str(c_expr.temp_num);
    c_expr.expr &:= "=rflValue((objreftype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")))";
  end func;


const proc: process_scr_clear (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "scrClear(";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_scr_cursor (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "scrCursor(";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_scr_flush (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "scrFlush();\n";
  end func;


const proc: process_scr_height (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "scrHeight()";
  end func;


const proc: process_scr_h_scl (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "scrHScroll(";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[6], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_scr_open (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "scrOpen();\n";
  end func;


const proc: process_scr_setpos (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "scrSetpos(";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_scr_v_scl (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "scrVScroll(";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[6], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_scr_width (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "scrWidth()";
  end func;


const proc: process_scr_write (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "scrWrite(";
    getAnyParamToExpr(params[2], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_sct_alloc (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
  begin
    # prepare_struct_result(getExprResultType(params[1]), c_expr);
    prepareAnyParamTemporarys(params[1], c_param1, c_expr);
    c_expr.expr &:= "/* SCT_ALLOC */ ";
    if c_param1.result_expr <> "" then
      c_expr.expr &:= c_param1.result_expr;
    else
      process_create_declaration(getExprResultType(params[1]), global_c_expr);
      process_create_call(getExprResultType(params[1]),
          c_param1.expr, c_expr.expr);
    end if;
  end func;


const proc: process_sct_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if has_temp_values(c_param3) then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    if c_param3.result_expr <> "" then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= "structtype *struct_ptr=&(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= ");\n";
      c_expr.expr &:= "structtype old_struct=*struct_ptr;\n";
      c_expr.expr &:= "*struct_ptr=(structtype)(";
      c_expr.expr &:= c_param3.result_expr;
      c_expr.expr &:= ");\n";
      c_expr.expr &:= "(*struct_ptr)->type_num = old_struct->type_num;\n";
      process_destr_declaration(getExprResultType(params[1]), global_c_expr);
      process_destr_call(getExprResultType(params[1]),
          "old_struct", c_expr.expr);
      c_expr.expr &:= "}\n";
    else
      process_cpy_declaration(getExprResultType(params[1]), global_c_expr);
      process_cpy_call(getExprResultType(params[1]),
          c_param1.expr, c_param3.expr, c_expr.expr);
      c_expr.expr &:= ";\n";
    end if;
    if has_temp_values(c_param3) then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_sct_select (in reference: function, in ref_list: params,
    inout expr_type: c_expr) is func

  local
    var type: object_type is void;
    var reference: params1 is NIL;
  begin
    object_type := getExprResultType(params[1]);
    if object_type in struct_elements and params[3] in struct_elements[object_type] then
      c_expr.expr &:= "((structtype)(";
      getAnyParamToExpr(params[1], c_expr);
      c_expr.expr &:= "))->stru[";
      c_expr.expr &:= str(struct_elements[object_type][params[3]]);
      c_expr.expr &:= "]";
      c_expr.expr &:= select_value_from_rtlObjectstruct(result_type(getType(function)));
      c_expr.expr &:= "/*->o_";
      create_name2(params[3], c_expr.expr);
      c_expr.expr &:= "*/";
    else
      if result_type(getType(function)) = floattype then
        c_expr.expr &:= "*sctFSelect(";
      else
        c_expr.expr &:= "*sctSelect(";
      end if;
      getAnyParamToExpr(params[1], c_expr);
      c_expr.expr &:= ", ";
      create_name(params[3], c_expr.expr);
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process_set_arrlit (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_set_result(c_expr);
    c_expr.result_expr := "setArrlit((inttype)(";
    getAnyParamToResultExpr(params[2], c_expr);
    c_expr.result_expr &:= "))";
  end func;


const proc: process_set_baselit (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_set_result(c_expr);
    c_expr.result_expr := "setBaselit(";
    getStdParamToResultExpr(params[2], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_set_card (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "setCard((settype)(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_set_conv (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_set_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if has_temp_values(c_param3) then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    if c_param3.result_expr <> "" then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= "settype *set_ptr=&(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= ");\n";
      c_expr.expr &:= "settype old_set=*set_ptr;\n";
      c_expr.expr &:= "*set_ptr=(settype)(";
      c_expr.expr &:= c_param3.result_expr;
      c_expr.expr &:= ");\n";
      c_expr.expr &:= "setDestr(old_set);\n";
      c_expr.expr &:= "}\n";
    else
      c_expr.expr &:= "setCpy(&(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "), (settype)(";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= "));\n";
    end if;
    if has_temp_values(c_param3) then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_set_diff (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_set_result(c_expr);
    c_expr.result_expr := "setDiff((settype)(";
    getAnyParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= "), (settype)(";
    getAnyParamToResultExpr(params[3], c_expr);
    c_expr.result_expr &:= "))";
  end func;


const proc: process_set_elem (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "setElem(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", (settype)(";
    getAnyParamToExpr(params[3], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_set_eq (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "setEq((settype)(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= "), (settype)(";
    getAnyParamToExpr(params[3], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_set_excl (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param2 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param2.temp_num := c_param1.temp_num;
    process_expr(params[2], c_param2);
    if c_param2.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param2.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param2.temp_assigns;
    end if;
    c_expr.expr &:= "setExcl(&(";
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "), ";
    c_expr.expr &:= c_param2.expr;
    c_expr.expr &:= ");\n";
    if c_param2.temp_num <> 0 then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param2.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_set_ge (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "setGe((settype)(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= "), (settype)(";
    getAnyParamToExpr(params[3], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_set_gt (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "setGt((settype)(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= "), (settype)(";
    getAnyParamToExpr(params[3], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_set_hashcode (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "setHashCode((settype)(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_set_iconv (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "setIConv(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_set_incl (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param2 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param2.temp_num := c_param1.temp_num;
    process_expr(params[2], c_param2);
    if c_param2.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param2.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param2.temp_assigns;
    end if;
    c_expr.expr &:= "setIncl(&(";
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "), ";
    c_expr.expr &:= c_param2.expr;
    c_expr.expr &:= ");\n";
    if c_param2.temp_num <> 0 then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param2.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_set_intersect (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_set_result(c_expr);
    c_expr.result_expr := "setIntersect((settype)(";
    getAnyParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= "), (settype)(";
    getAnyParamToResultExpr(params[3], c_expr);
    c_expr.result_expr &:= "))";
  end func;


const proc: process_set_le (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "setLe((settype)(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= "), (settype)(";
    getAnyParamToExpr(params[3], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_set_lt (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "setLt((settype)(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= "), (settype)(";
    getAnyParamToExpr(params[3], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_set_max (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "setMax((settype)(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_set_min (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "setMin((settype)(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_set_ne (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "setNe((settype)(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= "), (settype)(";
    getAnyParamToExpr(params[3], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_set_not_elem (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "setNotElem(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", (settype)(";
    getAnyParamToExpr(params[4], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_set_rand (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "setRand((settype)(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_set_sconv (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "setSConv(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_set_symdiff (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_set_result(c_expr);
    c_expr.result_expr := "setSymdiff(";
    getAnyParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    getAnyParamToResultExpr(params[3], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_set_union (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_set_result(c_expr);
    c_expr.result_expr := "setUnion((settype)(";
    getAnyParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= "), (settype)(";
    getAnyParamToResultExpr(params[3], c_expr);
    c_expr.result_expr &:= "))";
  end func;


const proc: process_set_value (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "setValue(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_soc_accept (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "socAccept(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", &(";
    getAnyParamToExpr(params[2], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_soc_bind (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "socBind(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", (bstritype)(";
    getAnyParamToExpr(params[2], c_expr);
    c_expr.expr &:= "));\n";
  end func;


const proc: process_soc_close (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "socClose(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_soc_connect (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "socConnect(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", (bstritype)(";
    getAnyParamToExpr(params[2], c_expr);
    c_expr.expr &:= "));\n";
  end func;


const proc: process_soc_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "=(";
    if c_param3.result_expr <> "" then
      c_expr.expr &:= c_param3.result_expr;
    else
      c_expr.expr &:= c_param3.expr;
    end if;
    c_expr.expr &:= ");\n";
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_soc_eq (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") == (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_soc_getc (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "socGetc(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_soc_gets (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "socGets(";
    getStdParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    getStdParamToResultExpr(params[2], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_soc_inet_addr (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_bstri_result(c_expr);
    c_expr.result_expr &:= "socInetAddr(";
    getStdParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    getStdParamToResultExpr(params[2], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_soc_inet_local_addr (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_bstri_result(c_expr);
    c_expr.result_expr &:= "socInetLocalAddr(";
    getStdParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_soc_inet_serv_addr (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_bstri_result(c_expr);
    c_expr.result_expr &:= "socInetServAddr(";
    getStdParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_soc_line_read (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "socLineRead(";
    getStdParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ", &(";
    getStdParamToResultExpr(params[2], c_expr);
    c_expr.result_expr &:= "))";
  end func;


const proc: process_soc_listen (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "socListen(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_soc_ne (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") != (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_soc_recv (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "socRecv(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", &(";
    getAnyParamToExpr(params[2], c_expr);
    c_expr.expr &:= "), ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_soc_send (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "socSend(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    getAnyParamToExpr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_soc_socket (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "socSocket(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_soc_word_read (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "socWordRead(";
    getStdParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ", &(";
    getStdParamToResultExpr(params[2], c_expr);
    c_expr.result_expr &:= "))";
  end func;


const proc: process_soc_write (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "socWrite(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    getAnyParamToExpr(params[2], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_str_append (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if has_temp_values(c_param3) or c_param3.result_expr <> "" then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param3.result_decl;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    c_expr.expr &:= "strAppend(&(";
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "), (stritype)(";
    if c_param3.result_expr <> "" then
      c_expr.expr &:= c_param3.result_intro;
      c_expr.expr &:= c_param3.result_expr;
      c_expr.expr &:= c_param3.result_finish;
    else
      c_expr.expr &:= c_param3.expr;
    end if;
    c_expr.expr &:= "));\n";
    if has_temp_values(c_param3) or c_param3.result_expr <> "" then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= c_param3.result_free;
      c_expr.expr &:= "}\n";
    end if;
  end func;


(*
const func string: evaluate_const_str_cat (in reference: param1, in string: stri2) is func
  result
    var string: result is "";
  local
    var ref_list: param_list is ref_list.EMPTY;
    var string: action_name is "";
  begin
    if category(param1) = STRIOBJECT and not isVar(param1) and
      result := getValue(param1, string) & stri2;
    else
      if category(param1) = CALLOBJECT then
        param_list := getValue(param1, ref_list);
        if category(param_list[1]) = ACTOBJECT then
          action_name := str(getValue(param_list[1], ACTION));
          if action_name = "STR_CAT" then
            if category(param_list[4]) = STRIOBJECT and not isVar(param_list[4]) then
              result := evaluate_const_str_cat(param_list[2],
                  getValue(params[4], string)) & stri2;
            end if;
          end if;
        end if;
      end if;
    end if;
  end func;


const proc: process_const_str_cat (in reference: param1, in string: stri2,
    inout expr_type: c_expr) is func
  local
    var string: stri is "";
  begin
    incr(countOptimizations);
    if category(param1) = STRIOBJECT and not isVar(param1) and
      stri := getValue(param1, string) & stri2;
      if stri not in stri_const_table then
        stri_const_table @:= [stri] length(stri_const_table);
      end if;
      c_expr.expr &:= "str[";
      c_expr.expr &:= str(stri_const_table[stri]);
      c_expr.expr &:= "] /* ";
      c_expr.expr &:= replace(literal(stri), "*/", "*\\/");
      c_expr.expr &:= " */";
  end func;
*)


(**
 *  Produces code for the string concatenation.
 *  When the first parameter is a temporary value the concatenation
 *  is done with strConcatTemp. The strConcatTemp function returns
 *  the first parameter as result of the concatenation. That way the
 *  temporary of the first parameter must not be freed.
 *)
const proc: process_str_cat (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
  begin
    prepare_stri_result(c_expr);
    prepareAnyParamTemporarys(params[1], c_param1, c_expr);
    if c_param1.result_expr <> "" then
      c_expr.result_expr := "strConcatTemp((stritype)(";
      c_expr.result_expr &:= c_param1.result_expr;
    else
      c_expr.result_expr := "strConcat((stritype)(";
      c_expr.result_expr &:= c_param1.expr;
    end if;
    c_expr.result_expr &:= "), (stritype)(";
    getAnyParamToResultExpr(params[3], c_expr);
    c_expr.result_expr &:= "))";
  end func;


const proc: process_str_chipos (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "strChIpos(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_str_chpos (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "strChPos(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_str_chsplit (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_array_result(array_type[getExprResultType(params[1])], c_expr);
    c_expr.result_expr := "strChSplit(";
    getAnyParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    getStdParamToResultExpr(params[2], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_str_clit (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr := "strCLit(";
    getAnyParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_str_cmp (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "strCompare((stritype)(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= "), (stritype)(";
    getAnyParamToExpr(params[2], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_str_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if has_temp_values(c_param3) then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    if c_param3.result_expr <> "" then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= "stritype *stri_ptr=&(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= ");\n";
      c_expr.expr &:= "stritype old_stri=*stri_ptr;\n";
      c_expr.expr &:= "*stri_ptr=";
      c_expr.expr &:= c_param3.result_expr;
      c_expr.expr &:= ";\n";
      c_expr.expr &:= "strDestr(old_stri);\n";
      c_expr.expr &:= "}\n";
    else
      c_expr.expr &:= "strCopy(&(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "), (stritype)(";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= "));\n";
    end if;
    if has_temp_values(c_param3) then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_const_str_elemcpy (in reference: function, in reference: param1,
    in integer: index, in reference: param6, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param6 is expr_type.value;
  begin
    incr(countOptimizations);
    if index < 1 then
      c_expr.expr &:= "/* 'string @:= [n] char' with n < 1 */\n";
      process_raise_error("RANGE_ERROR", function, c_expr);
      c_expr.expr &:= ";\n";
    else
      process_expr(param1, c_param1);
      c_param6.temp_num := c_param1.temp_num;
      process_expr(param6, c_param6);
      if c_param6.temp_num <> 0 or array_range_check then
        c_expr.expr &:= "{\n";
      end if;
      if c_param6.temp_num <> 0 then
        c_expr.expr &:= c_param1.temp_decls;
        c_expr.expr &:= c_param6.temp_decls;
        c_expr.expr &:= c_param1.temp_assigns;
        c_expr.expr &:= c_param6.temp_assigns;
      end if;
      if array_range_check then
        c_expr.expr &:= "stritype str1=";
        c_expr.expr &:= c_param1.expr;
        c_expr.expr &:= ";\n";
        c_expr.expr &:= "if (";
        c_expr.expr &:= str(pred(index));
        c_expr.expr &:= " >= str1->size) {\n";
        c_expr.expr &:= "  ";
        process_raise_error("RANGE_ERROR", function, c_expr);
        c_expr.expr &:= ";\n";
        c_expr.expr &:= "} else {\n";
        c_expr.expr &:= "  str1->mem[";
        c_expr.expr &:= str(pred(index));
        c_expr.expr &:= "] = (strelemtype)(";
        c_expr.expr &:= c_param6.expr;
        c_expr.expr &:= ");\n";
        c_expr.expr &:= "}\n";
      else
        c_expr.expr &:= "((stritype)(";
        c_expr.expr &:= c_param1.expr;
        c_expr.expr &:= "))->mem[";
        c_expr.expr &:= str(pred(index));
        c_expr.expr &:= "] = (strelemtype)(";
        c_expr.expr &:= c_param6.expr;
        c_expr.expr &:= ");\n";
      end if;
      if c_param6.temp_num <> 0 then
        c_expr.expr &:= c_param1.temp_frees;
        c_expr.expr &:= c_param6.temp_frees;
      end if;
      if c_param6.temp_num <> 0 or array_range_check then
        c_expr.expr &:= "}\n";
      end if;
    end if;
  end func;


const proc: process_str_elemcpy (in reference: function, in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param4 is expr_type.value;
    var expr_type: c_param6 is expr_type.value;
  begin
    if category(params[4]) = INTOBJECT and not isVar(params[4]) then
      process_const_str_elemcpy(function, params[1], getValue(params[4], integer), params[6], c_expr);
    else
      process_expr(params[1], c_param1);
      c_param4.temp_num := c_param1.temp_num;
      process_expr(params[4], c_param4);
      c_param6.temp_num := c_param4.temp_num;
      process_expr(params[6], c_param6);
      if c_param6.temp_num <> 0 or array_range_check then
        c_expr.expr &:= "{\n";
      end if;
      if c_param6.temp_num <> 0 then
        c_expr.expr &:= c_param1.temp_decls;
        c_expr.expr &:= c_param4.temp_decls;
        c_expr.expr &:= c_param6.temp_decls;
        c_expr.expr &:= c_param1.temp_assigns;
        c_expr.expr &:= c_param4.temp_assigns;
        c_expr.expr &:= c_param6.temp_assigns;
      end if;
      if array_range_check then
        c_expr.expr &:= "stritype str1=";
        c_expr.expr &:= c_param1.expr;
        c_expr.expr &:= ";\n";
        if TWOS_COMPLEMENT_INTTYPE then
          c_expr.expr &:= "memsizetype pos=(";
        else
          c_expr.expr &:= "inttype pos=(";
        end if;
        c_expr.expr &:= c_param4.expr;
        c_expr.expr &:= ")-1;\n";
        c_expr.expr &:= "if (";
        if not TWOS_COMPLEMENT_INTTYPE then
          c_expr.expr &:= "pos < 0 && ";
        end if;
        c_expr.expr &:= "pos >= str1->size) {\n";
        c_expr.expr &:= "  ";
        process_raise_error("RANGE_ERROR", function, c_expr);
        c_expr.expr &:= ";\n";
        c_expr.expr &:= "} else {\n";
        c_expr.expr &:= "  str1->mem[pos] = (strelemtype)(";
        c_expr.expr &:= c_param6.expr;
        c_expr.expr &:= ");\n";
        c_expr.expr &:= "}\n";
      else
        c_expr.expr &:= "((stritype)(";
        c_expr.expr &:= c_param1.expr;
        c_expr.expr &:= "))->mem[(";
        c_expr.expr &:= c_param4.expr;
        c_expr.expr &:= ")-1] = (strelemtype)(";
        c_expr.expr &:= c_param6.expr;
        c_expr.expr &:= ");\n";
      end if;
      if c_param6.temp_num <> 0 then
        c_expr.expr &:= c_param1.temp_frees;
        c_expr.expr &:= c_param4.temp_frees;
        c_expr.expr &:= c_param6.temp_frees;
      end if;
      if c_param6.temp_num <> 0 or array_range_check then
        c_expr.expr &:= "}\n";
      end if;
    end if;
  end func;


const proc: process_const_str_eq (in reference: param1, in string: stri,
    inout expr_type: c_expr) is func

  local
    var integer: temp_num is 0;
  begin
    incr(countOptimizations);
    if category(param1) = STRIOBJECT and not isVar(param1) then
      c_expr.expr &:= "/* ";
      c_expr.expr &:= replace(literal(getValue(param1, string)), "*/", "*\\/");
      c_expr.expr &:= " == ";
      c_expr.expr &:= replace(literal(stri), "*/", "*\\/");
      c_expr.expr &:= " */ ";
      if getValue(param1, string) = stri then
        c_expr.expr &:= "1";
      else
        c_expr.expr &:= "0";
      end if;
    elsif stri = "" then
      c_expr.expr &:= "(((stritype)(";
      getAnyParamToExpr(param1, c_expr);
      c_expr.expr &:= "))->size==0 /* \"\" */)";
    elsif length(stri) = 1 then
      incr(c_expr.temp_num);
      temp_num := c_expr.temp_num;
      c_expr.temp_decls &:= "stritype tmp_";
      c_expr.temp_decls &:= str(temp_num);
      c_expr.temp_decls &:= ";\n";
      (* Formula used: (a->size==1&&a->mem[0]==b->mem[0]) *)
      c_expr.expr &:= "(tmp_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "=(";
      getAnyParamToExpr(param1, c_expr);
      c_expr.expr &:= "),tmp_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "->size==1&&tmp_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "->mem[0]==";
      c_expr.expr &:= str(ord(stri[1]));
      c_expr.expr &:= " /* ";
      c_expr.expr &:= literal(stri);
      c_expr.expr &:= " */)";
    else
      if stri not in stri_const_table then
        stri_const_table @:= [stri] length(stri_const_table);
      end if;
      incr(c_expr.temp_num);
      temp_num := c_expr.temp_num;
      c_expr.temp_decls &:= "stritype tmp_";
      c_expr.temp_decls &:= str(temp_num);
      c_expr.temp_decls &:= ";\n";
      (* Formula used: (a->size==b->size&&memcmp(a->mem,b->mem,
                       a->size*sizeof(strelemtype))==0) *)
      c_expr.expr &:= "(tmp_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "=(";
      getAnyParamToExpr(param1, c_expr);
      c_expr.expr &:= "),tmp_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "->size==";
      c_expr.expr &:= str(length(stri));
      c_expr.expr &:= "&&memcmp(tmp_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "->mem,str[";
      c_expr.expr &:= str(stri_const_table[stri]);
      c_expr.expr &:= "] /* ";
      c_expr.expr &:= replace(literal(stri), "*/", "*\\/");
      c_expr.expr &:= " */->mem,";
      c_expr.expr &:= str(length(stri));
      c_expr.expr &:= "*sizeof(strelemtype))==0)";
    end if;
  end func;


const proc: process_str_eq (in ref_list: params, inout expr_type: c_expr) is func

  local
    var integer: temp_num is 0;
  begin
    if category(params[3]) = STRIOBJECT and not isVar(params[3]) then
      process_const_str_eq(params[1], getValue(params[3], string), c_expr);
    elsif category(params[1]) = STRIOBJECT and not isVar(params[1]) then
      process_const_str_eq(params[3], getValue(params[1], string), c_expr);
    else
      incr(c_expr.temp_num);
      temp_num := c_expr.temp_num;
      c_expr.temp_decls &:= "stritype tmp_a_";
      c_expr.temp_decls &:= str(temp_num);
      c_expr.temp_decls &:= ";\n";
      c_expr.temp_decls &:= "stritype tmp_b_";
      c_expr.temp_decls &:= str(temp_num);
      c_expr.temp_decls &:= ";\n";
      (* Formula used: (a->size==b->size&&memcmp(a->mem,b->mem,
                       a->size*sizeof(strelemtype))==0) *)
      c_expr.expr &:= "(tmp_a_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "=(stritype)(";
      getAnyParamToExpr(params[1], c_expr);
      c_expr.expr &:= "),tmp_b_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "=(stritype)(";
      getAnyParamToExpr(params[3], c_expr);
      c_expr.expr &:= "),tmp_a_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "->size==tmp_b_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "->size&&memcmp(tmp_a_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "->mem,tmp_b_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "->mem,tmp_a_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "->size*sizeof(strelemtype))==0)";
    end if;
  end func;


const proc: process_str_ge (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "strGe((stritype)(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= "), (stritype)(";
    getAnyParamToExpr(params[3], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_str_getenv (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr := "strGetenv(";
    getAnyParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_str_gt (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "strGt((stritype)(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= "), (stritype)(";
    getAnyParamToExpr(params[3], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_str_hashcode (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "strHashCode(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_str_head (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "strHead(";
    getAnyParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    getStdParamToResultExpr(params[4], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_const_str_idx (in reference: function, in string: stri,
    in reference: param3, inout expr_type: c_expr) is func

  local
    var integer: index is 0;
    var integer: index_temp_num is 0;
  begin
    incr(countOptimizations);
    if category(param3) = INTOBJECT and not isVar(param3) then
      index := getValue(param3, integer);
      if index < 1 or index > length(stri) then
        process_raise_error("RANGE_ERROR", function, c_expr);
      else
        c_expr.expr &:=  c_literal(stri[index]);
      end if;
    else
      if stri not in stri_const_table then
        stri_const_table @:= [stri] length(stri_const_table);
      end if;
      c_expr.expr &:= "str[";
      c_expr.expr &:= str(stri_const_table[stri]);
      c_expr.expr &:= "] /* ";
      c_expr.expr &:= replace(literal(stri), "*/", "*\\/");
      c_expr.expr &:= " */->mem[";
      if array_range_check then
        incr(c_expr.temp_num);
        index_temp_num := c_expr.temp_num;
        if TWOS_COMPLEMENT_INTTYPE then
          c_expr.temp_decls &:= "memsizetype tmp_";
        else
          c_expr.temp_decls &:= "inttype tmp_";
        end if;
        c_expr.temp_decls &:= str(index_temp_num);
        c_expr.temp_decls &:= ";\n";
        c_expr.expr &:= "(tmp_";
        c_expr.expr &:= str(index_temp_num);
        c_expr.expr &:= "=(";
        process_expr(param3, c_expr);
        c_expr.expr &:= ")-1, tmp_";
        if not TWOS_COMPLEMENT_INTTYPE then
          c_expr.expr &:= str(index_temp_num);
          c_expr.expr &:= "<0 || tmp_";
        end if;
        c_expr.expr &:= str(index_temp_num);
        c_expr.expr &:= ">=";
        c_expr.expr &:= str(length(stri));
        c_expr.expr &:= " ? ";
        process_raise_error("RANGE_ERROR", function, c_expr);
        c_expr.expr &:= " : 0, tmp_";
        c_expr.expr &:= str(index_temp_num);
        c_expr.expr &:= ")";
      else
        c_expr.expr &:= "(";
        process_expr(param3, c_expr);
        c_expr.expr &:= ")-1";
      end if;
      c_expr.expr &:= "]";
    end if;
  end func;


const proc: process_const_str_idx (in reference: function, in reference: param1,
    in integer: index, inout expr_type: c_expr) is func

  local
    var integer: string_temp_num is 0;
  begin
    incr(countOptimizations);
    if index < 1 then
      process_raise_error("RANGE_ERROR", function, c_expr);
    elsif array_range_check then
      incr(c_expr.temp_num);
      string_temp_num := c_expr.temp_num;
      c_expr.temp_decls &:= "stritype tmp_";
      c_expr.temp_decls &:= str(string_temp_num);
      c_expr.temp_decls &:= ";\n";
      c_expr.expr &:= "(*(tmp_";
      c_expr.expr &:= str(string_temp_num);
      c_expr.expr &:= "=(stritype)(";
      getAnyParamToExpr(param1, c_expr);
      c_expr.expr &:= "), &tmp_";
      c_expr.expr &:= str(string_temp_num);
      c_expr.expr &:= "->mem[(tmp_";
      c_expr.expr &:= str(string_temp_num);
      c_expr.expr &:= "->size<";
      c_expr.expr &:= str(index);
      c_expr.expr &:= " ? ";
      process_raise_error("RANGE_ERROR", function, c_expr);
      c_expr.expr &:= " : 0, ";
      c_expr.expr &:= str(pred(index));
      c_expr.expr &:= ")";
      c_expr.expr &:= "]))";
    else
      c_expr.expr &:= "((stritype)(";
      getAnyParamToExpr(param1, c_expr);
      c_expr.expr &:= "))->mem[";
      c_expr.expr &:= str(pred(index));
      c_expr.expr &:= "]";
    end if;
  end func;


const proc: process_str_idx (in reference: function, in ref_list: params, inout expr_type: c_expr) is func

  local
    var integer: string_temp_num is 0;
    var integer: index_temp_num is 0;
  begin
    if category(params[1]) = STRIOBJECT and not isVar(params[1]) then
      process_const_str_idx(function, getValue(params[1], string), params[3], c_expr);
    elsif category(params[3]) = INTOBJECT and not isVar(params[3]) then
      process_const_str_idx(function, params[1], getValue(params[3], integer), c_expr);
    elsif array_range_check then
      incr(c_expr.temp_num);
      string_temp_num := c_expr.temp_num;
      c_expr.temp_decls &:= "stritype tmp_";
      c_expr.temp_decls &:= str(string_temp_num);
      c_expr.temp_decls &:= ";\n";
      c_expr.expr &:= "(*(tmp_";
      c_expr.expr &:= str(string_temp_num);
      c_expr.expr &:= "=(stritype)(";
      getAnyParamToExpr(params[1], c_expr);
      c_expr.expr &:= "), &tmp_";
      c_expr.expr &:= str(string_temp_num);
      c_expr.expr &:= "->mem[";
      incr(c_expr.temp_num);
      index_temp_num := c_expr.temp_num;
      if TWOS_COMPLEMENT_INTTYPE then
        c_expr.temp_decls &:= "memsizetype tmp_";
      else
        c_expr.temp_decls &:= "inttype tmp_";
      end if;
      c_expr.temp_decls &:= str(index_temp_num);
      c_expr.temp_decls &:= ";\n";
      c_expr.expr &:= "(tmp_";
      c_expr.expr &:= str(index_temp_num);
      c_expr.expr &:= "=(";
      process_expr(params[3], c_expr);
      c_expr.expr &:= ")-1, tmp_";
      if not TWOS_COMPLEMENT_INTTYPE then
        c_expr.expr &:= str(index_temp_num);
        c_expr.expr &:= "<0 || tmp_";
      end if;
      c_expr.expr &:= str(index_temp_num);
      c_expr.expr &:= ">=tmp_";
      c_expr.expr &:= str(string_temp_num);
      c_expr.expr &:= "->size ? ";
      process_raise_error("RANGE_ERROR", function, c_expr);
      c_expr.expr &:= " : 0, tmp_";
      c_expr.expr &:= str(index_temp_num);
      c_expr.expr &:= ")";
      c_expr.expr &:= "]))";
    else
      c_expr.expr &:= "((stritype)(";
      getAnyParamToExpr(params[1], c_expr);
      c_expr.expr &:= "))->mem[(";
      process_expr(params[3], c_expr);
      c_expr.expr &:= ")-1]";
    end if;
  end func;


const proc: process_str_ipos (in ref_list: params, inout expr_type: c_expr) is func

  begin
    if category(params[2]) = STRIOBJECT and not isVar(params[2]) and
        length(getValue(params[2], string)) = 1 then
      incr(countOptimizations);
      c_expr.expr &:= "strChIpos(";
      getAnyParamToExpr(params[1], c_expr);
      c_expr.expr &:= ", ";
      c_expr.expr &:= c_literal(getValue(params[2], string)[1]);
      c_expr.expr &:= ", ";
      process_expr(params[3], c_expr);
      c_expr.expr &:= ")";
    else
      c_expr.expr &:= "strIpos(";
      getAnyParamToExpr(params[1], c_expr);
      c_expr.expr &:= ", ";
      getAnyParamToExpr(params[2], c_expr);
      c_expr.expr &:= ", ";
      process_expr(params[3], c_expr);
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process_str_le (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "strLe((stritype)(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= "), (stritype)(";
    getAnyParamToExpr(params[3], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_str_lit (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "strLit(";
    getAnyParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_str_lng (in ref_list: params, inout expr_type: c_expr) is func

  local
    var string: stri is "";
  begin
    if category(params[1]) = STRIOBJECT and not isVar(params[1]) then
      incr(countOptimizations);
      stri := getValue(params[1], string);
      c_expr.expr &:= str(length(stri));
      c_expr.expr &:= " /* length(";
      c_expr.expr &:= replace(literal(stri), "*/", "*\\/");
      c_expr.expr &:= ") */";
    else
      c_expr.expr &:= "(inttype)((stritype)(";
      getAnyParamToExpr(params[1], c_expr);
      c_expr.expr &:= "))->size";
    end if;
  end func;


(**
 *  Produces code to return a string converted to lower case.
 *  When the parameter is a temporary value the conversion is done
 *  with strLowTemp. The strLowTemp function returns the parameter as
 *  result of the conversion. That way the temporary of the parameter
 *  must not be freed.
 *)
const proc: process_str_low (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
  begin
    prepare_stri_result(c_expr);
    prepareAnyParamTemporarys(params[1], c_param1, c_expr);
    if c_param1.result_expr <> "" then
      c_expr.result_expr := "strLowTemp(";
      c_expr.result_expr &:= c_param1.result_expr;
    else
      c_expr.result_expr := "strLow(";
      c_expr.result_expr &:= c_param1.expr;
    end if;
    c_expr.result_expr &:= ")";
  end func;


const proc: process_str_lpad (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "strLpad((stritype)(";
    getAnyParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= "), ";
    getStdParamToResultExpr(params[3], c_expr);
    c_expr.result_expr &:= ")";
  end func;


(**
 *  Produces code for the lpad0 operator.
 *  When the first parameter is a temporary value the operation
 *  is done with strLpad0Temp. The strLpad0Temp function returns
 *  the first parameter as result of the operation. That way the
 *  temporary of the first parameter must not be freed.
 *)
const proc: process_str_lpad0 (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
  begin
    prepare_stri_result(c_expr);
    prepareAnyParamTemporarys(params[1], c_param1, c_expr);
    if c_param1.result_expr <> "" then
      c_expr.result_expr := "strLpad0Temp(";
      c_expr.result_expr &:= c_param1.result_expr;
    else
      c_expr.result_expr := "strLpad0(";
      c_expr.result_expr &:= c_param1.expr;
    end if;
    c_expr.result_expr &:= ", ";
    getAnyParamToResultExpr(params[3], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_str_lt (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "strLt((stritype)(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= "), (stritype)(";
    getAnyParamToExpr(params[3], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_str_mult (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "strMult(";
    getAnyParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    getStdParamToResultExpr(params[3], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_const_str_ne (in reference: param1, in string: stri,
    inout expr_type: c_expr) is func

  local
    var integer: temp_num is 0;
  begin
    incr(countOptimizations);
    if category(param1) = STRIOBJECT and not isVar(param1) then
      c_expr.expr &:= "/* ";
      c_expr.expr &:= replace(literal(getValue(param1, string)), "*/", "*\\/");
      c_expr.expr &:= " != ";
      c_expr.expr &:= replace(literal(stri), "*/", "*\\/");
      c_expr.expr &:= " */ ";
      if getValue(param1, string) <> stri then
        c_expr.expr &:= "1";
      else
        c_expr.expr &:= "0";
      end if;
    elsif stri = "" then
      c_expr.expr &:= "(((stritype)(";
      getAnyParamToExpr(param1, c_expr);
      c_expr.expr &:= "))->size!=0 /* \"\" */)";
    elsif length(stri) = 1 then
      incr(c_expr.temp_num);
      temp_num := c_expr.temp_num;
      c_expr.temp_decls &:= "stritype tmp_";
      c_expr.temp_decls &:= str(temp_num);
      c_expr.temp_decls &:= ";\n";
      (* Formula used: (a->size!=1||a->mem[0]!=b->mem[0]) *)
      c_expr.expr &:= "(tmp_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "=(";
      getAnyParamToExpr(param1, c_expr);
      c_expr.expr &:= "),tmp_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "->size!=1||tmp_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "->mem[0]!=";
      c_expr.expr &:= str(ord(stri[1]));
      c_expr.expr &:= " /* ";
      c_expr.expr &:= literal(stri);
      c_expr.expr &:= " */)";
    else
      if stri not in stri_const_table then
        stri_const_table @:= [stri] length(stri_const_table);
      end if;
      incr(c_expr.temp_num);
      temp_num := c_expr.temp_num;
      c_expr.temp_decls &:= "stritype tmp_";
      c_expr.temp_decls &:= str(temp_num);
      c_expr.temp_decls &:= ";\n";
      (* Formula used: (a->size!=b->size||memcmp(a->mem,b->mem,
                       a->size*sizeof(strelemtype))!=0) *)
      c_expr.expr &:= "(tmp_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "=(";
      getAnyParamToExpr(param1, c_expr);
      c_expr.expr &:= "),tmp_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "->size!=";
      c_expr.expr &:= str(length(stri));
      c_expr.expr &:= "||memcmp(tmp_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "->mem,str[";
      c_expr.expr &:= str(stri_const_table[stri]);
      c_expr.expr &:= "] /* ";
      c_expr.expr &:= replace(literal(stri), "*/", "*\\/");
      c_expr.expr &:= " */->mem,";
      c_expr.expr &:= str(length(stri));
      c_expr.expr &:= "*sizeof(strelemtype))!=0)";
    end if;
  end func;


const proc: process_str_ne (in ref_list: params, inout expr_type: c_expr) is func

  local
    var integer: temp_num is 0;
  begin
    if category(params[3]) = STRIOBJECT and not isVar(params[3]) then
      process_const_str_ne(params[1], getValue(params[3], string), c_expr);
    elsif category(params[1]) = STRIOBJECT and not isVar(params[1]) then
      process_const_str_ne(params[3], getValue(params[1], string), c_expr);
    else
      incr(c_expr.temp_num);
      temp_num := c_expr.temp_num;
      c_expr.temp_decls &:= "stritype tmp_a_";
      c_expr.temp_decls &:= str(temp_num);
      c_expr.temp_decls &:= ";\n";
      c_expr.temp_decls &:= "stritype tmp_b_";
      c_expr.temp_decls &:= str(temp_num);
      c_expr.temp_decls &:= ";\n";
      (* Formula used: (a->size!=b->size||memcmp(a->mem,b->mem,
                       a->size*sizeof(strelemtype))!=0) *)
      c_expr.expr &:= "(tmp_a_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "=(stritype)(";
      getAnyParamToExpr(params[1], c_expr);
      c_expr.expr &:= "),tmp_b_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "=(stritype)(";
      getAnyParamToExpr(params[3], c_expr);
      c_expr.expr &:= "),tmp_a_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "->size!=tmp_b_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "->size||memcmp(tmp_a_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "->mem,tmp_b_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "->mem,tmp_a_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= "->size*sizeof(strelemtype))!=0)";
    end if;
  end func;


const proc: process_str_pos (in ref_list: params, inout expr_type: c_expr) is func

  begin
    if category(params[2]) = STRIOBJECT and not isVar(params[2]) and
        length(getValue(params[2], string)) = 1 then
      incr(countOptimizations);
      c_expr.expr &:= "strChPos(";
      getAnyParamToExpr(params[1], c_expr);
      c_expr.expr &:= ", ";
      c_expr.expr &:= c_literal(getValue(params[2], string)[1]);
      c_expr.expr &:= ")";
    else
      c_expr.expr &:= "strPos(";
      getAnyParamToExpr(params[1], c_expr);
      c_expr.expr &:= ", ";
      getAnyParamToExpr(params[2], c_expr);
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process_str_range (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "strRange(";
    getAnyParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    getStdParamToResultExpr(params[3], c_expr);
    c_expr.result_expr &:= ", ";
    getStdParamToResultExpr(params[5], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_str_rchpos (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "strRChPos(";
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_str_repl (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "strRepl(";
    getAnyParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    getAnyParamToResultExpr(params[2], c_expr);
    c_expr.result_expr &:= ", ";
    getAnyParamToResultExpr(params[3], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_str_rpad (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "strRpad((stritype)(";
    getAnyParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= "), ";
    getStdParamToResultExpr(params[3], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_str_rpos (in ref_list: params, inout expr_type: c_expr) is func

  begin
    if category(params[2]) = STRIOBJECT and not isVar(params[2]) and
        length(getValue(params[2], string)) = 1 then
      incr(countOptimizations);
      c_expr.expr &:= "strRChPos(";
      getAnyParamToExpr(params[1], c_expr);
      c_expr.expr &:= ", ";
      c_expr.expr &:= c_literal(getValue(params[2], string)[1]);
      c_expr.expr &:= ")";
    else
      c_expr.expr &:= "strRpos(";
      getAnyParamToExpr(params[1], c_expr);
      c_expr.expr &:= ", ";
      getAnyParamToExpr(params[2], c_expr);
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process_str_split (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_array_result(array_type[getExprResultType(params[1])], c_expr);
    if category(params[2]) = STRIOBJECT and not isVar(params[2]) and
        length(getValue(params[2], string)) = 1 then
      incr(countOptimizations);
      c_expr.result_expr := "strChSplit(";
      getAnyParamToResultExpr(params[1], c_expr);
      c_expr.result_expr &:= ", ";
      c_expr.result_expr &:= c_literal(getValue(params[2], string)[1]);
      c_expr.result_expr &:= ")";
    else
      c_expr.result_expr := "strSplit(";
      getAnyParamToResultExpr(params[1], c_expr);
      c_expr.result_expr &:= ", ";
      getAnyParamToResultExpr(params[2], c_expr);
      c_expr.result_expr &:= ")";
    end if;
  end func;


const proc: process_str_str (in ref_list: params, inout expr_type: c_expr) is func

  begin
    process_expr(params[1], c_expr);
  end func;


const proc: process_str_substr (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "strSubstr(";
    getAnyParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    getStdParamToResultExpr(params[3], c_expr);
    c_expr.result_expr &:= ", ";
    getStdParamToResultExpr(params[5], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_str_tail (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "strTail(";
    getAnyParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    getStdParamToResultExpr(params[3], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_str_toutf8 (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "strToUtf8(";
    getAnyParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_str_trim (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "strTrim(";
    getAnyParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ")";
  end func;


(**
 *  Produces code to return a string converted to upper case.
 *  When the parameter is a temporary value the conversion is done
 *  with strUpTemp. The strUpTemp function returns the parameter as
 *  result of the conversion. That way the temporary of the parameter
 *  must not be freed.
 *)
const proc: process_str_up (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
  begin
    prepare_stri_result(c_expr);
    prepareAnyParamTemporarys(params[1], c_param1, c_expr);
    if c_param1.result_expr <> "" then
      c_expr.result_expr := "strUpTemp(";
      c_expr.result_expr &:= c_param1.result_expr;
    else
      c_expr.result_expr := "strUp(";
      c_expr.result_expr &:= c_param1.expr;
    end if;
    c_expr.result_expr &:= ")";
  end func;


const proc: process_str_utf8tostri (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "strUtf8ToStri(";
    getAnyParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_str_value (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "strValue(";
    getStdParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_tim_await (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "timAwait(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[6], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[7], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[8], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_tim_now (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "timNow(&(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "), &(";
    process_expr(params[2], c_expr);
    c_expr.expr &:= "), &(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= "), &(";
    process_expr(params[4], c_expr);
    c_expr.expr &:= "), &(";
    process_expr(params[5], c_expr);
    c_expr.expr &:= "), &(";
    process_expr(params[6], c_expr);
    c_expr.expr &:= "), &(";
    process_expr(params[7], c_expr);
    c_expr.expr &:= "), &(";
    process_expr(params[8], c_expr);
    c_expr.expr &:= "), &(";
    process_expr(params[9], c_expr);
    c_expr.expr &:= "));\n";
  end func;


const proc: process_typ_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "=(";
    if c_param3.result_expr <> "" then
      c_expr.expr &:= c_param3.result_expr;
    else
      c_expr.expr &:= c_param3.expr;
    end if;
    c_expr.expr &:= ");\n";
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_typ_eq (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") == (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_typ_hashcode (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(inttype)(((uinttype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")) >> 6)";
  end func;


const proc: process_typ_isderived (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compDataLibraryUsed := TRUE;
    c_expr.expr &:= "typIsDerived(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_typ_isfunc (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compDataLibraryUsed := TRUE;
    c_expr.expr &:= "typIsFunc(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_typ_isvarfunc (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compDataLibraryUsed := TRUE;
    c_expr.expr &:= "typIsVarfunc(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_typ_matchobj (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compDataLibraryUsed := TRUE;
    c_expr.expr &:= "typMatchobj(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_typ_meta (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compDataLibraryUsed := TRUE;
    c_expr.expr &:= "typMeta(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_typ_ne (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") != (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_typ_num (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compDataLibraryUsed := TRUE;
    c_expr.expr &:= "typNum(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_typ_result (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compDataLibraryUsed := TRUE;
    c_expr.expr &:= "typResult(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_typ_str (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "typStr(";
    getStdParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_typ_value (in ref_list: params, inout expr_type: c_expr) is func

  begin
    compDataLibraryUsed := TRUE;
    c_expr.expr &:= "typValue(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_typ_varconv (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ut8_getc (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "ut8Getc((filetype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_ut8_gets (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "ut8Gets((filetype)(";
    getStdParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= "), ";
    getStdParamToResultExpr(params[2], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_ut8_line_read (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "ut8LineRead((filetype)(";
    getStdParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= "), &(";
    getStdParamToResultExpr(params[2], c_expr);
    c_expr.result_expr &:= "))";
  end func;


const proc: process_ut8_seek (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "ut8Seek((filetype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "), ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_ut8_word_read (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "ut8WordRead((filetype)(";
    getStdParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &:= "), &(";
    getStdParamToResultExpr(params[2], c_expr);
    c_expr.result_expr &:= "))";
  end func;


const proc: process_ut8_write (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "ut8Write((filetype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "), ";
    getAnyParamToExpr(params[2], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_unknown_action (in string: action_name, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "/* ACTOBJECT { ";
    c_expr.expr &:= action_name;
    c_expr.expr &:= " }*/";
  end func;


const proc: process_action (in reference: function, in ref_list: params,
    inout expr_type: c_expr) is func

  local
    var ACTION: current_action is action "PRC_NOOP";
    var string: action_name is "";
    var string: action_prefix is "";
  begin
    current_action := getValue(function, ACTION);
    action_name := str(current_action);
    action_prefix := action_name[ .. 3];
    if action_prefix = "ACT" then
      if action_name = "ACT_CPY" then
        process_act_cpy(params, c_expr);
      elsif action_name = "ACT_STR" then
        process_act_str(params, c_expr);
      elsif action_name = "ACT_VALUE" then
        process_act_value(params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "ARR" then
      if action_name = "ARR_APPEND" then
        process_arr_append(params, c_expr);
      elsif action_name = "ARR_ARRLIT" then
        process_arr_arrlit(params, c_expr);
      elsif action_name = "ARR_ARRLIT2" then
        process_arr_arrlit2(params, c_expr);
      elsif action_name = "ARR_BASELIT" then
        process_arr_baselit(function, params, c_expr);
      elsif action_name = "ARR_BASELIT2" then
        process_arr_baselit2(function, params, c_expr);
      elsif action_name = "ARR_CAT" then
        process_arr_cat(params, c_expr);
      elsif action_name = "ARR_CONV" then
        process_arr_conv(params, c_expr);
      elsif action_name = "ARR_CPY" then
        process_arr_cpy(params, c_expr);
      elsif action_name = "ARR_CREATE" then
        process_arr_create(function, params, c_expr);
      elsif action_name = "ARR_DESTR" then
        process_arr_destr(function, params, c_expr);
      elsif action_name = "ARR_EXTEND" then
        process_arr_extend(params, c_expr);
      elsif action_name = "ARR_GEN" then
        process_arr_gen(function, params, c_expr);
      elsif action_name = "ARR_HEAD" then
        process_arr_head(params, c_expr);
      elsif action_name = "ARR_IDX" then
        process_arr_idx(function, params, c_expr);
      elsif action_name = "ARR_LNG" then
        process_arr_lng(params, c_expr);
      elsif action_name = "ARR_MAXIDX" then
        process_arr_maxidx(params, c_expr);
      elsif action_name = "ARR_MINIDX" then
        process_arr_minidx(params, c_expr);
      elsif action_name = "ARR_RANGE" then
        process_arr_range(params, c_expr);
      elsif action_name = "ARR_REMOVE" then
        process_arr_remove(function, params, c_expr);
      elsif action_name = "ARR_SORT" then
        process_arr_sort(params, c_expr);
      elsif action_name = "ARR_TIMES" then
        process_arr_times(function, params, c_expr);
      elsif action_name = "ARR_TAIL" then
        process_arr_tail(params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "BIG" then
      if action_name = "BIG_ABS" then
        process_big_abs(params, c_expr);
      elsif action_name = "BIG_ADD" then
        process_big_add(params, c_expr);
      elsif action_name = "BIG_BIT_LENGTH" then
        process_big_bit_length(params, c_expr);
      elsif action_name = "BIG_CLIT" then
        process_big_clit(params, c_expr);
      elsif action_name = "BIG_CMP" then
        process_big_cmp(params, c_expr);
      elsif action_name = "BIG_CPY" then
        process_big_cpy(params, c_expr);
      elsif action_name = "BIG_DECR" then
        process_big_decr(params, c_expr);
      elsif action_name = "BIG_DIV" then
        process_big_div(params, c_expr);
      elsif action_name = "BIG_EQ" then
        process_big_eq(params, c_expr);
      elsif action_name = "BIG_GCD" then
        process_big_gcd(params, c_expr);
      elsif action_name = "BIG_GE" then
        process_big_ge(params, c_expr);
      elsif action_name = "BIG_GROW" then
        process_big_grow(params, c_expr);
      elsif action_name = "BIG_GT" then
        process_big_gt(params, c_expr);
      elsif action_name = "BIG_HASHCODE" then
        process_big_hashcode(params, c_expr);
      elsif action_name = "BIG_ICONV" then
        process_big_iconv(params, c_expr);
      elsif action_name = "BIG_INCR" then
        process_big_incr(params, c_expr);
      elsif action_name = "BIG_IPOW" then
        process_big_ipow(params, c_expr);
      elsif action_name = "BIG_LE" then
        process_big_le(params, c_expr);
      elsif action_name = "BIG_LOG2" then
        process_big_log2(params, c_expr);
      elsif action_name = "BIG_LOWEST_SET_BIT" then
        process_big_lowest_set_bit(params, c_expr);
      elsif action_name = "BIG_LSHIFT" then
        process_big_lshift(params, c_expr);
      elsif action_name = "BIG_LSHIFT_ASSIGN" then
        process_big_lshift_assign(params, c_expr);
      elsif action_name = "BIG_LT" then
        process_big_lt(params, c_expr);
      elsif action_name = "BIG_MDIV" then
        process_big_mdiv(params, c_expr);
      elsif action_name = "BIG_MINUS" then
        process_big_minus(params, c_expr);
      elsif action_name = "BIG_MOD" then
        process_big_mod(params, c_expr);
      elsif action_name = "BIG_MULT" then
        process_big_mult(params, c_expr);
      elsif action_name = "BIG_MULT_ASSIGN" then
        process_big_mult_assign(params, c_expr);
      elsif action_name = "BIG_NE" then
        process_big_ne(params, c_expr);
      elsif action_name = "BIG_ODD" then
        process_big_odd(params, c_expr);
      elsif action_name = "BIG_ORD" then
        process_big_ord(params, c_expr);
      elsif action_name = "BIG_PARSE" then
        process_big_parse(params, c_expr);
      elsif action_name = "BIG_PLUS" then
        process_big_plus(params, c_expr);
      elsif action_name = "BIG_SBTR" then
        process_big_sbtr(params, c_expr);
      elsif action_name = "BIG_SHRINK" then
        process_big_shrink(params, c_expr);
      elsif action_name = "BIG_PRED" then
        process_big_pred(params, c_expr);
      elsif action_name = "BIG_RAND" then
        process_big_rand(params, c_expr);
      elsif action_name = "BIG_REM" then
        process_big_rem(params, c_expr);
      elsif action_name = "BIG_RSHIFT" then
        process_big_rshift(params, c_expr);
      elsif action_name = "BIG_RSHIFT_ASSIGN" then
        process_big_rshift_assign(params, c_expr);
      elsif action_name = "BIG_STR" then
        process_big_str(params, c_expr);
      elsif action_name = "BIG_SUCC" then
        process_big_succ(params, c_expr);
      elsif action_name = "BIG_VALUE" then
        process_big_value(params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "BLN" then
      if action_name = "BLN_AND" then
        process_bln_and(params, c_expr);
      elsif action_name = "BLN_CPY" then
        process_bln_cpy(params, c_expr);
      elsif action_name = "BLN_EQ" then
        process_bln_eq(params, c_expr);
      elsif action_name = "BLN_GE" then
        process_bln_ge(params, c_expr);
      elsif action_name = "BLN_GT" then
        process_bln_gt(params, c_expr);
      elsif action_name = "BLN_ICONV" then
        process_bln_iconv(params, c_expr);
      elsif action_name = "BLN_LE" then
        process_bln_le(params, c_expr);
      elsif action_name = "BLN_LT" then
        process_bln_lt(params, c_expr);
      elsif action_name = "BLN_NE" then
        process_bln_ne(params, c_expr);
      elsif action_name = "BLN_NOT" then
        process_bln_not(params, c_expr);
      elsif action_name = "BLN_OR" then
        process_bln_or(params, c_expr);
      elsif action_name = "BLN_ORD" then
        process_bln_ord(params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "BST" then
      if action_name = "BST_CPY" then
        process_bst_cpy(params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "CHR" then
      if action_name = "CHR_CHR" then
        process_chr_chr(function, params, c_expr);
      elsif action_name = "CHR_CONV" then
        process_chr_conv(params, c_expr);
      elsif action_name = "CHR_CPY" then
        process_chr_cpy(params, c_expr);
      elsif action_name = "CHR_EQ" then
        process_chr_eq(params, c_expr);
      elsif action_name = "CHR_DECR" then
        process_chr_decr(params, c_expr);
      elsif action_name = "CHR_GE" then
        process_chr_ge(params, c_expr);
      elsif action_name = "CHR_GROW" then
        process_chr_grow(params, c_expr);
      elsif action_name = "CHR_GT" then
        process_chr_gt(params, c_expr);
      elsif action_name = "CHR_HASHCODE" then
        process_chr_hashcode(params, c_expr);
      elsif action_name = "CHR_ICONV" then
        process_chr_iconv(params, c_expr);
      elsif action_name = "CHR_INCR" then
        process_chr_incr(params, c_expr);
      elsif action_name = "CHR_LE" then
        process_chr_le(params, c_expr);
      elsif action_name = "CHR_LOW" then
        process_chr_low(params, c_expr);
      elsif action_name = "CHR_LT" then
        process_chr_lt(params, c_expr);
      elsif action_name = "CHR_NE" then
        process_chr_ne(params, c_expr);
      elsif action_name = "CHR_ORD" then
        process_chr_ord(params, c_expr);
      elsif action_name = "CHR_PRED" then
        process_chr_pred(params, c_expr);
      elsif action_name = "CHR_SHRINK" then
        process_chr_shrink(params, c_expr);
      elsif action_name = "CHR_STR" then
        process_chr_str(params, c_expr);
      elsif action_name = "CHR_SUCC" then
        process_chr_succ(params, c_expr);
      elsif action_name = "CHR_UP" then
        process_chr_up(params, c_expr);
      elsif action_name = "CHR_VALUE" then
        process_chr_value(params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "CMD" then
      if action_name = "CMD_BIG_FILESIZE" then
        process_cmd_big_filesize(params, c_expr);
      elsif action_name = "CMD_CHDIR" then
        process_cmd_chdir(params, c_expr);
      elsif action_name = "CMD_CONFIG_VALUE" then
        process_cmd_config_value(params, c_expr);
      elsif action_name = "CMD_CLONE_FILE" then
        process_cmd_clone_file(params, c_expr);
      elsif action_name = "CMD_COPY_FILE" then
        process_cmd_copy_file(params, c_expr);
      elsif action_name = "CMD_FILESIZE" then
        process_cmd_filesize(params, c_expr);
      elsif action_name = "CMD_FILETYPE" then
        process_cmd_filetype(params, c_expr);
      elsif action_name = "CMD_GETCWD" then
        process_cmd_getcwd(params, c_expr);
      elsif action_name = "CMD_GET_ATIME" then
        process_cmd_get_atime(params, c_expr);
      elsif action_name = "CMD_GET_MTIME" then
        process_cmd_get_mtime(params, c_expr);
      elsif action_name = "CMD_LS" then
        process_cmd_ls(params, c_expr);
      elsif action_name = "CMD_MKDIR" then
        process_cmd_mkdir(params, c_expr);
      elsif action_name = "CMD_MOVE" then
        process_cmd_move(params, c_expr);
      elsif action_name = "CMD_READLINK" then
        process_cmd_readlink(params, c_expr);
      elsif action_name = "CMD_REMOVE" then
        process_cmd_remove(params, c_expr);
      elsif action_name = "CMD_REMOVE_ANY_FILE" then
        process_cmd_remove_any_file(params, c_expr);
      elsif action_name = "CMD_SET_ATIME" then
        process_cmd_set_atime(params, c_expr);
      elsif action_name = "CMD_SET_MTIME" then
        process_cmd_set_mtime(params, c_expr);
      elsif action_name = "CMD_SHELL" then
        process_cmd_shell(params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "DCL" then
      if action_name = "DCL_CONST" then
        write_object_declaration := FALSE;
      elsif action_name = "DCL_FWD" then
        write_object_declaration := FALSE;
      elsif action_name = "DCL_GLOBAL" then
        write_object_declaration := FALSE;
      elsif action_name = "DCL_VAR" then
        write_object_declaration := FALSE;
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "DRW" then
      if action_name = "DRW_ARC" then
        process_drw_arc(params, c_expr);
      elsif action_name = "DRW_ARC2" then
        process_drw_arc2(params, c_expr);
      elsif action_name = "DRW_BACKGROUND" then
        process_drw_background(params, c_expr);
      elsif action_name = "DRW_CIRCLE" then
        process_drw_circle(params, c_expr);
      elsif action_name = "DRW_CLEAR" then
        process_drw_clear(params, c_expr);
      elsif action_name = "DRW_COLOR" then
        process_drw_color(params, c_expr);
      elsif action_name = "DRW_COPYAREA" then
        process_drw_copyarea(params, c_expr);
      elsif action_name = "DRW_CPY" then
        process_drw_cpy(params, c_expr);
      elsif action_name = "DRW_EQ" then
        process_drw_eq(params, c_expr);
      elsif action_name = "DRW_FARCCHORD" then
        process_drw_farcchord(params, c_expr);
      elsif action_name = "DRW_FARCPIESLICE" then
        process_drw_farcpieslice(params, c_expr);
      elsif action_name = "DRW_FCIRCLE" then
        process_drw_fcircle(params, c_expr);
      elsif action_name = "DRW_FELLIPSE" then
        process_drw_fellipse(params, c_expr);
      elsif action_name = "DRW_FLUSH" then
        process_drw_flush(params, c_expr);
      elsif action_name = "DRW_FPOLYLINE" then
        process_drw_fpolyline(params, c_expr);
      elsif action_name = "DRW_GENPOINTLIST" then
        process_drw_genpointlist(params, c_expr);
      elsif action_name = "DRW_GET" then
        process_drw_get(params, c_expr);
      elsif action_name = "DRW_HEIGHT" then
        process_drw_height(params, c_expr);
      elsif action_name = "DRW_IMAGE" then
        process_drw_image(params, c_expr);
      elsif action_name = "DRW_LINE" then
        process_drw_line(params, c_expr);
      elsif action_name = "DRW_NE" then
        process_drw_ne(params, c_expr);
      elsif action_name = "DRW_NEW_PIXMAP" then
        process_drw_new_pixmap(params, c_expr);
      elsif action_name = "DRW_OPEN" then
        process_drw_open(params, c_expr);
      elsif action_name = "DRW_PARC" then
        process_drw_parc(params, c_expr);
      elsif action_name = "DRW_PCIRCLE" then
        process_drw_pcircle(params, c_expr);
      elsif action_name = "DRW_PFARCCHORD" then
        process_drw_pfarcchord(params, c_expr);
      elsif action_name = "DRW_PFARCPIESLICE" then
        process_drw_pfarcpieslice(params, c_expr);
      elsif action_name = "DRW_PFCIRCLE" then
        process_drw_pfcircle(params, c_expr);
      elsif action_name = "DRW_PFELLIPSE" then
        process_drw_pfellipse(params, c_expr);
      elsif action_name = "DRW_PLINE" then
        process_drw_pline(params, c_expr);
      elsif action_name = "DRW_POINT" then
        process_drw_point(params, c_expr);
      elsif action_name = "DRW_POLYLINE" then
        process_drw_polyline(params, c_expr);
      elsif action_name = "DRW_PPOINT" then
        process_drw_ppoint(params, c_expr);
      elsif action_name = "DRW_PRECT" then
        process_drw_prect(params, c_expr);
      elsif action_name = "DRW_PUT" then
        process_drw_put(params, c_expr);
      elsif action_name = "DRW_RECT" then
        process_drw_rect(params, c_expr);
      elsif action_name = "DRW_RGBCOL" then
        process_drw_rgbcol(params, c_expr);
      elsif action_name = "DRW_SETTRANSPARENTCOLOR" then
        process_drw_setTransparentColor(params, c_expr);
      elsif action_name = "DRW_TEXT" then
        process_drw_text(params, c_expr);
      elsif action_name = "DRW_WIDTH" then
        process_drw_width(params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "ENU" then
      if action_name = "ENU_CONV" then
        process_enu_conv(params, c_expr);
      elsif action_name = "ENU_CPY" then
        process_enu_cpy(params, c_expr);
      elsif action_name = "ENU_EQ" then
        process_enu_eq(params, c_expr);
      elsif action_name = "ENU_ICONV2" then
        process_enu_iconv2(params, c_expr);
      elsif action_name = "ENU_NE" then
        process_enu_ne(params, c_expr);
      elsif action_name = "ENU_ORD2" then
        process_enu_ord2(params, c_expr);
      elsif action_name = "ENU_VALUE" then
        process_enu_value(params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "FIL" then
      if action_name = "FIL_BIG_LNG" then
        process_fil_big_lng(params, c_expr);
      elsif action_name = "FIL_BIG_SEEK" then
        process_fil_big_seek(params, c_expr);
      elsif action_name = "FIL_BIG_TELL" then
        process_fil_big_tell(params, c_expr);
      elsif action_name = "FIL_CLOSE" then
        process_fil_close(params, c_expr);
      elsif action_name = "FIL_CPY" then
        process_fil_cpy(params, c_expr);
      elsif action_name = "FIL_EOF" then
        process_fil_eof(params, c_expr);
      elsif action_name = "FIL_EQ" then
        process_fil_eq(params, c_expr);
      elsif action_name = "FIL_ERR" then
        process_fil_err(params, c_expr);
      elsif action_name = "FIL_FLUSH" then
        process_fil_flush(params, c_expr);
      elsif action_name = "FIL_GETC" then
        process_fil_getc(params, c_expr);
      elsif action_name = "FIL_GETS" then
        process_fil_gets(params, c_expr);
      elsif action_name = "FIL_HAS_NEXT" then
        process_fil_has_next(params, c_expr);
      elsif action_name = "FIL_IN" then
        process_fil_in(params, c_expr);
      elsif action_name = "FIL_LINE_READ" then
        process_fil_line_read(params, c_expr);
      elsif action_name = "FIL_LIT" then
        process_fil_lit(params, c_expr);
      elsif action_name = "FIL_LNG" then
        process_fil_lng(params, c_expr);
      elsif action_name = "FIL_NE" then
        process_fil_ne(params, c_expr);
      elsif action_name = "FIL_NIL" then
        process_fil_nil(params, c_expr);
      elsif action_name = "FIL_OPEN" then
        process_fil_open(params, c_expr);
      elsif action_name = "FIL_OUT" then
        process_fil_out(params, c_expr);
      elsif action_name = "FIL_POPEN" then
        process_fil_popen(params, c_expr);
      elsif action_name = "FIL_PRINT" then
        process_fil_print(params, c_expr);
      elsif action_name = "FIL_SEEK" then
        process_fil_seek(params, c_expr);
      elsif action_name = "FIL_SETBUF" then
        process_fil_setbuf(params, c_expr);
      elsif action_name = "FIL_TELL" then
        process_fil_tell(params, c_expr);
      elsif action_name = "FIL_VALUE" then
        process_fil_value(params, c_expr);
      elsif action_name = "FIL_WRITE" then
        process_fil_write(params, c_expr);
      elsif action_name = "FIL_WORD_READ" then
        process_fil_word_read(params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "FLT" then
      if action_name = "FLT_A2TAN" then
        process_flt_a2tan(params, c_expr);
      elsif action_name = "FLT_ABS" then
        process_flt_abs(params, c_expr);
      elsif action_name = "FLT_ACOS" then
        process_flt_acos(params, c_expr);
      elsif action_name = "FLT_ADD" then
        process_flt_add(params, c_expr);
      elsif action_name = "FLT_ASIN" then
        process_flt_asin(params, c_expr);
      elsif action_name = "FLT_ATAN" then
        process_flt_atan(params, c_expr);
      elsif action_name = "FLT_CAST" then
        process_flt_cast(params, c_expr);
      elsif action_name = "FLT_CEIL" then
        process_flt_ceil(params, c_expr);
      elsif action_name = "FLT_CMP" then
        process_flt_cmp(params, c_expr);
      elsif action_name = "FLT_COS" then
        process_flt_cos(params, c_expr);
      elsif action_name = "FLT_COSH" then
        process_flt_cosh(params, c_expr);
      elsif action_name = "FLT_CPY" then
        process_flt_cpy(params, c_expr); 
      elsif action_name = "FLT_DGTS" then
        process_flt_dgts(params, c_expr);
      elsif action_name = "FLT_DIV" then
        process_flt_div(params, c_expr);
      elsif action_name = "FLT_DIV_ASSIGN" then
        process_flt_div_assign(params, c_expr);
      elsif action_name = "FLT_EQ" then
        process_flt_eq(params, c_expr);
      elsif action_name = "FLT_EXP" then
        process_flt_exp(params, c_expr);
      elsif action_name = "FLT_FLOOR" then
        process_flt_floor(params, c_expr);
      elsif action_name = "FLT_GE" then
        process_flt_ge(params, c_expr);
      elsif action_name = "FLT_GROW" then
        process_flt_grow(params, c_expr);
      elsif action_name = "FLT_GT" then
        process_flt_gt(params, c_expr);
      elsif action_name = "FLT_HASHCODE" then
        process_flt_hashcode(params, c_expr);
      elsif action_name = "FLT_ICAST" then
        process_flt_icast(params, c_expr);
      elsif action_name = "FLT_ICONV" then
        process_flt_iconv(params, c_expr);
      elsif action_name = "FLT_IFLT" then
        process_flt_iflt(params, c_expr);
      elsif action_name = "FLT_IPOW" then
        process_flt_ipow(params, c_expr);
      elsif action_name = "FLT_ISNAN" then
        process_flt_isnan(params, c_expr);
      elsif action_name = "FLT_LE" then
        process_flt_le(params, c_expr);
      elsif action_name = "FLT_LOG" then
        process_flt_log(params, c_expr);
      elsif action_name = "FLT_LOG10" then
        process_flt_log10(params, c_expr);
      elsif action_name = "FLT_LT" then
        process_flt_lt(params, c_expr);
      elsif action_name = "FLT_MINUS" then
        process_flt_minus(params, c_expr);
      elsif action_name = "FLT_MULT" then
        process_flt_mult(params, c_expr);
      elsif action_name = "FLT_MULT_ASSIGN" then
        process_flt_mult_assign(params, c_expr);
      elsif action_name = "FLT_NE" then
        process_flt_ne(params, c_expr);
      elsif action_name = "FLT_PARSE" then
        process_flt_parse(params, c_expr);
      elsif action_name = "FLT_PLUS" then
        process_flt_plus(params, c_expr);
      elsif action_name = "FLT_POW" then
        process_flt_pow(params, c_expr);
      elsif action_name = "FLT_RAND" then
        process_flt_rand(params, c_expr);
      elsif action_name = "FLT_ROUND" then
        process_flt_round(params, c_expr);
      elsif action_name = "FLT_SBTR" then
        process_flt_sbtr(params, c_expr);
      elsif action_name = "FLT_SHRINK" then
        process_flt_shrink(params, c_expr);
      elsif action_name = "FLT_SIN" then
        process_flt_sin(params, c_expr);
      elsif action_name = "FLT_SINH" then
        process_flt_sinh(params, c_expr);
      elsif action_name = "FLT_SQRT" then
        process_flt_sqrt(params, c_expr);
      elsif action_name = "FLT_STR" then
        process_flt_str(params, c_expr);
      elsif action_name = "FLT_TAN" then
        process_flt_tan(params, c_expr);
      elsif action_name = "FLT_TANH" then
        process_flt_tanh(params, c_expr);
      elsif action_name = "FLT_TRUNC" then
        process_flt_trunc(params, c_expr);
      elsif action_name = "FLT_VALUE" then
        process_flt_value(params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "GKB" then
      if action_name = "GKB_BUSY_GETC" then
        process_gkb_busy_getc(params, c_expr);
      elsif action_name = "GKB_GETC" then
        process_gkb_getc(params, c_expr);
      elsif action_name = "GKB_GETS" then
        process_gkb_gets(params, c_expr);
      elsif action_name = "GKB_KEYPRESSED" then
        process_gkb_keypressed(params, c_expr);
      elsif action_name = "GKB_LINE_READ" then
        process_gkb_line_read(params, c_expr);
      elsif action_name = "GKB_RAW_GETC" then
        process_gkb_raw_getc(params, c_expr);
      elsif action_name = "GKB_WINDOW" then
        process_gkb_window(params, c_expr);
      elsif action_name = "GKB_WORD_READ" then
        process_gkb_word_read(params, c_expr);
      elsif action_name = "GKB_XPOS" then
        process_gkb_xpos(params, c_expr);
      elsif action_name = "GKB_YPOS" then
        process_gkb_ypos(params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "HSH" then
      if action_name = "HSH_CONTAINS" then
        process_hsh_contains(params, c_expr);
      elsif action_name = "HSH_CPY" then
        process_hsh_cpy(params, c_expr);
      elsif action_name = "HSH_CREATE" then
        process_hsh_create(params, c_expr);
      elsif action_name = "HSH_DESTR" then
        process_hsh_destr(params, c_expr);
      elsif action_name = "HSH_EXCL" then
        process_hsh_excl(params, c_expr);
      elsif action_name = "HSH_FOR" then
        process_hsh_for(params, c_expr);
      elsif action_name = "HSH_FOR_DATA_KEY" then
        process_hsh_for_data_key(params, c_expr);
      elsif action_name = "HSH_FOR_KEY" then
        process_hsh_for_key(params, c_expr);
      elsif action_name = "HSH_IDX" then
        process_hsh_idx(function, params, c_expr);
      elsif action_name = "HSH_INCL" then
        process_hsh_incl(params, c_expr);
      elsif action_name = "HSH_KEYS" then
        process_hsh_keys(params, c_expr);
      elsif action_name = "HSH_LNG" then
        process_hsh_lng(params, c_expr);
      elsif action_name = "HSH_VALUES" then
        process_hsh_values(params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "INT" then
      if action_name = "INT_ABS" then
        process_int_abs(params, c_expr);
      elsif action_name = "INT_ADD" then
        process_int_add(params, c_expr);
      elsif action_name = "INT_BINOM" then
        process_int_binom(params, c_expr);
      elsif action_name = "INT_BIT_LENGTH" then
        process_int_bit_length(params, c_expr);
      elsif action_name = "INT_CMP" then
        process_int_cmp(params, c_expr);
      elsif action_name = "INT_CONV" then
        process_int_conv(params, c_expr);
      elsif action_name = "INT_CPY" then
        process_int_cpy(params, c_expr);
      elsif action_name = "INT_DECR" then
        process_int_decr(params, c_expr);
      elsif action_name = "INT_DIV" then
        process_int_div(params, c_expr);
      elsif action_name = "INT_EQ" then
        process_int_eq(params, c_expr);
      elsif action_name = "INT_FACT" then
        process_int_fact(params, c_expr);
      elsif action_name = "INT_GE" then
        process_int_ge(params, c_expr);
      elsif action_name = "INT_GROW" then
        process_int_grow(params, c_expr);
      elsif action_name = "INT_GT" then
        process_int_gt(params, c_expr);
      elsif action_name = "INT_HASHCODE" then
        process_int_hashcode(params, c_expr);
      elsif action_name = "INT_INCR" then
        process_int_incr(params, c_expr);
      elsif action_name = "INT_LE" then
        process_int_le(params, c_expr);
      elsif action_name = "INT_LOG2" then
        process_int_log2(params, c_expr);
      elsif action_name = "INT_LOWEST_SET_BIT" then
        process_int_lowest_set_bit(params, c_expr);
      elsif action_name = "INT_LPAD0" then
        process_int_lpad0(params, c_expr);
      elsif action_name = "INT_LSHIFT" then
        process_int_lshift(params, c_expr);
      elsif action_name = "INT_LSHIFT_ASSIGN" then
        process_int_lshift_assign(params, c_expr);
      elsif action_name = "INT_LT" then
        process_int_lt(params, c_expr);
      elsif action_name = "INT_MDIV" then
        process_int_mdiv(params, c_expr);
      elsif action_name = "INT_MINUS" then
        process_int_minus(params, c_expr);
      elsif action_name = "INT_MOD" then
        process_int_mod(params, c_expr);
      elsif action_name = "INT_MULT" then
        process_int_mult(params, c_expr);
      elsif action_name = "INT_MULT_ASSIGN" then
        process_int_mult_assign(params, c_expr);
      elsif action_name = "INT_NE" then
        process_int_ne(params, c_expr);
      elsif action_name = "INT_ODD" then
        process_int_odd(params, c_expr);
      elsif action_name = "INT_ORD" then
        process_int_ord(params, c_expr);
      elsif action_name = "INT_PARSE" then
        process_int_parse(params, c_expr);
      elsif action_name = "INT_PLUS" then
        process_int_plus(params, c_expr);
      elsif action_name = "INT_RAND" then
        process_int_rand(params, c_expr);
      elsif action_name = "INT_POW" then
        process_int_pow(params, c_expr);
      elsif action_name = "INT_PRED" then
        process_int_pred(params, c_expr);
      elsif action_name = "INT_REM" then
        process_int_rem(params, c_expr);
      elsif action_name = "INT_RSHIFT" then
        process_int_rshift(params, c_expr);
      elsif action_name = "INT_RSHIFT_ASSIGN" then
        process_int_rshift_assign(params, c_expr);
      elsif action_name = "INT_SBTR" then
        process_int_sbtr(params, c_expr);
      elsif action_name = "INT_SHRINK" then
        process_int_shrink(params, c_expr);
      elsif action_name = "INT_SQRT" then
        process_int_sqrt(params, c_expr);
      elsif action_name = "INT_STR" then
        process_int_str(params, c_expr);
      elsif action_name = "INT_STR_BASED" then
        process_int_str_based(params, c_expr);
      elsif action_name = "INT_SUCC" then
        process_int_succ(params, c_expr);
      elsif action_name = "INT_VALUE" then
        process_int_value(params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "ITF" then
      if action_name = "ITF_CONV2" then
        process_itf_conv2(params, c_expr);
      elsif action_name = "ITF_CPY" then
        process_itf_cpy(params, c_expr);
      elsif action_name = "ITF_CPY2" then
        process_itf_cpy2(params, c_expr);
      elsif action_name = "ITF_EQ" then
        process_itf_eq(params, c_expr);
      elsif action_name = "ITF_NE" then
        process_itf_ne(params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "KBD" then
      if action_name = "KBD_BUSY_GETC" then
        process_kbd_busy_getc(params, c_expr);
      elsif action_name = "KBD_GETC" then
        process_kbd_getc(params, c_expr);
      elsif action_name = "KBD_GETS" then
        process_kbd_gets(params, c_expr);
      elsif action_name = "KBD_KEYPRESSED" then
        process_kbd_keypressed(params, c_expr);
      elsif action_name = "KBD_LINE_READ" then
        process_kbd_line_read(params, c_expr);
      elsif action_name = "KBD_RAW_GETC" then
        process_kbd_raw_getc(params, c_expr);
      elsif action_name = "KBD_WORD_READ" then
        process_kbd_word_read(params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "PRC" then
      if action_name = "PRC_ARGS" then
        process_prc_args(params, c_expr);
      elsif action_name = "PRC_BLOCK" then
        process_prc_block(params, c_expr);
      elsif action_name = "PRC_CASE" then
        process_prc_case(params, c_expr);
      elsif action_name = "PRC_CASE_DEF" then
        process_prc_case_def(params, c_expr);
      elsif action_name = "PRC_DYNAMIC" then
        process_prc_dynamic(function, params, c_expr);
      elsif action_name = "PRC_EXIT" then
        process_prc_exit(params, c_expr);
      elsif action_name = "PRC_FOR_DOWNTO" then
        process_prc_for_downto(params, c_expr);
      elsif action_name = "PRC_FOR_TO" then
        process_prc_for_to(params, c_expr);
      elsif action_name = "PRC_HSIZE" then
        process_prc_hsize(params, c_expr);
      elsif action_name = "PRC_IF" then
        process_prc_if(params, c_expr);
      elsif action_name = "PRC_IF_ELSIF" then
        process_prc_if_elsif(params, c_expr);
      elsif action_name = "PRC_NOOP" then
        process_prc_noop(function, params, c_expr);
      elsif action_name = "PRC_RAISE" then
        process_prc_raise(function, params, c_expr);
      elsif action_name = "PRC_REPEAT" then
        process_prc_repeat(params, c_expr);
      elsif action_name = "PRC_WHILE" then
        process_prc_while(params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "PRG" then
      if action_name = "PRG_CPY" then
        process_prg_cpy(params, c_expr);
      elsif action_name = "PRG_DECL_OBJECTS" then
        process_prg_decl_objects(params, c_expr);
      elsif action_name = "PRG_EQ" then
        process_prg_eq(params, c_expr);
      elsif action_name = "PRG_ERROR_COUNT" then
        process_prg_error_count(params, c_expr);
      elsif action_name = "PRG_EVAL" then
        process_prg_eval(params, c_expr);
      elsif action_name = "PRG_EXEC" then
        process_prg_exec(params, c_expr);
      elsif action_name = "PRG_FIL_PARSE" then
        process_prg_fil_parse(params, c_expr);
      elsif action_name = "PRG_MATCH" then
        process_prg_match(params, c_expr);
      elsif action_name = "PRG_MATCH_EXPR" then
        process_prg_match_expr(params, c_expr);
      elsif action_name = "PRG_NAME" then
        process_prg_name(params, c_expr);
      elsif action_name = "PRG_NE" then
        process_prg_ne(params, c_expr);
      elsif action_name = "PRG_STR_PARSE" then
        process_prg_str_parse(params, c_expr);
      elsif action_name = "PRG_SYOBJECT" then
        process_prg_syobject(params, c_expr);
      elsif action_name = "PRG_SYSVAR" then
        process_prg_sysvar(params, c_expr);
      elsif action_name = "PRG_VALUE" then
        process_prg_value(params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "REF" then
      if action_name = "REF_ADDR" then
        process_ref_addr(params, c_expr);
      elsif action_name = "REF_ALLOC" then
        process_ref_alloc(params, c_expr);
      elsif action_name = "REF_ARRMAXIDX" then
        process_ref_arrmaxidx(params, c_expr);
      elsif action_name = "REF_ARRMINIDX" then
        process_ref_arrminidx(params, c_expr);
      elsif action_name = "REF_ARRTOLIST" then
        process_ref_arrtolist(params, c_expr);
      elsif action_name = "REF_BODY" then
        process_ref_body(params, c_expr);
      elsif action_name = "REF_CATEGORY" then
        process_ref_category(params, c_expr);
      elsif action_name = "REF_CAT_PARSE" then
        process_ref_cat_parse(params, c_expr);
      elsif action_name = "REF_CAT_STR" then
        process_ref_cat_str(params, c_expr);
      elsif action_name = "REF_CONV" then
        process_ref_conv(params, c_expr);
      elsif action_name = "REF_CPY" then
        process_ref_cpy(params, c_expr);
      elsif action_name = "REF_DEREF" then
        process_ref_deref(params, c_expr);
      elsif action_name = "REF_EQ" then
        process_ref_eq(params, c_expr);
      elsif action_name = "REF_FILE" then
        process_ref_file(params, c_expr);
      elsif action_name = "REF_HASHCODE" then
        process_ref_hashcode(params, c_expr);
      elsif action_name = "REF_HSHDATATOLIST" then
        process_ref_hshdatatolist(params, c_expr);
      elsif action_name = "REF_HSHKEYTOLIST" then
        process_ref_hshkeytolist(params, c_expr);
      elsif action_name = "REF_ISVAR" then
        process_ref_isvar(params, c_expr);
      elsif action_name = "REF_ITFTOSCT" then
        process_ref_itftosct(params, c_expr);
      elsif action_name = "REF_LINE" then
        process_ref_line(params, c_expr);
      elsif action_name = "REF_LOCAL_CONSTS" then
        process_ref_local_consts(params, c_expr);
      elsif action_name = "REF_LOCAL_VARS" then
        process_ref_local_vars(params, c_expr);
      elsif action_name = "REF_NE" then
        process_ref_ne(params, c_expr);
      elsif action_name = "REF_NUM" then
        process_ref_num(params, c_expr);
      elsif action_name = "REF_PARAMS" then
        process_ref_params(params, c_expr);
      elsif action_name = "REF_RESINI" then
        process_ref_resini(params, c_expr);
      elsif action_name = "REF_RESULT" then
        process_ref_result(params, c_expr);
      elsif action_name = "REF_SCTTOLIST" then
        process_ref_scttolist(params, c_expr);
      elsif action_name = "REF_SELECT" then
        process_ref_select(function, params, c_expr);
      elsif action_name = "REF_SETCATEGORY" then
        process_ref_setcategory(params, c_expr);
      elsif action_name = "REF_SETPARAMS" then
        process_ref_setparams(params, c_expr);
      elsif action_name = "REF_SETTYPE" then
        process_ref_settype(params, c_expr);
      elsif action_name = "REF_SETVAR" then
        process_ref_setvar(params, c_expr);
      elsif action_name = "REF_STR" then
        process_ref_str(params, c_expr);
      elsif action_name = "REF_TRACE" then
        process_ref_trace(params, c_expr);
      elsif action_name = "REF_TYPE" then
        process_ref_type(params, c_expr);
      elsif action_name = "REF_VALUE" then
        process_ref_value(params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "RFL" then
      if action_name = "RFL_APPEND" then
        process_rfl_append(params, c_expr);
      elsif action_name = "RFL_CAT" then
        process_rfl_cat(params, c_expr);
      elsif action_name = "RFL_CPY" then
        process_rfl_cpy(params, c_expr);
      elsif action_name = "RFL_ELEM" then
        process_rfl_elem(params, c_expr);
      elsif action_name = "RFL_ELEMCPY" then
        process_rfl_elemcpy(params, c_expr);
      elsif action_name = "RFL_EQ" then
        process_rfl_eq(params, c_expr);
      elsif action_name = "RFL_FOR" then
        process_rfl_for(params, c_expr);
      elsif action_name = "RFL_HEAD" then
        process_rfl_head(params, c_expr);
      elsif action_name = "RFL_IDX" then
        process_rfl_idx(params, c_expr);
      elsif action_name = "RFL_INCL" then
        process_rfl_incl(params, c_expr);
      elsif action_name = "RFL_IPOS" then
        process_rfl_ipos(params, c_expr);
      elsif action_name = "RFL_LNG" then
        process_rfl_lng(params, c_expr);
      elsif action_name = "RFL_MKLIST" then
        process_rfl_mklist(params, c_expr);
      elsif action_name = "RFL_NE" then
        process_rfl_ne(params, c_expr);
      elsif action_name = "RFL_NOT_ELEM" then
        process_rfl_not_elem(params, c_expr);
      elsif action_name = "RFL_POS" then
        process_rfl_pos(params, c_expr);
      elsif action_name = "RFL_SETVALUE" then
        process_rfl_setvalue(params, c_expr);
      elsif action_name = "RFL_TAIL" then
        process_rfl_tail(params, c_expr);
      elsif action_name = "RFL_VALUE" then
        process_rfl_value(params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "SCR" then
      if action_name = "SCR_CLEAR" then
        process_scr_clear(params, c_expr);
      elsif action_name = "SCR_CURSOR" then
        process_scr_cursor(params, c_expr);
      elsif action_name = "SCR_FLUSH" then
        process_scr_flush(params, c_expr);
      elsif action_name = "SCR_HEIGHT" then
        process_scr_height(params, c_expr);
      elsif action_name = "SCR_H_SCL" then
        process_scr_h_scl(params, c_expr);
      elsif action_name = "SCR_OPEN" then
        process_scr_open(params, c_expr);
      elsif action_name = "SCR_SETPOS" then
        process_scr_setpos(params, c_expr);
      elsif action_name = "SCR_V_SCL" then
        process_scr_v_scl(params, c_expr);
      elsif action_name = "SCR_WIDTH" then
        process_scr_width(params, c_expr);
      elsif action_name = "SCR_WRITE" then
        process_scr_write(params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "SCT" then
      if action_name = "SCT_ALLOC" then
        process_sct_alloc(params, c_expr);
      elsif action_name = "SCT_CPY" then
        process_sct_cpy(params, c_expr);
      elsif action_name = "SCT_SELECT" then
        process_sct_select(function, params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "SET" then
      if action_name = "SET_ARRLIT" then
        process_set_arrlit(params, c_expr);
      elsif action_name = "SET_BASELIT" then
        process_set_baselit(params, c_expr);
      elsif action_name = "SET_CARD" then
        process_set_card(params, c_expr);
      elsif action_name = "SET_CONV" then
        process_set_conv(params, c_expr);
      elsif action_name = "SET_CPY" then
        process_set_cpy(params, c_expr);
      elsif action_name = "SET_DIFF" then
        process_set_diff(params, c_expr);
      elsif action_name = "SET_ELEM" then
        process_set_elem(params, c_expr);
      elsif action_name = "SET_EQ" then
        process_set_eq(params, c_expr);
      elsif action_name = "SET_EXCL" then
        process_set_excl(params, c_expr);
      elsif action_name = "SET_GE" then
        process_set_ge(params, c_expr);
      elsif action_name = "SET_GT" then
        process_set_gt(params, c_expr);
      elsif action_name = "SET_HASHCODE" then
        process_set_hashcode(params, c_expr);
      elsif action_name = "SET_ICONV" then
        process_set_iconv(params, c_expr);
      elsif action_name = "SET_INCL" then
        process_set_incl(params, c_expr);
      elsif action_name = "SET_INTERSECT" then
        process_set_intersect(params, c_expr);
      elsif action_name = "SET_LE" then
        process_set_le(params, c_expr);
      elsif action_name = "SET_LT" then
        process_set_lt(params, c_expr);
      elsif action_name = "SET_MAX" then
        process_set_max(params, c_expr);
      elsif action_name = "SET_MIN" then
        process_set_min(params, c_expr);
      elsif action_name = "SET_NE" then
        process_set_ne(params, c_expr);
      elsif action_name = "SET_NOT_ELEM" then
        process_set_not_elem(params, c_expr);
      elsif action_name = "SET_RAND" then
        process_set_rand(params, c_expr);
      elsif action_name = "SET_SCONV" then
        process_set_sconv(params, c_expr);
      elsif action_name = "SET_SYMDIFF" then
        process_set_symdiff(params, c_expr);
      elsif action_name = "SET_UNION" then
        process_set_union(params, c_expr);
      elsif action_name = "SET_VALUE" then
        process_set_value(params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "SOC" then
      if action_name = "SOC_ACCEPT" then
        process_soc_accept(params, c_expr);
      elsif action_name = "SOC_BIND" then
        process_soc_bind(params, c_expr);
      elsif action_name = "SOC_CLOSE" then
        process_soc_close(params, c_expr);
      elsif action_name = "SOC_CONNECT" then
        process_soc_connect(params, c_expr);
      elsif action_name = "SOC_CPY" then
        process_soc_cpy(params, c_expr);
      elsif action_name = "SOC_EQ" then
        process_soc_eq(params, c_expr);
      elsif action_name = "SOC_GETC" then
        process_soc_getc(params, c_expr);
      elsif action_name = "SOC_GETS" then
        process_soc_gets(params, c_expr);
      elsif action_name = "SOC_INET_ADDR" then
        process_soc_inet_addr(params, c_expr);
      elsif action_name = "SOC_INET_LOCAL_ADDR" then
        process_soc_inet_local_addr(params, c_expr);
      elsif action_name = "SOC_INET_SERV_ADDR" then
        process_soc_inet_serv_addr(params, c_expr);
      elsif action_name = "SOC_LINE_READ" then
        process_soc_line_read(params, c_expr);
      elsif action_name = "SOC_LISTEN" then
        process_soc_listen(params, c_expr);
      elsif action_name = "SOC_NE" then
        process_soc_ne(params, c_expr);
      elsif action_name = "SOC_RECV" then
        process_soc_recv(params, c_expr);
      elsif action_name = "SOC_SEND" then
        process_soc_send(params, c_expr);
      elsif action_name = "SOC_SOCKET" then
        process_soc_socket(params, c_expr);
      elsif action_name = "SOC_WORD_READ" then
        process_soc_word_read(params, c_expr);
      elsif action_name = "SOC_WRITE" then
        process_soc_write(params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "STR" then
      if action_name = "STR_APPEND" then
        process_str_append(params, c_expr);
      elsif action_name = "STR_CAT" then
        process_str_cat(params, c_expr);
      elsif action_name = "STR_CHIPOS" then
        process_str_chipos(params, c_expr);
      elsif action_name = "STR_CHPOS" then
        process_str_chpos(params, c_expr);
      elsif action_name = "STR_CHSPLIT" then
        process_str_chsplit(params, c_expr);
      elsif action_name = "STR_CLIT" then
        process_str_clit(params, c_expr);
      elsif action_name = "STR_CMP" then
        process_str_cmp(params, c_expr);
      elsif action_name = "STR_CPY" then
        process_str_cpy(params, c_expr);
      elsif action_name = "STR_ELEMCPY" then
        process_str_elemcpy(function, params, c_expr);
      elsif action_name = "STR_EQ" then
        process_str_eq(params, c_expr);
      elsif action_name = "STR_GE" then
        process_str_ge(params, c_expr);
      elsif action_name = "STR_GETENV" then
        process_str_getenv(params, c_expr);
      elsif action_name = "STR_GT" then
        process_str_gt(params, c_expr);
      elsif action_name = "STR_HASHCODE" then
        process_str_hashcode(params, c_expr);
      elsif action_name = "STR_HEAD" then
        process_str_head(params, c_expr);
      elsif action_name = "STR_IDX" then
        process_str_idx(function, params, c_expr);
      elsif action_name = "STR_IPOS" then
        process_str_ipos(params, c_expr);
      elsif action_name = "STR_LE" then
        process_str_le(params, c_expr);
      elsif action_name = "STR_LIT" then
        process_str_lit(params, c_expr);
      elsif action_name = "STR_LNG" then
        process_str_lng(params, c_expr);
      elsif action_name = "STR_LOW" then
        process_str_low(params, c_expr);
      elsif action_name = "STR_LPAD" then
        process_str_lpad(params, c_expr);
      elsif action_name = "STR_LPAD0" then
        process_str_lpad0(params, c_expr);
      elsif action_name = "STR_LT" then
        process_str_lt(params, c_expr);
      elsif action_name = "STR_MULT" then
        process_str_mult(params, c_expr);
      elsif action_name = "STR_NE" then
        process_str_ne(params, c_expr);
      elsif action_name = "STR_POS" then
        process_str_pos(params, c_expr);
      elsif action_name = "STR_RANGE" then
        process_str_range(params, c_expr);
      elsif action_name = "STR_RCHPOS" then
        process_str_rchpos(params, c_expr);
      elsif action_name = "STR_REPL" then
        process_str_repl(params, c_expr);
      elsif action_name = "STR_RPAD" then
        process_str_rpad(params, c_expr);
      elsif action_name = "STR_RPOS" then
        process_str_rpos(params, c_expr);
      elsif action_name = "STR_SPLIT" then
        process_str_split(params, c_expr);
      elsif action_name = "STR_STR" then
        process_str_str(params, c_expr);
      elsif action_name = "STR_SUBSTR" then
        process_str_substr(params, c_expr);
      elsif action_name = "STR_TAIL" then
        process_str_tail(params, c_expr);
      elsif action_name = "STR_TOUTF8" then
        process_str_toutf8(params, c_expr);
      elsif action_name = "STR_TRIM" then
        process_str_trim(params, c_expr);
      elsif action_name = "STR_UP" then
        process_str_up(params, c_expr);
      elsif action_name = "STR_UTF8TOSTRI" then
        process_str_utf8tostri(params, c_expr);
      elsif action_name = "STR_VALUE" then
        process_str_value(params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "TIM" then
      if action_name = "TIM_AWAIT" then
        process_tim_await(params, c_expr);
      elsif action_name = "TIM_NOW" then
        process_tim_now(params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "TYP" then
      if action_name = "TYP_CPY" then
        process_typ_cpy(params, c_expr);
      elsif action_name = "TYP_EQ" then
        process_typ_eq(params, c_expr);
      elsif action_name = "TYP_HASHCODE" then
        process_typ_hashcode(params, c_expr);
      elsif action_name = "TYP_ISDERIVED" then
        process_typ_isderived(params, c_expr);
      elsif action_name = "TYP_ISFUNC" then
        process_typ_isfunc(params, c_expr);
      elsif action_name = "TYP_ISVARFUNC" then
        process_typ_isvarfunc(params, c_expr);
      elsif action_name = "TYP_MATCHOBJ" then
        process_typ_matchobj(params, c_expr);
      elsif action_name = "TYP_META" then
        process_typ_meta(params, c_expr);
      elsif action_name = "TYP_NE" then
        process_typ_ne(params, c_expr);
      elsif action_name = "TYP_NUM" then
        process_typ_num(params, c_expr);
      elsif action_name = "TYP_RESULT" then
        process_typ_result(params, c_expr);
      elsif action_name = "TYP_STR" then
        process_typ_str(params, c_expr);
      elsif action_name = "TYP_VALUE" then
        process_typ_value(params, c_expr);
      elsif action_name = "TYP_VARCONV" then
        process_typ_varconv(params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "UT8" then
      if action_name = "UT8_GETC" then
        process_ut8_getc(params, c_expr);
      elsif action_name = "UT8_GETS" then
        process_ut8_gets(params, c_expr);
      elsif action_name = "UT8_LINE_READ" then
        process_ut8_line_read(params, c_expr);
      elsif action_name = "UT8_SEEK" then
        process_ut8_seek(params, c_expr);
      elsif action_name = "UT8_WORD_READ" then
        process_ut8_word_read(params, c_expr);
      elsif action_name = "UT8_WRITE" then
        process_ut8_write(params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    else
      process_unknown_action(action_name, c_expr);
    end if;
  end func;


const func boolean: valueIsAtHeap (in type: aType) is func

  result
    var boolean: result is FALSE;
  begin
    if  aType = biginttype or
        aType = stritype or
        aType = wintype or
        aType in array_element or
        aType in struct_elements or
        aType in set_types or
        aType in isHashType or
        aType in isInterfaceType then
      result := TRUE;
    end if;
  end func;


const func boolean: valueIsAtHeap (in reference: a_param) is
  return valueIsAtHeap(getType(a_param));


const func boolean: isPointerParam (in reference: a_param) is func

  result
    var boolean: result is TRUE;
  begin
    result := category(a_param) = REFPARAMOBJECT and
        (not valueIsAtHeap(a_param) or isVar(a_param));
  end func;


const func boolean: isCopyParam (in reference: a_param) is func

  result
    var boolean: result is TRUE;
  begin
    result := category(a_param) = VALUEPARAMOBJECT and
        valueIsAtHeap(a_param);
  end func;


const func boolean: isInOutParam (in reference: a_param) is func

  result
    var boolean: result is TRUE;
  begin
    result := category(a_param) = REFPARAMOBJECT and isVar(a_param);
  end func;


const func boolean: canTakeAddress (in reference: an_expression) is func

  result
    var boolean: result is TRUE;
  local
    var category: exprCategory is category.value;
    var string: action_name is "";
  begin
    exprCategory := category(an_expression);
    if (exprCategory = INTOBJECT or
        exprCategory = CHAROBJECT or
        exprCategory = FLOATOBJECT) and
        not isVar(an_expression) then
      result := FALSE;
    end if;
    if is_func(getType(an_expression)) then
      result := FALSE;
    end if;
    if exprCategory = CALLOBJECT then
      if category(getValue(an_expression, ref_list)[1]) = ACTOBJECT then
        action_name := str(getValue(getValue(an_expression, ref_list)[1], ACTION));
        if  action_name = "ARR_IDX" or
            action_name = "SCT_SELECT" then
          result := TRUE;
        end if;
      end if;
    end if;
  end func;


const proc: process_constenumobject (in reference: function, in ref_list: params,
    inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "/*constenumobject*/";
    noop_params(params(function), params, c_expr);
  end func;


const func boolean: param_list_okay (in ref_list: formal_params) is func

  result
    var boolean: okay is TRUE;
  local
    var reference: obj is NIL;
    var category: paramCategory is category.value;
  begin
    for obj range formal_params do
      paramCategory := category(obj);
      if paramCategory <> SYMBOLOBJECT and paramCategory <> TYPEOBJECT then
        if                                  # getType(obj) = typetype or
            is_func(getType(obj)) then
          okay := FALSE;
        end if;
      end if;
    end for;
  end func;


const proc: process_local_declaration (in reference: current_object, in var reference: object_value,
    inout expr_type: c_expr) is func

  local
    var type: objectType is void;
    var category: valueCategory is category.value;
    var expr_type: c_value is expr_type.value;
    var string: param_name is "";
    var string: param_value is "";
  begin
    objectType := getType(current_object);
    declare_type_if_necessary(objectType, global_c_expr);
    c_expr.temp_decls &:= type_name(objectType);
    c_expr.temp_decls &:= " o_";
    create_name(current_object, c_expr.temp_decls);
    valueCategory := category(object_value);
    if objectType in isInterfaceType then
      if valueCategory = INTERFACEOBJECT then
        object_value := interface_to_struct(object_value);
        valueCategory := category(object_value);
      end if;
      if isVar(object_value) then
        c_expr.temp_decls &:= "=o_";
        create_name(object_value, c_expr.temp_decls);
        c_expr.temp_decls &:= "/* ";
        c_expr.temp_decls &:= str(valueCategory);
        c_expr.temp_decls &:= " */";
      else
        if object_value not in const_table then
          const_table @:= [object_value] length(const_table);
        end if;
        c_expr.temp_assigns &:= "o_";
        create_name(current_object, c_expr.temp_assigns);
        c_expr.temp_assigns &:= "=itf[";
        c_expr.temp_assigns &:= str(const_table[object_value]);
        c_expr.temp_assigns &:= "];\n";
      end if;
    elsif valueCategory = TYPEOBJECT then
      c_expr.temp_decls &:= "=NULL";
    elsif valueCategory = INTOBJECT then
      c_expr.temp_decls &:= "=";
      c_expr.temp_decls &:= str(getValue(object_value, integer));
    elsif valueCategory = BIGINTOBJECT then
      if getValue(object_value, bigInteger) not in bigint_const_table then
        bigint_const_table @:= [getValue(object_value, bigInteger)] length(bigint_const_table);
      end if;
      c_expr.temp_assigns &:= "o_";
      create_name(current_object, c_expr.temp_assigns);
      c_expr.temp_assigns &:= "=bigCreate(big[";
      c_expr.temp_assigns &:= str(bigint_const_table[getValue(object_value, bigInteger)]);
      c_expr.temp_assigns &:= "] /* ";
      c_expr.temp_assigns &:= str(getValue(object_value, bigInteger));
      c_expr.temp_assigns &:= " */);\n";
      c_expr.temp_frees &:= "bigDestr(o_";
      create_name(current_object, c_expr.temp_frees);
      c_expr.temp_frees  &:= ");\n";
    elsif valueCategory = CHAROBJECT then
      c_expr.temp_decls &:= "=";
      c_expr.temp_decls &:= c_literal(getValue(object_value, char));
    elsif valueCategory = FLOATOBJECT then
      c_expr.temp_decls &:= "=";
      c_expr.temp_decls &:= str(getValue(object_value, float));
    elsif valueCategory = STRIOBJECT then
      c_expr.temp_assigns &:= "o_";
      create_name(current_object, c_expr.temp_assigns);
      c_expr.temp_assigns &:= "=";
      process_str_create_call(getValue(object_value, string), c_expr.temp_assigns);
      c_expr.temp_frees &:= "strDestr(o_";
      create_name(current_object, c_expr.temp_frees);
      c_expr.temp_frees  &:= ");\n";
    elsif valueCategory = BSTRIOBJECT then
      c_expr.temp_assigns &:= "o_";
      create_name(current_object, c_expr.temp_assigns);
      c_expr.temp_assigns &:= "=bstCreate(&empty_bst);\n";
      c_expr.temp_frees &:= "bstDestr(o_";
      create_name(current_object, c_expr.temp_frees);
      c_expr.temp_frees  &:= ");\n";
    elsif valueCategory = SETOBJECT then
      if getValue(object_value, bitset) not in set_const_table then
        set_const_table @:= [getValue(object_value, bitset)] length(set_const_table);
      end if;
      c_expr.temp_assigns &:= "o_";
      create_name(current_object, c_expr.temp_assigns);
      c_expr.temp_assigns &:= "=setCreate(set[";
      c_expr.temp_assigns &:= str(set_const_table[getValue(object_value, bitset)]);
      c_expr.temp_assigns &:= "]);\n";
      c_expr.temp_frees &:= "setDestr((settype)(o_";
      create_name(current_object, c_expr.temp_frees);
      c_expr.temp_frees  &:= "));\n";
    elsif valueCategory = REFOBJECT then
      c_expr.temp_decls &:= "=";
      reference_value(getValue(object_value, reference), c_value);
      c_expr.temp_decls &:= c_value.expr;
    elsif valueCategory = REFLISTOBJECT then
      c_expr.temp_decls &:= "=";
      ref_list_value(getValue(object_value, ref_list), c_value);
      c_expr.temp_decls &:= c_value.expr;
    elsif valueCategory = FILEOBJECT then
      c_expr.temp_decls &:= "=NULL";
    elsif valueCategory = SOCKETOBJECT then
      c_expr.temp_decls &:= "=-1";
    elsif valueCategory = ARRAYOBJECT then
      if object_value not in const_table then
        const_table @:= [object_value] length(const_table);
      end if;
      process_create_declaration(getType(current_object), global_c_expr);
      process_destr_declaration(getType(current_object), global_c_expr);
      c_expr.temp_assigns &:= "o_";
      create_name(current_object, c_expr.temp_assigns);
      c_expr.temp_assigns &:= "=";
      param_value := "(";
      param_value &:= type_name(getType(current_object));
      param_value &:= ")(arr[";
      param_value &:= str(const_table[object_value]);
      param_value &:= "])";
      process_create_call(getType(current_object),
          param_value, c_expr.temp_assigns);
      c_expr.temp_assigns &:= ";\n";
      param_name := "o_";
      create_name(current_object, param_name);
      process_destr_call(getType(current_object),
          param_name, c_expr.temp_frees);
    elsif valueCategory = STRUCTOBJECT then
      if object_value not in const_table then
        const_table @:= [object_value] length(const_table);
      end if;
      process_create_declaration(getType(current_object), global_c_expr);
      process_destr_declaration(getType(current_object), global_c_expr);
      c_expr.temp_assigns &:= "o_";
      create_name(current_object, c_expr.temp_assigns);
      c_expr.temp_assigns &:= "=";
      param_value := "(";
      param_value &:= type_name(getType(current_object));
      param_value &:= ")(sct[";
      param_value &:= str(const_table[object_value]);
      param_value &:= "])";
      process_create_call(getType(current_object),
          param_value, c_expr.temp_assigns);
      c_expr.temp_assigns &:= ";\n";
      param_name := "o_";
      create_name(current_object, param_name);
      process_destr_call(getType(current_object),
          param_name, c_expr.temp_frees);
    elsif valueCategory = HASHOBJECT then
      if object_value not in const_table then
        const_table @:= [object_value] length(const_table);
      end if;
      process_create_declaration(getType(current_object), global_c_expr);
      process_destr_declaration(getType(current_object), global_c_expr);
      c_expr.temp_assigns &:= "o_";
      create_name(current_object, c_expr.temp_assigns);
      c_expr.temp_assigns &:= "=";
      param_value := "(";
      param_value &:= type_name(getType(current_object));
      param_value &:= ")(hsh[";
      param_value &:= str(const_table[object_value]);
      param_value &:= "])";
      process_create_call(getType(current_object),
          param_value, c_expr.temp_assigns);
      c_expr.temp_assigns &:= ";\n";
      param_name := "o_";
      create_name(current_object, param_name);
      process_destr_call(getType(current_object),
          param_name, c_expr.temp_frees);
    elsif valueCategory = INTERFACEOBJECT then
      if object_value not in const_table then
        const_table @:= [object_value] length(const_table);
      end if;
      c_expr.temp_assigns &:= "o_";
      create_name(current_object, c_expr.temp_assigns);
      c_expr.temp_assigns &:= "=itf[";
      c_expr.temp_assigns &:= str(const_table[object_value]);
      c_expr.temp_assigns &:= "];\n";
    elsif valueCategory = WINOBJECT then
      c_expr.temp_decls &:= "=NULL";
      c_expr.temp_frees &:= "drwDestr(o_";
      create_name(current_object, c_expr.temp_frees);
      c_expr.temp_frees  &:= ");\n";
    elsif valueCategory = PROGOBJECT then
      c_expr.temp_decls &:= "=NULL";
      c_expr.temp_frees &:= "prgDestr(o_";
      create_name(current_object, c_expr.temp_frees);
      c_expr.temp_frees  &:= ");\n";
    elsif valueCategory = CONSTENUMOBJECT then
      c_expr.temp_decls &:= "=";
      c_expr.temp_decls &:= enum_value(getValue(object_value, reference));
    elsif valueCategory = VARENUMOBJECT then
      c_expr.temp_decls &:= "=";
      c_expr.temp_decls &:= enum_value(getValue(object_value, reference));
    elsif valueCategory = ENUMLITERALOBJECT then
      c_expr.temp_decls &:= "=o_";
      create_name(object_value, c_expr.temp_decls);
    elsif valueCategory = CALLOBJECT then
      param_name := "o_";
      create_name(current_object, param_name);
      c_value.temp_num := c_expr.temp_num;
      getTemporaryToResultExpr(object_value, c_value);
      c_expr.temp_num := c_value.temp_num;
      c_expr.temp_decls &:= c_value.temp_decls;
      c_expr.temp_assigns &:= c_value.temp_assigns;
      c_expr.temp_frees &:= c_value.temp_frees;
      c_expr.temp_assigns &:= param_name;
      c_expr.temp_assigns &:= "=";
      c_expr.temp_assigns &:= c_value.result_expr;
      c_expr.temp_assigns &:= ";\n";
      process_destr_declaration(getType(current_object), global_c_expr);
      process_destr_call(getType(current_object),
          param_name, c_expr.temp_frees);
    elsif valueCategory = ACTOBJECT then
      c_expr.temp_decls &:= "=NULL";
    else
      c_expr.temp_decls &:= "/* ";
      c_expr.temp_decls &:= str(valueCategory);
      c_expr.temp_decls &:= " */";
    end if;
    c_expr.temp_decls &:= ";\n";
  end func;


const proc: process_local_var_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var ref_list: objects is ref_list.EMPTY;
    var reference: obj is NIL;
  begin
    objects := local_vars(current_object);
    for obj range objects do
      process_local_declaration(obj, getValue(obj, reference), c_expr);
    end for;
  end func;


const proc: push_object_value (in reference: obj, in reference: value) is func

  local
    var integer: length is 0;
    var integer: number is 0;
  begin
    length := length(object_value);
    number := obj_number(obj);
    if length < number then
      object_value := object_value & number - length times ref_list.EMPTY;
    end if;
    incl(object_value[number], value);
  end func;


const proc: pop_object_value (in reference: obj) is func

  local
    var integer: length is 0;
    var integer: number is 0;
  begin
    number := obj_number(obj);
    object_value[number] := object_value[number][2 ..];
  end func;


const proc: push_macro_param (in reference: formal_param,
    in reference: actual_param, inout expr_type: c_expr) is func

  local
    var type: param_type is void;
    var integer: temp_num is 0;
  begin
    if category(formal_param) <> SYMBOLOBJECT then
      param_type := getType(formal_param);
      if is_func(param_type) then
        c_expr.expr &:= "/* proc param o_";
        create_name2(formal_param, c_expr.expr);
        c_expr.expr &:= "*/\n";
        push_object_value(formal_param, actual_param);
(*
      elsif param_type = typetype then
        c_expr.expr &:= "/* type param o_";
        create_name2(formal_param, c_expr.expr);
        c_expr.expr &:= "*/\n";
*)
      else
        c_expr.expr &:= type_name(param_type);
        if isPointerParam(formal_param) then
          c_expr.expr &:= " *o_";
          create_name(formal_param, c_expr.expr);
          c_expr.expr &:= "=";
          if category(actual_param) = REFPARAMOBJECT then
            c_expr.expr &:= "o_";
            create_name(actual_param, c_expr.expr);
            c_expr.expr &:= ";\n";
          elsif canTakeAddress(actual_param) then
            c_expr.expr &:= "&(";
            process_expr(actual_param, c_expr);
            c_expr.expr &:= ");\n";
          else
            incr(c_expr.temp_num);
            temp_num := c_expr.temp_num;
            c_expr.temp_decls &:= type_name(getExprResultType(actual_param));
            c_expr.temp_decls &:= " tmp_";
            c_expr.temp_decls &:= str(temp_num);
            c_expr.temp_decls &:= ";\n";
            c_expr.expr &:= "(tmp_";
            c_expr.expr &:= str(temp_num);
            c_expr.expr &:= "=";
            getAnyParamToExpr(actual_param, c_expr);
            c_expr.expr &:= ", &tmp_";
            c_expr.expr &:= str(temp_num);
            c_expr.expr &:= ");\n";
          end if;
        else
          c_expr.expr &:= " o_";
          create_name(formal_param, c_expr.expr);
          c_expr.expr &:= "=";
          getAnyParamToExpr(actual_param, c_expr);
          c_expr.expr &:= ";\n";
        end if;
      end if;
    end if;
  end func;


const proc: push_macro_params (in ref_list: formal_params,
    in ref_list: actual_params, inout expr_type: c_expr) is func

  local
    var integer: number is 0;
  begin
    for number range 1 to length(formal_params) do
      push_macro_param(formal_params[number], actual_params[number], c_expr);
    end for;
  end func;


const proc: pop_macro_param (in reference: formal_param,
    inout expr_type: c_expr) is func

  local
    var category: paramCategory is category.value;
    var type: param_type is void;
  begin
    paramCategory := category(formal_param);
    if paramCategory <> SYMBOLOBJECT then
      param_type := getType(formal_param);
      if is_func(param_type) then
        c_expr.expr &:= "/* end proc param o_";
        create_name2(formal_param, c_expr.expr);
        c_expr.expr &:= "*/\n";
        pop_object_value(formal_param);
      end if;
    end if;
  end func;


const proc: pop_macro_params (in ref_list: formal_params,
    inout expr_type: c_expr) is func

  local
    var integer: number is 0;
  begin
    for number range 1 to length(formal_params) do
      pop_macro_param(formal_params[number], c_expr);
    end for;
  end func;


const proc: process_macro (in reference: function,
    in ref_list: formal_params, in ref_list: actual_params,
    inout expr_type: c_expr) is func

  local
    var type: result_type is void;
    var expr_type: macro_decls is expr_type.value;
    var reference: result_object is NIL;
  begin
    result_type := result_type(getType(function));
    if result_type = voidtype then
      c_expr.expr &:= "/* macro o_";
      create_name2(function, c_expr.expr);
      c_expr.expr &:= "*/ {\n";
      c_expr.expr &:= "/* macro params */\n";
      push_macro_params(formal_params, actual_params, c_expr);
      c_expr.expr &:= "/* macro local_vars */\n";
      process_local_var_declaration(function, macro_decls);
      c_expr.expr &:= macro_decls.temp_decls;
      c_expr.expr &:= macro_decls.temp_assigns;
      c_expr.expr &:= "/* macro body */\n";
      process_expr(body(function), c_expr);
      c_expr.expr &:= macro_decls.temp_frees;
      pop_macro_params(formal_params, c_expr);
      c_expr.expr &:= "\n} /* macro o_";
      create_name2(function, c_expr.expr);
      c_expr.expr &:= "*/\n";
    else
      c_expr.expr &:= "/* macro o_";
      create_name2(function, c_expr.expr);
      c_expr.expr &:= "*/ (\n";
      macro_decls.temp_num := c_expr.temp_num;
      push_macro_params(formal_params, actual_params, macro_decls);
      process_local_var_declaration(function, macro_decls);
      result_object := func_result(function);
      if result_object <> NIL then
        macro_decls.expr &:= type_name(getType(result_object));
        macro_decls.expr &:= " o_";
        create_name(result_object, macro_decls.expr);
        macro_decls.expr &:= ";\n";
      end if;
      c_expr.temp_num := macro_decls.temp_num;
      incr(c_expr.temp_num);
      c_expr.temp_decls &:= macro_decls.temp_decls;
      c_expr.temp_assigns &:= macro_decls.temp_assigns;
      c_expr.temp_assigns &:= macro_decls.expr;
      c_expr.temp_frees &:= macro_decls.temp_frees;
      process_expr(body(function), c_expr);
      pop_macro_params(formal_params, c_expr);
      c_expr.expr &:= "\n) /* macro o_";
      create_name2(function, c_expr.expr);
      c_expr.expr &:= "*/\n";
    end if;
  end func;


const proc: call_params (in ref_list: formal_params,
    in ref_list: actual_params, inout expr_type: c_expr) is func

  local
    var integer: number is 0;
    var reference: formal_param is NIL;
    var reference: actual_param is NIL;
    var category: paramCategory is category.value;
    var boolean: first_element is TRUE;
    var integer: temp_num is 0;
  begin
#    for number range 1 to length(formal_params) do
    for number range 1 to length(actual_params) do
      formal_param := formal_params[number];
      actual_param := actual_params[number];
      paramCategory := category(formal_param);
      if paramCategory <> SYMBOLOBJECT then
        if paramCategory = TYPEOBJECT then
          c_expr.expr &:= "/* attr t_";
          c_expr.expr &:= str(type_number(getValue(formal_param, type)));
          c_expr.expr &:= " ";
          c_expr.expr &:= str(getValue(formal_param, type));
          c_expr.expr &:= "*/ ";
        else
          if first_element then
            first_element := FALSE;
          else
            c_expr.expr &:= ", ";
          end if;
          if isPointerParam(formal_param) then
            if category(actual_param) = REFPARAMOBJECT then
              c_expr.expr &:= "o_";
              create_name(actual_param, c_expr.expr);
            elsif canTakeAddress(actual_param) then
              c_expr.expr &:= "&(";
              process_expr(actual_param, c_expr);
              c_expr.expr &:= ")";
            else
              c_expr.expr &:= "/* ";
              c_expr.expr &:= str(category(actual_param));
              c_expr.expr &:= " */";
              incr(c_expr.temp_num);
              temp_num := c_expr.temp_num;
              c_expr.temp_decls &:= type_name(getExprResultType(actual_param));
              c_expr.temp_decls &:= " tmp_";
              c_expr.temp_decls &:= str(temp_num);
              c_expr.temp_decls &:= ";\n";
              c_expr.expr &:= "(tmp_";
              c_expr.expr &:= str(temp_num);
              c_expr.expr &:= "=";
              getAnyParamToExpr(actual_param, c_expr);
              c_expr.expr &:= ", &tmp_";
              c_expr.expr &:= str(temp_num);
              c_expr.expr &:= ")";
            end if;
          else
            getAnyParamToExpr(actual_param, c_expr);
          end if;
        end if;
      end if;
    end for;
  end func;


const proc: process_prototype_declaration (in reference: current_object,
    inout expr_type: c_expr) is forward;


const proc: process_function (in reference: function,
    in ref_list: formal_params, in ref_list: actual_params,
    inout expr_type: c_expr) is func

  local
    var type: function_type is void;
    var type: result_type is void;
    var expr_type: c_params is expr_type.value;
  begin

    if function not in prototype_declared then
      process_prototype_declaration(function, global_c_expr);
      prototype_declared @:= [function] TRUE;
    end if;

    function_type := getType(function);
    result_type := result_type(function_type);
    if valueIsAtHeap(result_type) and
        not is_varfunc(function_type) and
        function not in return_ref_to_value then
      prepare_typed_result(result_type, c_expr);
      if is_varfunc(function_type) then
        c_expr.result_expr &:= "*o_";
      else
        c_expr.result_expr &:= "o_";
      end if;
      create_name(function, c_expr.result_expr);
      c_expr.result_expr &:= "(";
      c_params.temp_num := c_expr.temp_num;
      call_params(formal_params, actual_params, c_params);
      c_expr.temp_num := c_params.temp_num;
      c_expr.temp_decls &:= c_params.temp_decls;
      c_expr.temp_decls &:= c_params.temp_assigns;
      c_expr.temp_frees &:= c_params.temp_frees;
      c_expr.result_expr &:= c_params.expr;
      c_expr.result_expr &:= ")";
    elsif result_type = voidtype then
      call_params(formal_params, actual_params, c_params);
      if c_params.temp_num <> 0 then
        c_expr.expr &:= "{\n";
        c_expr.expr &:= c_params.temp_decls;
        c_expr.expr &:= c_params.temp_assigns;
      end if;
      if is_varfunc(function_type) then
        c_expr.expr &:= "*o_";
      else
        c_expr.expr &:= "o_";
      end if;
      create_name(function, c_expr.expr);
      c_expr.expr &:= "(";
      c_expr.expr &:= c_params.expr;
      c_expr.expr &:= ")";
      c_expr.expr &:= ";\n";
      if c_params.temp_num <> 0 then
        c_expr.expr &:= c_params.temp_frees;
        c_expr.expr &:= "}\n";
      end if;
    else
      if is_varfunc(function_type) then
        c_expr.expr &:= "*o_";
      else
        c_expr.expr &:= "o_";
      end if;
      create_name(function, c_expr.expr);
      c_expr.expr &:= "(";
      call_params(formal_params, actual_params, c_expr);
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process_call (in reference: current_expression, inout expr_type: c_expr) is func

  local
    var ref_list: params is ref_list.EMPTY;
    var reference: function is NIL;
    var category: functionCategory is category.value;
    var type: result_type is void;
    var ref_list: formal_params is ref_list.EMPTY;
    var reference: obj is NIL;
    var boolean: first_element is TRUE;
  begin
    # c_expr.expr &:= "/* ";
    # c_expr.expr &:= str(current_expression);
    # c_expr.expr &:= " */";
    params := getValue(current_expression, ref_list);
    function := params[1];
    params := params[2 ..];
    functionCategory := category(function);
    if functionCategory = ACTOBJECT then
      process_action(function, params, c_expr);
    elsif functionCategory = BLOCKOBJECT then
      result_type := result_type(getType(function));
      formal_params := params(function);
      if function in function_declared then
        process_function(function, formal_params, params, c_expr);
      else
        process_macro(function, formal_params, params, c_expr);
      end if;
    elsif functionCategory = VALUEPARAMOBJECT then
      process_expr(function, c_expr);
    elsif functionCategory = REFPARAMOBJECT then
      process_expr(function, c_expr);
    elsif functionCategory = CONSTENUMOBJECT then
      (* process_constenumobject(function, params, c_expr); *)
      process_expr(function, c_expr);
    elsif functionCategory = INTOBJECT then
      process_expr(function, c_expr);
    elsif functionCategory = BIGINTOBJECT then
      process_expr(function, c_expr);
    elsif functionCategory = CHAROBJECT then
      process_expr(function, c_expr);
    elsif functionCategory = STRIOBJECT then
      process_expr(function, c_expr);
    elsif functionCategory = BSTRIOBJECT then
      process_expr(function, c_expr);
    elsif functionCategory = HASHOBJECT then
      process_expr(function, c_expr);
    elsif functionCategory = SETOBJECT then
      process_expr(function, c_expr);
    elsif functionCategory = STRUCTOBJECT then
      process_expr(function, c_expr);
    elsif functionCategory = INTERFACEOBJECT then
      process_expr(function, c_expr);
    elsif functionCategory = WINOBJECT then
      process_expr(function, c_expr);
    elsif functionCategory = PROGOBJECT then
      process_expr(function, c_expr);
    elsif functionCategory = ENUMLITERALOBJECT then
      process_expr(function, c_expr);
    elsif functionCategory = REFOBJECT then
      c_expr.expr &:= "o_";
      create_name(function, c_expr.expr);
    elsif functionCategory = REFLISTOBJECT then
      c_expr.expr &:= "o_";
      create_name(function, c_expr.expr);
    else
      c_expr.expr &:= "/*[ ";
      c_expr.expr &:= str(functionCategory);
      c_expr.expr &:= " ]*/";
      c_expr.expr &:= "o_";
      create_name(function, c_expr.expr);
      c_expr.expr &:= "(";
      for obj range params do
        if category(obj) <> SYMBOLOBJECT then
          if first_element then
            first_element := FALSE;
          else
            c_expr.expr &:= ", ";
          end if;
          process_expr(obj, c_expr);
        end if;
      end for;
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process_expr (in var reference: current_expression, inout expr_type: c_expr) is func

  local
    var reference: evaluated_expression is NIL;
    var category: exprCategory is category.value;
    var expr_type: c_body is expr_type.value;
  begin
(*
    if isConstant(current_expression) then
      evaluated_expression := evaluate(prog, current_expression);
      if evaluated_expression <> NIL then
        current_expression := evaluated_expression;
      end if;
    end if;
*)
    exprCategory := category(current_expression);
    if exprCategory = MATCHOBJECT then
      process_call(current_expression, c_expr);
    elsif exprCategory = CALLOBJECT then
      process_call(current_expression, c_expr);
    elsif exprCategory = BLOCKOBJECT then
      c_expr.expr &:= "o_";
      create_name(current_expression, c_expr.expr);
      c_expr.expr &:= "()";
      if result_type(getType(current_expression)) = voidtype then
        c_expr.expr &:= ";\n";
      end if;
    elsif exprCategory = ACTOBJECT then
      process_action(current_expression, ref_list.EMPTY, c_expr);
    elsif exprCategory = LOCALVOBJECT then
      c_expr.expr &:= "o_";
      create_name(current_expression, c_expr.expr);
    elsif exprCategory = VALUEPARAMOBJECT then
      c_expr.expr &:= "o_";
      create_name(current_expression, c_expr.expr);
    elsif exprCategory = REFPARAMOBJECT then
      if isPointerParam(current_expression) then
        if obj_number(current_expression) <= length(object_value) and
            length(object_value[obj_number(current_expression)]) > 0 then
          if getType(current_expression) = proctype then
            c_expr.expr &:= "/* body o_";
            create_name2(current_expression, c_expr.expr);
            c_expr.expr &:= "*/ {\n";
            process_expr(object_value[obj_number(current_expression)][1], c_body);
            c_expr.expr &:= c_body.temp_decls;
            c_expr.expr &:= c_body.temp_assigns;
            c_expr.expr &:= c_body.expr;
            c_expr.expr &:= c_body.temp_frees;
            c_expr.expr &:= "\n} /* body o_";
            create_name2(current_expression, c_expr.expr);
            c_expr.expr &:= "*/\n";
          else
            c_expr.expr &:= "/* body o_";
            create_name2(current_expression, c_expr.expr);
            c_expr.expr &:= "*/ (";
            process_expr(object_value[obj_number(current_expression)][1], c_body);
            c_expr.expr &:= c_body.temp_decls;
            c_expr.expr &:= c_body.temp_assigns;
            c_expr.expr &:= c_body.expr;
            c_expr.expr &:= c_body.temp_frees;
            c_expr.expr &:= ")";
          end if;
        else
          c_expr.expr &:= "(*o_";
          create_name(current_expression, c_expr.expr);
          c_expr.expr &:= ")";
        end if;
      else
        c_expr.expr &:= "o_";
        create_name(current_expression, c_expr.expr);
      end if;
    elsif exprCategory = RESULTOBJECT then
      c_expr.expr &:= "o_";
      create_name(current_expression, c_expr.expr);
    elsif exprCategory = TYPEOBJECT then
      if isVar(current_expression) then
        c_expr.expr &:= "o_";
        create_name(current_expression, c_expr.expr);
      else
        c_expr.expr &:= "NULL/*";
        c_expr.expr &:= str(current_expression);
        c_expr.expr &:= "*/";
      end if;
    elsif exprCategory = INTOBJECT then
      if isVar(current_expression) then
        c_expr.expr &:= "o_";
        create_name(current_expression, c_expr.expr);
      else
        c_expr.expr &:= str(getValue(current_expression, integer)) & INTTYPE_LITERAL_SUFFIX;
      end if;
    elsif exprCategory = BIGINTOBJECT then
      if isVar(current_expression) then
        c_expr.expr &:= "o_";
        create_name(current_expression, c_expr.expr);
      else
        if getValue(current_expression, bigInteger) not in bigint_const_table then
          bigint_const_table @:= [getValue(current_expression, bigInteger)] length(bigint_const_table);
        end if;
        c_expr.expr &:= "big[";
        c_expr.expr &:= str(bigint_const_table[getValue(current_expression, bigInteger)]);
        c_expr.expr &:= "] /* ";
        c_expr.expr &:= str(getValue(current_expression, bigInteger));
        c_expr.expr &:= " */";
      end if;
    elsif exprCategory = FLOATOBJECT then
      if isVar(current_expression) then
        c_expr.expr &:= "o_";
        create_name(current_expression, c_expr.expr);
      elsif isnan(getValue(current_expression, float)) then
        if FLOAT_ZERO_DIV_ERROR then
          c_expr.expr &:= "f_const[0].floatvalue /* 0.0/0.0 */";
        else
          c_expr.expr &:= "0.0/0.0";
        end if;
      elsif getValue(current_expression, float) = Infinity then
        if FLOAT_ZERO_DIV_ERROR then
          c_expr.expr &:= "f_const[1].floatvalue /* 1.0/0.0 */";
        else
          c_expr.expr &:= "1.0/0.0";
        end if;
      elsif getValue(current_expression, float) = -Infinity then
        if FLOAT_ZERO_DIV_ERROR then
          c_expr.expr &:= "f_const[2].floatvalue /* -1.0/0.0 */";
        else
          c_expr.expr &:= "-1.0/0.0";
        end if;
      else
        c_expr.expr &:= str(getValue(current_expression, float));
      end if;
    elsif exprCategory = CHAROBJECT then
      if isVar(current_expression) then
        c_expr.expr &:= "o_";
        create_name(current_expression, c_expr.expr);
      else
        c_expr.expr &:= c_literal(getValue(current_expression, char));
      end if;
    elsif exprCategory = STRIOBJECT then
      if isVar(current_expression) then
        c_expr.expr &:= "o_";
        create_name(current_expression, c_expr.expr);
      else
        if getValue(current_expression, string) not in stri_const_table then
          stri_const_table @:= [getValue(current_expression, string)] length(stri_const_table);
        end if;
        c_expr.expr &:= "str[";
        c_expr.expr &:= str(stri_const_table[getValue(current_expression, string)]);
        c_expr.expr &:= "] /* ";
        c_expr.expr &:= replace(literal(getValue(current_expression, string)), "*/", "*\\/");
        c_expr.expr &:= " */";
      end if;
    elsif exprCategory = BSTRIOBJECT then
      if isVar(current_expression) then
        c_expr.expr &:= "o_";
        create_name(current_expression, c_expr.expr);
      else
        c_expr.expr &:= "&empty_bst";
      end if;
    elsif exprCategory = REFOBJECT then
      if isVar(current_expression) then
        c_expr.expr &:= "o_";
        create_name(current_expression, c_expr.expr);
      else
        if getValue(current_expression, reference) = NIL then
          c_expr.expr &:= "NULL";
        else
          c_expr.expr &:= "&(";
          process_expr(getValue(current_expression, reference), c_expr);
          c_expr.expr &:= ")";
        end if;
      end if;
    elsif exprCategory = REFLISTOBJECT then
      c_expr.expr &:= "o_";
      create_name(current_expression, c_expr.expr);
    elsif exprCategory = ARRAYOBJECT then
      c_expr.expr &:= "o_";
      create_name(current_expression, c_expr.expr);
    elsif exprCategory = HASHOBJECT then
      c_expr.expr &:= "o_";
      create_name(current_expression, c_expr.expr);
    elsif exprCategory = SETOBJECT then
      if isVar(current_expression) then
        c_expr.expr &:= "o_";
        create_name(current_expression, c_expr.expr);
      else
        if getValue(current_expression, bitset) not in set_const_table then
          set_const_table @:= [getValue(current_expression, bitset)] length(set_const_table);
        end if;
        c_expr.expr &:= "(";
        c_expr.expr &:= type_name(getType(current_expression));
        c_expr.expr &:= ")(set[";
        c_expr.expr &:= str(set_const_table[getValue(current_expression, bitset)]);
        c_expr.expr &:= "])";
      end if;
    elsif exprCategory = STRUCTOBJECT then
      c_expr.expr &:= "o_";
      create_name(current_expression, c_expr.expr);
    elsif exprCategory = INTERFACEOBJECT then
      c_expr.expr &:= "o_";
      create_name(current_expression, c_expr.expr);
    elsif exprCategory = FILEOBJECT then
      c_expr.expr &:= "o_";
      create_name(current_expression, c_expr.expr);
    elsif exprCategory = SOCKETOBJECT then
      c_expr.expr &:= "o_";
      create_name(current_expression, c_expr.expr);
    elsif exprCategory = WINOBJECT then
      if isVar(current_expression) then
        c_expr.expr &:= "o_";
        create_name(current_expression, c_expr.expr);
      else
        c_expr.expr &:= "/*WINOBJECT*/ NULL";
      end if;
    elsif exprCategory = PROGOBJECT then
      if isVar(current_expression) then
        c_expr.expr &:= "o_";
        create_name(current_expression, c_expr.expr);
      else
        if getValue(current_expression, program) = program.EMPTY then
          c_expr.expr &:= "/*program.EMPTY*/NULL";
        else
          c_expr.expr &:= "o_";
          create_name(current_expression, c_expr.expr);
        end if;
      end if;
    elsif exprCategory = CONSTENUMOBJECT then
      c_expr.expr &:= "o_";
      create_name(current_expression, c_expr.expr);
    elsif exprCategory = VARENUMOBJECT then
      c_expr.expr &:= "o_";
      create_name(current_expression, c_expr.expr);
    elsif exprCategory = ENUMLITERALOBJECT then
      c_expr.expr &:= "o_";
      create_name(current_expression, c_expr.expr);
    elsif exprCategory = EXPROBJECT then
      c_expr.expr &:= "o_";
      create_name(current_expression, c_expr.expr);
    elsif exprCategory = SYMBOLOBJECT then
      c_expr.expr &:= "/* SYMBOLOBJECT ";
      c_expr.expr &:= str(current_expression);
      c_expr.expr &:= " */";
    else
      c_expr.expr &:= "/* ";
      c_expr.expr &:= str(exprCategory);
      c_expr.expr &:= " */";
    end if;
  end func;


const proc: process_param_declaration (in reference: formal_param, inout expr_type: c_expr) is func

  local
    var string: param_name is "";
  begin
    c_expr.expr &:= type_name(getType(formal_param));
    if isPointerParam(formal_param) then
      c_expr.expr &:= " *o_";
      create_name(formal_param, c_expr.expr);
    elsif isCopyParam(formal_param) then
      create_name(formal_param, param_name);
      c_expr.expr &:= " value_o_";
      c_expr.expr &:= param_name;
      c_expr.temp_decls &:= type_name(getType(formal_param));
      c_expr.temp_decls &:= " o_";
      c_expr.temp_decls &:= param_name;
      c_expr.temp_decls &:= ";\n";
      c_expr.temp_assigns &:= "o_";
      c_expr.temp_assigns &:= param_name;
      c_expr.temp_assigns &:= "=";
      process_create_declaration(getType(formal_param), global_c_expr);
      process_create_call(getType(formal_param),
          "value_o_" & param_name, c_expr.temp_assigns);
      c_expr.temp_assigns &:= ";\n";
      process_destr_declaration(getType(formal_param), global_c_expr);
      process_destr_call(getType(formal_param),
          "o_" & param_name, c_expr.temp_frees);
    else
      c_expr.expr &:= " o_";
      create_name(formal_param, c_expr.expr);
    end if;
  end func;


const proc: process_param_list_declaration (in ref_list: formal_params, inout expr_type: c_expr) is func

  local
    var reference: formal_param is NIL;
    var category: paramCategory is category.value;
    var boolean: first_element is TRUE;
  begin
    for formal_param range formal_params do
      paramCategory := category(formal_param);
      if paramCategory <> SYMBOLOBJECT then
        if paramCategory = TYPEOBJECT then
          c_expr.expr &:= "/* attr t_";
          c_expr.expr &:= str(type_number(getValue(formal_param, type)));
          c_expr.expr &:= " ";
          c_expr.expr &:= str(getValue(formal_param, type));
          c_expr.expr &:= "*/ ";
        else
          if first_element then
            first_element := FALSE;
          else
            c_expr.expr &:= ", ";
          end if;
          process_param_declaration(formal_param, c_expr);
        end if;
      end if;
    end for;
    if first_element then
      c_expr.expr &:= "void";
    end if;
  end func;


const proc: process_result_declaration (in reference: result_object, in reference: result_init,
    inout expr_type: c_expr) is func

  begin
    if result_object <> NIL then
      process_local_declaration(result_object, result_init, c_expr);
    end if;
  end func;


const proc: process_return (in reference: result_object,
    inout expr_type: c_expr) is func

  begin
    if result_object <> NIL then
      c_expr.expr &:= "return(o_";
      create_name(result_object, c_expr.expr);
      c_expr.expr &:= ");\n";
    end if;
  end func;


const proc: process_return_value (in reference: function,
    in type: result_type, in expr_type: c_proc_body,
    inout expr_type: c_expr) is func

  begin
    if is_varfunc(getType(function)) then
      c_expr.expr &:= "&(";
      if c_proc_body.result_expr <> "" then
        c_expr.expr &:= c_proc_body.result_expr;
      else
        c_expr.expr &:= c_proc_body.expr;
      end if;
    else
      c_expr.expr &:= "(";
      if c_proc_body.result_expr <> "" then
        c_expr.expr &:= c_proc_body.result_expr;
      else
        if function in prototype_declared then
          process_create_declaration(result_type, global_c_expr);
          process_create_call(result_type, c_proc_body.expr, c_expr.expr);
        else
          if valueIsAtHeap(result_type) then
            return_ref_to_value @:= [function] TRUE;
            c_expr.expr &:= "/*ref_to_value*/ ";
          end if;
          c_expr.expr &:= c_proc_body.expr;
        end if;
      end if;
    end if;
    c_expr.expr &:= ");\n";
  end func;


const proc: process_local_consts (in reference: current_object,
    inout expr_type: c_expr) is forward;


const proc: process_func_declaration (in reference: function,
    inout expr_type: c_expr) is func

  local
    var expr_type: c_param_list is expr_type.value;
    var expr_type: c_result is expr_type.value;
    var expr_type: c_local_vars is expr_type.value;
    var expr_type: c_proc_body is expr_type.value;
    var type: function_type is void;
    var type: result_type is void;
    var ref_list: param_list is ref_list.EMPTY;
    var reference: result_object is NIL;
    var reference: result_init is NIL;
  begin
    function_type := getType(function);
    result_type := result_type(function_type);
    param_list := params(function);
    if param_list_okay(param_list) then
      # Try to process the function declaration always.
      # The variable write_object_declaration is used to
      # decide if the function declaration should be written
      function_declared @:= [function] TRUE;
      process_local_consts(function, c_expr);
      c_expr.expr &:= "static ";
      c_expr.expr &:= type_name(result_type);
      if is_varfunc(getType(function)) then
        c_expr.expr &:= " /*varfunc*/ *o_";
      else
        c_expr.expr &:= " o_";
      end if;
      create_name(function, c_expr.expr);
      c_expr.expr &:= " (";
      process_param_list_declaration(param_list, c_param_list);
      c_expr.expr &:= c_param_list.expr;
      c_expr.expr &:= ")\n";
      c_expr.expr &:= "{\n";
      result_object := func_result(function);
      if function_type <> proctype and result_object = NIL then
        process_expr(body(function), c_proc_body);
        if c_proc_body.temp_num <> 0 or c_param_list.temp_decls <> "" then
          c_expr.expr &:= type_name(result_type);
          if is_varfunc(getType(function)) then
            c_expr.expr &:= " *result;\n";
          else
            c_expr.expr &:= " result;\n";
          end if;
          c_expr.expr &:= c_param_list.temp_decls;
          c_expr.expr &:= c_proc_body.temp_decls;
          c_expr.expr &:= c_param_list.temp_assigns;
          c_expr.expr &:= c_proc_body.temp_assigns;
          c_expr.expr &:= "result=";
          process_return_value(function, result_type, c_proc_body, c_expr);
          c_expr.expr &:= c_param_list.temp_frees;
          c_expr.expr &:= c_proc_body.temp_frees;
          c_expr.expr &:= "return(result);\n";
        else
          c_expr.expr &:= "return ";
          process_return_value(function, result_type, c_proc_body, c_expr);
        end if;
      else
        result_init := func_res_init(function);
        process_result_declaration(result_object, result_init, c_result);
        process_local_var_declaration(function, c_local_vars);
        process_expr(body(function), c_proc_body);
        c_expr.expr &:= c_param_list.temp_decls;
        c_expr.expr &:= c_result.temp_decls;
        c_expr.expr &:= c_local_vars.temp_decls;
        c_expr.expr &:= c_proc_body.temp_decls;
        c_expr.expr &:= c_param_list.temp_assigns;
        c_expr.expr &:= c_result.temp_assigns;
        c_expr.expr &:= c_local_vars.temp_assigns;
        c_expr.expr &:= c_proc_body.temp_assigns;
        c_expr.expr &:= c_proc_body.expr;
        c_expr.expr &:= c_param_list.temp_frees;
        c_expr.expr &:= c_local_vars.temp_frees;
        c_expr.expr &:= c_proc_body.temp_frees;
        process_return(result_object, c_expr);
      end if;
      c_expr.expr &:= "}\n\n";
      if write_object_declaration then
        prototype_declared @:= [function] TRUE;
        count_declarations;
      else
        excl(function_declared, function);
        c_expr.expr &:= "/* declare macro o_";
        create_name2(function, c_expr.expr);
        c_expr.expr &:= "*/\n";
      end if;
    else
      c_expr.expr &:= "/* declare macro o_";
      create_name2(function, c_expr.expr);
      c_expr.expr &:= "*/\n";
    end if;
  end func;


const proc: process_prototype_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var expr_type: c_param_list is expr_type.value;
    var type: current_type is void;
    var type: result_type is void;
    var ref_list: param_list is ref_list.EMPTY;
    var reference: result_object is NIL;
    var reference: result_init is NIL;
  begin
    current_type := getType(current_object);
    if is_func(current_type) or is_varfunc(current_type) then
      result_type := result_type(current_type);
      param_list := params(current_object);
      if param_list_okay(param_list) then
        # Forward declared functions cannot (at the moment) be macros 
        function_declared @:= [current_object] TRUE;
        c_expr.expr &:= "static ";
        c_expr.expr &:= type_name(result_type);
        if is_varfunc(current_type) then
          c_expr.expr &:= " *o_";
        else
          c_expr.expr &:= " o_";
        end if;
        create_name(current_object, c_expr.expr);
        c_expr.expr &:= " (";
        process_param_list_declaration(param_list, c_param_list);
        c_expr.expr &:= c_param_list.expr;
        c_expr.expr &:= ");\n\n";
      end if;
    else
      c_expr.expr &:= type_name(current_type);
      c_expr.expr &:= " o_";
      create_name(current_object, c_expr.expr);
      c_expr.expr &:= ";\n\n";
    end if;
  end func;


const proc: process_forward_declaration (in reference: fwd_ref,
    inout expr_type: c_expr) is func

  begin
    process_prototype_declaration(getValue(fwd_ref, reference), c_expr);
  end func;


const proc: process_type_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var type: aType is void;
  begin
    if isVar(current_object) then
      c_expr.expr &:= "typetype o_";
      create_name(current_object, c_expr.expr);
      c_expr.expr &:= "=NULL";
      c_expr.expr &:= ";\n\n";
    else
      aType := getValue(current_object, type);
      if is_derived(aType) and
          meta(aType) in isInterfaceType and
          aType not in isInterfaceType then
        isInterfaceType @:= [aType] TRUE;
      end if;
      declare_type_if_necessary(aType, c_expr);
    end if;
    count_declarations;
  end func;


const proc: process_int_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  begin
    if isVar(current_object) then
      c_expr.expr &:= "inttype o_";
      create_name(current_object, c_expr.expr);
      c_expr.expr &:= "=";
      c_expr.expr &:= str(getValue(current_object, integer));
      c_expr.expr &:= ";\n\n";
      count_declarations;
    end if;
  end func;


const proc: process_bigint_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  begin
    if isVar(current_object) then
      c_expr.expr &:= "biginttype o_";
      create_name(current_object, c_expr.expr);
      c_expr.expr &:= ";\n\n";
      if getValue(current_object, bigInteger) not in bigint_const_table then
        bigint_const_table @:= [getValue(current_object, bigInteger)] length(bigint_const_table);
      end if;
      global_init.expr &:= "o_";
      create_name(current_object, global_init.expr);
      global_init.expr &:= "=bigCreate(big[";
      global_init.expr &:= str(bigint_const_table[getValue(current_object, bigInteger)]);
      global_init.expr &:= "] /* ";
      global_init.expr &:= str(getValue(current_object, bigInteger));
      global_init.expr &:= " */";
      global_init.expr &:= ");\n";
      count_declarations;
    end if;
  end func;


const proc: process_char_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  begin
    if isVar(current_object) then
      c_expr.expr &:= "chartype o_";
      create_name(current_object, c_expr.expr);
      c_expr.expr &:= "=";
      c_expr.expr &:= c_literal(getValue(current_object, char));
      c_expr.expr &:= ";\n\n";
      count_declarations;
    end if;
  end func;


const proc: process_stri_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  begin
    if isVar(current_object) then
      c_expr.expr &:= "stritype o_";
      create_name(current_object, c_expr.expr);
      c_expr.expr &:= ";\n\n";
      global_init.expr &:= "o_";
      create_name(current_object, global_init.expr);
      global_init.expr &:= "=";
      process_str_create_call(getValue(current_object, string), global_init.expr);
      count_declarations;
    end if;
  end func;


const proc: process_bstri_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  begin
    if isVar(current_object) then
      c_expr.expr &:= "bstritype o_";
      create_name(current_object, c_expr.expr);
      c_expr.expr &:= ";\n\n";
      global_init.expr &:= "o_";
      create_name(current_object, global_init.expr);
      global_init.expr &:= "=bstCreate(&empty_bst);\n";
      count_declarations;
    end if;
  end func;


const proc: process_float_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  begin
    if isVar(current_object) then
      c_expr.expr &:= "floattype o_";
      create_name(current_object, c_expr.expr);
      c_expr.expr &:= "=";
      c_expr.expr &:= str(getValue(current_object, float));
      c_expr.expr &:= ";\n\n";
      count_declarations;
    end if;
  end func;


const proc: action_address (in reference: function, inout expr_type: c_expr) is func

  local
    var ACTION: current_action is action "PRC_NOOP";
    var string: action_name is "";
    var type: object_type is void;
  begin
    current_action := getValue(function, ACTION);
    action_name := str(current_action);
    if action_name = "ARR_CREATE" then
      object_type := getType(params(function)[1]);
      process_create_declaration(object_type, global_c_expr);
      c_expr.expr &:= "&create_";
      c_expr.expr &:= str(type_number(object_type));
    elsif action_name = "ARR_DESTR" then
      object_type := getType(params(function)[1]);
      process_destr_declaration(object_type, global_c_expr);
      c_expr.expr &:= "&destr_";
      c_expr.expr &:= str(type_number(object_type));
    elsif action_name = "ARR_CPY" then
      object_type := getType(params(function)[1]);
      process_cpy_declaration(object_type, global_c_expr);
      c_expr.expr &:= "&cpy_";
      c_expr.expr &:= str(type_number(object_type));
    elsif action_name = "BIG_CMP" then
      c_expr.expr &:= "&bigCmp";
    elsif action_name = "BIG_CPY" then
      c_expr.expr &:= "&bigCpy";
    elsif action_name = "BIG_CREATE" then
      c_expr.expr &:= "&bigCreate";
    elsif action_name = "BIG_DESTR" then
      c_expr.expr &:= "&bigDestr";
    elsif action_name = "BLN_CPY" then
      c_expr.expr &:= "&blnCpy";
    elsif action_name = "BLN_CREATE" then
      c_expr.expr &:= "&blnCreate";
    elsif action_name = "CHR_CMP" then
      c_expr.expr &:= "&chrCmp";
    elsif action_name = "CHR_CPY" then
      c_expr.expr &:= "&chrCpy";
    elsif action_name = "CHR_CREATE" then
      c_expr.expr &:= "&chrCreate";
    elsif action_name = "DRW_CMP" then
      c_expr.expr &:= "&drwCmp";
    elsif action_name = "DRW_CPY" then
      c_expr.expr &:= "&drwCpy";
    elsif action_name = "DRW_CREATE" then
      c_expr.expr &:= "&drwCreate";
    elsif action_name = "DRW_DESTR" then
      c_expr.expr &:= "&drwDestr";
    elsif action_name = "FLT_CMP" then
      c_expr.expr &:= "&fltCmp";
    elsif action_name = "FLT_CPY" then
      c_expr.expr &:= "&fltCpy";
    elsif action_name = "FLT_CREATE" then
      c_expr.expr &:= "&fltCreate";
    elsif action_name = "INT_CMP" then
      c_expr.expr &:= "&intCmp";
    elsif action_name = "INT_CPY" then
      c_expr.expr &:= "&intCpy";
    elsif action_name = "INT_CREATE" then
      c_expr.expr &:= "&intCreate";
    elsif action_name = "ITF_CPY" then
      c_expr.expr &:= "&intCpy";
    elsif action_name = "ITF_CREATE" then
      c_expr.expr &:= "&intCreate";
    elsif action_name = "PRC_NOOP" then
      c_expr.expr &:= "&prcNoop";
    elsif action_name = "REF_CREATE" then
      c_expr.expr &:= "&refCreate";
    elsif action_name = "REF_CPY" then
      c_expr.expr &:= "&refCpy";
    elsif action_name = "REF_CMP" then
      c_expr.expr &:= "&refCmp";
    elsif action_name = "SCT_CREATE" then
      object_type := getType(params(function)[1]);
      process_create_declaration(object_type, global_c_expr);
      c_expr.expr &:= "&create_";
      c_expr.expr &:= str(type_number(object_type));
    elsif action_name = "SCT_DESTR" then
      object_type := getType(params(function)[1]);
      process_destr_declaration(object_type, global_c_expr);
      c_expr.expr &:= "&destr_";
      c_expr.expr &:= str(type_number(object_type));
    elsif action_name = "SCT_CPY" then
      object_type := getType(params(function)[1]);
      process_cpy_declaration(object_type, global_c_expr);
      c_expr.expr &:= "&cpy_";
      c_expr.expr &:= str(type_number(object_type));
    elsif action_name = "SET_CMP" then
      c_expr.expr &:= "&setCmp";
    elsif action_name = "SET_CPY" then
      c_expr.expr &:= "&setCpy";
    elsif action_name = "SET_CREATE" then
      c_expr.expr &:= "&setCreate";
    elsif action_name = "SET_DESTR" then
      c_expr.expr &:= "&setDestr";
    elsif action_name = "STR_CMP" then
      c_expr.expr &:= "&strCompare";
    elsif action_name = "STR_CPY" then
      c_expr.expr &:= "&strCopy";
    elsif action_name = "STR_CREATE" then
      c_expr.expr &:= "&strCreate";
    elsif action_name = "STR_DESTR" then
      c_expr.expr &:= "&strDestr";
    elsif action_name = "TYP_CMP" then
      c_expr.expr &:= "&typCmp";
    elsif action_name = "TYP_CPY" then
      c_expr.expr &:= "&typCpy";
    elsif action_name = "TYP_CREATE" then
      c_expr.expr &:= "&typCreate";
    elsif action_name = "TYP_DESTR" then
      c_expr.expr &:= "&typDestr";
    else
      c_expr.expr &:= "NULL /* ACTOBJECT { ";
      c_expr.expr &:= action_name;
      c_expr.expr &:= " }*/";
    end if;
  end func;


const proc: block_address (in reference: function, inout expr_type: c_expr) is func

  local
    var ref_list: formal_params is ref_list.EMPTY;
    var reference: formal_param is NIL;
    var type: object_type is void;
    var boolean: hash_create is FALSE;
  begin
    formal_params := params(function);
    if length(formal_params) = 3 and category(formal_params[2]) = SYMBOLOBJECT and
        str(formal_params[2]) = "::=" then
      formal_param := formal_params[1];
      object_type := getType(formal_param);
      if object_type in parametersOfHshCreate then
        process_create_declaration(object_type, global_c_expr);
        hash_create := TRUE;
        c_expr.expr &:= "&create_";
        c_expr.expr &:= str(type_number(object_type));
      end if;
    end if;
    if not hash_create then
      c_expr.expr &:= "&o_";
      create_name(function, c_expr.expr);
    end if;
  end func;


const proc: object_address (in reference: current_object, inout expr_type: c_expr) is func

  local
    var reference: curr_expr is NIL;
    var category: exprCategory is category.value;
  begin
    curr_expr := getValue(current_object, reference);
    if curr_expr = NIL then
      c_expr.expr &:= "NULL";
    else
      exprCategory := category(curr_expr);
      if exprCategory = ACTOBJECT then
        # c_expr.expr &:= "(objreftype) ";
        action_address(curr_expr, c_expr);
      elsif exprCategory = BLOCKOBJECT then
        block_address(curr_expr, c_expr);
      else
        c_expr.expr &:= "/* ";
        c_expr.expr &:= str(exprCategory);
        c_expr.expr &:= " */";
        block
          c_expr.expr &:= "&(";
          process_expr(curr_expr, c_expr);
          c_expr.expr &:= ")";
        exception
          catch RANGE_ERROR:
            c_expr.expr &:= "/*RANGE_ERROR*/";
            writeln("] ");
            TRACE(curr_expr);
            writeln;
        end block;
      end if;
    end if;
  end func;


const func boolean: useFunctype (in reference: current_object) is func

  result
    var boolean: okay is TRUE;
  local
    var reference: curr_expr is NIL;
    var category: exprCategory is category.value;
  begin
    curr_expr := getValue(current_object, reference);
    if curr_expr <> NIL then
      exprCategory := category(curr_expr);
      okay := exprCategory = ACTOBJECT or
              exprCategory = BLOCKOBJECT;
    end if;
  end func;


const proc: process_reference_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var reference: curr_expr is NIL;
    var category: exprCategory is category.value;
  begin
    (* if isVar(current_object) then *)
      if useFunctype(current_object) then
        c_expr.expr &:= "intfunctype o_";
      else
        c_expr.expr &:= "objreftype o_";
      end if;
      create_name(current_object, c_expr.expr);
      c_expr.expr &:= "=";
      object_address(current_object, c_expr);
      c_expr.expr &:= ";\n\n";
      function_pointer_declared @:= [current_object] TRUE;
      count_declarations;
    (* end if; *)
  end func;


const proc: process_ref_list_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var reference: element is NIL;
    var boolean: first_element is TRUE;
  begin
    if TRUE then
      if length(getValue(current_object, ref_list)) = 0 then
        c_expr.expr &:= "void *o_";
        create_name(current_object, c_expr.expr);
        c_expr.expr &:= "=";
        c_expr.expr &:= "NULL";
      else
        c_expr.expr &:= "void *o_";
        create_name(current_object, c_expr.expr);
        c_expr.expr &:= "[]=";
        c_expr.expr &:= "{";
        for element range getValue(current_object, ref_list) do
          if first_element then
            first_element := FALSE;
          else
            c_expr.expr &:= ", ";
          end if;
          c_expr.expr &:= "&(";
          process_expr(element, c_expr);
          c_expr.expr &:= ")";
        end for;
        c_expr.expr &:= "}";
      end if;
      c_expr.expr &:= ";\n\n";
      count_declarations;
    end if;
  end func;


const proc: process_file_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "filetype o_";
    create_name(current_object, c_expr.expr);
    c_expr.expr &:= "=NULL;\n\n";
    count_declarations;
  end func;


const proc: process_socket_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "sockettype o_";
    create_name(current_object, c_expr.expr);
    c_expr.expr &:= "=-1;\n\n";
    count_declarations;
  end func;


const proc: process_array_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var string: param_value is "";
  begin
    c_expr.expr &:= type_name(getType(current_object));
    c_expr.expr &:= " o_";
    create_name(current_object, c_expr.expr);
    c_expr.expr &:= ";\n\n";
    if current_object not in const_table then
      const_table @:= [current_object] length(const_table);
    end if;
    global_init.expr &:= "o_";
    create_name(current_object, global_init.expr);
    global_init.expr &:= "=";
    param_value := "(";
    param_value &:= type_name(getType(current_object));
    param_value &:= ")(arr[";
    param_value &:= str(const_table[current_object]);
    param_value &:= "])";
    if isVar(current_object) then
      process_create_declaration(getType(current_object), global_c_expr);
      process_create_call(getType(current_object),
          param_value, global_init.expr);
    else
      global_init.expr &:= param_value;
    end if;
    global_init.expr &:= ";\n";
    count_declarations;
  end func;


const proc: process_hash_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var string: param_value is "";
  begin
    c_expr.expr &:= type_name(getType(current_object));
    c_expr.expr &:= " o_";
    create_name(current_object, c_expr.expr);
    c_expr.expr &:= ";\n\n";
    if current_object not in const_table then
      const_table @:= [current_object] length(const_table);
    end if;
    global_init.expr &:= "o_";
    create_name(current_object, global_init.expr);
    global_init.expr &:= "=";
    param_value := "(";
    param_value &:= type_name(getType(current_object));
    param_value &:= ")(hsh[";
    param_value &:= str(const_table[current_object]);
    param_value &:= "])";
    if isVar(current_object) then
      process_create_declaration(getType(current_object), global_c_expr);
      process_create_call(getType(current_object),
          param_value, global_init.expr);
    else
      global_init.expr &:= param_value;
    end if;
    global_init.expr &:= ";\n";
    count_declarations;
  end func;


const proc: process_set_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  begin
    if isVar(current_object) then
      c_expr.expr &:= type_name(getType(current_object));
      c_expr.expr &:= " o_";
      create_name(current_object, c_expr.expr);
      c_expr.expr &:= ";\n\n";
      if getValue(current_object, bitset) not in set_const_table then
        set_const_table @:= [getValue(current_object, bitset)] length(set_const_table);
      end if;
      global_init.expr &:= "o_";
      create_name(current_object, global_init.expr);
      global_init.expr &:= "=(";
      global_init.expr &:= type_name(getType(current_object));
      global_init.expr &:= ")(setCreate(set[";
      global_init.expr &:= str(set_const_table[getValue(current_object, bitset)]);
      global_init.expr &:= "]));\n";
      count_declarations;
    end if;
  end func;


const proc: process_struct_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var string: param_value is "";
  begin
    c_expr.expr &:= type_name(getType(current_object));
    c_expr.expr &:= " o_";
    create_name(current_object, c_expr.expr);
    c_expr.expr &:= ";\n\n";
    if current_object not in const_table then
      const_table @:= [current_object] length(const_table);
    end if;
    global_init.expr &:= "o_";
    create_name(current_object, global_init.expr);
    global_init.expr &:= "=";
    param_value := "(";
    param_value &:= type_name(getType(current_object));
    param_value &:= ")(sct[";
    param_value &:= str(const_table[current_object]);
    param_value &:= "])";
    if isVar(current_object) then
      process_create_declaration(getType(current_object), global_c_expr);
      process_create_call(getType(current_object),
          param_value, global_init.expr);
    else
      global_init.expr &:= param_value;
    end if;
    global_init.expr &:= ";\n";
    count_declarations;
  end func;


const proc: process_interface_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= type_name(getType(current_object));
    c_expr.expr &:= " o_";
    create_name(current_object, c_expr.expr);
    c_expr.expr &:= ";\n\n";
    if current_object not in const_table then
      const_table @:= [current_object] length(const_table);
    end if;
    global_init.expr &:= "o_";
    create_name(current_object, global_init.expr);
    global_init.expr &:= "=(";
    global_init.expr &:= type_name(getType(current_object));
    global_init.expr &:= ")(itf[";
    global_init.expr &:= str(const_table[current_object]);
    global_init.expr &:= "]);\n";
    count_declarations;
  end func;


const proc: process_win_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  begin
    if isVar(current_object) then
      c_expr.expr &:= "wintype o_";
      create_name(current_object, c_expr.expr);
      c_expr.expr &:= "=";
      c_expr.expr &:= "NULL";
      c_expr.expr &:= ";\n\n";
      count_declarations;
    end if;
  end func;


const proc: process_prog_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  begin
    if isVar(current_object) then
      c_expr.expr &:= "progtype o_";
      create_name(current_object, c_expr.expr);
      c_expr.expr &:= "=";
      c_expr.expr &:= "NULL";
      c_expr.expr &:= ";\n\n";
      count_declarations;
    end if;
  end func;


const proc: process_enum_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  begin
    if isVar(current_object) then
      declare_type_if_necessary(getType(current_object), c_expr);
      c_expr.expr &:= type_name(getType(current_object));
      c_expr.expr &:= " o_";
      create_name(current_object, c_expr.expr);
      c_expr.expr &:= "=";
      c_expr.expr &:= enum_value(getValue(current_object, reference));
      c_expr.expr &:= ";\n\n";
    else
      declare_type_if_necessary(getType(current_object), c_expr);
      c_expr.expr &:= type_name(getType(current_object));
      c_expr.expr &:= " o_";
      create_name(current_object, c_expr.expr);
      c_expr.expr &:= "=";
      c_expr.expr &:= enum_value(getValue(current_object, reference));
      c_expr.expr &:= ";\n\n";
    end if;
    count_declarations;
  end func;


const proc: process_enum_literal_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var type: enum_type is void;
  begin
    enum_type := getType(current_object);
    if enum_type not in enum_literal then
      enum_literal @:= [enum_type] element_number_hash.EMPTY_HASH;
    end if;
    if current_object not in enum_literal[enum_type] then
      enum_literal[enum_type] @:= [current_object] length(enum_literal[enum_type]);
    end if;
    declare_type_if_necessary(getType(current_object), c_expr);
    c_expr.expr &:= type_name(getType(current_object));
    c_expr.expr &:= " o_";
    create_name(current_object, c_expr.expr);
    c_expr.expr &:= "=";
    c_expr.expr &:= enum_value(current_object);
    c_expr.expr &:= ";\n\n";
    count_declarations;
  end func;


const proc: print_parameter_list (in ref_list: formal_params,
    inout expr_type: c_expr) is func

  local
    var reference: formal_param is NIL;
    var category: paramCategory is category.value;
    var boolean: first_element is TRUE;
    var type: param_type is void;
    var type: implementationType is void;
  begin
    for formal_param range formal_params do
      paramCategory := category(formal_param);
      if paramCategory <> SYMBOLOBJECT then
        if first_element then
          first_element := FALSE;
        else
          c_expr.expr &:= " printf(\", \");\n";
        end if;
        param_type := getType(formal_param);
        if param_type in implements then
          c_expr.expr &:= " /*# ";
          for implementationType range implements[param_type] do
            c_expr.expr &:= "t_";
            c_expr.expr &:= str(type_number(implementationType));
            c_expr.expr &:= "**";
            c_expr.expr &:= str(implementationType);
            c_expr.expr &:= "  ";
          end for;
          c_expr.expr &:= " */ ";
        end if;
        c_expr.expr &:= "printf(";
        c_expr.expr &:= c_literal(str(paramCategory) & " ");
        c_expr.expr &:= "); ";
        if param_type = stritype then
          c_expr.expr &:= "printf(\"stritype \"); ";
          c_expr.expr &:= "filPrint(";
        elsif param_type = chartype then
          c_expr.expr &:= "printf(\"chartype \"); ";
          c_expr.expr &:= "printf(\"%c\", ";
        elsif param_type = inttype then
          c_expr.expr &:= "printf(\"inttype \"); ";
          c_expr.expr &:= "printf(\"%ld\", ";
        elsif param_type = floattype then
          c_expr.expr &:= "printf(\"floattype \"); ";
          c_expr.expr &:= "printf(\"%f\", ";
        elsif param_type = typetype then
          c_expr.expr &:= "printf(\"typetype \"); ";
          c_expr.expr &:= "printf(\"%X\", ";
        elsif param_type = proctype then
          c_expr.expr &:= "printf(\"proctype \"); ";
          c_expr.expr &:= "printf(\"%X\", ";
        elsif param_type = voidtype then
          c_expr.expr &:= "printf(\"voidtype \"); ";
          c_expr.expr &:= "printf(\"%X\", ";
        else
          c_expr.expr &:= "printf(\"";
          c_expr.expr &:= "t_";
          c_expr.expr &:= str(type_number(param_type));
          c_expr.expr &:= "/*";
          c_expr.expr &:= str(param_type);
          c_expr.expr &:= "*/ \"); ";
          c_expr.expr &:= "printf(\"%X\", ";
        end if;
        if isPointerParam(formal_param) then
          c_expr.expr &:= "(o_";
          create_name(formal_param, c_expr.expr);
          c_expr.expr &:= "?*o_";
          create_name(formal_param, c_expr.expr);
          c_expr.expr &:= ":0)";
        else
          c_expr.expr &:= "o_";
          create_name(formal_param, c_expr.expr);
        end if;
        c_expr.expr &:= ");";
      end if;
    end for;
  end func;


const proc: process_dynamic_parameter_list (in ref_list: actual_params,
    in reference: matched_object, inout expr_type: c_expr) is func

  local
    var ref_list: formal_params is ref_list.EMPTY;
    var reference: formal_param is NIL;
    var reference: actual_param is NIL;
    var category: paramCategory is category.value;
    var boolean: first_element is TRUE;
    var type: param_type is void;
    var type: implementationType is void;
    var integer: number is 0;
  begin
    formal_params := params(matched_object);
    for number range 1 to length(formal_params) do
      formal_param := formal_params[number];
      actual_param := actual_params[number];
      paramCategory := category(actual_param);
      if paramCategory <> SYMBOLOBJECT and
          category(formal_param) <> SYMBOLOBJECT then
        if first_element then
          first_element := FALSE;
        else
          c_expr.expr &:= ", ";
        end if;
        if not isVar(actual_param) and isInOutParam(formal_param) then
          c_expr.expr &:= "/* SHOULD NOT HAPPEN &o_";
          create_name(actual_param, c_expr.expr);
          c_expr.expr &:= " */";
        elsif isPointerParam(actual_param) = isPointerParam(formal_param) then
          c_expr.expr &:= "o_";
          create_name(actual_param, c_expr.expr);
        elsif isPointerParam(actual_param) and not isPointerParam(formal_param) then
          c_expr.expr &:= "*o_";
          create_name(actual_param, c_expr.expr);
        else # if isVar(actual_param) or not isInOutParam(formal_param) then
          c_expr.expr &:= "&o_";
          create_name(actual_param, c_expr.expr);
        end if;
      end if;
    end for;
  end func;


const proc: process_dynamic_action_call (in ref_list: actual_params,
    in reference: matched_object, inout expr_type: c_expr) is func

  local
    var expr_type: c_action_expr is expr_type.value;
  begin
    # c_expr.expr &:= "/* ";
    # c_expr.expr &:= str(getValue(matched_object, ACTION));
    # c_expr.expr &:= " */ ";
    c_action_expr.temp_num := c_expr.temp_num;
    process_action(matched_object, actual_params, c_action_expr);
    c_expr.temp_num := c_action_expr.temp_num;
    c_expr.temp_decls &:= c_action_expr.temp_decls;
    c_expr.temp_assigns &:= c_action_expr.temp_assigns;
    c_expr.temp_frees &:= c_action_expr.temp_frees;
    if c_action_expr.result_expr <> "" then
      c_expr.expr &:= c_action_expr.result_expr;
    else
      c_expr.expr &:= c_action_expr.expr;
    end if;
  end func;


const proc: process_dynamic_call (in reference: current_object,
    in reference: matched_object, in ref_list: actual_params,
    inout expr_type: c_expr) is func

  local
    var category: objectCategory is category.value;
    var expr_type: resultExpr is expr_type.value;
  begin
    if matched_object <> NIL then
      objectCategory := category(matched_object);
      if objectCategory = BLOCKOBJECT then
        if result_type(getType(current_object)) <> voidtype then
          c_expr.expr &:= "return ";
        end if;
        resultExpr.expr &:= "o_";
        create_name(matched_object, resultExpr.expr);
        resultExpr.expr &:= "(";
        process_dynamic_parameter_list(actual_params, matched_object, resultExpr);
        resultExpr.expr &:= ")\n";
        if matched_object in return_ref_to_value then
          c_expr.expr &:= "/* copy ref_to_value */ ";
          process_create_declaration(result_type(getType(current_object)), global_c_expr);
          process_create_call(result_type(getType(current_object)),
              resultExpr.expr, c_expr.expr);
        else
          c_expr.expr &:= resultExpr.expr;
        end if;
        c_expr.temp_decls &:= resultExpr.temp_decls;
        c_expr.temp_assigns &:= resultExpr.temp_assigns;
        c_expr.temp_frees &:= resultExpr.temp_frees;
        c_expr.expr &:= ";\n";
      elsif objectCategory = ACTOBJECT then
        if result_type(getType(current_object)) <> voidtype then
          c_expr.expr &:= "return ";
          if is_varfunc(getType(current_object)) then
            c_expr.expr &:= "&(";
          end if;
        end if;
        process_dynamic_action_call(actual_params, matched_object, c_expr);
        if result_type(getType(current_object)) <> voidtype then
          if is_varfunc(getType(current_object)) then
            c_expr.expr &:= ")";
          end if;
          c_expr.expr &:= ";\n";
        end if;
      elsif objectCategory = INTOBJECT or
          objectCategory = BIGINTOBJECT or
          objectCategory = FLOATOBJECT or
          objectCategory = CHAROBJECT or
          objectCategory = STRIOBJECT or
          objectCategory = BSTRIOBJECT or
          objectCategory = SETOBJECT or
          objectCategory = CONSTENUMOBJECT then
        c_expr.expr &:= "return ";
        getAnyParamToExpr(matched_object, resultExpr);
        process_create_declaration(getType(matched_object), global_c_expr);
        process_create_call(getType(matched_object),
            resultExpr.expr, c_expr.expr);
        c_expr.expr &:= ";\n";
      else
        c_expr.expr &:= "/* ";
        c_expr.expr &:= str(objectCategory);
        c_expr.expr &:= " */\n";
      end if;
    else
      c_expr.expr &:= "/* NOT FOUND */\n";
    end if;
  end func;


const proc: process_dynamic_condition (in reference: current_object,
    inout ref_list: formal_params, in var integer: paramNum,
    inout expr_type: c_expr) is forward;


const proc: process_dynamic_param_implements (in reference: current_object,
    inout ref_list: formal_params, in var integer: paramNum,
    in type: param_type, inout expr_type: c_expr) is func

  local
    var reference: formal_param is NIL;
    var type: implementationType is void;
  begin
    formal_param := formal_params[paramNum];
    for implementationType range implements[param_type] do
      c_expr.expr &:= "if (";
      if isPointerParam(formal_param) then
        c_expr.expr &:= "((interfacetype) *o_";
        create_name(formal_param, c_expr.expr);
        c_expr.expr &:= ")->type_num";
      else
        c_expr.expr &:= "((interfacetype) o_";
        create_name(formal_param, c_expr.expr);
        c_expr.expr &:= ")->type_num";
      end if;
      c_expr.expr &:= "==";
      c_expr.expr &:= str(type_number(implementationType));
      c_expr.expr &:= "/*";
      c_expr.expr &:= str(implementationType);
      c_expr.expr &:= "*/";
      c_expr.expr &:= ") {\n";

      setType(formal_params[paramNum], implementationType);
      process_dynamic_condition(current_object,
          formal_params, paramNum, c_expr);
      setType(formal_params[paramNum], param_type);
      c_expr.expr &:= "} else ";
    end for;
    c_expr.expr &:= "{\n";
    c_expr.expr &:= "printf(\"type_num=%d\\n\", ";
    if isPointerParam(formal_param) then
      c_expr.expr &:= "((interfacetype) *o_";
      create_name(formal_param, c_expr.expr);
      c_expr.expr &:= ")->type_num";
    else
      c_expr.expr &:= "((interfacetype) o_";
      create_name(formal_param, c_expr.expr);
      c_expr.expr &:= ")->type_num";
    end if;
    c_expr.expr &:= ");\n";
    c_expr.expr &:= "printf(\"o_";
    create_name(current_object, c_expr.expr);
    c_expr.expr &:= "(\");\n";
    print_parameter_list(formal_params, c_expr);
    c_expr.expr &:= "printf(\")\\n\");\n";
    c_expr.expr &:= "}\n";
  end func;


const proc: process_dynamic_param_enumeration (in reference: current_object,
    inout ref_list: formal_params, in var integer: paramNum,
    in type: param_type, inout expr_type: c_expr) is func

  local
    var reference: formal_param is NIL;
    var reference: enumLiteral is NIL;
    var integer: enumLiteralNumber is 0;
    var reference: backupParam is NIL;
  begin
    formal_param := formal_params[paramNum];
    c_expr.expr &:= "switch (";
    if isPointerParam(formal_param) then
      c_expr.expr &:= "*o_";
      create_name(formal_param, c_expr.expr);
    else
      c_expr.expr &:= "o_";
      create_name(formal_param, c_expr.expr);
    end if;
    c_expr.expr &:= ") {\n";
    for enumLiteralNumber key enumLiteral range enum_literal[param_type] do
      c_expr.expr &:= "case ";
      c_expr.expr &:= str(enumLiteralNumber);
      c_expr.expr &:= ": {\n";

      backupParam := formal_params[paramNum];
      formal_params @:= [paramNum] enumLiteral;
      process_dynamic_condition(current_object,
          formal_params, paramNum, c_expr);
      formal_params @:= [paramNum] backupParam;
      c_expr.expr &:= "} break;\n";
    end for;
    c_expr.expr &:= "default: {\n";
    c_expr.expr &:= "printf(\"literal_num=%d\\n\", ";
    if isPointerParam(formal_param) then
      c_expr.expr &:= "*o_";
      create_name(formal_param, c_expr.expr);
    else
      c_expr.expr &:= "o_";
      create_name(formal_param, c_expr.expr);
    end if;
    c_expr.expr &:= ");\n";
    c_expr.expr &:= "printf(\"o_";
    create_name(current_object, c_expr.expr);
    c_expr.expr &:= "(\");\n";
    print_parameter_list(formal_params, c_expr);
    c_expr.expr &:= "printf(\")\\n\");\n";
    c_expr.expr &:= "} break;\n";
    c_expr.expr &:= "}\n";
  end func;


const proc: process_dynamic_condition (in reference: current_object,
    inout ref_list: formal_params, in var integer: paramNum,
    inout expr_type: c_expr) is func

  local
    var reference: formal_param is NIL;
    var category: paramCategory is category.value;
    var type: param_type is void;
    var ref_list: param_list is ref_list.EMPTY;
    var reference: matched_object is NIL;
  begin
    incr(paramNum);
    if paramNum <= length(formal_params) then
      formal_param := formal_params[paramNum];
      paramCategory := category(formal_param);
      if paramCategory <> SYMBOLOBJECT then
        param_type := getType(formal_param);
        if param_type in implements then
          process_dynamic_param_implements(current_object,
              formal_params, paramNum, param_type, c_expr);
        elsif param_type in enum_literal then
          process_dynamic_param_enumeration(current_object,
              formal_params, paramNum, param_type, c_expr);
        else
          process_dynamic_condition(current_object,
              formal_params, paramNum, c_expr);
        end if;
      else
        process_dynamic_condition(current_object,
            formal_params, paramNum, c_expr);
      end if;
    else
      param_list := formal_params;
      matched_object := match(prog, param_list);
      process_dynamic_call(current_object, matched_object, formal_params, c_expr);
    end if;
  end func;


const proc: process_dynamic_decision (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var expr_type: c_param_list is expr_type.value;
    var expr_type: c_proc_body is expr_type.value;
    var type: object_type is void;
    var type: result_type is void;
    var ref_list: param_list is ref_list.EMPTY;
  begin
    object_type := getType(current_object);
    if is_func(object_type) or is_varfunc(object_type) then
      result_type := result_type(object_type);
      if result_type <> typetype then
        c_expr.expr &:= "/* DYNAMIC */ static ";
        c_expr.expr &:= type_name(result_type);
        if is_varfunc(object_type) then
          c_expr.expr &:= " *o_";
        else
          c_expr.expr &:= " o_";
        end if;
        create_name(current_object, c_expr.expr);
        param_list := params(current_object);
        c_expr.expr &:= " (";
        process_param_list_declaration(param_list, c_param_list);
        c_expr.expr &:= c_param_list.expr;
        c_expr.expr &:= ")\n";
        c_expr.expr &:= "{\n";
        process_dynamic_condition(current_object,
            param_list, 0, c_proc_body);
        c_expr.expr &:= c_param_list.temp_decls;
        c_expr.expr &:= c_proc_body.temp_decls;
        c_expr.expr &:= c_param_list.temp_assigns;
        c_expr.expr &:= c_proc_body.temp_assigns;
        c_expr.expr &:= c_proc_body.expr;
        c_expr.expr &:= c_param_list.temp_frees;
        c_expr.expr &:= c_proc_body.temp_frees;
        c_expr.expr &:= "}\n\n";
      end if;
    end if;
  end func;


const proc: process_dynamic_decisions (inout expr_type: c_expr) is func

  local
    var reference: current_object is NIL;
  begin
    for current_object range dynamic_functions do
      process_dynamic_decision(current_object, c_expr);
    end for;
  end func;


const proc: process_dynamic_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var expr_type: c_param_list is expr_type.value;
    var type: object_type is void;
    var type: result_type is void;
    var ref_list: param_list is ref_list.EMPTY;
  begin
    object_type := getType(current_object);
    if is_func(object_type) or is_varfunc(object_type) then
      result_type := result_type(object_type);
      if result_type <> typetype then
        dynamic_functions &:= make_list(current_object);
        c_expr.expr &:= "/* DYNAMIC */ static ";
        c_expr.expr &:= type_name(result_type);
        if is_varfunc(object_type) then
          c_expr.expr &:= " *o_";
        else
          c_expr.expr &:= " o_";
        end if;
        create_name(current_object, c_expr.expr);
        param_list := params(current_object);
        c_expr.expr &:= " (";
        process_param_list_declaration(param_list, c_param_list);
        c_expr.expr &:= c_param_list.expr;
        c_expr.expr &:= ");\n";
        prototype_declared @:= [current_object] TRUE;
      end if;
    end if;
  end func;


const proc: create_func_addr(in type: arrayType, inout expr_type: c_expr) is func
  local
    var type: baseType is void;
  begin
(*
    main_obj := sys_var(prog, "main");
    baseType := base_type(arrayType);
(ref baseType param) ::= (in baseType param)
*)
    c_expr.expr &:= "NULL";
  end func;


const proc: destroy_func_addr(in type: arrayType, inout expr_type: c_expr) is func
  local
    var type: baseType is void;
  begin
(*
    main_obj := sys_var(prog, "main");
    baseType := base_type(arrayType);
(ref baseType param) ::= (in baseType param)
*)
    c_expr.expr &:= "NULL";
  end func;


const proc: copy_func_addr(in type: arrayType, inout expr_type: c_expr) is func
  local
    var type: baseType is void;
  begin
(*
    main_obj := sys_var(prog, "main");
    baseType := base_type(arrayType);
(ref baseType param) ::= (in baseType param)
*)
    c_expr.expr &:= "NULL";
  end func;


const func type: base_type (in type: array_type) is func
  result
    var type: result is void;
  local
    var ref_list: param_list is ref_list.EMPTY;
    var reference: matched_object is NIL;
  begin
    param_list := make_list(match_obj(array_type));
    param_list &:= make_list(syobject(prog, "base_type"));
    matched_object := match(prog, param_list);
    if matched_object <> NIL and category(matched_object) = TYPEOBJECT then
      result := getValue(matched_object, type);
    end if;
  end func;


const proc: process_hashcode (in reference: current_object, inout expr_type: c_expr) is func
  local
    var ref_list: param_list is ref_list.EMPTY;
    var reference: expression is NIL;
  begin
    setVar(current_object, FALSE);
    param_list := make_list(current_object);
    param_list &:= make_list(syobject(prog, "hashCode"));
    expression := matchExpr(prog, param_list);
    process_expr(expression, c_expr);
  end func;


const func reference: keyCreateObj (in type: hash_type) is func
  result
    var reference: result is NIL;
  local
    var ref_list: param_list is ref_list.EMPTY;
  begin
    param_list := make_list(match_obj(hash_type));
    param_list &:= make_list(syobject(prog, "."));
    param_list &:= make_list(syobject(prog, "keyCreate"));
    result := match(prog, param_list);
  end func;


const func reference: keyCompareObj (in type: hash_type) is func
  result
    var reference: result is NIL;
  local
    var ref_list: param_list is ref_list.EMPTY;
  begin
    param_list := make_list(match_obj(hash_type));
    param_list &:= make_list(syobject(prog, "."));
    param_list &:= make_list(syobject(prog, "keyCompare"));
    result := match(prog, param_list);
  end func;


const func reference: dataCreateObj (in type: hash_type) is func
  result
    var reference: result is NIL;
  local
    var ref_list: param_list is ref_list.EMPTY;
  begin
    param_list := make_list(match_obj(hash_type));
    param_list &:= make_list(syobject(prog, "."));
    param_list &:= make_list(syobject(prog, "dataCreate"));
    result := match(prog, param_list);
  end func;


const func reference: dataCopyObj (in type: hash_type) is func
  result
    var reference: result is NIL;
  local
    var ref_list: param_list is ref_list.EMPTY;
  begin
    param_list := make_list(match_obj(hash_type));
    param_list &:= make_list(syobject(prog, "."));
    param_list &:= make_list(syobject(prog, "dataCopy"));
    result := match(prog, param_list);
  end func;


const proc: process_arr_create_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var ref_list: params is ref_list.EMPTY;
    var type: base_type is void;
    var type: object_type is void;
    var element_number_hash: element_number is element_number_hash.EMPTY_HASH;
    var element_type_hash: element_type is element_type_hash.EMPTY_HASH;
  begin
    params := params(current_object);
    object_type := getType(params[1]);
    base_type := base_type(object_type);
    if base_type <> void then
      if object_type not in array_element then
        array_element @:= [object_type] base_type;
      end if;
      if base_type not in array_type then
        array_type @:= [base_type] object_type;
      end if;
    end if;
  end func;


const proc: process_arr_gen_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var ref_list: params is ref_list.EMPTY;
    var type: result_type is void;
    var type: object_type is void;
    var element_number_hash: element_number is element_number_hash.EMPTY_HASH;
    var element_type_hash: element_type is element_type_hash.EMPTY_HASH;
  begin
    result_type := result_type(getType(current_object));
    params := params(current_object);
    object_type := getType(params[1]);
    if result_type not in array_element then
      array_element @:= [result_type] object_type;
    end if;
    if object_type not in array_type then
      array_type @:= [object_type] result_type;
    end if;
    c_expr.expr &:= "/* ACTION ARR_GEN for type ";
    c_expr.expr &:= "t_";
    c_expr.expr &:= str(type_number(result_type));
    c_expr.expr &:= "**";
    c_expr.expr &:= str(result_type);
    c_expr.expr &:= " element is ";
    c_expr.expr &:= "t_";
    c_expr.expr &:= str(type_number(object_type));
    c_expr.expr &:= "**";
    c_expr.expr &:= str(object_type);
    c_expr.expr &:= "*/\n\n";
  end func;


const proc: process_arr_idx_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var ref_list: params is ref_list.EMPTY;
    var type: result_type is void;
    var type: object_type is void;
    var element_number_hash: element_number is element_number_hash.EMPTY_HASH;
    var element_type_hash: element_type is element_type_hash.EMPTY_HASH;
  begin
    result_type := result_type(getType(current_object));
    params := params(current_object);
    object_type := getType(params[1]);
    if object_type not in array_element then
      array_element @:= [object_type] result_type;
    end if;
    if result_type not in array_type then
      array_type @:= [result_type] object_type;
    end if;
    c_expr.expr &:= "/* ACTION ARR_IDX for type ";
    c_expr.expr &:= "t_";
    c_expr.expr &:= str(type_number(object_type));
    c_expr.expr &:= "**";
    c_expr.expr &:= str(object_type);
    c_expr.expr &:= " element is ";
    c_expr.expr &:= "t_";
    c_expr.expr &:= str(type_number(result_type));
    c_expr.expr &:= "**";
    c_expr.expr &:= str(result_type);
    c_expr.expr &:= "*/\n\n";
  end func;


const proc: process_arr_times_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var ref_list: params is ref_list.EMPTY;
    var type: result_type is void;
    var type: object_type is void;
    var integer: number is 0;
    var reference: struct_elem is NIL;
  begin
    result_type := result_type(getType(current_object));
    params := params(current_object);
    object_type := getType(params[3]);
    process_create_declaration(object_type, c_expr);
    # c_expr.expr &:= type_name(result_type);
    c_expr.expr &:= "arraytype times_";
    c_expr.expr &:= str(type_number(result_type));
    c_expr.expr &:= " (inttype n, ";
    c_expr.expr &:= type_name(object_type);
    c_expr.expr &:= " b)\n";
    prototype_declared @:= [current_object] TRUE;
    c_expr.expr &:= "{\n";
    c_expr.expr &:= "arraytype a;\n";
    c_expr.expr &:= "unsigned long i;\n";
    c_expr.expr &:= "if (n < 0) {\n";
    process_raise_error("RANGE_ERROR", NIL, c_expr);
    c_expr.expr &:= ";\n";
    c_expr.expr &:= "} else {\n";
    c_expr.expr &:= "a=malloc(sizeof(struct arraystruct) - sizeof(rtlObjecttype) +\n";
    c_expr.expr &:= "  n * sizeof(rtlObjecttype));\n";
#!    c_expr.expr &:= "ALLOC_RTL_ARRAY(a,n);\n";
    c_expr.expr &:= "if (a == NULL) {\n";
    c_expr.expr &:= "raise_error(MEMORY_ERROR);\n";
    c_expr.expr &:= "} else {\n";
    c_expr.expr &:= "a->min_position = 1;\n";
    c_expr.expr &:= "a->max_position = n;\n";
    c_expr.expr &:= "for (i = 0; i < n; i++) {\n";
    c_expr.expr &:= "a->arr[i]";
    c_expr.expr &:= select_value_from_rtlObjectstruct(object_type);
    c_expr.expr &:= "=";
    process_create_call(object_type, "b", c_expr.expr);
    c_expr.expr &:= ";\n";
    c_expr.expr &:= "}\n";
    c_expr.expr &:= "}\n";
    c_expr.expr &:= "}\n";
    c_expr.expr &:= "return(a);\n";
    c_expr.expr &:= "}\n\n";
  end func;


const proc: process_bln_cpy_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var ref_list: params is ref_list.EMPTY;
    var type: booltype is void;
  begin
    params := params(current_object);
    booltype := getType(params[1]);
    if booltype not in simple_pod_type then
      simple_pod_type @:= [booltype] TRUE;
    end if;
  end func;


const proc: process_itf_cpy_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var ref_list: params is ref_list.EMPTY;
    var type: itf_type is void;
  begin
    params := params(current_object);
    itf_type := getType(params[1]);
    if itf_type not in isInterfaceType then
      isInterfaceType @:= [itf_type] TRUE;
    end if;
  end func;


const proc: addImplementationToInterface (in type: implementationType, in type: interfaceType) is func

  begin
    if interfaceType in implements then
      implements[interfaceType] &:= [] (implementationType);
    else
      implements @:= [interfaceType] [] (implementationType);
    end if;
    if implementationType in interfaceOfType then
      interfaceOfType[implementationType] &:= [] (interfaceType);
    else
      interfaceOfType @:= [implementationType] [] (interfaceType);
    end if;
  end func;


const proc: process_itf_cpy2_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var ref_list: params is ref_list.EMPTY;
    var type: interfaceType is void;
    var type: implementationType is void;
  begin
    params := params(current_object);
    interfaceType := getType(params[1]);
    implementationType := getType(params[3]);
    addImplementationToInterface(implementationType, interfaceType);
    c_expr.expr &:= "/* itf_cpy2: t_";
    c_expr.expr &:= str(type_number(interfaceType));
    c_expr.expr &:= "**";
    c_expr.expr &:= str(interfaceType);
    c_expr.expr &:= " := t_";
    c_expr.expr &:= str(type_number(implementationType));
    c_expr.expr &:= "**";
    c_expr.expr &:= str(implementationType);
    c_expr.expr &:= "*/\n";
  end func;


const proc: process_drw_cpy_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var ref_list: params is ref_list.EMPTY;
  begin
    params := params(current_object);
    wintype := getType(params[1]);
  end func;


const proc: process_fil_cpy_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var ref_list: params is ref_list.EMPTY;
    var type: filetype is void;
  begin
    params := params(current_object);
    filetype := getType(params[1]);
    if filetype not in simple_pod_type then
      simple_pod_type @:= [filetype] TRUE;
    end if;
  end func;


const proc: process_soc_cpy_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var ref_list: params is ref_list.EMPTY;
    var type: sockettype is void;
  begin
    params := params(current_object);
    sockettype := getType(params[1]);
    if sockettype not in simple_pod_type then
      simple_pod_type @:= [sockettype] TRUE;
    end if;
  end func;


const proc: process_hsh_cpy_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var ref_list: params is ref_list.EMPTY;
    var type: hash_type is void;
  begin
    params := params(current_object);
    hash_type := getType(params[1]);
    if hash_type not in isHashType then
      isHashType @:= [hash_type] TRUE;
    end if;
  end func;


const proc: process_ref_cpy_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var ref_list: params is ref_list.EMPTY;
    var type: aType is void;
  begin
    params := params(current_object);
    aType := getType(params[1]);
    if aType not in simple_pod_type then
      simple_pod_type @:= [aType] TRUE;
    end if;
  end func;


const proc: addStructElem (in type: structType, in type: elemType, in reference: elementOfStruct) is func

  local
    var element_number_hash: element_number is element_number_hash.EMPTY_HASH;
    var element_type_hash: element_type is element_type_hash.EMPTY_HASH;
  begin
    if structType in struct_elements then
      if elementOfStruct not in struct_elements[structType] then
        struct_elements[structType] @:= [elementOfStruct] length(struct_elements[structType]);
      end if;
      if elementOfStruct not in struct_element_type[structType] then
        struct_element_type[structType] @:= [elementOfStruct] elemType;
      end if;
    else
      element_number @:= [elementOfStruct] 0;
      struct_elements @:= [structType] element_number;
      element_type @:= [elementOfStruct] elemType;
      struct_element_type @:= [structType] element_type;
    end if;
  end func;


const proc: process_sct_cpy_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var ref_list: params is ref_list.EMPTY;
    var type: sct_type is void;
    var type: meta_type is void;
    var type: interfaceType is void;
    var number_element_hash: elements is number_element_hash.EMPTY_HASH;
    var reference: elementOfStruct is NIL;
    var integer: number is 0;
  begin
    params := params(current_object);
    sct_type := getType(params[1]);
    if is_derived(sct_type) then
      meta_type := meta(sct_type);
      if meta_type in struct_elements then
        elements := flip(struct_elements[meta_type]);
        for number range 0 to pred(length(elements)) do
          elementOfStruct := elements[number][1];
          addStructElem(sct_type, struct_element_type[meta_type][elementOfStruct], elementOfStruct);
        end for;
      end if;
      if meta_type in interfaceOfType then
        for interfaceType range interfaceOfType[meta_type] do
          addImplementationToInterface(sct_type, interfaceType);
        end for;
      end if;
    end if;
  end func;


const proc: process_sct_select_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var ref_list: params is ref_list.EMPTY;
    var type: elemType is void;
    var type: structType is void;
    var reference: elementOfStruct is NIL;
  begin
    elemType := result_type(getType(current_object));
    params := params(current_object);
    structType := getType(params[1]);
    elementOfStruct := params[3];
    addStructElem(structType, elemType, elementOfStruct);
    c_expr.expr &:= "/* struct element t_";
    c_expr.expr &:= str(type_number(elemType));
    c_expr.expr &:= "**";
    c_expr.expr &:= str(elemType);
    c_expr.expr &:= "** t_";
    c_expr.expr &:= str(type_number(structType));
    c_expr.expr &:= "**";
    c_expr.expr &:= str(structType);
    c_expr.expr &:= "**->o_";
    create_name2(elementOfStruct, c_expr.expr);
    c_expr.expr &:= " = ";
    c_expr.expr &:= str(struct_elements[structType][elementOfStruct]);
    c_expr.expr &:= " */\n";
  end func;


const proc: process_ref_select_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var ref_list: params is ref_list.EMPTY;
    var type: elemType is void;
    var type: structType is void;
    var reference: elementOfStruct is NIL;
  begin
    elemType := result_type(getType(current_object));
    params := params(current_object);
    structType := getType(params[1]);
    elementOfStruct := params[3];
    addStructElem(structType, elemType, elementOfStruct);
    c_expr.expr &:= "/* ref struct element t_";
    c_expr.expr &:= str(type_number(elemType));
    c_expr.expr &:= "**";
    c_expr.expr &:= str(elemType);
    c_expr.expr &:= "** t_";
    c_expr.expr &:= str(type_number(structType));
    c_expr.expr &:= "**";
    c_expr.expr &:= str(structType);
    c_expr.expr &:= "**->o_";
    create_name2(elementOfStruct, c_expr.expr);
    c_expr.expr &:= " = ";
    c_expr.expr &:= str(struct_elements[structType][elementOfStruct]);
    c_expr.expr &:= " */\n";
  end func;


const proc: process_int_cpy_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var ref_list: params is ref_list.EMPTY;
    var type: int_type is void;
  begin
    params := params(current_object);
    int_type := getType(params[1]);
    if int_type not in int_types then
      int_types @:= [int_type] TRUE;
    end if;
  end func;


const proc: process_enu_cpy_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var ref_list: params is ref_list.EMPTY;
    var type: enum_type is void;
  begin
    params := params(current_object);
    enum_type := getType(params[1]);
    if enum_type not in enum_types then
      enum_types @:= [enum_type] TRUE;
    end if;
  end func;


const proc: process_rfl_cpy_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var ref_list: params is ref_list.EMPTY;
    var type: ref_list_type is void;
  begin
    params := params(current_object);
    ref_list_type := getType(params[1]);
    if ref_list_type not in ref_list_types then
      ref_list_types @:= [ref_list_type] TRUE;
    end if;
  end func;


const proc: process_set_cpy_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var ref_list: params is ref_list.EMPTY;
    var type: set_type is void;
  begin
    params := params(current_object);
    set_type := getType(params[1]);
    if set_type not in set_types then
      set_types @:= [set_type] TRUE;
    end if;
  end func;


const proc: process_bst_cpy_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var ref_list: params is ref_list.EMPTY;
  begin
    params := params(current_object);
    bstri_types @:= [getType(params[1])] TRUE;
  end func;


const proc: process_action_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var ACTION: current_action is action "PRC_NOOP";
    var string: action_name is "";
    var type: object_type is void;
  begin
    current_action := getValue(current_object, ACTION);
    action_name := str(current_action);
    if action_name = "PRC_DYNAMIC" then
      process_dynamic_declaration(current_object, c_expr);
      count_declarations;
    elsif action_name = "ARR_CREATE" then
      process_arr_create_declaration(current_object, c_expr);
      count_declarations;
    elsif action_name = "ARR_GEN" then
      process_arr_gen_declaration(current_object, c_expr);
      count_declarations;
    elsif action_name = "ARR_IDX" then
      process_arr_idx_declaration(current_object, c_expr);
      count_declarations;
    elsif action_name = "ARR_TIMES" then
      process_arr_times_declaration(current_object, c_expr);
      count_declarations;
    elsif action_name = "BLN_CPY" then
      process_bln_cpy_declaration(current_object, c_expr);
      count_declarations;
    elsif action_name = "ITF_CPY" then
      process_itf_cpy_declaration(current_object, c_expr);
      count_declarations;
    elsif action_name = "ITF_CPY2" then
      process_itf_cpy2_declaration(current_object, c_expr);
      count_declarations;
    elsif action_name = "DRW_CPY" then
      process_drw_cpy_declaration(current_object, c_expr);
      count_declarations;
    elsif action_name = "ENU_CPY" then
      process_enu_cpy_declaration(current_object, c_expr);
      count_declarations;
    elsif action_name = "FIL_CPY" then
      process_fil_cpy_declaration(current_object, c_expr);
      count_declarations;
    elsif action_name = "INT_CPY" then
      process_int_cpy_declaration(current_object, c_expr);
      count_declarations;
    elsif action_name = "SOC_CPY" then
      process_soc_cpy_declaration(current_object, c_expr);
      count_declarations;
    elsif action_name = "HSH_CPY" then
      process_hsh_cpy_declaration(current_object, c_expr);
      count_declarations;
    elsif action_name = "REF_CPY" then
      process_ref_cpy_declaration(current_object, c_expr);
      count_declarations;
    elsif action_name = "REF_SELECT" then
      process_ref_select_declaration(current_object, c_expr);
      count_declarations;
    elsif action_name = "RFL_CPY" then
      process_rfl_cpy_declaration(current_object, c_expr);
      count_declarations;
    elsif action_name = "SCT_CPY" then
      process_sct_cpy_declaration(current_object, c_expr);
      count_declarations;
    elsif action_name = "SCT_SELECT" then
      process_sct_select_declaration(current_object, c_expr);
      count_declarations;
    elsif action_name = "SET_CPY" then
      process_set_cpy_declaration(current_object, c_expr);
      count_declarations;
    elsif action_name = "BST_CPY" then
      process_bst_cpy_declaration(current_object, c_expr);
      count_declarations;
(*
    else
      c_expr.expr &:= "/* ACTION ";
      c_expr.expr &:= action_name;
      c_expr.expr &:= " */";
*)
    end if;
  end func;


const proc: process_object_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var category: objectCategory is category.value;
  begin
    objectCategory := category(current_object);
    if objectCategory = BLOCKOBJECT then
      process_func_declaration(current_object, c_expr);
    elsif objectCategory = TYPEOBJECT then
      process_type_declaration(current_object, c_expr);
    elsif objectCategory = INTOBJECT then
      process_int_declaration(current_object, c_expr);
    elsif objectCategory = BIGINTOBJECT then
      process_bigint_declaration(current_object, c_expr);
    elsif objectCategory = CHAROBJECT then
      process_char_declaration(current_object, c_expr);
    elsif objectCategory = STRIOBJECT then
      process_stri_declaration(current_object, c_expr);
    elsif objectCategory = BSTRIOBJECT then
      process_bstri_declaration(current_object, c_expr);
    elsif objectCategory = FLOATOBJECT then
      process_float_declaration(current_object, c_expr);
    elsif objectCategory = REFOBJECT then
      process_reference_declaration(current_object, c_expr);
    elsif objectCategory = REFLISTOBJECT then
      process_ref_list_declaration(current_object, c_expr);
    elsif objectCategory = FILEOBJECT then
      process_file_declaration(current_object, c_expr);
    elsif objectCategory = SOCKETOBJECT then
      process_socket_declaration(current_object, c_expr);
    elsif objectCategory = ARRAYOBJECT then
      process_array_declaration(current_object, c_expr);
    elsif objectCategory = HASHOBJECT then
      process_hash_declaration(current_object, c_expr);
    elsif objectCategory = SETOBJECT then
      process_set_declaration(current_object, c_expr);
    elsif objectCategory = STRUCTOBJECT then
      process_struct_declaration(current_object, c_expr);
    elsif objectCategory = INTERFACEOBJECT then
      process_interface_declaration(current_object, c_expr);
    elsif objectCategory = WINOBJECT then
      process_win_declaration(current_object, c_expr);
    elsif objectCategory = PROGOBJECT then
      process_prog_declaration(current_object, c_expr);
    elsif objectCategory = CONSTENUMOBJECT then
      process_enum_declaration(current_object, c_expr);
    elsif objectCategory = VARENUMOBJECT then
      process_enum_declaration(current_object, c_expr);
    elsif objectCategory = ENUMLITERALOBJECT then
      process_enum_literal_declaration(current_object, c_expr);
    elsif objectCategory = ACTOBJECT then
      process_action_declaration(current_object, c_expr);
    elsif objectCategory = FWDREFOBJECT then
      process_forward_declaration(current_object, c_expr);
    else
      c_expr.expr &:= "/* ";
      c_expr.expr &:= str(objectCategory);
      c_expr.expr &:= " */\n";
    end if;
  end func;


const proc: addAdditionalParams (in reference: local_function,
    in ref_list: additional_act_params, in ref_list: additional_form_params) is func
  local
    var integer: index is 0;
  begin
    if local_function not in additional_params then
      additional_params @:= [local_function] variable_to_param_hash.value;
    end if;
    for index range 1 to length(additional_act_params) do
      if additional_act_params[index] not in additional_params[local_function] then
(*
        write("!!!!!! ");
        write(str(local_function) <& "_" <& str(obj_number(local_function)));
        writeln;
        write(str(additional_act_params[index]) <& "_" <& str(obj_number(additional_act_params[index])));
        TRACE_OBJ(additional_act_params[index]);
        writeln;
        write(str(additional_form_params[index]) <& "_" <& str(obj_number(additional_form_params[index])));
        TRACE_OBJ(additional_form_params[index]);
        writeln;
*)
        additional_params[local_function] @:= [additional_act_params[index]] additional_form_params[index];
      elsif additional_params[local_function][additional_act_params[index]] <> additional_form_params[index] then
(*
        write("###### ");
        TRACE_OBJ(additional_params[local_function][additional_act_params[index]]);
        writeln;
        TRACE_OBJ(additional_form_params[index]);
        writeln;
*)
        noop;
      end if;
    end for;
  end func;


const proc: replace_locals_from_outside (inout reference: current_expression,
    in ref_list: local_objects, inout ref_list: additional_act_params,
    inout ref_list: additional_form_params) is func
  local
    var ref_list: params is ref_list.EMPTY;
    var integer: paramNum is 0;
    var reference: aParam is NIL;
    var category: paramCategory is category.value;
    var reference: formalRefParam is NIL;
  begin
    params := getValue(current_expression, ref_list);
    for paramNum range 2 to length(params) do
      aParam := params[paramNum];
      paramCategory := category(aParam);
      if paramCategory = MATCHOBJECT or
          paramCategory = CALLOBJECT then
        replace_locals_from_outside(aParam, local_objects,
            additional_act_params, additional_form_params);
      elsif paramCategory = LOCALVOBJECT or paramCategory = VALUEPARAMOBJECT or
          paramCategory = REFPARAMOBJECT or paramCategory = RESULTOBJECT then
        if aParam not in local_objects then
          if aParam in additional_act_params then
            formalRefParam := additional_form_params[pos(additional_act_params, aParam)];
          else
            additional_act_params &:= make_list(aParam);
            formalRefParam := alloc(aParam);
            setCategory(formalRefParam, REFPARAMOBJECT);
            additional_form_params &:= make_list(formalRefParam);
          end if;
          params @:= [paramNum] formalRefParam;
        end if;
      end if;
    end for;
    setValue(current_expression, params);
  end func;


const proc: change_calls_from_local_function (inout reference: current_expression,
    in reference: local_function_obj, in ref_list: additional_form_params) is func
  local
    var ref_list: params is ref_list.EMPTY;
    var integer: paramNum is 0;
    var reference: aParam is NIL;
    var category: paramCategory is category.value;
  begin
    params := getValue(current_expression, ref_list);
    for paramNum range 2 to length(params) do
      aParam := params[paramNum];
      paramCategory := category(aParam);
      if paramCategory = MATCHOBJECT or
          paramCategory = CALLOBJECT then
        change_calls_from_local_function(aParam, local_function_obj, additional_form_params);
      elsif aParam = local_function_obj then
        aParam := alloc(aParam);
        setCategory(aParam, MATCHOBJECT);
        setValue(aParam, make_list(params[paramNum]) & additional_form_params);
        params @:= [paramNum] aParam;
        setValue(current_expression, params);
      end if;
    end for;
    if params[1] = local_function_obj then
      params &:= additional_form_params;
      setValue(current_expression, params);
    end if;
  end func;


const proc: change_calls_from_local_sub_function (inout reference: current_expression,
    in reference: local_function_obj, in ref_list: additional_act_params) is func
  local
    var ref_list: params is ref_list.EMPTY;
    var ref_list: match_params is ref_list.EMPTY;
    var reference: actParam is NIL;
    var reference: formalParam is NIL;
    var integer: paramNum is 0;
    var reference: aParam is NIL;
    var category: paramCategory is category.value;
  begin
    params := getValue(current_expression, ref_list);
    for paramNum range 2 to length(params) do
      aParam := params[paramNum];
      paramCategory := category(aParam);
      if paramCategory = MATCHOBJECT or
          paramCategory = CALLOBJECT then
        change_calls_from_local_sub_function(aParam, local_function_obj,
            additional_act_params);
      elsif aParam = local_function_obj then
        aParam := alloc(aParam);
        setCategory(aParam, MATCHOBJECT);
        match_params := make_list(params[paramNum]);
        for actParam range additional_act_params do
          if actParam in additional_params[local_function_obj] then
            formalParam := additional_params[local_function_obj][actParam];
            match_params &:= make_list(formalParam);
(*
            write("?? 1 ? ");
            write(str(formalParam) <& "_" <& str(obj_number(formalParam)));
*)
          end if;
        end for;
        setValue(aParam, match_params);
        params @:= [paramNum] aParam;
        setValue(current_expression, params);
      end if;
    end for;
    if params[1] = local_function_obj then
      for actParam range additional_act_params do
        if actParam in additional_params[local_function_obj] then
          formalParam := additional_params[local_function_obj][actParam];
          if pos(params, formalParam, 2) = 0 then
            params &:= make_list(formalParam);
(*
            write("?? 2 ? ");
            write(str(formalParam) <& "_" <& str(obj_number(formalParam)));
*)
          end if;
        end if;
      end for;
      setValue(current_expression, params);
    end if;
  end func;


const proc: change_calls_from_global_function (inout reference: current_expression,
    in reference: local_function_obj, in ref_list: additional_act_params) is func
  local
    var ref_list: params is ref_list.EMPTY;
    var integer: paramNum is 0;
    var reference: aParam is NIL;
    var category: paramCategory is category.value;
  begin
    params := getValue(current_expression, ref_list);
    for paramNum range 2 to length(params) do
      aParam := params[paramNum];
      paramCategory := category(aParam);
      if paramCategory = MATCHOBJECT or
          paramCategory = CALLOBJECT then
        change_calls_from_global_function(aParam, local_function_obj, additional_act_params);
      elsif aParam = local_function_obj then
        aParam := alloc(aParam);
        setCategory(aParam, MATCHOBJECT);
        setValue(aParam, make_list(params[paramNum]) & additional_act_params);
        params @:= [paramNum] aParam;
        setValue(current_expression, params);
      end if;
    end for;
    if params[1] = local_function_obj then
      params &:= additional_act_params;
      setValue(current_expression, params);
    end if;
  end func;


const proc: fix_local_function (in reference: global_function,
    in reference: local_function, inout expr_type: c_expr) is func

  local
    var reference: body_expression is NIL;
    var ref_list: local_objects is ref_list.EMPTY;
    var category: bodyCategory is category.value;
    var ref_list: additional_act_params is ref_list.EMPTY;
    var ref_list: additional_form_params is ref_list.EMPTY;
    var reference: obj is NIL;
    var reference: localConst is NIL;
  begin
    (* writeln("fix_local_function(" <&
        str(global_function) <& "_" <& str(obj_number(global_function)) <& ", " <&
        str(local_function) <& "_" <& str(obj_number(local_function))); *)
    for obj range local_consts(local_function) do
      if category(obj) = BLOCKOBJECT then
        fix_local_function(local_function, obj, c_expr);
      end if;
    end for;
    body_expression := body(local_function);
    local_objects := params(local_function) & local_vars(local_function) &
        make_list(func_result(local_function));
    bodyCategory := category(body_expression);
    if bodyCategory = MATCHOBJECT or
        bodyCategory = CALLOBJECT then
      replace_locals_from_outside(body_expression, local_objects,
          additional_act_params, additional_form_params);
(*
write(str(local_function) <& "_" <& str(obj_number(local_function)));
write(" additional_act_params=");
TRACE_LIST(additional_act_params);
writeln;
write(str(local_function) <& "_" <& str(obj_number(local_function)));
write(" additional_form_params=");
TRACE_LIST(additional_form_params);
writeln;
*)
      addAdditionalParams(local_function, additional_act_params, additional_form_params);
      setParams(local_function, params(local_function) & additional_form_params);
      change_calls_from_local_function(body_expression, local_function, additional_form_params);

      for localConst range local_consts(local_function) do
        if category(localConst) = BLOCKOBJECT then
          body_expression := body(localConst);
          change_calls_from_local_sub_function(body_expression, local_function,
              additional_act_params);
        end if;
      end for;

      for obj range local_consts(global_function) do
        if obj <> local_function and category(obj) = BLOCKOBJECT then
          # c_expr.expr &:= "/* local function */ o_";
          # create_name(obj, c_expr.expr);
          # c_expr.expr &:= ";\n";
          body_expression := body(obj);
          change_calls_from_local_function(body_expression, local_function, additional_act_params);
(*
          for localConst range local_consts(obj) do
            if category(localConst) = BLOCKOBJECT then
              body_expression := body(localConst);
              change_calls_from_local_sub_function(body_expression, local_function,
                  additional_act_params);
            end if;
          end for;
*)
        end if;
      end for;
      body_expression := body(global_function);
      change_calls_from_global_function(body_expression, local_function, additional_act_params);
    end if;
    (* writeln("end fix_local_function(" <&
        str(global_function) <& "_" <& str(obj_number(global_function)) <& ", " <&
        str(local_function) <& "_" <& str(obj_number(local_function))); *)
  end func;


const proc: process_local_consts (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var ref_list: objects is ref_list.EMPTY;
    var reference: obj is NIL;
  begin
    objects := local_consts(current_object);
    for obj range objects do
      if category(obj) = BLOCKOBJECT then
        c_expr.expr &:= "/* local function */\n";
        fix_local_function(current_object, obj, c_expr);
      end if;
      process_object_declaration(obj, c_expr);
    end for;
  end func;


const proc: process_object (in reference: current_object) is func

  local
    var expr_type: c_expr is expr_type.value;
  begin
    write_object_declaration := TRUE;
    process_object_declaration(current_object, c_expr);
    write(c_prog, global_c_expr.expr);
    if write_object_declaration then
      write(c_prog, c_expr.expr);
(*
    else
      write(c_prog, "#ifdef WRITE_OBJECT_DECLARATION\n");
      write(c_prog, c_expr.expr);
      write(c_prog, "#endif\n");
*)
    end if;
    global_c_expr := expr_type.value;
  end func;


const proc: write_file_head is func

  begin
    writeln(c_prog, temp_marker);
    writeln(c_prog, "#include <stdlib.h>");
    writeln(c_prog, "#include <stdio.h>");
    writeln(c_prog, "#include <string.h>");
    writeln(c_prog, "#include <math.h>");
    writeln(c_prog, "#include <setjmp.h>");
    writeln(c_prog, "#include <signal.h>");
(*
    writeln(c_prog, "#define DO_HEAPSIZE_COMPUTATION"); #!
    writeln(c_prog, "#define DO_HEAP_STATISTIC"); #!
    writeln(c_prog, "#define EXTERN extern"); #!
    writeln(c_prog, "#define TRUE 1"); #!
    writeln(c_prog, "#define FALSE 0"); #!
    writeln(c_prog, "typedef size_t SIZE_TYPE;"); #!
*)
    writeln(c_prog, "typedef long booltype;");
    writeln(c_prog, "typedef long typetype;");
    if INTTYPE_64BIT then
      writeln(c_prog, "typedef long long int inttype;");
      writeln(c_prog, "typedef unsigned long long int uinttype;");
    else
      writeln(c_prog, "typedef long int inttype;");
      writeln(c_prog, "typedef unsigned long int uinttype;");
    end if;
    writeln(c_prog, "typedef float floattype;");
    writeln(c_prog, "typedef unsigned long int chartype;");
    writeln(c_prog, "typedef long int schartype;");
    writeln(c_prog, "typedef unsigned long int strelemtype;");
    writeln(c_prog, "typedef uinttype bitsettype;");
    writeln(c_prog, "typedef unsigned long int memsizetype;");
#!    writeln(c_prog, "#include \"../src/heaputl.h\""); #!
    writeln(c_prog, "typedef struct stri {");
    writeln(c_prog, "  memsizetype size;");
    if WITH_STRI_CAPACITY then
      writeln(c_prog, "  memsizetype capacity;");
    end if;
    writeln(c_prog, "  strelemtype mem[1];");
    writeln(c_prog, "} *stritype;");
    writeln(c_prog, "typedef struct {");
    writeln(c_prog, "  int dummy;");
    writeln(c_prog, "} *biginttype;");
    writeln(c_prog, "typedef struct {");
    writeln(c_prog, "  unsigned long usage_count;");
    writeln(c_prog, "} *wintype;");
    writeln(c_prog, "typedef inttype generictype;");
    writeln(c_prog, "typedef union {");
    writeln(c_prog, "  generictype genericvalue;");
    writeln(c_prog, "  inttype     intvalue;");
    writeln(c_prog, "  typetype    typevalue;");
    writeln(c_prog, "  floattype   floatvalue;");
    writeln(c_prog, "  stritype    strivalue;");
    writeln(c_prog, "  biginttype  bigintvalue;");
    writeln(c_prog, "  wintype     winvalue;");
    writeln(c_prog, "} valueunion;");
    writeln(c_prog, "typedef struct rtlObjectstruct {");
    writeln(c_prog, "  valueunion value;");
    writeln(c_prog, "} rtlObjecttype;");
    writeln(c_prog, "typedef FILE *filetype;");
    writeln(c_prog, "typedef int sockettype;");
    writeln(c_prog, "typedef inttype (*intfunctype)();");
    writeln(c_prog, "typedef inttype objreftype;");
    writeln(c_prog, "typedef struct list {");
    writeln(c_prog, "  struct list *next;");
    writeln(c_prog, "  objreftype obj;");
    writeln(c_prog, "} *listtype;");
    writeln(c_prog, "typedef struct bstri {");
    writeln(c_prog, "  memsizetype size;");
    writeln(c_prog, "  unsigned char mem[1];");
    writeln(c_prog, "} *bstritype;");
    writeln(c_prog, "typedef struct arraystruct {");
    writeln(c_prog, "  inttype min_position;");
    writeln(c_prog, "  inttype max_position;");
    writeln(c_prog, "  rtlObjecttype arr[1];");
    writeln(c_prog, "} *arraytype;");
#!    writeln(c_prog, "typedef arraytype rtlArraytype;"); #!
#!    writeln(c_prog, "typedef struct arraystruct rtlArrayrecord;"); #!
    writeln(c_prog, "typedef struct helemstruct *helemtype;");
    writeln(c_prog, "struct helemstruct {");
    writeln(c_prog, "  helemtype next_less;");
    writeln(c_prog, "  helemtype next_greater;");
    writeln(c_prog, "  rtlObjecttype key;");
    writeln(c_prog, "  rtlObjecttype data;");
    writeln(c_prog, "};");
    writeln(c_prog, "typedef struct hashstruct {");
    writeln(c_prog, "  int bits;");
    writeln(c_prog, "  int mask;");
    writeln(c_prog, "  int table_size;");
    writeln(c_prog, "  memsizetype size;");
    writeln(c_prog, "  helemtype table[1];");
    writeln(c_prog, "} *hashtype;");
    writeln(c_prog, "typedef inttype (*comparetype) (generictype, generictype);");
    writeln(c_prog, "typedef generictype (*createfunctype) (generictype);");
    writeln(c_prog, "typedef void (*destrfunctype) (generictype);");
    writeln(c_prog, "typedef void (*copyfunctype) (generictype *, generictype);");
    writeln(c_prog, "typedef struct {");
    writeln(c_prog, "  inttype min_position;");
    writeln(c_prog, "  inttype max_position;");
    writeln(c_prog, "  bitsettype bitset[1];");
    writeln(c_prog, "} *settype;");
    writeln(c_prog, "typedef struct structstruct {");
    writeln(c_prog, "  unsigned long int type_num;");
    writeln(c_prog, "  rtlObjecttype stru[1];");
    writeln(c_prog, "} *structtype;");
    writeln(c_prog, "typedef structtype interfacetype;");
    writeln(c_prog, "typedef void *progtype;");
    writeln(c_prog, "typedef union {");
    writeln(c_prog, "  inttype intvalue;");
    writeln(c_prog, "  floattype floatvalue;");
    writeln(c_prog, "} float2int;");
    writeln(c_prog, "stritype       arg_0;");
    writeln(c_prog, "arraytype      arg_v;");
    writeln(c_prog, "biginttype    *big;");
    writeln(c_prog, "stritype       str[];");
    writeln(c_prog, "settype        set[];");
    writeln(c_prog, "arraytype     *arr;");
    writeln(c_prog, "structtype    *sct;");
    writeln(c_prog, "hashtype      *hsh;");
    writeln(c_prog, "interfacetype *itf;");
    writeln(c_prog, "float2int      flt2int;");
    writeln(c_prog, "unsigned long int hs;");
    writeln(c_prog);
    writeln(c_prog, "static struct bstri empty_bst = {0, 0};");
    writeln(c_prog, "static inttype fact[] = {");
    writeln(c_prog, "    1, 1, 2, 6, 24, 120, 720, 5040, 40320,");
    writeln(c_prog, "    362880, 3628800, 39916800, 479001600");
    writeln(c_prog, "  };");
    writeln(c_prog, "extern float2int f_const[];");
    writeln(c_prog, "#define OKAY_NO_ERROR 0");
    writeln(c_prog, "#define MEMORY_ERROR  1");
    writeln(c_prog, "#define NUMERIC_ERROR 2");
    writeln(c_prog, "#define RANGE_ERROR   3");
    writeln(c_prog, "#define FILE_ERROR    4");
    writeln(c_prog, "#define CREATE_ERROR  5");
    writeln(c_prog, "#define DESTROY_ERROR 6");
    writeln(c_prog, "#define COPY_ERROR    7");
    writeln(c_prog, "#define IN_ERROR      8");
    writeln(c_prog, "static char *exception_name[] = {");
    writeln(c_prog, "    \"OKAY_NO_ERROR\",");
    writeln(c_prog, "    \"MEMORY_ERROR\",");
    writeln(c_prog, "    \"NUMERIC_ERROR\",");
    writeln(c_prog, "    \"RANGE_ERROR\",");
    writeln(c_prog, "    \"FILE_ERROR\",");
    writeln(c_prog, "    \"CREATE_ERROR\",");
    writeln(c_prog, "    \"DESTROY_ERROR\",");
    writeln(c_prog, "    \"COPY_ERROR\",");
    writeln(c_prog, "    \"IN_ERROR\",");
    writeln(c_prog, "  };");
    writeln(c_prog, "#define push_stack(stack,elem) \\");
    writeln(c_prog, "{\\");
    writeln(c_prog, "  listtype new_head = (listtype) malloc(sizeof(struct list));\\");
    writeln(c_prog, "  if (new_head == NULL) {\\");
    writeln(c_prog, "    raise_error(MEMORY_ERROR);\\");
    writeln(c_prog, "  } else {\\");
    writeln(c_prog, "    new_head->next = stack;\\");
    writeln(c_prog, "    new_head->obj = elem;\\");
    writeln(c_prog, "    stack = new_head;\\");
    writeln(c_prog, "  }\\");
    writeln(c_prog, "}");
    writeln(c_prog, "#define pop_stack(stack,elem) \\");
    writeln(c_prog, "{\\");
    writeln(c_prog, "  listtype old_head = stack;\\");
    writeln(c_prog, "  if (old_head == NULL) {\\");
    writeln(c_prog, "    elem = NULL;\\");
    writeln(c_prog, "  } else {\\");
    writeln(c_prog, "    stack = old_head->next;\\");
    writeln(c_prog, "    elem = (helemtype)(old_head->obj);\\");
    writeln(c_prog, "    free(old_head);\\");
    writeln(c_prog, "  }\\");
    writeln(c_prog, "}");
    # writeln(c_prog, "typedef sigjmp_buf catch_type;");
    writeln(c_prog, "typedef jmp_buf catch_type;");
    writeln(c_prog, "catch_type *catch_stack;");
    writeln(c_prog, "int catch_stack_pos;");
    writeln(c_prog, "int max_catch_stack;");
    writeln(c_prog, "char *error_file = NULL;");
    writeln(c_prog, "int error_line = 0;");
  end func;


const proc: write_prototypes is func

  begin
    writeln(c_prog, "stritype    actStr (generictype);");
    writeln(c_prog, "generictype actValue (objreftype);");
    writeln(c_prog, "void        arrAppend (arraytype *, arraytype);");
    writeln(c_prog, "arraytype   arrArrlit (arraytype);");
    writeln(c_prog, "arraytype   arrArrlit2 (inttype, arraytype);");
    writeln(c_prog, "arraytype   arrBaselit (long);");
    writeln(c_prog, "arraytype   arrBaselit2 (inttype, long);");
    writeln(c_prog, "arraytype   arrCat (arraytype, arraytype);");
    writeln(c_prog, "arraytype   arrExtend (arraytype, inttype);");
    writeln(c_prog, "arraytype   arrGen (inttype, inttype);");
    writeln(c_prog, "arraytype   arrHead (arraytype, inttype);");
    writeln(c_prog, "arraytype   arrRange (arraytype, inttype, inttype);");
    writeln(c_prog, "generictype arrRemove (arraytype, inttype);");
    writeln(c_prog, "arraytype   arrSort (arraytype, comparetype);");
    writeln(c_prog, "arraytype   arrTail (arraytype, inttype);");
    writeln(c_prog, "biginttype  bigAbs (biginttype);");
    writeln(c_prog, "biginttype  bigAdd (biginttype, biginttype);");
    writeln(c_prog, "inttype     bigBitLength (biginttype);");
    writeln(c_prog, "inttype     bigCmp (biginttype, biginttype);");
    writeln(c_prog, "inttype     bigCmpSignedDigit (biginttype, inttype);");
    writeln(c_prog, "void        bigCpy (biginttype *, biginttype);");
    writeln(c_prog, "biginttype  bigCreate (biginttype);");
    writeln(c_prog, "void        bigDecr (biginttype *);");
    writeln(c_prog, "void        bigDestr (biginttype);");
    writeln(c_prog, "biginttype  bigDiv (biginttype, biginttype);");
    writeln(c_prog, "booltype    bigEq (biginttype, biginttype);");
    writeln(c_prog, "void        bigGrow (biginttype *, biginttype);");
    if INTTYPE_64BIT then
      writeln(c_prog, "biginttype  bigFromInt64 (inttype);");
      writeln(c_prog, "#define bigIConv bigFromInt64");
    else
      writeln(c_prog, "biginttype  bigFromInt32 (inttype);");
      writeln(c_prog, "#define bigIConv bigFromInt32");
    end if;
    writeln(c_prog, "void        bigIncr (biginttype *);");
    writeln(c_prog, "biginttype  bigIPow (biginttype, inttype);");
    writeln(c_prog, "biginttype  bigLog2 (biginttype);");
    writeln(c_prog, "inttype     bigLowestSetBit (biginttype);");
    writeln(c_prog, "biginttype  bigMDiv (biginttype, biginttype);");
    writeln(c_prog, "biginttype  bigMinus (biginttype);");
    writeln(c_prog, "biginttype  bigMod (biginttype, biginttype);");
    writeln(c_prog, "biginttype  bigMult (biginttype, biginttype);");
    writeln(c_prog, "booltype    bigNe (biginttype, biginttype);");
    if INTTYPE_64BIT then
      writeln(c_prog, "inttype bigToInt64 (biginttype);");
      writeln(c_prog, "#define bigOrd   bigToInt64");
    else
      writeln(c_prog, "inttype bigToInt32 (biginttype);");
      writeln(c_prog, "#define bigOrd   bigToInt32");
    end if;
    writeln(c_prog, "inttype     bigOrd (biginttype);");
    writeln(c_prog, "biginttype  bigParse (stritype);");
    writeln(c_prog, "void        blnCpy (booltype *, booltype);");
    writeln(c_prog, "booltype    blnCreate (booltype);");
    writeln(c_prog, "inttype     chrCmp (chartype, chartype);");
    writeln(c_prog, "void        chrCpy (chartype *, chartype);");
    writeln(c_prog, "chartype    chrCreate (chartype);");
    writeln(c_prog, "chartype    chrLow (chartype);");
    writeln(c_prog, "stritype    chrStr (chartype);");
    writeln(c_prog, "chartype    chrUp (chartype);");
    writeln(c_prog, "biginttype  cmdBigFileSize (stritype);");
    writeln(c_prog, "void        cmdCloneFile (stritype, stritype);");
    writeln(c_prog, "void        cmdCopyFile (stritype, stritype);");
    writeln(c_prog, "inttype     cmdFileSize (stritype);");
    writeln(c_prog, "stritype    cmdGetcwd (void);");
    writeln(c_prog, "void        cmdGetATime (stritype, inttype *, inttype *, inttype *, inttype *, inttype *, inttype *, inttype *, inttype *, booltype *);");
    writeln(c_prog, "void        cmdGetMTime (stritype, inttype *, inttype *, inttype *, inttype *, inttype *, inttype *, inttype *, inttype *, booltype *);");
    writeln(c_prog, "arraytype   cmdLs (stritype);");
    writeln(c_prog, "void        cmdMove (stritype, stritype);");
    writeln(c_prog, "stritype    cmdReadlink (stritype);");
    writeln(c_prog, "void        cmdRemove (stritype);");
    writeln(c_prog, "void        cmdRemoveAnyFile (stritype);");
    writeln(c_prog, "void        cmdSetATime (stritype, inttype, inttype, inttype, inttype, inttype, inttype, inttype, inttype);");
    writeln(c_prog, "void        cmdSetMTime (stritype, inttype, inttype, inttype, inttype, inttype, inttype, inttype, inttype);");
    writeln(c_prog, "inttype     cmdShell (stritype);");
    writeln(c_prog, "void        drwArc (wintype, inttype, inttype, inttype, floattype, floattype);");
    writeln(c_prog, "void        drwArc2 (wintype, inttype, inttype, inttype, inttype, inttype);");
    writeln(c_prog, "void        drwCircle (wintype, inttype, inttype, inttype);");
    writeln(c_prog, "void        drwClear (wintype, inttype);");
    writeln(c_prog, "void        drwColor (inttype);");
    writeln(c_prog, "void        drwCopyArea (wintype, wintype, inttype, inttype, inttype, inttype, inttype, inttype);");
    writeln(c_prog, "void        drwCpy (wintype *, wintype);");
    writeln(c_prog, "wintype     drwCreate (wintype);");
    writeln(c_prog, "void        drwDestr (wintype);");
    writeln(c_prog, "void        drwFArcChord (wintype, inttype, inttype, inttype, floattype, floattype);");
    writeln(c_prog, "void        drwFArcPieSlice (wintype, inttype, inttype, inttype, floattype, floattype);");
    writeln(c_prog, "void        drwFCircle (wintype, inttype, inttype, inttype);");
    writeln(c_prog, "void        drwFEllipse (wintype, inttype, inttype, inttype, inttype);");
    writeln(c_prog, "void        drwFlush (void);");
    writeln(c_prog, "wintype     drwGet (wintype, inttype, inttype, inttype, inttype);");
    writeln(c_prog, "inttype     drwHeight (wintype);");
    writeln(c_prog, "wintype     drwImage (wintype, inttype *, inttype, inttype);");
    writeln(c_prog, "void        drwLine (wintype, inttype, inttype, inttype, inttype);");
    writeln(c_prog, "wintype     drwOpen (inttype, inttype, inttype, inttype, stritype);");
    writeln(c_prog, "void        drwPArc (wintype, inttype, inttype, inttype, floattype, floattype, inttype);");
    writeln(c_prog, "void        drwPCircle (wintype, inttype, inttype, inttype, inttype);");
    writeln(c_prog, "void        drwPFArcChord (wintype, inttype, inttype, inttype, floattype, floattype, inttype);");
    writeln(c_prog, "void        drwPFArcPieSlice (wintype, inttype, inttype, inttype, floattype, floattype, inttype);");
    writeln(c_prog, "void        drwPFCircle (wintype, inttype, inttype, inttype, inttype);");
    writeln(c_prog, "void        drwPFEllipse (wintype, inttype, inttype, inttype, inttype, inttype);");
    writeln(c_prog, "void        drwPLine (wintype, inttype, inttype, inttype, inttype, inttype);");
    writeln(c_prog, "void        drwPoint (wintype, inttype, inttype);");
    writeln(c_prog, "void        drwPPoint (wintype, inttype, inttype, inttype);");
    writeln(c_prog, "void        drwPRect (wintype, inttype, inttype, inttype, inttype, inttype);");
    writeln(c_prog, "void        drwPut (wintype, wintype, inttype, inttype);");
    writeln(c_prog, "void        drwRect (wintype, inttype, inttype, inttype, inttype);");
    writeln(c_prog, "inttype     drwRgbColor (inttype, inttype, inttype);");
    writeln(c_prog, "void        drwText (wintype, inttype, inttype, stritype, inttype, inttype);");
    writeln(c_prog, "inttype     drwWidth (wintype);");
    writeln(c_prog, "inttype     enuValue (objreftype a)                         {printf(\"enuValue\\n\");}");
    writeln(c_prog, "biginttype  filBigLng (filetype);");
    writeln(c_prog, "void        filBigSeek (filetype, biginttype);");
    writeln(c_prog, "biginttype  filBigTell (filetype);");
    writeln(c_prog, "stritype    filGets (filetype, inttype);");
    writeln(c_prog, "booltype    filHasNext (filetype);");
    writeln(c_prog, "stritype    filLineRead (filetype, chartype *);");
    writeln(c_prog, "inttype     filLng (filetype);");
    writeln(c_prog, "filetype    filOpen (stritype, stritype);");
    writeln(c_prog, "void        filPrint (stritype);");
    writeln(c_prog, "void        filSeek (filetype, inttype);");
    writeln(c_prog, "void        filSetbuf (filetype, inttype, inttype);");
    writeln(c_prog, "inttype     filTell (filetype);");
    writeln(c_prog, "stritype    filWordRead (filetype, chartype *);");
    writeln(c_prog, "void        filWrite (filetype, stritype);");
    writeln(c_prog, "inttype     fltCmp (floattype, floattype);");
    writeln(c_prog, "void        fltCpy (floattype *, floattype);");
    writeln(c_prog, "floattype   fltCreate (floattype);");
    writeln(c_prog, "stritype    fltDgts (floattype, inttype);");
    writeln(c_prog, "floattype   fltIPow (floattype, inttype);");
    writeln(c_prog, "floattype   fltParse (stritype);");
    writeln(c_prog, "floattype   fltPow (floattype, floattype);");
    writeln(c_prog, "floattype   fltRand (floattype, floattype);");
    writeln(c_prog, "stritype    fltStr (floattype);");
    writeln(c_prog, "floattype   fltValue (objreftype);");
    writeln(c_prog, "chartype    gkbGetc (void);");
    writeln(c_prog, "stritype    gkbGets (inttype);");
    writeln(c_prog, "inttype     gkbKeyPressed (void);");
    writeln(c_prog, "stritype    gkbLineRead (chartype *);");
    writeln(c_prog, "chartype    gkbRawGetc (void);");
    writeln(c_prog, "wintype     gkbWindow (void);");
    writeln(c_prog, "stritype    gkbWordRead (chartype *);");
    writeln(c_prog, "booltype    hshContains (hashtype, generictype, inttype, comparetype);");
    writeln(c_prog, "void        hshCpy (hashtype *, hashtype, createfunctype, destrfunctype, createfunctype, destrfunctype);");
    writeln(c_prog, "hashtype    hshCreate (hashtype, createfunctype, destrfunctype, createfunctype, destrfunctype);");
    writeln(c_prog, "void        hshDestr (hashtype, destrfunctype, destrfunctype);");
    writeln(c_prog, "hashtype    hshEmpty (void);");
    writeln(c_prog, "void        hshExcl (hashtype, generictype, inttype, comparetype, destrfunctype, destrfunctype);");
    writeln(c_prog, "generictype hshIdx (hashtype, generictype, inttype, comparetype);");
    writeln(c_prog, "rtlObjecttype *hshIdxAddr (hashtype, generictype, inttype, comparetype);");
    writeln(c_prog, "void        hshIncl (hashtype, generictype, generictype, inttype, comparetype, createfunctype, createfunctype, copyfunctype);");
    writeln(c_prog, "arraytype   hshKeys (hashtype, createfunctype, destrfunctype);");
    writeln(c_prog, "arraytype   hshValues (hashtype, createfunctype, destrfunctype);");
    writeln(c_prog, "inttype     intBinom (inttype, inttype);");
    writeln(c_prog, "inttype     intBitLength (inttype);");
    writeln(c_prog, "inttype     intCmp (inttype, inttype);");
    writeln(c_prog, "void        intCpy (inttype *, inttype);");
    writeln(c_prog, "inttype     intCreate (inttype);");
    writeln(c_prog, "inttype     intLog2 (inttype);");
    writeln(c_prog, "inttype     intLowestSetBit (inttype);");
    writeln(c_prog, "inttype     intParse (stritype);");
    writeln(c_prog, "inttype     intPow (inttype, inttype);");
    writeln(c_prog, "inttype     intRand (inttype, inttype);");
    writeln(c_prog, "inttype     intSqrt (inttype);");
    writeln(c_prog, "stritype    intStr (inttype);");
    writeln(c_prog, "stritype    intStrBased (inttype, inttype);");
    writeln(c_prog, "stritype    intStrHex (inttype);");
    writeln(c_prog, "chartype    kbdGetc (void);");
    writeln(c_prog, "stritype    kbdGets (inttype);");
    writeln(c_prog, "inttype     kbdKeyPressed (void);");
    writeln(c_prog, "stritype    kbdLineRead (chartype *);");
    writeln(c_prog, "chartype    kbdRawGetc (void);");
    writeln(c_prog, "stritype    kbdWordRead (chartype *);");
    writeln(c_prog, "inttype     heapsize (void);");
    writeln(c_prog, "void        prcNoop (void)                                {}");
    writeln(c_prog, "void *      prgSysvar (progtype, stritype);");
    writeln(c_prog, "long        refAddr (objreftype a)                        {printf(\"refAddr\\n\");}");
    writeln(c_prog, "inttype     refCmp (objreftype, objreftype);");
    writeln(c_prog, "void        refCpy (objreftype *, objreftype);");
    writeln(c_prog, "objreftype  refCreate (objreftype);");
    writeln(c_prog, "stritype    refFile (objreftype);");
    writeln(c_prog, "booltype    refIsvar (objreftype);");
    writeln(c_prog, "void *      refItftosct (objreftype);");
    writeln(c_prog, "long *      refSelect (void *a, inttype b)                {printf(\"refSelect\\n\");}");
    writeln(c_prog, "inttype     refLine (objreftype);");
    writeln(c_prog, "float *     refFSselect (void *a, inttype b)              {printf(\"refFSelect\\n\");}");
    writeln(c_prog, "stritype    refStr (objreftype);");
    writeln(c_prog, "inttype     refType (objreftype);");
    writeln(c_prog, "void        rflAppend (listtype *, listtype);");
    writeln(c_prog, "void        rflCpy (listtype *, listtype);");
    writeln(c_prog, "listtype    rflCreate (listtype);");
    writeln(c_prog, "booltype    rflElem (objreftype, listtype);");
    writeln(c_prog, "booltype    rflEq (listtype, listtype);");
    writeln(c_prog, "objreftype  rflIdx (listtype, inttype);");
    writeln(c_prog, "inttype     rflLng (listtype);");
    writeln(c_prog, "listtype    rflMklist (objreftype);");
    writeln(c_prog, "booltype    rflNe (listtype, listtype);");
    writeln(c_prog, "listtype    rflValue (objreftype);");
    writeln(c_prog, "void        scrClear (inttype, inttype, inttype, inttype);");
    writeln(c_prog, "void        scrCursor (booltype);");
    writeln(c_prog, "void        scrFlush (void);");
    writeln(c_prog, "int         scrHeight (void);");
    writeln(c_prog, "void        scrHScroll (inttype, inttype, inttype, inttype, inttype);");
    writeln(c_prog, "int         scrOpen (void);");
    writeln(c_prog, "void        scrSetpos (inttype, inttype);");
    writeln(c_prog, "void        scrShut (void);");
    writeln(c_prog, "void        scrVScroll (inttype, inttype, inttype, inttype, inttype);");
    writeln(c_prog, "int         scrWidth (void);");
    writeln(c_prog, "void        scrWrite (stritype stri);");
    writeln(c_prog, "void        sctCreate (structtype a, structtype b)        {printf(\"sctCreate\\n\");}");
    writeln(c_prog, "long *      sctSelect (void *a, inttype b)                {printf(\"sctSelect\\n\");}");
    writeln(c_prog, "float *     sctFSelect (void *a, inttype b)               {printf(\"sctFSelect\\n\");}");
    writeln(c_prog, "settype     setArrlit (inttype);");
    writeln(c_prog, "settype     setBaselit (inttype);");
    writeln(c_prog, "inttype     setCard (settype);");
    writeln(c_prog, "inttype     setCmp (settype, settype);");
    writeln(c_prog, "void        setCpy (settype *, settype);");
    writeln(c_prog, "settype     setCreate (settype);");
    writeln(c_prog, "void        setDestr (settype);");
    writeln(c_prog, "settype     setDiff (settype, settype);");
    writeln(c_prog, "booltype    setElem (inttype, settype);");
    writeln(c_prog, "booltype    setEq (settype, settype);");
    writeln(c_prog, "void        setExcl (settype *, inttype);");
    writeln(c_prog, "booltype    setGe (settype, settype);");
    writeln(c_prog, "booltype    setGt (settype, settype);");
    writeln(c_prog, "inttype     setHashCode (settype);");
    writeln(c_prog, "void        setIncl (settype *, inttype);");
    writeln(c_prog, "settype     setIntersect (settype, settype);");
    writeln(c_prog, "booltype    setLe (settype, settype);");
    writeln(c_prog, "booltype    setLt (settype, settype);");
    writeln(c_prog, "inttype     setMax (settype);");
    writeln(c_prog, "inttype     setMin (settype);");
    writeln(c_prog, "booltype    setNe (settype, settype);");
    writeln(c_prog, "booltype    setNotElem (inttype, settype);");
    writeln(c_prog, "inttype     setRand (settype);");
    writeln(c_prog, "settype     setSymdiff (settype, settype);");
    writeln(c_prog, "settype     setUnion (settype, settype);");
    writeln(c_prog, "sockettype  socAccept (sockettype, bstritype * );");
    writeln(c_prog, "void        socBind (sockettype, bstritype);");
    writeln(c_prog, "void        socClose (sockettype);");
    writeln(c_prog, "void        socConnect (sockettype, bstritype);");
    writeln(c_prog, "chartype    socGetc (sockettype);");
    writeln(c_prog, "stritype    socGets (sockettype, inttype);");
    writeln(c_prog, "bstritype   socInetAddr (stritype, inttype);");
    writeln(c_prog, "bstritype   socInetLocalAddr (inttype);");
    writeln(c_prog, "bstritype   socInetServAddr (inttype);");
    writeln(c_prog, "stritype    socLineRead (sockettype, chartype * );");
    writeln(c_prog, "void        socListen (sockettype, inttype);");
    writeln(c_prog, "inttype     socRecv (sockettype, stritype *, inttype, inttype);");
    writeln(c_prog, "inttype     socRecvfrom (sockettype, stritype *, inttype, inttype, bstritype * );");
    writeln(c_prog, "inttype     socSend (sockettype, stritype, inttype);");
    writeln(c_prog, "inttype     socSendto (sockettype, stritype, inttype, bstritype);");
    writeln(c_prog, "sockettype  socSocket (inttype, inttype, inttype);");
    writeln(c_prog, "stritype    socWordRead (sockettype, chartype * );");
    writeln(c_prog, "void        socWrite (sockettype, stritype);");
    writeln(c_prog, "void        strAppend (stritype *, stritype);");
    writeln(c_prog, "inttype     strChIpos (stritype, chartype, inttype);");
    writeln(c_prog, "inttype     strChPos (stritype, chartype);");
    writeln(c_prog, "arraytype   strChSplit (stritype, chartype);");
    writeln(c_prog, "inttype     strCompare (stritype, stritype);");
    writeln(c_prog, "stritype    strConcat (stritype, stritype);");
    writeln(c_prog, "stritype    strConcatTemp (stritype, stritype);");
    writeln(c_prog, "stritype    strCLit (stritype);");
    writeln(c_prog, "void        strCopy (stritype *, stritype);");
    writeln(c_prog, "stritype    strCreate (stritype);");
    writeln(c_prog, "void        strDestr (stritype);");
    writeln(c_prog, "stritype    strEmpty(void);");
    writeln(c_prog, "booltype    strGe (stritype, stritype);");
    writeln(c_prog, "booltype    strGt (stritype, stritype);");
    writeln(c_prog, "inttype     strHashCode (stritype);");
    writeln(c_prog, "stritype    strHead (stritype, inttype);");
    writeln(c_prog, "inttype     strIpos (stritype, stritype, inttype);");
    writeln(c_prog, "booltype    strLe (stritype, stritype);");
    writeln(c_prog, "stritype    strLit (stritype);");
    writeln(c_prog, "stritype    strLow (stritype);");
    writeln(c_prog, "stritype    strLowTemp (stritype);");
    writeln(c_prog, "stritype    strLpad (stritype, inttype);");
    writeln(c_prog, "stritype    strLpad0 (stritype, inttype);");
    writeln(c_prog, "stritype    strLpad0Temp (stritype, inttype);");
    writeln(c_prog, "booltype    strLt (stritype, stritype);");
    writeln(c_prog, "stritype    strMult (stritype, inttype);");
    writeln(c_prog, "inttype     strPos (stritype, stritype);");
    writeln(c_prog, "stritype    strRange (stritype, inttype, inttype);");
    writeln(c_prog, "inttype     strRChPos (stritype, chartype);");
    writeln(c_prog, "stritype    strRepl (stritype, stritype, stritype);");
    writeln(c_prog, "stritype    strRpad (stritype, inttype);");
    writeln(c_prog, "inttype     strRpos (stritype, stritype);");
    writeln(c_prog, "arraytype   strSplit (stritype, stritype);");
    writeln(c_prog, "stritype    strSubstr (stritype, inttype, inttype);");
    writeln(c_prog, "stritype    strTail (stritype, inttype);");
    writeln(c_prog, "stritype    strTrim (stritype);");
    writeln(c_prog, "stritype    strUp (stritype);");
    writeln(c_prog, "stritype    strUpTemp (stritype);");
    writeln(c_prog, "stritype    cstri_to_stri (char *);");
    writeln(c_prog, "char *      str_to_cstri (stritype a)                     {printf(\"str_to_cstri\\n\");}");
    writeln(c_prog, "void        timAwait (inttype, inttype, inttype, inttype, inttype, inttype, inttype, inttype);");
    writeln(c_prog, "void        timNow (inttype *, inttype *, inttype*, inttype *, inttype *, inttype *, inttype *, inttype *, booltype *);");
    writeln(c_prog, "inttype     typCmp (typetype, typetype);");
    writeln(c_prog, "void        typCpy (typetype *, typetype);");
    writeln(c_prog, "typetype    typCreate (typetype);");
    writeln(c_prog, "void        typDestr (typetype);");
    writeln(c_prog, "stritype    typStr (int);");
    writeln(c_prog, "inttype     typValue (objreftype);");
    writeln(c_prog, "chartype    ut8Getc (filetype);");
    writeln(c_prog, "stritype    ut8Gets (filetype, inttype);");
    writeln(c_prog, "stritype    ut8LineRead (filetype, chartype *);");
    writeln(c_prog, "void        ut8Seek (filetype, inttype);");
    writeln(c_prog, "stritype    ut8WordRead (filetype, chartype *);");
    writeln(c_prog, "void        ut8Write (filetype, stritype);");
    writeln(c_prog, "void        raise_error2 (int, char *, int);");
    writeln(c_prog, "#define raise_error(num) raise_error2(num, __FILE__, __LINE__)\n");
(*
    writeln(c_prog, "arraytype   arrHead (arraytype a, inttype b)              {printf(\"arrHead\\n\");}");
    writeln(c_prog, "arraytype   arrRange (arraytype a, inttype b, inttype c)  {printf(\"arrRange\\n\");}");
    writeln(c_prog, "generictype arrRemove (arraytype a, inttype b)            {printf(\"arrRemove\\n\");");
    writeln(c_prog, "arraytype   arrSort (arraytype a, void *b)                {printf(\"arrSort\\n\");}");
    writeln(c_prog, "arraytype   arrTail (arraytype a, inttype b)              {printf(\"arrTail\\n\");}");
    writeln(c_prog, "inttype     enuValue (objreftype);");
    writeln(c_prog, "void        filPrint (stritype stri) {\n\
              \char *str1;\n\
              \str1 = cp_to_cstri(stri);\n\
              \if (str1 != NULL) {\n\
              \  fputs(str1, stdout);\n\
              \  fflush(stdout);\n\
              \  free(str1);\n\
              \}\n\
              \}");
    writeln(c_prog, "void        hsh_create (hashtype *, hashtype, void *, void *, void *, void * );");
    writeln(c_prog, "void        hsh_destr (hashtype, void *, void * );");
    writeln(c_prog, "void        hsh_cpy (hashtype *, hashtype, void *, void *, void *, void * );");
    writeln(c_prog, "inttype     hsh_contains ();");
    writeln(c_prog, "void        hsh_incl ();");
    writeln(c_prog, "void        hsh_excl ();");
    writeln(c_prog, "inttype     heapsize (void);");
    writeln(c_prog, "void        prcNoop (void);");
    writeln(c_prog, "long        refAddr (void * );");
    writeln(c_prog, "booltype    refIsvar (void * );");
    writeln(c_prog, "void *      refItftosct (void *a)                         {printf(\"refItftosct\\n\");}");
    writeln(c_prog, "long *      refSelect (void *, inttype);");
    writeln(c_prog, "float *     refFSelect (void *, inttype);");
    writeln(c_prog, "stritype    refStr (void *a)                              {printf(\"ref_str\\n\");}");
    writeln(c_prog, "void        rflAppend (listtype *a, listtype b)           {printf(\"rflAppend\\n\");}");
    writeln(c_prog, "void        rflCpy (listtype *a, listtype b)              {printf(\"rflCpy\\n\");}");
    writeln(c_prog, "booltype    rflElem (void *a, listtype b)                 {printf(\"rflElem\\n\");}");
    writeln(c_prog, "void *      rflIdx (listtype a, inttype b)                {printf(\"rflIdx\\n\");}");
    writeln(c_prog, "inttype     rflLng (listtype a)                           {printf(\"rflLng\\n\");}");
    writeln(c_prog, "void        sct_cpy (structtype a, structtype b)          {printf(\"sct_cpy\\n\");}");
    writeln(c_prog, "void        sct_cpy (structtype, structtype);");
    writeln(c_prog, "long *      sctSelect (void *, inttype);");
    writeln(c_prog, "float *     sctFSelect (void *, inttype);");
    writeln(c_prog, "stritype    strCLit (stritype);");
    writeln(c_prog, "char *      str_to_cstri (stritype);");
    writeln(c_prog, "stritype    typStr (int a)                                {printf(\"typStr\\n\");}");
*)
  end func;


const proc: write_signal_handlers is func

  begin
    writeln(c_prog);
    writeln(c_prog);
    writeln(c_prog, "static void activate_signal_handlers (void);");
    writeln(c_prog);
    writeln(c_prog);
    writeln(c_prog, "static void handle_signals (int sig_num)");
    writeln(c_prog);
    writeln(c_prog, "  {");
    writeln(c_prog, "    int ch;");
    writeln(c_prog, "    char *sig_name;");
    writeln(c_prog, "    char buffer[20];");
    writeln(c_prog);
    writeln(c_prog, "    if (sig_num == SIGABRT) {");
    writeln(c_prog, "      sig_name = \"ABORT\";");
    writeln(c_prog, "    } else if (sig_num == SIGFPE) {");
    writeln(c_prog, "      sig_name = \"FPE\";");
    writeln(c_prog, "    } else if (sig_num == SIGILL) {");
    writeln(c_prog, "      sig_name = \"ILL\";");
    writeln(c_prog, "    } else if (sig_num == SIGINT) {");
    writeln(c_prog, "      sig_name = \"INTR\";");
    writeln(c_prog, "    } else if (sig_num == SIGSEGV) {");
    writeln(c_prog, "      sig_name = \"SEGV\";");
    writeln(c_prog, "    } else if (sig_num == SIGTERM) {");
    writeln(c_prog, "      sig_name = \"TERM\";");
    writeln(c_prog, "    } else {");
    writeln(c_prog, "      sprintf(buffer, \"%d\", sig_num);");
    writeln(c_prog, "      sig_name = buffer;");
    writeln(c_prog, "    } /* if */");
    writeln(c_prog, "    printf(\"\\n*** SIGNAL %s RAISED\\n\", sig_name);");
    writeln(c_prog, "    printf(\"\\n*** (Type RETURN to continue or '*' to terminate)\\n\");");
    writeln(c_prog, "    ch = fgetc(stdin);");
    writeln(c_prog, "    if (ch == '*') {");
    writeln(c_prog, "      exit(1);");
    writeln(c_prog, "    } /* if */");
    writeln(c_prog, "    activate_signal_handlers();");
    writeln(c_prog, "  }");
    writeln(c_prog);
    writeln(c_prog);
    writeln(c_prog, "static void handle_term_signal (int sig_num)");
    writeln(c_prog);
    writeln(c_prog, "  {");
    writeln(c_prog, "    printf(\"\\n*** SIGNAL TERM RAISED\\n\");");
    writeln(c_prog, "    printf(\"\\n*** Program terminated\\n\");");
    writeln(c_prog, "    exit(1);");
    writeln(c_prog, "  }");
    writeln(c_prog);
    writeln(c_prog);
    writeln(c_prog, "static void handle_fpe_signal (int sig_num)");
    writeln(c_prog);
    writeln(c_prog, "  {");
    if not USE_SIGSETJMP then
      writeln(c_prog, "    signal(SIGFPE, handle_fpe_signal);");
    end if;
    writeln(c_prog, "    raise_error(NUMERIC_ERROR);");
    writeln(c_prog, "  }");
    writeln(c_prog);
    writeln(c_prog);
    writeln(c_prog, "static void activate_signal_handlers (void)");
    writeln(c_prog);
    writeln(c_prog, "  {");
    writeln(c_prog, "    signal(SIGABRT, handle_signals);");
    writeln(c_prog, "    signal(SIGFPE, handle_fpe_signal);");
    writeln(c_prog, "    signal(SIGILL, handle_signals);");
    writeln(c_prog, "    signal(SIGINT, handle_signals);");
    writeln(c_prog, "    signal(SIGSEGV, handle_signals);");
    writeln(c_prog, "    signal(SIGTERM, handle_term_signal);");
    writeln(c_prog, "  }");
    writeln(c_prog);
    writeln(c_prog);
    writeln(c_prog, "static void resize_catch_stack (void)");
    writeln(c_prog);
    writeln(c_prog, "  {");
    writeln(c_prog, "    catch_type *resized_stack;");
    writeln(c_prog);
    writeln(c_prog, "    max_catch_stack += 128;");
    writeln(c_prog, "    resized_stack = realloc(catch_stack, max_catch_stack);");
    writeln(c_prog, "    if (resized_stack == NULL) {");
    writeln(c_prog, "      catch_stack_pos--;");
    writeln(c_prog, "      raise_error(MEMORY_ERROR);");
    writeln(c_prog, "    } else {");
    writeln(c_prog, "      catch_stack = resized_stack;");
    writeln(c_prog, "    }");
    writeln(c_prog, "  }");
    writeln(c_prog);
    writeln(c_prog);
  end func;


const proc: write_call_of_main (in program: prog, inout expr_type: c_expr) is func

  local
    var reference: main_obj is NIL;
  begin
    main_obj := sys_var(prog, "main");
    if main_obj <> NIL then
      c_expr.expr &:= "o_";
      create_name(main_obj, c_expr.expr);
      c_expr.expr &:= "();\n";
    else
      writeln(" *** MAIN not declared.\n");
    end if;
  end func;


const proc: walk_const_list (in ref_list: const_list, inout ref_list: sorted_list) is func
  local
    var reference: current_object is NIL;
    var reference: struct_of_interface is NIL;
    var category: objectCategory is category.value;
  begin
    for current_object range const_list do
      objectCategory := category(current_object);
      if objectCategory = BIGINTOBJECT then
        if getValue(current_object, bigInteger) not in bigint_const_table then
          bigint_const_table @:= [getValue(current_object, bigInteger)] length(bigint_const_table);
        end if;
      elsif objectCategory = STRIOBJECT then
        if getValue(current_object, string) not in stri_const_table then
          stri_const_table @:= [getValue(current_object, string)] length(stri_const_table);
        end if;
      elsif objectCategory = ARRAYOBJECT then
        if current_object not in const_table then
          const_table @:= [current_object] length(const_table);
        end if;
        walk_const_list(array_to_list(current_object), sorted_list);
        sorted_list &:= make_list(current_object);
      elsif objectCategory = STRUCTOBJECT then
        if current_object not in const_table then
          const_table @:= [current_object] length(const_table);
        end if;
        walk_const_list(struct_to_list(current_object), sorted_list);
        sorted_list &:= make_list(current_object);
      elsif objectCategory = HASHOBJECT then
        if current_object not in const_table then
          const_table @:= [current_object] length(const_table);
        end if;
        walk_const_list(hash_key_to_list(current_object), sorted_list);
        walk_const_list(hash_data_to_list(current_object), sorted_list);
        sorted_list &:= make_list(current_object);
      elsif objectCategory = INTERFACEOBJECT then
        if current_object not in const_table then
          const_table @:= [current_object] length(const_table);
        end if;
        struct_of_interface := interface_to_struct(current_object);
        if struct_of_interface not in const_table then
          const_table @:= [struct_of_interface] length(const_table);
          walk_const_list(struct_to_list(struct_of_interface), sorted_list);
          sorted_list &:= make_list(struct_of_interface);
        elsif const_table[struct_of_interface] >= const_table[current_object] then
          sorted_list &:= make_list(struct_of_interface);
        end if;
        sorted_list &:= make_list(current_object);
      end if;
    end for;
  end func;


const proc: init_const_value (in reference: current_object, inout expr_type: c_expr) is func
  local
    var category: objectCategory is category.value;
  begin
    objectCategory := category(current_object);
    if objectCategory = INTOBJECT then
      c_expr.expr &:= ".value.intvalue=";
      c_expr.expr &:= str(getValue(current_object, integer));
    elsif objectCategory = BIGINTOBJECT then
      c_expr.expr &:= ".value.intvalue=";
      c_expr.expr &:= "big[";
      c_expr.expr &:= str(bigint_const_table[getValue(current_object, bigInteger)]);
      c_expr.expr &:= "] /* ";
      c_expr.expr &:= str(getValue(current_object, bigInteger));
      c_expr.expr &:= " */";
    elsif objectCategory = CHAROBJECT then
      c_expr.expr &:= ".value.intvalue=";
      c_expr.expr &:= c_literal(getValue(current_object, char));
    elsif objectCategory = STRIOBJECT then
      c_expr.expr &:= ".value.intvalue=";
      c_expr.expr &:= "str[";
      c_expr.expr &:= str(stri_const_table[getValue(current_object, string)]);
      c_expr.expr &:= "] /* ";
      c_expr.expr &:= replace(literal(getValue(current_object, string)), "*/", "*\\/");
      c_expr.expr &:= " */";
    elsif objectCategory = BSTRIOBJECT then
      c_expr.expr &:= ".value.intvalue=";
      c_expr.expr &:= "&empty_bst";
    elsif objectCategory = SETOBJECT then
      c_expr.expr &:= ".value.intvalue=";
      c_expr.expr &:= "set[";
      c_expr.expr &:= str(set_const_table[getValue(current_object, bitset)]);
      c_expr.expr &:= "]";
    elsif objectCategory = FLOATOBJECT then
      c_expr.expr &:= ".value.floatvalue=";
      if isnan(getValue(current_object, float)) then
        if FLOAT_ZERO_DIV_ERROR then
          c_expr.expr &:= "f_const[0].floatvalue /* 0.0/0.0 */";
        else
          c_expr.expr &:= "0.0/0.0";
        end if;
      elsif getValue(current_object, float) = Infinity then
        if FLOAT_ZERO_DIV_ERROR then
          c_expr.expr &:= "f_const[1].floatvalue /* 1.0/0.0 */";
        else
          c_expr.expr &:= "1.0/0.0";
        end if;
      elsif getValue(current_object, float) = -Infinity then
        if FLOAT_ZERO_DIV_ERROR then
          c_expr.expr &:= "f_const[2].floatvalue /* -1.0/0.0 */";
        else
          c_expr.expr &:= "-1.0/0.0";
        end if;
      else
        c_expr.expr &:= str(getValue(current_object, float));
      end if;
    elsif objectCategory = REFOBJECT then
      c_expr.expr &:= ".value.intvalue=";
      if getValue(current_object, reference) = NIL then
        c_expr.expr &:= "NULL";
      else
        c_expr.expr &:= "&(";
        process_expr(getValue(current_object, reference), c_expr);
        c_expr.expr &:= ")";
      end if;
    elsif objectCategory = FILEOBJECT then
      c_expr.expr &:= ".value.intvalue=";
      c_expr.expr &:= literal(getValue(current_object, PRIMITIVE_FILE));
    elsif objectCategory = SOCKETOBJECT then
      c_expr.expr &:= ".value.intvalue=";
      c_expr.expr &:= "-1";
    elsif objectCategory = WINOBJECT then
      c_expr.expr &:= ".value.intvalue=";
      c_expr.expr &:= "NULL";
    elsif objectCategory = CONSTENUMOBJECT then
      c_expr.expr &:= ".value.intvalue=";
      c_expr.expr &:= enum_value(getValue(current_object, reference));
    elsif objectCategory = VARENUMOBJECT then
      c_expr.expr &:= ".value.intvalue=";
      c_expr.expr &:= enum_value(getValue(current_object, reference));
    elsif objectCategory = ARRAYOBJECT then
      c_expr.expr &:= ".value.intvalue=";
      c_expr.expr &:= "arr[";
      c_expr.expr &:= str(const_table[current_object]);
      c_expr.expr &:= "]";
    elsif objectCategory = STRUCTOBJECT then
      c_expr.expr &:= ".value.intvalue=";
      c_expr.expr &:= "sct[";
      c_expr.expr &:= str(const_table[current_object]);
      c_expr.expr &:= "]";
    elsif objectCategory = HASHOBJECT then
      c_expr.expr &:= ".value.intvalue=";
      c_expr.expr &:= "hsh[";
      c_expr.expr &:= str(const_table[current_object]);
      c_expr.expr &:= "]";
    elsif objectCategory = INTERFACEOBJECT then
      c_expr.expr &:= ".value.intvalue=";
      c_expr.expr &:= "itf[";
      c_expr.expr &:= str(const_table[current_object]);
      c_expr.expr &:= "] /* ";
      c_expr.expr &:= str(objectCategory);
      c_expr.expr &:= " */";
    else
      c_expr.expr &:= "/* ";
      c_expr.expr &:= str(objectCategory);
      c_expr.expr &:= " */";
    end if;
  end func;


const proc: init_bigint_constants (inout expr_type: c_expr) is func
  local
    var bigint_index_hash: bigint_index is bigint_index_hash.EMPTY_HASH;
    var bigInteger: big1 is bigInteger.value;
    var integer: number is 0;
  begin
    bigint_index := flip(bigint_const_table);
    for number range sort(keys(bigint_index)) do
      big1 := bigint_index[number][1];
      c_expr.expr &:= "/* big[";
      c_expr.expr &:= str(number);
      c_expr.expr &:= "] */ static unsigned char big_";
      c_expr.expr &:= str(number);
      c_expr.expr &:= "[]=";
      c_expr.expr &:= c_literal(big1);
      c_expr.expr &:= ";\n";
    end for;
  end func;


const proc: assign_bigint_constants (inout expr_type: c_expr) is func
  local
    var bigint_index_hash: bigint_index is bigint_index_hash.EMPTY_HASH;
    var bigInteger: big1 is bigInteger.value;
    var integer: number is 0;
  begin
    c_expr.expr &:= "big = malloc(";
    c_expr.expr &:= str(length(bigint_const_table));
    c_expr.expr &:= " * sizeof(biginttype));\n";
    bigint_index := flip(bigint_const_table);
    if length(bigint_const_table) > 0 then
      for number range sort(keys(bigint_index)) do
        big1 := bigint_index[number][1];
        c_expr.expr &:= "big[";
        c_expr.expr &:= str(number);
        c_expr.expr &:= "]=bigImport(big_";
        c_expr.expr &:= str(number);
        c_expr.expr &:= "); /* ";
        c_expr.expr &:= str(big1);
        c_expr.expr &:= " */\n";
      end for;
    end if;
  end func;


const proc: init_string_constants (inout expr_type: c_expr) is func
  local
    var stri_index_hash: stri_index is stri_index_hash.EMPTY_HASH;
    var string: stri is "";
    var integer: number is 0;
    var char: ch is ' ';
  begin
    stri_index := flip(stri_const_table);
    for number range sort(keys(stri_index)) do
      stri := stri_index[number][1];
      c_expr.expr &:= "/* str[";
      c_expr.expr &:= str(number);
      c_expr.expr &:= "] */ static strelemtype stri_";
      c_expr.expr &:= str(number);
      c_expr.expr &:= "[]={";
      c_expr.expr &:= str(length(stri));
      c_expr.expr &:= ",";
      if WITH_STRI_CAPACITY then
        c_expr.expr &:= str(length(stri));
        c_expr.expr &:= ",";
      end if;
      for ch range stri do
        c_expr.expr &:= c_literal(ch);
        c_expr.expr &:= ",";
      end for;
      c_expr.expr &:= "};\n";
    end for;
    if length(stri_const_table) > 0 then
      c_expr.expr &:= "stritype str[]={\n";
      for number range sort(keys(stri_index)) do
        c_expr.expr &:= "(stritype) stri_";
        c_expr.expr &:= str(number);
        c_expr.expr &:= ",\n";
      end for;
      c_expr.expr &:= "};\n\n";
    end if;
  end func;


const proc: init_set_constants (inout expr_type: c_expr) is func
  local
    var set_index_hash: set_index is set_index_hash.EMPTY_HASH;
    var bitset: set1 is EMPTY_SET;
    var integer: min_position is 0;
    var integer: max_position is 0;
    var integer: number is 0;
    var integer: elem_num is 0;
    var integer: byte_num is 0;
    var integer: bit_num is 0;
    var integer: hex_digit is 0;
    var string: hex_num is "";
  begin
    set_index := flip(set_const_table);
    for number range sort(keys(set_index)) do
      set1 := set_index[number][1];
      c_expr.expr &:= "/* set[";
      c_expr.expr &:= str(number);
      c_expr.expr &:= "] */ static bitsettype set_";
      c_expr.expr &:= str(number);
      c_expr.expr &:= "[]={";
      if set1 = EMPTY_SET then
        c_expr.expr &:= "0,0,0,";
      else
        min_position := min(set1) mdiv 32;
        max_position := max(set1) mdiv 32;
        c_expr.expr &:= str(min_position);
        c_expr.expr &:= ",";
        c_expr.expr &:= str(max_position);
        c_expr.expr &:= ",";
        for elem_num range min_position to max_position do
          hex_num := "";
          for byte_num range 0 to 3 do
            hex_digit := 0;
            for bit_num range 0 to 3 do
              if elem_num * 32 + byte_num * 8 + bit_num in set1 then
                hex_digit +:= 2 ** bit_num;
              end if;
            end for;
            hex_num  := "0123456789ABCDEF"[succ(hex_digit) len 1] & hex_num;
            hex_digit := 0;
            for bit_num range 4 to 7 do
              if elem_num * 32 + byte_num * 8 + bit_num in set1 then
                hex_digit +:= 2 ** (bit_num - 4);
              end if;
            end for;
            hex_num  := "0123456789ABCDEF"[succ(hex_digit) len 1] & hex_num;
          end for;
          c_expr.expr &:= "0x";
          c_expr.expr &:= hex_num;
          c_expr.expr &:= ",";
        end for;
      end if;
      c_expr.expr &:= "};\n";
    end for;
    if length(set_const_table) > 0 then
      c_expr.expr &:= "settype set[]={\n";
      for number range sort(keys(set_index)) do
        c_expr.expr &:= "(settype) set_";
        c_expr.expr &:= str(number);
        c_expr.expr &:= ",\n";
      end for;
      c_expr.expr &:= "};\n\n";
    end if;
  end func;


const proc: generate_main (in program: prog) is func

  local
    var expr_type: c_expr is expr_type.value;
    var stri_index_hash: stri_index is stri_index_hash.EMPTY_HASH;
    var const_index_hash: const_index is const_index_hash.EMPTY_HASH;
    var reference: const_object is NIL;
    var reference: struct_of_interface is NIL;
    var integer: number is 0;
    var integer: elem_num is 0;
    var ref_list: array_list is ref_list.EMPTY;
    var ref_list: struct_list is ref_list.EMPTY;
    var ref_list: hash_key_list is ref_list.EMPTY;
    var ref_list: hash_data_list is ref_list.EMPTY;
    var ref_list: sorted_list is ref_list.EMPTY;
  begin
    if not compilerLibraryUsed then
      c_expr.expr &:= "void raise_error2 (int a, char *file_name, int line_number)\n";
      c_expr.expr &:= "{\n";
      c_expr.expr &:= "  error_file = file_name;\n";
      c_expr.expr &:= "  error_line = line_number;\n";
#     c_expr.expr &:= "  printf(\"error: %s(%d)\\n\", file_name, line_number);\n";
      if USE_SIGSETJMP then
        c_expr.expr &:= "  siglongjmp(catch_stack[catch_stack_pos], a);\n";
      else
        c_expr.expr &:= "  longjmp(catch_stack[catch_stack_pos], a);\n";
      end if;
#     c_expr.expr &:= "  raise(SIGINT);\n";
#     c_expr.expr &:= "  raise(SIGSEGV);\n";
      c_expr.expr &:= "}\n";
      c_expr.expr &:= "\n";
    end if;
    if not compDataLibraryUsed then
      c_expr.expr &:= "inttype heapsize (void) {return(0);}\n";
#!    c_expr.expr &:= "inttype heapsize (void) {rtlHeapStatistic(); return(0);}\n";
      c_expr.expr &:= "inttype refType (objreftype a) {printf(\"refType\\n\");}\n";
      c_expr.expr &:= "inttype typValue (objreftype a) {printf(\"typValue\\n\");}\n";
    end if;
    if compDataLibraryUsed and not compilerLibraryUsed then
      c_expr.expr &:= "unsigned char *file_name (unsigned int a) {printf(\"file_name\\n\");}\n";
      c_expr.expr &:= "void *get_param_list (listtype a, int *b) {printf(\"get_param_list\\n\");}\n";
      c_expr.expr &:= "void *create_parameter_list (listtype a, int *b) {printf(\"create_parameter_list\\n\");}\n";
    end if;
    process_dynamic_decisions(c_expr);
    const_index := flip(const_table);
    for number range sort(keys(const_index)) do
      const_object := const_index[number][1];
      if category(const_object) = ARRAYOBJECT then
        walk_const_list(array_to_list(const_object), sorted_list);
        sorted_list &:= make_list(const_object);
      elsif category(const_object) = STRUCTOBJECT then
        walk_const_list(struct_to_list(const_object), sorted_list);
        sorted_list &:= make_list(const_object);
      elsif category(const_object) = HASHOBJECT then
        walk_const_list(hash_key_to_list(const_object), sorted_list);
        walk_const_list(hash_data_to_list(const_object), sorted_list);
        sorted_list &:= make_list(const_object);
      elsif category(const_object) = INTERFACEOBJECT then
        if const_object not in const_table then
          const_table @:= [const_object] length(const_table);
        end if;
        struct_of_interface := interface_to_struct(const_object);
        if struct_of_interface not in const_table then
          const_table @:= [struct_of_interface] length(const_table);
          walk_const_list(struct_to_list(struct_of_interface), sorted_list);
          sorted_list &:= make_list(struct_of_interface);
        elsif const_table[struct_of_interface] >= const_table[const_object] then
          sorted_list &:= make_list(struct_of_interface);
        end if;
        sorted_list &:= make_list(const_object);
      end if;
    end for;
    writeln("after walk_const_list");
    init_bigint_constants(c_expr);
    init_string_constants(c_expr);
    init_set_constants(c_expr);

    c_expr.expr &:= "int main (int argc, char **argv)\n";
    c_expr.expr &:= "\n";
    c_expr.expr &:= "{\n";
    c_expr.expr &:= "int fail_value;\n";
    c_expr.expr &:= "rtlObjecttype hash_key;\n";
    c_expr.expr &:= "rtlObjecttype hash_data;\n";
    c_expr.expr &:= "catch_stack_pos = 0;\n";
    c_expr.expr &:= "max_catch_stack = 128;\n";
    c_expr.expr &:= "catch_stack = malloc(max_catch_stack * sizeof(catch_type));\n";

    if USE_SIGSETJMP then
      c_expr.expr &:= "if ((fail_value = sigsetjmp(catch_stack[catch_stack_pos], -1)) == 0) {\n";
    else
      c_expr.expr &:= "if ((fail_value = setjmp(catch_stack[catch_stack_pos])) == 0) {\n";
    end if;

    c_expr.expr &:= "arg_0 = cstri_to_stri(argv[0]);\n";
    c_expr.expr &:= "arg_v = malloc(sizeof(struct arraystruct) - sizeof(rtlObjecttype) +\n";
    c_expr.expr &:= "  argc * sizeof(rtlObjecttype));\n";
    c_expr.expr &:= "arg_v->min_position = 1;\n";
    c_expr.expr &:= "arg_v->max_position = argc - 1;\n";
    c_expr.expr &:= "{\n";
    c_expr.expr &:= "  int number;\n";
    c_expr.expr &:= "  for (number = 1; number < argc; number++) {\n";
    c_expr.expr &:= "    arg_v->arr[number-1].value.intvalue=cstri_to_stri(argv[number]);\n";
    c_expr.expr &:= "  }\n";
    c_expr.expr &:= "}\n";
    c_expr.expr &:= "setupFloat();\n";

    assign_bigint_constants(c_expr);
    c_expr.expr &:= "arr = malloc(";
    c_expr.expr &:= str(length(const_table));
    c_expr.expr &:= " * sizeof(arraytype));\n";
    c_expr.expr &:= "sct = arr;\n";
    c_expr.expr &:= "hsh = arr;\n";
    c_expr.expr &:= "itf = arr;\n";
    for const_object range sorted_list do
      number := const_table[const_object];
      if category(const_object) = ARRAYOBJECT then
        array_list := array_to_list(const_object);
        c_expr.expr &:= "arr[";
        c_expr.expr &:= str(number);
        c_expr.expr &:= "]=malloc(sizeof(struct arraystruct) - sizeof(rtlObjecttype) +\n  ";
        c_expr.expr &:= str(length(array_list));
        c_expr.expr &:= " * sizeof(rtlObjecttype));\n";
        c_expr.expr &:= "arr[";
        c_expr.expr &:= str(number);
        c_expr.expr &:= "]->min_position=";
        c_expr.expr &:= str(array_min_index(const_object));
        c_expr.expr &:= ";\n";
        c_expr.expr &:= "arr[";
        c_expr.expr &:= str(number);
        c_expr.expr &:= "]->max_position=";
        c_expr.expr &:= str(pred(array_min_index(const_object) + length(array_list)));
        c_expr.expr &:= ";\n";
        for elem_num range 1 to length(array_list) do
          c_expr.expr &:= "arr[";
          c_expr.expr &:= str(number);
          c_expr.expr &:= "]->arr[";
          c_expr.expr &:= str(pred(elem_num));
          c_expr.expr &:= "]";
          init_const_value(array_list[elem_num], c_expr);
          c_expr.expr &:= ";\n";
        end for;
      elsif category(const_object) = STRUCTOBJECT then
        struct_list := struct_to_list(const_object);
        c_expr.expr &:= "sct[";
        c_expr.expr &:= str(number);
        c_expr.expr &:= "]=malloc(sizeof(struct structstruct) - sizeof(rtlObjecttype) +\n  ";
        c_expr.expr &:= str(length(struct_list));
        c_expr.expr &:= " * sizeof(rtlObjecttype));\n";
        c_expr.expr &:= "sct[";
        c_expr.expr &:= str(number);
        c_expr.expr &:= "]->type_num=";
        c_expr.expr &:= str(type_number(getType(const_object)));
        c_expr.expr &:= "/*";
        c_expr.expr &:= str(getType(const_object));
        c_expr.expr &:= "*/";
        c_expr.expr &:= ";\n";
        for elem_num range 1 to length(struct_list) do
          c_expr.expr &:= "sct[";
          c_expr.expr &:= str(number);
          c_expr.expr &:= "]->stru[";
          c_expr.expr &:= str(pred(elem_num));
          c_expr.expr &:= "]";
          init_const_value(struct_list[elem_num], c_expr);
          c_expr.expr &:= ";\n";
        end for;
      elsif category(const_object) = HASHOBJECT then
        hash_key_list := hash_key_to_list(const_object);
        hash_data_list := hash_data_to_list(const_object);
        c_expr.expr &:= "hsh[";
        c_expr.expr &:= str(number);
        c_expr.expr &:= "]=hshEmpty();\n";
        for elem_num range 1 to length(hash_key_list) do
          c_expr.expr &:= "hash_key";
          init_const_value(hash_key_list[elem_num], c_expr);
          c_expr.expr &:= ";\n";
          c_expr.expr &:= "hash_data";
          init_const_value(hash_data_list[elem_num], c_expr);
          c_expr.expr &:= ";\n";
          c_expr.expr &:= "hshIncl(hsh[";
          c_expr.expr &:= str(number);
          c_expr.expr &:= "], hash_key.value.genericvalue, hash_data.value.genericvalue, ";
          process_hashcode(hash_key_list[elem_num], c_expr);
          c_expr.expr &:= ", (comparetype)(";
          object_address(keyCompareObj(getType(const_object)), c_expr);
          c_expr.expr &:= "), (createfunctype)(";
          object_address(keyCreateObj(getType(const_object)), c_expr);
          c_expr.expr &:= "), (createfunctype)(";
          object_address(dataCreateObj(getType(const_object)), c_expr);
          c_expr.expr &:= "), (copyfunctype)(";
          object_address(dataCopyObj(getType(const_object)), c_expr);
          c_expr.expr &:= "));\n";
        end for;
      elsif category(const_object) = INTERFACEOBJECT then
        struct_of_interface := interface_to_struct(const_object);
        c_expr.expr &:= "itf[";
        c_expr.expr &:= str(number);
        c_expr.expr &:= "]";
        if category(struct_of_interface) = STRUCTOBJECT then
          c_expr.expr &:= "=";
          c_expr.expr &:= "sct[";
          c_expr.expr &:= str(const_table[struct_of_interface]);
          c_expr.expr &:= "]";
        else
          c_expr.expr &:= " /* = ";
          c_expr.expr &:= str(category(struct_of_interface));
          c_expr.expr &:= " */";
        end if;
        c_expr.expr &:= ";\n";
      else
        c_expr.expr &:= "/* const ";
        c_expr.expr &:= str(category(const_object));
        c_expr.expr &:= " [";
        c_expr.expr &:= str(number);
        c_expr.expr &:= "] */\n";
      end if;
    end for;
    c_expr.expr &:= "activate_signal_handlers();\n";
    c_expr.expr &:= global_init.temp_decls;
    c_expr.expr &:= global_init.temp_assigns;
    c_expr.expr &:= global_init.expr;
    write_call_of_main(prog, c_expr);
    c_expr.expr &:= global_init.temp_frees;
    c_expr.expr &:= "return 0;\n";
    c_expr.expr &:= "} else {\n";
    c_expr.expr &:= "  if (fail_value >= 0 && fail_value < sizeof(exception_name) / sizeof(char *)) {\n";
    c_expr.expr &:= "    printf(\"\\n*** Uncaught EXCEPTION %s raised\",\n";
    c_expr.expr &:= "        exception_name[fail_value]);\n";
    c_expr.expr &:= "  } else {\n";
    c_expr.expr &:= "    printf(\"\\n*** Uncaught EXCEPTION %d raised\\n\",\n";
    c_expr.expr &:= "        fail_value);\n";
    c_expr.expr &:= "  }\n";
    c_expr.expr &:= "  if (error_file != NULL) {\n";
    c_expr.expr &:= "    printf(\" at %s(%d)\", error_file, error_line);\n";
    c_expr.expr &:= "  }\n";
    c_expr.expr &:= "  printf(\"\\n\");\n";
    c_expr.expr &:= "  return 1;\n";
    c_expr.expr &:= "}\n";
    c_expr.expr &:= "}\n";
    write(c_prog, c_expr.expr);
    count_declarations;
  end func;


const proc: init_systypes (in program: prog) is func

  local
    var reference: type_ref is NIL;
    var reference: ref_to_empty is NIL;
  begin
    type_ref := sys_var(prog, "type");
    if type_ref <> NIL then
      typetype := getValue(type_ref, type);
    end if;
    type_ref := sys_var(prog, "proc");
    if type_ref <> NIL then
      proctype := getValue(type_ref, type);
    end if;
    type_ref := sys_var(prog, "integer");
    if type_ref <> NIL then
      inttype := getValue(type_ref, type);
    end if;
    type_ref := sys_var(prog, "bigInteger");
    if type_ref <> NIL then
      biginttype := getValue(type_ref, type);
    end if;
    type_ref := sys_var(prog, "char");
    if type_ref <> NIL then
      chartype := getValue(type_ref, type);
    end if;
    type_ref := sys_var(prog, "string");
    if type_ref <> NIL then
      stritype := getValue(type_ref, type);
    end if;
    type_ref := sys_var(prog, "float");
    if type_ref <> NIL then
      floattype := getValue(type_ref, type);
    end if;
    ref_to_empty := sys_var(prog, "empty");
    if ref_to_empty <> NIL then
      voidtype := getType(ref_to_empty);
    end if;
  end func;


const func string: temp_name (in string: source) is func
  result
    var string: result is "";
  begin
    if rpos(source, "/") = 0 then
      result := "tmp_" & source;
    else
      result := source[.. rpos(source, "/")] &
          "tmp_" & source[succ(rpos(source, "/")) ..];
    end if;
  end func;


const proc: pass_1 (in string: source, inout program: prog,
    inout boolean: okay) is func

  begin
    if source <> "" then
      writeln("Compiling the program ...");
      if "-r" in compiler_option then
        array_range_check := FALSE;
      end if;
      prog := parseFile(source);
      if prog = program.EMPTY then
        okay := FALSE;
      elsif error_count(prog) <> 0 then
        write(error_count(prog) <& " error");
        if error_count(prog) > 1 then
          write("s");
        end if;
        writeln(" found");
        okay := FALSE;
      end if;
    else
      okay := FALSE;
    end if;
  end func;


const proc: pass_2 (in string: source, in program: prog,
    inout boolean: okay) is func

  local
    var reference: main_object is NIL;
    var ref_list: declared_objects is ref_list.EMPTY;
    var reference: obj is NIL;
  begin
    if okay then
      main_object := sys_var(prog, "main");
      if main_object <> NIL then
        # The temporary tmp_*.c file is marked with a temp_marker.
        # The temp_marker is checked, before the file is overwritten.
        c_prog := open(temp_name(source) & ".c", "r");
        if c_prog <> STD_NULL then
          if getln(c_prog) <> temp_marker then
            write("*** The file ");
            write(literal(temp_name(source) & ".c"));
            writeln(" was not created by the compiler.");
            write("*** Remove the file ");
            write(literal(temp_name(source) & ".c"));
            writeln(" manually and restart the compiler.");
            okay := FALSE;
          end if;
          close(c_prog);
        end if;
        if okay then
          c_prog := open(temp_name(source) & ".c", "w");
          if c_prog <> STD_NULL then
            writeln("Generating code ...");
            init_systypes(prog);
            write_file_head;
            write_prototypes;
            write_signal_handlers;
            declared_objects := declared_objects(prog);
            for obj range declared_objects do
              process_object(obj);
            end for;
            generate_main(prog);
            close(c_prog);
            writeln;
            writeln(countOptimizations <& " optimizations done");
          else
            write("*** Cannot open temp file ");
            write(literal(temp_name(source) & ".c"));
            writeln(".");
            okay := FALSE;
          end if;
        end if;
      else
        writeln("*** main not found.");
        okay := FALSE;
      end if;
    end if;
  end func;


const proc: pass_3 (in string: source, in program: prog,
    inout boolean: okay) is func

  local
    const string: OBJECT_FILE_EXTENSION is     configValue("OBJECT_FILE_EXTENSION");
    const string: EXECUTABLE_FILE_EXTENSION is configValue("EXECUTABLE_FILE_EXTENSION");
    const string: C_COMPILER is                configValue("C_COMPILER");
    const string: INHIBIT_C_WARNINGS is        configValue("INHIBIT_C_WARNINGS");
    const string: REDIRECT_C_ERRORS is         configValue("REDIRECT_C_ERRORS");
    const string: LINKER_FLAGS is              configValue("LINKER_FLAGS");
    const string: SYSTEM_LIBS is               configValue("SYSTEM_LIBS");
    const string: SEED7_LIB is                 configValue("SEED7_LIB");
    const string: COMP_DATA_LIB is             configValue("COMP_DATA_LIB");
    const string: COMPILER_LIB is              configValue("COMPILER_LIB");
    var string: options is "";
    var string: compile_cmd is "";
    var string: link_cmd is "";
  begin
    if okay then
      writeln("Calling the C compiler ...");
      remove(temp_name(source) & OBJECT_FILE_EXTENSION);
      options := " " & INHIBIT_C_WARNINGS;
      if "-O" in compiler_option then
        options &:= " -O" & compiler_option["-O"];
      end if;
      if "-g" in compiler_option then
        options &:= " -g";
      end if;
      compile_cmd := C_COMPILER & options & " -c " &
          temp_name(source) & ".c " &
          REDIRECT_C_ERRORS &
          temp_name(source) & ".cerrs";
      writeln(compile_cmd);
      flush(OUT);
      cmd_sh(compile_cmd);
      if not fileExists(temp_name(source) & OBJECT_FILE_EXTENSION) then
        if fileType(temp_name(source) & ".cerrs") = FILE_REGULAR and
            fileSize(temp_name(source) & ".cerrs") <> 0 then
          writeln("*** Errors in " <& literal(temp_name(source) & ".c") <&
              " - see " <& literal(temp_name(source) & ".cerrs"));
        else
          writeln("*** Compilation terminated without error messages");
          remove(temp_name(source) & ".cerrs");
        end if;
      else
        remove(temp_name(source) & ".cerrs");
        remove(source & EXECUTABLE_FILE_EXTENSION);
        writeln("Calling the linker ...");
        link_cmd := C_COMPILER;
        if LINKER_FLAGS <> "" then
          link_cmd &:= " " & LINKER_FLAGS;
        end if;
        link_cmd &:= " -o " & source & EXECUTABLE_FILE_EXTENSION;
        link_cmd &:= " " & temp_name(source) & OBJECT_FILE_EXTENSION;
        if compilerLibraryUsed then
          link_cmd &:= " " & literal(COMPILER_LIB);
        end if;
        if compDataLibraryUsed then
          link_cmd &:= " " & literal(COMP_DATA_LIB);
        end if;
        link_cmd &:= " " & literal(SEED7_LIB);
        link_cmd &:= " " & SYSTEM_LIBS;
        link_cmd &:= " " & REDIRECT_C_ERRORS &
            temp_name(source) & ".lerrs";
        writeln(link_cmd);
        flush(OUT);
        cmd_sh(link_cmd);
        if not fileExists(source & EXECUTABLE_FILE_EXTENSION) then
          writeln("*** Linker errors with " <&
              literal(temp_name(source) & OBJECT_FILE_EXTENSION) <&
              " - see " <& literal(temp_name(source) & ".lerrs"));
        else
          remove(temp_name(source) & ".lerrs");
        end if;
        remove(temp_name(source) & OBJECT_FILE_EXTENSION);
      end if;
    end if;
  end func;


const proc: main is func

  local
    var integer: number is 0;
    var string: curr_arg is "";
    var string: source is "";
    var boolean: okay is TRUE;

  begin
    writeln("SEED7 COMPILER Version 2.0  Copyright (c) 1990-2009 Thomas Mertes");
    if length(argv(PROGRAM)) >= 1 then
      number := 1;
      while number <= length(argv(PROGRAM)) do
        curr_arg := argv(PROGRAM)[number];
        if length(curr_arg) >= 2 and curr_arg[1] = '-' then
          compiler_option @:= [curr_arg[.. 2]] curr_arg[3 ..];
        elsif source = "" then
          source := curr_arg;
        end if;
        incr(number);
      end while;
      write("Source: ");
      writeln(source);
    else
      write("Source? ");
      readln(source);
    end if;
    if lower(source[length(source) - 3 ..]) = ".sd7" then
      source := source[.. length(source) - 4];
    end if;
    pass_1(source, prog, okay);
    pass_2(source, prog, okay);
    pass_3(source, prog, okay);
  end func;
