
(********************************************************************)
(*                                                                  *)
(*  comp.sd7      Compiler from Seed7 to C                          *)
(*  Copyright (C) 1990 - 1994, 2004 - 2007  Thomas Mertes           *)
(*                                                                  *)
(*  This program is free software; you can redistribute it and/or   *)
(*  modify it under the terms of the GNU General Public License as  *)
(*  published by the Free Software Foundation; either version 2 of  *)
(*  the License, or (at your option) any later version.             *)
(*                                                                  *)
(*  This program is distributed in the hope that it will be useful, *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of  *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *)
(*  GNU General Public License for more details.                    *)
(*                                                                  *)
(*  You should have received a copy of the GNU General Public       *)
(*  License along with this program; if not, write to the           *)
(*  Free Software Foundation, Inc., 51 Franklin Street,             *)
(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)
(*                                                                  *)
(********************************************************************)


$ info off;
$ message "Compiling the compiler ...";
$ include "seed7_05.s7i";
  include "bigint.s7i";
  include "float.s7i";
  include "progs.s7i";

const string: temp_marker is "/* Seed7 compiler temp file */";

const type: option_hash is hash [string] string;

var option_hash: compiler_option is option_hash.value;

var boolean: array_range_check is TRUE;

var program: prog is program.EMPTY;
var file: c_prog is STD_NULL;
var type: typetype is void;
var type: proctype is void;
var type: inttype is void;
var type: biginttype is void;
var type: chartype is void;
var type: stritype is void;
var type: floattype is void;
var type: voidtype is void;
var type: wintype is void;

var ref_list: declared_types is ref_list.EMPTY;

const type: expr_type is new struct
  var integer: temp_num is 0;
  var string: temp_decls is "";
  var string: temp_assigns is "";
  var string: expr is "";
  var string: temp_frees is "";
  var string: result_decl is "";
  var string: result_free is "";
  var string: result_intro is "";
  var string: result_expr is "";
  var string: result_finish is "";
end struct;

var expr_type: global_c_expr is expr_type.value;

var integer: declaration_count is 1;
var array ref_list: object_value is 0 times ref_list.EMPTY;
var expr_type: global_init is expr_type.value;

const type: bigint_table_hash is hash [bigInteger] integer;
const type: bigint_index_hash is hash [integer] array bigInteger;

var bigint_table_hash: bigint_const_table is bigint_table_hash.EMPTY_HASH;

const type: stri_table_hash is hash [string] integer;
const type: stri_index_hash is hash [integer] array string;

var stri_table_hash: stri_const_table is stri_table_hash.EMPTY_HASH;

const type: set_table_hash is hash [bitset] integer;
const type: set_index_hash is hash [integer] array bitset;

var set_table_hash: set_const_table is set_table_hash.EMPTY_HASH;

const type: const_table_hash is hash [reference] integer;
const type: const_index_hash is hash [integer] array reference;

var const_table_hash: const_table is const_table_hash.EMPTY_HASH;

const type: type_hash is hash [type] type;
const type: element_number_hash is hash [reference] integer;
const type: number_element_hash is hash [integer] array reference;
const type: element_type_hash is hash [reference] type;
const type: struct_elements_hash is hash [type] element_number_hash;
const type: struct_element_type_hash is hash [type] element_type_hash;
const type: boolean_type_hash is hash [type] boolean;
const type: boolean_obj_hash is hash [reference] boolean;
const type: implements_hash is hash [type] array type;
const type: interface_hash is hash [type] array type;
const type: enum_literal_hash is hash [type] element_number_hash;

var type_hash: array_element is type_hash.EMPTY_HASH;
var type_hash: array_type is type_hash.EMPTY_HASH;
var struct_elements_hash: struct_elements is struct_elements_hash.EMPTY_HASH;
var struct_element_type_hash: struct_element_type is struct_element_type_hash.EMPTY_HASH;
var boolean_type_hash: create_declared is boolean_type_hash.EMPTY_HASH;
var boolean_type_hash: destr_declared is boolean_type_hash.EMPTY_HASH;
var boolean_type_hash: cpy_declared is boolean_type_hash.EMPTY_HASH;
var boolean_type_hash: simple_pod_type is boolean_type_hash.EMPTY_HASH;
var boolean_obj_hash: function_declared is boolean_obj_hash.EMPTY_HASH;
var ref_list: dynamic_functions is ref_list.EMPTY;
var implements_hash: implements is implements_hash.EMPTY_HASH;
var interface_hash: interfaceOfType is interface_hash.EMPTY_HASH;
var boolean_type_hash: isInterfaceType is boolean_type_hash.EMPTY_HASH;
var boolean_type_hash: isHashType is boolean_type_hash.EMPTY_HASH;
var enum_literal_hash: enum_literal is enum_literal_hash.EMPTY_HASH;
var boolean_type_hash: set_types is boolean_type_hash.EMPTY_HASH;
var boolean_type_hash: bstri_types is boolean_type_hash.EMPTY_HASH;

var boolean: write_object_declaration is TRUE;


const proc: process_action (in reference: procedure, in ref_list: params,
    inout expr_type: c_expr) is forward;
const proc: process_expr (in reference: current_expression, inout expr_type: c_expr) is forward;


const proc: count_declarations is func

  begin
    incr(declaration_count);
    OUT << declaration_count;
    OUT << " ";
    OUT << heapsize(PROGRAM);
    OUT << "     \r";
    flush(OUT);
  end func;


const proc: create_name (in reference: current_object, inout string: expr) is func

  begin
    expr &:= str(obj_number(current_object));
    expr &:= "/*";
    expr &:= str(current_object);
    expr &:= "*/";
  end func;


const func string: type_name (in type: object_type) is func

  result
    var string: result is "";
  begin
    if object_type = typetype then
      result := "typetype";
    elsif object_type = inttype then
      result := "inttype";
    elsif object_type = biginttype then
      result := "biginttype";
    elsif object_type = chartype then
      result := "chartype";
    elsif object_type = stritype then
      result := "stritype";
    elsif object_type = floattype then
      result := "floattype";
    else
      result := "t_";
      result &:= str(type_number(object_type));
      result &:= "/*";
      result &:= str(object_type);
      result &:= "*/";
    end if;
  end func;


const func type: getExprResultType (in reference: type_ref) is func
  result
    var type: result is void;
  begin
    result := getType(type_ref);
    while is_func(result) or is_varfunc(result) do
      result := result_type(result);
    end while;
  end func;


const proc: process_create_declaration (in type: object_type,
    inout expr_type: c_expr) is forward;


const proc: process_create_call (in type: object_type,
    in string: param_b, inout string: expr) is forward;


const proc: process_arr_create_declaration (in type: object_type,
    inout expr_type: c_expr) is func

  local
    var integer: number is 0;
    var reference: struct_elem is NIL;
  begin
    process_create_declaration(array_element[object_type], c_expr);
    c_expr.expr &:= "static ";
    c_expr.expr &:= type_name(object_type);
    c_expr.expr &:= " create_";
    c_expr.expr &:= str(type_number(object_type));
    c_expr.expr &:= " (";
    c_expr.expr &:= type_name(object_type);
    c_expr.expr &:= " b)\n";
    c_expr.expr &:= "{\n";
    c_expr.expr &:= type_name(object_type);
    c_expr.expr &:= " a;\n";
    c_expr.expr &:= "unsigned long i;\n";
    c_expr.expr &:= "unsigned long size = ((arraytype)b)->max_position - ((arraytype)b)->min_position + 1;\n";
    c_expr.expr &:= "a=malloc(sizeof(struct arraystruct) - sizeof(long) + size * sizeof(long));\n";
    c_expr.expr &:= "((arraytype)a)->min_position = ((arraytype)b)->min_position;\n";
    c_expr.expr &:= "((arraytype)a)->max_position = ((arraytype)b)->max_position;\n";
    c_expr.expr &:= "for (i = 0; i < size; i++) {\n";
    c_expr.expr &:= "((arraytype)a)->arr[i].value.intvalue=";
    process_create_call(array_element[object_type],
        "((arraytype)b)->arr[i].value.intvalue", c_expr.expr);
    c_expr.expr &:= ";\n";
    c_expr.expr &:= "}\n";
    c_expr.expr &:= "return(a);\n";
    c_expr.expr &:= "}\n\n";
    create_declared @:= [object_type] TRUE;
  end func;


const proc: process_sct_create_declaration (in type: object_type,
    inout expr_type: c_expr) is func

  local
    var number_element_hash: elements is number_element_hash.EMPTY_HASH;
    var integer: number is 0;
    var reference: struct_elem is NIL;
  begin
    elements := flip(struct_elements[object_type]);
    for number range 0 to pred(length(elements)) do
      struct_elem := elements[number][1];
      process_create_declaration(struct_element_type[object_type][struct_elem], c_expr);
    end for;
    c_expr.expr &:= "static ";
    c_expr.expr &:= type_name(object_type);
    c_expr.expr &:= " create_";
    c_expr.expr &:= str(type_number(object_type));
    c_expr.expr &:= " (";
    c_expr.expr &:= type_name(object_type);
    c_expr.expr &:= " b)\n";
    c_expr.expr &:= "{\n";
    c_expr.expr &:= type_name(object_type);
    c_expr.expr &:= " a;\n";
    c_expr.expr &:= "a=malloc(sizeof(struct structstruct) - sizeof(long) + ";
    c_expr.expr &:= str(length(elements));
    c_expr.expr &:= " * sizeof(long));\n";
    c_expr.expr &:= "((structtype)a)->type_num = ((structtype)b)->type_num;\n";
    for number range 0 to pred(length(elements)) do
      struct_elem := elements[number][1];
      c_expr.expr &:= "((structtype)a)->stru[" & str(number) & "].value.intvalue=";
      process_create_call(struct_element_type[object_type][struct_elem],
          "((structtype)b)->stru[" & str(number) & "].value.intvalue", c_expr.expr);
      c_expr.expr &:= ";\n";
    end for;
    c_expr.expr &:= "return(a);\n";
    c_expr.expr &:= "}\n\n";
    create_declared @:= [object_type] TRUE;
  end func;


const proc: process_create_declaration (in type: object_type,
    inout expr_type: c_expr) is func

  begin
    if object_type not in create_declared then
      if object_type in array_element then
        process_arr_create_declaration(object_type, c_expr);
      elsif object_type in struct_elements then
        process_sct_create_declaration(object_type, c_expr);
      elsif object_type = inttype or
          object_type = biginttype or
          object_type = chartype or
          object_type = stritype or
          object_type = floattype or
          object_type = wintype or
          object_type in set_types or
          object_type in bstri_types or
          object_type in simple_pod_type then
        create_declared @:= [object_type] TRUE;
      else
        c_expr.expr &:= "/* create_";
        c_expr.expr &:= str(type_number(object_type));
        c_expr.expr &:= " declaration for type t_";
        c_expr.expr &:= str(type_number(object_type));
        c_expr.expr &:= "**";
        c_expr.expr &:= str(object_type);
        c_expr.expr &:= "*/\n\n";
      end if;
    end if;
  end func;


const proc: process_create_call (in type: object_type,
    in string: param_b, inout string: expr) is func

  begin
    if object_type = inttype then
      expr &:= param_b;
    elsif object_type = biginttype then
      expr &:= "bigCreate(" & param_b & ")";
    elsif object_type = chartype then
      expr &:= param_b;
    elsif object_type = stritype then
      expr &:= "strCreate(" & param_b & ")";
    elsif object_type in bstri_types then
      expr &:= "bstCreate(" & param_b & ")";
    elsif object_type = floattype then
      expr &:= param_b;
    elsif object_type = wintype then
      expr &:= "drwCreate(" & param_b & ")";
    elsif object_type in set_types then
      expr &:= "setCreate(" & param_b & ")";
    elsif object_type in simple_pod_type then
      expr &:= param_b;
    elsif object_type in array_element then
      expr &:= "create_";
      expr &:= str(type_number(object_type));
      expr &:= "(";
      expr &:= param_b;
      expr &:= ")";
    elsif object_type in struct_elements then
      expr &:= "create_";
      expr &:= str(type_number(object_type));
      expr &:= "(";
      expr &:= param_b;
      expr &:= ")";
    elsif object_type in isInterfaceType then
      expr &:= param_b;
    else
      expr &:= param_b & " /* create_";
      expr &:= str(type_number(object_type));
      expr &:= " for type t_";
      expr &:= str(type_number(object_type));
      expr &:= "**";
      expr &:= str(object_type);
      expr &:= "*/";
    end if;
  end func;


const proc: process_destr_declaration (in type: object_type,
    inout expr_type: c_expr) is forward;


const proc: process_destr_call (in type: object_type,
    in string: param_b, inout string: expr) is forward;


const proc: process_arr_destr_declaration (in type: object_type,
    inout expr_type: c_expr) is func

  local
    var integer: number is 0;
    var reference: struct_elem is NIL;
  begin
    process_destr_declaration(array_element[object_type], c_expr);
    c_expr.expr &:= "static void destr_";
    c_expr.expr &:= str(type_number(object_type));
    c_expr.expr &:= " (";
    c_expr.expr &:= type_name(object_type);
    c_expr.expr &:= " b)\n";
    c_expr.expr &:= "{\n";
    c_expr.expr &:= "unsigned long i;\n";
    c_expr.expr &:= "unsigned long size;\n";
    c_expr.expr &:= "if (b != NULL) {\n";
    c_expr.expr &:= "size = ((arraytype)b)->max_position - ((arraytype)b)->min_position + 1;\n";
    c_expr.expr &:= "for (i = 0; i < size; i++) {\n";
    process_destr_call(array_element[object_type],
        "((arraytype)b)->arr[i].value.intvalue", c_expr.expr);
    c_expr.expr &:= "}\n";
    c_expr.expr &:= "free(b);\n";
    c_expr.expr &:= "}\n";
    c_expr.expr &:= "}\n\n";
    destr_declared @:= [object_type] TRUE;
  end func;


const proc: process_sct_destr_declaration (in type: object_type,
    inout expr_type: c_expr) is func

  local
    var number_element_hash: elements is number_element_hash.EMPTY_HASH;
    var integer: number is 0;
    var reference: struct_elem is NIL;
  begin
    elements := flip(struct_elements[object_type]);
    for number range 0 to pred(length(elements)) do
      struct_elem := elements[number][1];
      process_destr_declaration(struct_element_type[object_type][struct_elem], c_expr);
    end for;
    c_expr.expr &:= "static void destr_";
    c_expr.expr &:= str(type_number(object_type));
    c_expr.expr &:= " (";
    c_expr.expr &:= type_name(object_type);
    c_expr.expr &:= " b)\n";
    c_expr.expr &:= "{\n";
    c_expr.expr &:= "if (b != NULL) {\n";
    for number range 0 to pred(length(elements)) do
      struct_elem := elements[number][1];
      process_destr_call(struct_element_type[object_type][struct_elem],
          "((structtype)b)->stru[" & str(number) & "].value.intvalue", c_expr.expr);
    end for;
    c_expr.expr &:= "free(b);\n";
    c_expr.expr &:= "}\n";
    c_expr.expr &:= "}\n\n";
    destr_declared @:= [object_type] TRUE;
  end func;


const proc: process_destr_declaration (in type: object_type,
    inout expr_type: c_expr) is func

  begin
    if object_type not in destr_declared then
      if object_type in array_element then
        process_arr_destr_declaration(object_type, c_expr);
      elsif object_type in struct_elements then
        process_sct_destr_declaration(object_type, c_expr);
      elsif object_type = inttype or
          object_type = biginttype or
          object_type = chartype or
          object_type = stritype or
          object_type = floattype or
          object_type = wintype or
          object_type in set_types or
          object_type in bstri_types or
          object_type in simple_pod_type then
        destr_declared @:= [object_type] TRUE;
      else
        c_expr.expr &:= "/* destr_";
        c_expr.expr &:= str(type_number(object_type));
        c_expr.expr &:= " declaration for type t_";
        c_expr.expr &:= str(type_number(object_type));
        c_expr.expr &:= "**";
        c_expr.expr &:= str(object_type);
        c_expr.expr &:= "*/\n\n";
      end if;
    end if;
  end func;


const proc: process_destr_call (in type: object_type,
    in string: param_b, inout string: expr) is func

  begin
    if object_type = inttype then
      noop;
    elsif object_type = biginttype then
      expr &:= "bigDestr(" & param_b & ");\n";
    elsif object_type = chartype then
      noop;
    elsif object_type = stritype then
      expr &:= "strDestr(" & param_b & ");\n";
    elsif object_type in bstri_types then
      expr &:= "bstDestr(" & param_b & ");\n";
    elsif object_type = floattype then
      noop;
    elsif object_type = wintype then
      expr &:= "drwDestr(" & param_b & ");\n";
    elsif object_type in set_types then
      expr &:= "setDestr(" & param_b & ");\n";
    elsif object_type in simple_pod_type then
      noop;
    elsif object_type in array_element then
      expr &:= "destr_";
      expr &:= str(type_number(object_type));
      expr &:= "(";
      expr &:= param_b;
      expr &:= ");\n";
    elsif object_type in struct_elements then
      expr &:= "destr_";
      expr &:= str(type_number(object_type));
      expr &:= "(";
      expr &:= param_b;
      expr &:= ");\n";
    elsif object_type in isInterfaceType then
      noop;
    else
      expr &:= param_b & " /* destr_";
      expr &:= str(type_number(object_type));
      expr &:= " for type t_";
      expr &:= str(type_number(object_type));
      expr &:= "**";
      expr &:= str(object_type);
      expr &:= "*/;\n";
    end if;
  end func;


const proc: process_cpy_declaration (in type: object_type,
    inout expr_type: c_expr) is forward;


const proc: process_cpy_call (in type: object_type,
    in string: param_a, in string: param_b, inout string: expr) is forward;


const proc: process_arr_cpy_declaration (in type: object_type,
    inout expr_type: c_expr) is func

  local
    var integer: number is 0;
    var reference: struct_elem is NIL;
  begin
    process_create_declaration(array_element[object_type], c_expr);
    process_destr_declaration(array_element[object_type], c_expr);
    process_cpy_declaration(array_element[object_type], c_expr);
    c_expr.expr &:= "static void cpy_";
    c_expr.expr &:= str(type_number(object_type));
    c_expr.expr &:= " (";
    c_expr.expr &:= type_name(object_type);
    c_expr.expr &:= " *a, ";
    c_expr.expr &:= type_name(object_type);
    c_expr.expr &:= " b)\n";
    c_expr.expr &:= "{\n";
    c_expr.expr &:= "unsigned long i;\n";
    c_expr.expr &:= "unsigned long size_a = ((arraytype)*a)->max_position - ((arraytype)*a)->min_position + 1;\n";
    c_expr.expr &:= "unsigned long size_b = ((arraytype)b)->max_position - ((arraytype)b)->min_position + 1;\n";
    c_expr.expr &:= "unsigned long size;\n";
    c_expr.expr &:= "((arraytype)*a)->min_position = ((arraytype)b)->min_position;\n";
    c_expr.expr &:= "((arraytype)*a)->max_position = ((arraytype)b)->max_position;\n";
    c_expr.expr &:= "if (size_a == size_b) {\n";
    c_expr.expr &:= "size = size_a;\n";
    c_expr.expr &:= "} else {\n";
    c_expr.expr &:= "if (size_a < size_b) {\n";
    c_expr.expr &:= "*a=realloc(*a, sizeof(struct arraystruct) - sizeof(long) + size_b * sizeof(long));\n";
    c_expr.expr &:= "size = size_a;\n";
    c_expr.expr &:= "for (i = size_a; i < size_b; i++) {\n";
    c_expr.expr &:= "((arraytype)*a)->arr[i].value.intvalue=";
    process_create_call(array_element[object_type],
        "((arraytype)b)->arr[i].value.intvalue", c_expr.expr);
    c_expr.expr &:= ";\n";
    c_expr.expr &:= "}\n";
    c_expr.expr &:= "} else /* size_a > size_b */ {\n";
    c_expr.expr &:= "size = size_b;\n";
    c_expr.expr &:= "for (i = size_b; i < size_a; i++) {\n";
    process_destr_call(array_element[object_type],
        "((arraytype)*a)->arr[i].value.intvalue", c_expr.expr);
    c_expr.expr &:= "}\n";
    c_expr.expr &:= "*a=realloc(*a, sizeof(struct arraystruct) - sizeof(long) + size_b * sizeof(long));\n";
    c_expr.expr &:= "}\n";
    c_expr.expr &:= "}\n";
    c_expr.expr &:= "for (i = 0; i < size; i++) {\n";
    process_cpy_call(array_element[object_type],
        "((arraytype)*a)->arr[i].value.intvalue", "((arraytype)b)->arr[i].value.intvalue", c_expr.expr);
    c_expr.expr &:= ";\n";
    c_expr.expr &:= "}\n";
    c_expr.expr &:= "}\n\n";
    cpy_declared @:= [object_type] TRUE;
  end func;


const proc: process_sct_cpy_declaration (in type: object_type,
    inout expr_type: c_expr) is func

  local
    var number_element_hash: elements is number_element_hash.EMPTY_HASH;
    var integer: number is 0;
    var reference: struct_elem is NIL;
  begin
    elements := flip(struct_elements[object_type]);
    for number range 0 to pred(length(elements)) do
      struct_elem := elements[number][1];
      process_cpy_declaration(struct_element_type[object_type][struct_elem], c_expr);
    end for;
    c_expr.expr &:= "static void cpy_";
    c_expr.expr &:= str(type_number(object_type));
    c_expr.expr &:= " (";
    c_expr.expr &:= type_name(object_type);
    c_expr.expr &:= " a, ";
    c_expr.expr &:= type_name(object_type);
    c_expr.expr &:= " b)\n";
    c_expr.expr &:= "{\n";
    c_expr.expr &:= "((structtype)a)->type_num = ((structtype)b)->type_num;\n";
    for number range 0 to pred(length(elements)) do
      struct_elem := elements[number][1];
      process_cpy_call(struct_element_type[object_type][struct_elem],
          "((structtype)a)->stru[" & str(number) & "].value.intvalue",
          "((structtype)b)->stru[" & str(number) & "].value.intvalue", c_expr.expr);
      c_expr.expr &:= ";\n";
    end for;
    c_expr.expr &:= "}\n\n";
    cpy_declared @:= [object_type] TRUE;
  end func;


const proc: process_cpy_declaration (in type: object_type,
    inout expr_type: c_expr) is func

  begin
    if object_type not in cpy_declared then
      if object_type in array_element then
        process_arr_cpy_declaration(object_type, c_expr);
      elsif object_type in struct_elements then
        process_sct_cpy_declaration(object_type, c_expr);
      elsif object_type = inttype or
          object_type = biginttype or
          object_type = chartype or
          object_type = stritype or
          object_type = floattype or
          object_type = wintype or
          object_type in set_types or
          object_type in bstri_types or
          object_type in simple_pod_type then
        cpy_declared @:= [object_type] TRUE;
      else
        c_expr.expr &:= "/* cpy_";
        c_expr.expr &:= str(type_number(object_type));
        c_expr.expr &:= " declaration for type t_";
        c_expr.expr &:= str(type_number(object_type));
        c_expr.expr &:= "**";
        c_expr.expr &:= str(object_type);
        c_expr.expr &:= "*/\n\n";
      end if;
    end if;
  end func;


const proc: process_cpy_call (in type: object_type,
    in string: param_a, in string: param_b, inout string: expr) is func

  begin
    if object_type = inttype then
      expr &:= param_a & "=" & param_b;
    elsif object_type = biginttype then
      expr &:= "bigCpy(&(" & param_a & "), " & param_b & ")";
    elsif object_type = chartype then
      expr &:= param_a & "=" & param_b;
    elsif object_type = stritype then
      expr &:= "strCopy(&(" & param_a & "), " & param_b & ")";
    elsif object_type in bstri_types then
      expr &:= "bstCpy(&(" & param_a & "), " & param_b & ")";
    elsif object_type = floattype then
      # expr &:= param_a & "=(" & param_b & ")";
      # expr &:= "*((float *) &(" & param_a & "))=(" & param_b & ")";
      expr &:= "memcpy(&(";
      expr &:= param_a;
      expr &:= "), &(";
      expr &:= param_b;
      expr &:= "), sizeof(float))"; # Assuming that sizeof(float) == sizeof(long)
    elsif object_type = wintype then
      expr &:= "drwCpy(&(" & param_a & "), " & param_b & ")";
    elsif object_type in set_types then
      expr &:= "setCpy(&(" & param_a & "), " & param_b & ")";
    elsif object_type in simple_pod_type then
      expr &:= param_a & "=" & param_b;
    elsif object_type in array_element then
      expr &:= "cpy_";
      expr &:= str(type_number(object_type));
      expr &:= "(&(";
      expr &:= param_a;
      expr &:= "), ";
      expr &:= param_b;
      expr &:= ")";
    elsif object_type in struct_elements then
      expr &:= "cpy_";
      expr &:= str(type_number(object_type));
      expr &:= "(";
      expr &:= param_a;
      expr &:= ", ";
      expr &:= param_b;
      expr &:= ")";
    elsif object_type in isInterfaceType then
      expr &:= param_a & "=" & param_b;
    else
      expr &:= param_b & " /* cpy_";
      expr &:= str(type_number(object_type));
      expr &:= " for type t_";
      expr &:= str(type_number(object_type));
      expr &:= "**";
      expr &:= str(object_type);
      expr &:= "*/";
    end if;
  end func;


const func boolean: has_temp_values (in expr_type: c_expr) is
  return c_expr.temp_num >= 2 or
      (c_expr.temp_num = 1 and c_expr.result_expr = "");


const proc: prepare_array_result (in type: array_type, inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.result_decl := "arraytype tmp_";
    c_expr.result_decl &:= str(c_expr.temp_num);
    c_expr.result_decl &:= " = NULL;\n";
    process_destr_declaration(array_type, global_c_expr);
    process_destr_call(array_type, "tmp_" & str(c_expr.temp_num), c_expr.result_free);
    c_expr.result_intro := "(tmp_";
    c_expr.result_intro &:= str(c_expr.temp_num);
    c_expr.result_intro &:= "=";
    c_expr.result_finish := ")";
  end func;


const proc: prepare_bigint_result (inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.result_decl := "biginttype tmp_";
    c_expr.result_decl &:= str(c_expr.temp_num);
    c_expr.result_decl &:= " = NULL;\n";
    c_expr.result_free := "bigDestr(tmp_";
    c_expr.result_free &:= str(c_expr.temp_num);
    c_expr.result_free &:= ");\n";
    c_expr.result_intro := "(tmp_";
    c_expr.result_intro &:= str(c_expr.temp_num);
    c_expr.result_intro &:= "=";
    c_expr.result_finish := ")";
  end func;


const proc: prepare_list_result (inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.result_decl := "listtype tmp_";
    c_expr.result_decl &:= str(c_expr.temp_num);
    c_expr.result_decl &:= " = NULL;\n";
    c_expr.result_free := "rflDestr(tmp_";
    c_expr.result_free &:= str(c_expr.temp_num);
    c_expr.result_free &:= ");\n";
    c_expr.result_intro := "(tmp_";
    c_expr.result_intro &:= str(c_expr.temp_num);
    c_expr.result_intro &:= "=";
    c_expr.result_finish := ")";
  end func;


const proc: prepare_set_result (inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.result_decl := "settype tmp_";
    c_expr.result_decl &:= str(c_expr.temp_num);
    c_expr.result_decl &:= " = NULL;\n";
    c_expr.result_free := "setDestr(tmp_";
    c_expr.result_free &:= str(c_expr.temp_num);
    c_expr.result_free &:= ");\n";
    c_expr.result_intro := "(tmp_";
    c_expr.result_intro &:= str(c_expr.temp_num);
    c_expr.result_intro &:= "=";
    c_expr.result_finish := ")";
  end func;


const proc: prepare_stri_result (inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.result_decl := "stritype tmp_";
    c_expr.result_decl &:= str(c_expr.temp_num);
    c_expr.result_decl &:= " = NULL;\n";
    c_expr.result_free := "strDestr(tmp_";
    c_expr.result_free &:= str(c_expr.temp_num);
    c_expr.result_free &:= ");\n";
    c_expr.result_intro := "(tmp_";
    c_expr.result_intro &:= str(c_expr.temp_num);
    c_expr.result_intro &:= "=";
    c_expr.result_finish := ")";
  end func;


const proc: prepare_bstri_result (inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.result_decl := "bstritype tmp_";
    c_expr.result_decl &:= str(c_expr.temp_num);
    c_expr.result_decl &:= " = NULL;\n";
    c_expr.result_free := "bstDestr(tmp_";
    c_expr.result_free &:= str(c_expr.temp_num);
    c_expr.result_free &:= ");\n";
    c_expr.result_intro := "(tmp_";
    c_expr.result_intro &:= str(c_expr.temp_num);
    c_expr.result_intro &:= "=";
    c_expr.result_finish := ")";
  end func;


const proc: prepare_struct_result (in type: struct_type, inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.result_decl := "structtype tmp_";
    c_expr.result_decl &:= str(c_expr.temp_num);
    c_expr.result_decl &:= " = NULL;\n";
    process_destr_declaration(struct_type, global_c_expr);
    process_destr_call(struct_type, "tmp_" & str(c_expr.temp_num), c_expr.result_free);
    c_expr.result_intro := "(tmp_";
    c_expr.result_intro &:= str(c_expr.temp_num);
    c_expr.result_intro &:= "=";
    c_expr.result_finish := ")";
  end func;


const proc: prepare_win_result (inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.result_decl := "wintype tmp_";
    c_expr.result_decl &:= str(c_expr.temp_num);
    c_expr.result_decl &:= " = NULL;\n";
    c_expr.result_free := "winDestr(tmp_";
    c_expr.result_free &:= str(c_expr.temp_num);
    c_expr.result_free &:= ");\n";
    c_expr.result_intro := "(tmp_";
    c_expr.result_intro &:= str(c_expr.temp_num);
    c_expr.result_intro &:= "=";
    c_expr.result_finish := ")";
  end func;


const proc: prepare_typed_result (in type: aType, inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.result_decl := "long tmp_";
    c_expr.result_decl &:= str(c_expr.temp_num);
    c_expr.result_decl &:= " = NULL;\n";
    process_destr_declaration(aType, global_c_expr);
    process_destr_call(aType, "tmp_" & str(c_expr.temp_num), c_expr.result_free);
    c_expr.result_intro := "(tmp_";
    c_expr.result_intro &:= str(c_expr.temp_num);
    c_expr.result_intro &:= "=";
    c_expr.result_finish := ")";
  end func;


const proc: get_result_arg (in reference: current_expression, inout expr_type: c_expr) is func

  local
    var expr_type: c_param is expr_type.value;
  begin
    c_param.temp_num := c_expr.temp_num;
    process_expr(current_expression, c_param);
    c_expr.temp_num := c_param.temp_num;
    c_expr.temp_decls &:= c_param.temp_decls;
    c_expr.temp_decls &:= c_param.result_decl;
    c_expr.temp_assigns &:= c_param.temp_assigns;
    c_expr.temp_frees &:= c_param.temp_frees;
    c_expr.temp_frees &:= c_param.result_free;
    if c_param.result_expr <> "" then
      c_expr.result_expr &:= c_param.result_intro;
      c_expr.result_expr &:= c_param.result_expr;
      c_expr.result_expr &:= c_param.result_finish;
    else
      c_expr.result_expr &:= c_param.expr;
    end if;
  end func;


const proc: get_std_arg (in reference: current_expression, inout expr_type: c_expr) is func

  local
    var expr_type: c_param is expr_type.value;
  begin
    c_param.temp_num := c_expr.temp_num;
    process_expr(current_expression, c_param);
    c_expr.temp_num := c_param.temp_num;
    c_expr.temp_decls &:= c_param.temp_decls;
    c_expr.temp_assigns &:= c_param.temp_assigns;
    c_expr.temp_frees &:= c_param.temp_frees;
    c_expr.result_expr &:= c_param.expr;
  end func;


const proc: process_arg (in reference: current_expression, inout expr_type: c_expr) is func

  local
    var expr_type: c_param is expr_type.value;
  begin
    c_param.temp_num := c_expr.temp_num;
    process_expr(current_expression, c_param);
    c_expr.temp_num := c_param.temp_num;
    c_expr.temp_decls &:= c_param.temp_decls;
    c_expr.temp_decls &:= c_param.result_decl;
    c_expr.temp_assigns &:= c_param.temp_assigns;
    c_expr.temp_frees &:= c_param.temp_frees;
    c_expr.temp_frees &:= c_param.result_free;
    if c_param.result_expr <> "" then
      c_expr.expr &:= c_param.result_intro;
      c_expr.expr &:= c_param.result_expr;
      c_expr.expr &:= c_param.result_finish;
    else
      c_expr.expr &:= c_param.expr;
    end if;
  end func;


const proc: process_cast_from_float_expr (in reference: current_expression,
    inout expr_type: c_expr) is func

  local
    var integer: temp_num is 0;
  begin
    if getExprResultType(current_expression) = floattype then
      incr(c_expr.temp_num);
      temp_num := c_expr.temp_num;
      c_expr.temp_decls &:= "float2int tmp_";
      c_expr.temp_decls &:= str(temp_num);
      c_expr.temp_decls &:= ";\n";
      c_expr.expr &:= "(tmp_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= ".floatvalue=(";
      process_expr(current_expression, c_expr);
      c_expr.expr &:= "),tmp_";
      c_expr.expr &:= str(temp_num);
      c_expr.expr &:= ".intvalue)";
    else
      process_expr(current_expression, c_expr);
    end if;
  end func;


const proc: get_create_call_arg (in reference: current_expression, inout expr_type: c_expr) is func

  local
    var expr_type: c_param is expr_type.value;
  begin
    c_param.temp_num := c_expr.temp_num;
    process_cast_from_float_expr(current_expression, c_param);
    c_expr.temp_num := c_param.temp_num;
    c_expr.temp_decls &:= c_param.temp_decls;
    c_expr.temp_assigns &:= c_param.temp_assigns;
    c_expr.temp_frees &:= c_param.temp_frees;
    if c_param.result_expr <> "" then
      c_expr.result_expr &:= c_param.result_expr;
    else
      process_create_declaration(getType(current_expression), global_c_expr);
      process_create_call(getType(current_expression), c_param.expr, c_expr.result_expr);
    end if;
  end func;


const func string: enum_value (in reference: current_object) is func

  result
    var string: result is "";
  local
    var string: object_name is "";
    var type: enum_type is void;
  begin
    object_name := str(current_object);
    if object_name = "FALSE" then
      result := "0/*FALSE*/";
    elsif object_name = "TRUE" then
      result := "1/*TRUE*/";
    else
      result := "/*" & str(current_object) & "*/";
      enum_type := getType(current_object);
      if enum_type in enum_literal and
          current_object in enum_literal[enum_type] then
        result &:= str(enum_literal[enum_type][current_object]);
      else
        result &:= str(obj_number(current_object));
      end if;
    end if;
  end func;


const proc: reference_value (in reference: current_value,
    inout expr_type: c_expr) is func

  begin
    if current_value = NIL then
      c_expr.expr &:= "NULL";
    else
      c_expr.expr &:= "&(";
      process_expr(current_value, c_expr);
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: ref_list_value (in ref_list: current_value,
    inout expr_type: c_expr) is func

  local
    var reference: element is NIL;
    var boolean: first_element is TRUE;
  begin
    if length(current_value) = 0 then
      c_expr.expr &:= "NULL";
    else
      c_expr.expr &:= "{";
      for element range current_value do
        if first_element then
          first_element := FALSE;
        else
          c_expr.expr &:= ", ";
        end if;
        c_expr.expr &:= "&(";
        process_expr(element, c_expr);
        c_expr.expr &:= ")";
      end for;
      c_expr.expr &:= "}";
    end if;
  end func;


const proc: declare_type_if_necessary (in type: aType, inout expr_type: c_expr) is func

  local
    var reference: type_obj is NIL;
(*
    var reference: expression is NIL;
    var reference: type_value is NIL;
    var string: category is "";
*)
  begin
    type_obj := match_obj(aType);
    if not type_obj in declared_types then
      if aType <> typetype and
          aType <> inttype and
          aType <> biginttype and
          aType <> chartype and
          aType <> stritype and
          aType <> floattype then
(*
        expression := NIL;
        type_value := evaluate(prog, expression);
        category := category(case_labels);
        if category = "STRUCTOBJECT" then
          noop;
        else
*)
          c_expr.expr &:= "typedef long ";
          c_expr.expr &:= type_name(aType);
          c_expr.expr &:= ";\n\n";
(*
        end if;
*)
        incl(declared_types, type_obj);
      end if;
    end if;
  end func;


const proc: process_statements (in expr_type: statements, inout expr_type: c_expr) is func

  begin
    if statements.temp_num <> 0 then
      c_expr.expr &:= statements.temp_decls;
      c_expr.expr &:= statements.temp_assigns;
      c_expr.expr &:= statements.expr;
      c_expr.expr &:= statements.temp_frees;
    else
      c_expr.expr &:= statements.expr;
    end if;
  end func;


const proc: process_else (in reference: else_part, inout expr_type: c_expr) is func

  local
    var string: category is "";
    var ref_list: params is ref_list.EMPTY;
    var reference: procedure is NIL;
    var expr_type: c_param2 is expr_type.value;
    var string: action_name is "";
  begin
    category := category(else_part);
    if category = "MATCHOBJECT" then
      params := getValue(else_part, ref_list);
      procedure := params[1];
      params := params[2 ..];
      category := category(procedure);
      if category = "CONSTENUMOBJECT" then
        process_expr(params[2], c_param2);
        c_expr.expr &:= "else {\n";
        process_statements(c_param2, c_expr);
        c_expr.expr &:= "}\n";
      elsif category = "ACTOBJECT" then
        c_expr.expr &:= "else ";
        process_action(procedure, params, c_expr);
      else
        c_expr.expr &:= "/*!!! ";
        c_expr.expr &:= category;
        c_expr.expr &:= " ";
        c_expr.expr &:= str(procedure);
        c_expr.expr &:= " !!!*/";
      end if;
    else
      c_expr.expr &:= "/*!! ";
      c_expr.expr &:= category;
      c_expr.expr &:= " ";
      c_expr.expr &:= str(else_part);
      c_expr.expr &:= " !!*/";
    end if
  end func;


const proc: process_prc_if (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param2 is expr_type.value;
    var expr_type: c_param4 is expr_type.value;
  begin
    process_expr(params[2], c_param2);
    process_expr(params[4], c_param4);
    if c_param2.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param2.temp_decls;
      c_expr.expr &:= c_param2.temp_assigns;
    end if;
    c_expr.expr &:= "if (";
    c_expr.expr &:= c_param2.expr;
    c_expr.expr &:= ") {\n";
    process_statements(c_param4, c_expr);
    c_expr.expr &:= "}\n";
    if c_param2.temp_num <> 0 then
      c_expr.expr &:= c_param2.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_prc_if_elsif (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param2 is expr_type.value;
    var expr_type: c_param4 is expr_type.value;
    var expr_type: c_param5 is expr_type.value;
  begin
    process_expr(params[2], c_param2);
    process_expr(params[4], c_param4);
    c_param5.temp_num := c_param2.temp_num;
    process_else(params[5], c_param5);
    if c_param5.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param2.temp_decls;
      c_expr.expr &:= c_param5.temp_decls;
      c_expr.expr &:= c_param2.temp_assigns;
      c_expr.expr &:= c_param5.temp_assigns;
    end if;
    c_expr.expr &:= "if (";
    c_expr.expr &:= c_param2.expr;
    c_expr.expr &:= ") {\n";
    process_statements(c_param4, c_expr);
    c_expr.expr &:= "} ";
    c_expr.expr &:= c_param5.expr;
    if c_param5.temp_num <> 0 then
      c_expr.expr &:= c_param2.temp_frees;
      c_expr.expr &:= c_param5.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_prc_while (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param2 is expr_type.value;
    var expr_type: c_param4 is expr_type.value;
  begin
    process_expr(params[2], c_param2);
    c_param4.temp_num := c_param2.temp_num;
    process_expr(params[4], c_param4);
    if c_param2.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param2.temp_decls;
      c_expr.expr &:= c_param2.temp_assigns;
    end if;
    c_expr.expr &:= "while (";
    c_expr.expr &:= c_param2.expr;
    c_expr.expr &:= ") {\n";
    if c_param2.temp_num <> 0 then
      c_expr.expr &:= c_param2.temp_frees;
    end if;
    process_statements(c_param4, c_expr);
    c_expr.expr &:= "}\n";
    if c_param2.temp_num <> 0 then
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_prc_repeat (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "do {\n";
    process_expr(params[2], c_expr);
    c_expr.expr &:= "} while (!(";
    process_expr(params[4], c_expr);
    c_expr.expr &:= "));\n";
  end func;


const proc: process_prc_for_downto (in ref_list: params, inout expr_type: c_expr) is func

  local
    var integer: temp_num is 0;
  begin
    incr(c_expr.temp_num);
    temp_num := c_expr.temp_num;
    c_expr.temp_decls &:= "inttype tmp_e_";
    c_expr.temp_decls &:= str(temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.expr &:= "{\ntmp_e_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "=(";
    process_expr(params[6], c_expr);
    c_expr.expr &:= ");\n";
    c_expr.expr &:= "for (";
    process_expr(params[2], c_expr);
    c_expr.expr &:= "=(";
    process_expr(params[4], c_expr);
    c_expr.expr &:= "); ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ">=tmp_e_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "; (";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")--) {\n";
    process_expr(params[8], c_expr);
    c_expr.expr &:= "}\n}\n";
  end func;


const proc: process_prc_for_to (in ref_list: params, inout expr_type: c_expr) is func

  local
    var integer: temp_num is 0;
  begin
    incr(c_expr.temp_num);
    temp_num := c_expr.temp_num;
    c_expr.temp_decls &:= "inttype tmp_e_";
    c_expr.temp_decls &:= str(temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.expr &:= "{\ntmp_e_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "=(";
    process_expr(params[6], c_expr);
    c_expr.expr &:= ");\n";
    c_expr.expr &:= "for (";
    process_expr(params[2], c_expr);
    c_expr.expr &:= "=(";
    process_expr(params[4], c_expr);
    c_expr.expr &:= "); ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= "<=tmp_e_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "; (";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")++) {\n";
    process_expr(params[8], c_expr);
    c_expr.expr &:= "}\n}\n";
  end func;


const proc: process_bitset (in bitset: currentSet, inout expr_type: c_expr) is func

  local
    var integer: number is 0;
  begin
    for number range min(currentSet) to max(currentSet) do
      if number in currentSet then
        c_expr.expr &:= "case ";
        c_expr.expr &:= str(number);
        c_expr.expr &:= ":\n";
      end if;
    end for;
  end func;


const proc: process_case_labels (in reference: current_expression, inout expr_type: c_expr) is func

  local
    var reference: case_labels is NIL;
    var string: category is "";
  begin
    case_labels := evaluate(prog, current_expression);
    category := category(case_labels);
    if category = "SETOBJECT" then
      process_bitset(getValue(case_labels, bitset), c_expr);
    else
      c_expr.expr &:= "/* case ";
      c_expr.expr &:= category;
      c_expr.expr &:= " */";
    end if;
  end func;


const proc: process_when (in reference: when_expr, inout expr_type: c_expr) is func

  local
    var ref_list: params is ref_list.EMPTY;
    var reference: procedure is NIL;
  begin
    params := getValue(when_expr, ref_list);
    procedure := params[1];
    params := params[2 ..];
    process_case_labels(params[2], c_expr);
    process_expr(params[4], c_expr);
    c_expr.expr &:= "break;\n";
    if length(params) >= 5 then
      process_when(params[5], c_expr);
    end if;
  end func;


const proc: process_prc_case (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "switch (";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ") {\n";
    process_when(params[4], c_expr);
    c_expr.expr &:= "}\n";
  end func;


const proc: process_prc_case_def (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "switch (";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ") {\n";
    process_when(params[4], c_expr);
    c_expr.expr &:= "default:\n";
    process_expr(params[7], c_expr);
    c_expr.expr &:= "break;\n";
    c_expr.expr &:= "}\n";
  end func;


const proc: process_prc_block (in ref_list: params, inout expr_type: c_expr) is func

  local
    var reference: current_catch is NIL;
    var ref_list: catch_expr is ref_list.EMPTY;
    var reference: catch_value is NIL;
    var string: category is "";
  begin
    c_expr.expr &:= "{\n";
    c_expr.expr &:= "int fail_value;\n";
    # c_expr.expr &:= "if ((fail_value = sigsetjmp(catch_position, 1)) == 0) {\n";
    c_expr.expr &:= "if ((fail_value = setjmp(catch_position)) == 0) {\n";
    process_expr(params[2], c_expr);
    c_expr.expr &:= "} else {\n";
    # c_expr.expr &:= "printf(\"catch %d\\n\", fail_value);\n";
    current_catch := params[4];
    catch_expr := getValue(current_catch, ref_list);
    while current_catch <> NIL and
        category(current_catch) = "MATCHOBJECT" and
        length(catch_expr) >= 5 do
      catch_value := catch_expr[3];
      c_expr.expr &:= "if (";
      process_expr(catch_value, c_expr);
      c_expr.expr &:= " == fail_value - 1) {\n";
      process_expr(catch_expr[5], c_expr);
      if length(catch_expr) >= 6 then
        c_expr.expr &:= "} else ";
        current_catch := catch_expr[6];
        catch_expr := getValue(current_catch, ref_list);
      else
        c_expr.expr &:= "}\n";
        current_catch := NIL;
      end if;
    end while;
    c_expr.expr &:= "}\n";
    c_expr.expr &:= "}\n";
  end func;


const proc: process_procedure (in reference: procedure,
    in ref_list: formal_params, in ref_list: actual_params,
    inout expr_type: c_expr) is forward;


const proc: process_prc_dynamic (in reference: procedure, in ref_list: params,
    inout expr_type: c_expr) is func

  local
    var reference: obj is NIL;
    var string: category is "";
    var boolean: first_element is TRUE;
  begin
    process_procedure(procedure, params(procedure), params, c_expr);
  end func;


const proc: process_prc_exit (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "exit(0);\n";
  end func;


const proc: process_prc_hsize (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "prc_hsize()";
  end func;


const proc: process_prc_semicol (in ref_list: params, inout expr_type: c_expr) is func

  begin
    process_expr(params[1], c_expr);
    # c_expr.expr &:= ";";
    # c_expr.expr &:= "\n";
    process_expr(params[3], c_expr);
  end func;


const proc: do_noop_param(in reference: formal_param, in reference: actual_param,
    inout expr_type: c_expr) is func

  local
    var string: category is "";
    var type: object_type is void;
  begin
    category := category(actual_param);
    if category <> "SYMBOLOBJECT" and
        category(formal_param) <> "SYMBOLOBJECT" then
      object_type := getType(formal_param);
      if is_func(object_type) or is_varfunc(object_type) then
        c_expr.expr &:= "/*expression*/";
(*
        if getType(formal_param) <> getType(actual_param) then
          PRINT("***###***\n");
        end if;
        object_type := result_type(object_type);
        TRACE(object_type); PRINT("\n");
        TRACE_OBJ(actual_param); PRINT("\n\n");
*)
      else
        c_expr.expr &:= "/* ";
        c_expr.expr &:= category;
        if category = "CALLOBJECT" then
          category := category(getValue(actual_param, ref_list)[1]);
          c_expr.expr &:= " ";
          c_expr.expr &:= category;
          if category = "ACTOBJECT" then
            c_expr.expr &:= " ";
            c_expr.expr &:= str(getValue(getValue(actual_param, ref_list)[1], ACTION));
          end if
        end if;
        c_expr.expr &:= " */";
        process_arg(actual_param, c_expr);
        c_expr.expr &:= ";";
      end if;
    else
      c_expr.expr &:= "/*";
      c_expr.expr &:= str(actual_param);
      c_expr.expr &:= "*/";
    end if;
  end func;


const proc: noop_params (in ref_list: formal_params,
    in ref_list: actual_params, inout expr_type: c_expr) is func

  local
    var integer: number is 0;
  begin
    for number range 1 to length(formal_params) do
      if number <= length(actual_params) then
        do_noop_param(formal_params[number], actual_params[number], c_expr);
      end if;
    end for;
  end func;


const proc: process_prc_other_noop (in reference: procedure, in ref_list: params,
    inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "/*noop*/";
    noop_params(params(procedure), params, c_expr);
    c_expr.expr &:= "\n";
  end func;


const proc: process_prc_noop (in reference: procedure, in ref_list: params,
    inout expr_type: c_expr) is func

  begin
    if length(params) = 3 and str(params[2]) = ";" then
      process_prc_semicol(params, c_expr);
    else
      process_prc_other_noop(procedure, params, c_expr);
    end if;
  end func;


const proc: process_prc_args (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "arg_v";
  end func;


const proc: process_prc_print (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "prc_print(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_prc_raise (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "raise_error(";
    process_arg(params[2], c_expr);
    c_expr.expr &:= "+1);\n";
  end func;


const proc: process_act_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "=(";
    c_expr.expr &:= c_param3.expr;
    c_expr.expr &:= ");\n";
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_act_str (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "act_str(";
    get_std_arg(params[1], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_act_value (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "actValue(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_arr_append (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    get_create_call_arg(params[3], c_param3);
    if has_temp_values(c_param3) then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    c_expr.expr &:= "arrAppend(&(";
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "), ";
    if c_param3.result_expr <> "" then
      c_expr.expr &:= c_param3.result_expr;
    else
      c_expr.expr &:= c_param3.expr;
    end if;
    c_expr.expr &:= ");\n";
    if has_temp_values(c_param3) then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_arr_arrlit (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_array_result(getExprResultType(params[3]), c_expr);
    c_expr.result_expr := "arrArrlit(";
    get_create_call_arg(params[3], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_arr_arrlit2 (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_array_result(getExprResultType(params[4]), c_expr);
    c_expr.result_expr := "arrArrlit2(";
    get_std_arg(params[2], c_expr);
    c_expr.result_expr &:= ", ";
    get_create_call_arg(params[4], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_arr_baselit (in reference: procedure, in ref_list: params,
    inout expr_type: c_expr) is func

  begin
    prepare_array_result(result_type(getType(procedure)), c_expr);
    c_expr.result_expr := "arrBaselit(";
    get_create_call_arg(params[3], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_arr_baselit2 (in reference: procedure, in ref_list: params,
    inout expr_type: c_expr) is func

  begin
    prepare_array_result(result_type(getType(procedure)), c_expr);
    c_expr.result_expr := "arrBaselit2(";
    get_std_arg(params[2], c_expr);
    c_expr.result_expr &:= ", ";
    get_create_call_arg(params[4], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_arr_cat (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_array_result(getExprResultType(params[1]), c_expr);
    c_expr.result_expr := "arrCat(";
    get_create_call_arg(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    get_create_call_arg(params[3], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_arr_conv (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_arr_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if has_temp_values(c_param3) then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    if c_param3.result_expr <> "" then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= "arraytype *array_ptr=&(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= ");\n";
      c_expr.expr &:= "arraytype old_array=*array_ptr;\n";
      c_expr.expr &:= "*array_ptr=";
      c_expr.expr &:= c_param3.result_expr;
      c_expr.expr &:= ";\n";
      process_destr_declaration(getExprResultType(params[1]), global_c_expr);
      process_destr_call(getExprResultType(params[1]),
          "old_array", c_expr.expr);
      c_expr.expr &:= "}\n";
    else
      process_cpy_declaration(getExprResultType(params[1]), global_c_expr);
      process_cpy_call(getExprResultType(params[1]),
          c_param1.expr, c_param3.expr, c_expr.expr);
      c_expr.expr &:= ";\n";
    end if;
    if has_temp_values(c_param3) then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_arr_create (in reference: procedure, in ref_list: params,
    inout expr_type: c_expr) is func

  begin
    process_create_declaration(result_type(getType(procedure)), global_c_expr);
    process_expr(params[1], c_expr);
    c_expr.expr &:= "=create_";
    c_expr.expr &:= str(type_number(result_type(getType(procedure))));
    c_expr.expr &:= "(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_arr_destr (in reference: procedure, in ref_list: params,
    inout expr_type: c_expr) is func

  begin
    process_destr_declaration(result_type(getType(procedure)), global_c_expr);
    c_expr.expr &:= "destr_";
    c_expr.expr &:= str(type_number(result_type(getType(procedure))));
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_arr_extend (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_array_result(getExprResultType(params[1]), c_expr);
    c_expr.result_expr := "arrExtend(";
    get_create_call_arg(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    get_create_call_arg(params[3], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_arr_gen (in reference: procedure, in ref_list: params,
    inout expr_type: c_expr) is func

  begin
    prepare_array_result(result_type(getType(procedure)), c_expr);
    c_expr.result_expr := "arrGen(";
    get_create_call_arg(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    get_create_call_arg(params[3], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_arr_head (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_array_result(getExprResultType(params[1]), c_expr);
    c_expr.result_expr := "arrHead(";
    get_create_call_arg(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    get_std_arg(params[4], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_arr_idx (in reference: procedure, in ref_list: params,
    inout expr_type: c_expr) is func

  local
    var integer: array_temp_num is 0;
    var integer: index_temp_num is 0;
  begin
    incr(c_expr.temp_num);
    array_temp_num := c_expr.temp_num;
    c_expr.temp_decls &:= "arraytype tmp_";
    c_expr.temp_decls &:= str(array_temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.expr &:= "(*(tmp_";
    c_expr.expr &:= str(array_temp_num);
    c_expr.expr &:= "=(arraytype)(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= "), &tmp_";
    c_expr.expr &:= str(array_temp_num);
    c_expr.expr &:= "->arr[";
    if array_range_check then
      incr(c_expr.temp_num);
      index_temp_num := c_expr.temp_num;
      c_expr.temp_decls &:= "inttype tmp_";
      c_expr.temp_decls &:= str(index_temp_num);
      c_expr.temp_decls &:= ";\n";
      c_expr.expr &:= "(tmp_";
      c_expr.expr &:= str(index_temp_num);
      c_expr.expr &:= "=";
      process_expr(params[3], c_expr);
      c_expr.expr &:= ", tmp_";
      c_expr.expr &:= str(index_temp_num);
      c_expr.expr &:= " < tmp_";
      c_expr.expr &:= str(array_temp_num);
      c_expr.expr &:= "->min_position || tmp_";
      c_expr.expr &:= str(index_temp_num);
      c_expr.expr &:= " > tmp_";
      c_expr.expr &:= str(array_temp_num);
      c_expr.expr &:= "->max_position ? raise_error(RANGE_ERROR) : 0, tmp_";
      c_expr.expr &:= str(index_temp_num);
      c_expr.expr &:= "-tmp_";
      c_expr.expr &:= str(array_temp_num);
      c_expr.expr &:= "->min_position)";
    else
      c_expr.expr &:= "(";
      process_expr(params[3], c_expr);
      c_expr.expr &:= ")-tmp_";
      c_expr.expr &:= str(array_temp_num);
      c_expr.expr &:= "->min_position";
    end if;
    c_expr.expr &:= "]";
    if result_type(getType(procedure)) = floattype then
      c_expr.expr &:= ".value.floatvalue";
    else
      c_expr.expr &:= ".value.intvalue";
    end if;
    c_expr.expr &:= "))";
  end func;


const proc: process_arr_lng (in ref_list: params, inout expr_type: c_expr) is func

  local
    var integer: temp_num is 0;
  begin
    incr(c_expr.temp_num);
    temp_num := c_expr.temp_num;
    c_expr.temp_decls &:= "arraytype tmp_";
    c_expr.temp_decls &:= str(temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.expr &:= "(tmp_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "=(arraytype)(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= "), tmp_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "->max_position - tmp_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "->min_position + 1)";
  end func;


const proc: process_arr_range (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_array_result(getExprResultType(params[1]), c_expr);
    c_expr.result_expr := "arrRange(";
    get_create_call_arg(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    get_std_arg(params[3], c_expr);
    c_expr.result_expr &:= ", ";
    get_std_arg(params[5], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_arr_sort (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_array_result(getExprResultType(params[1]), c_expr);
    c_expr.result_expr := "arrSort(";
    get_create_call_arg(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    get_std_arg(params[2], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_arr_tail (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_array_result(getExprResultType(params[1]), c_expr);
    c_expr.result_expr := "arrTail(";
    get_create_call_arg(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    get_std_arg(params[3], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_arr_times (in reference: procedure, in ref_list: params,
    inout expr_type: c_expr) is func

  begin
    prepare_array_result(result_type(getType(procedure)), c_expr);
    c_expr.result_expr &:= "times_";
    c_expr.result_expr &:= str(type_number(result_type(getType(procedure))));
    c_expr.result_expr &:= "(";
    get_std_arg(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    get_result_arg(params[3], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_big_abs (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_bigint_result(c_expr);
    c_expr.result_expr := "bigAbs(";
    get_result_arg(params[1], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_big_add (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_bigint_result(c_expr);
    c_expr.result_expr := "bigAdd(";
    get_result_arg(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    get_result_arg(params[3], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_big_clit (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "bigCLit(";
    get_result_arg(params[1], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_big_cmp (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "bigCmp(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_arg(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_big_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if has_temp_values(c_param3) then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    if c_param3.result_expr <> "" then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= "biginttype *big_ptr=&(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= ");\n";
      c_expr.expr &:= "biginttype old_big=*big_ptr;\n";
      c_expr.expr &:= "*big_ptr=";
      c_expr.expr &:= c_param3.result_expr;
      c_expr.expr &:= ";\n";
      c_expr.expr &:= "bigDestr(old_big);\n";
      c_expr.expr &:= "}\n";
    else
      c_expr.expr &:= "bigCpy(&(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "), ";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= ");\n";
    end if;
    if has_temp_values(c_param3) then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_big_decr (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "bigDecr(&(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= "));\n";
  end func;


const proc: process_big_div (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_bigint_result(c_expr);
    c_expr.result_expr := "bigDiv(";
    get_result_arg(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    get_result_arg(params[3], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_big_eq (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "bigEq(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_arg(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_big_ge (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(bigCmp(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_arg(params[3], c_expr);
    c_expr.expr &:= ") >= 0)";
  end func;


const proc: process_big_grow (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "bigGrow(&(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= "), ";
    process_arg(params[3], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_big_gt (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(bigCmp(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_arg(params[3], c_expr);
    c_expr.expr &:= ") > 0)";
  end func;


const proc: process_big_hashcode (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "bigHashCode(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_big_iconv (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_bigint_result(c_expr);
    c_expr.result_expr := "bigIConv(";
    get_std_arg(params[3], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_big_incr (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "bigIncr(&(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= "));\n";
  end func;


const proc: process_big_ipow (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_bigint_result(c_expr);
    c_expr.result_expr := "bigIPow(";
    get_result_arg(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    get_std_arg(params[3], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_big_le (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(bigCmp(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_arg(params[3], c_expr);
    c_expr.expr &:= ") <= 0)";
  end func;


const proc: process_big_log2 (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "bigLog2(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_big_lt (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(bigCmp(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_arg(params[3], c_expr);
    c_expr.expr &:= ") < 0)";
  end func;


const proc: process_big_mcpy (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "bigMCpy(&(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= "), ";
    process_arg(params[3], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_big_mdiv (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_bigint_result(c_expr);
    c_expr.result_expr := "bigMDiv(";
    get_result_arg(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    get_result_arg(params[3], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_big_minus (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_bigint_result(c_expr);
    c_expr.result_expr := "bigMinus(";
    get_result_arg(params[2], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_big_mod (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_bigint_result(c_expr);
    c_expr.result_expr := "bigMod(";
    get_result_arg(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    get_result_arg(params[3], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_big_mult (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_bigint_result(c_expr);
    c_expr.result_expr := "bigMult(";
    get_result_arg(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    get_result_arg(params[3], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_big_ne (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "bigNe(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_arg(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_big_odd (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_bigint_result(c_expr);
    c_expr.result_expr := "(((biginttype)(";
    get_result_arg(params[1], c_expr);
    c_expr.result_expr &:= "))->bigdigits[0] & 1)";
  end func;


const proc: process_big_ord (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "bigOrd(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_big_parse (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_bigint_result(c_expr);
    c_expr.result_expr := "bigParse(";
    get_result_arg(params[3], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_big_pred (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_bigint_result(c_expr);
    c_expr.result_expr := "bigPred(";
    get_result_arg(params[1], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_big_rand (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_bigint_result(c_expr);
    c_expr.result_expr := "bigRand(";
    get_result_arg(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    get_result_arg(params[2], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_big_rem (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_bigint_result(c_expr);
    c_expr.result_expr := "bigRem(";
    get_result_arg(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    get_result_arg(params[3], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_big_sbtr (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_bigint_result(c_expr);
    c_expr.result_expr := "bigSbtr(";
    get_result_arg(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    get_result_arg(params[3], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_big_shrink (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "bigShrink(&(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= "), ";
    process_arg(params[3], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_big_str (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "bigStr(";
    get_result_arg(params[1], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_big_succ (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_bigint_result(c_expr);
    c_expr.result_expr := "bigSucc(";
    get_result_arg(params[1], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_big_value (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_bigint_result(c_expr);
    c_expr.result_expr &:= "bigValue(";
    get_std_arg(params[1], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_bln_and (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") &&\n(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_bln_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "=(";
    c_expr.expr &:= c_param3.expr;
    c_expr.expr &:= ");\n";
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_bln_eq (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") == (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_bln_ge (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") >= (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_bln_gt (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") > (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_bln_iconv (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ") & 1";
  end func;


const proc: process_bln_le (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") <= (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_bln_lt (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") < (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_bln_ne (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") != (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_bln_not (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "!(";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_bln_or (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") ||\n(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_bln_ord (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(inttype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_bst_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if has_temp_values(c_param3) then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    if c_param3.result_expr <> "" then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= "bstritype *bstri_ptr=&(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= ");\n";
      c_expr.expr &:= "bstritype old_bstri=*bstri_ptr;\n";
      c_expr.expr &:= "*bstri_ptr=";
      c_expr.expr &:= c_param3.result_expr;
      c_expr.expr &:= ";\n";
      c_expr.expr &:= "bstDestr(old_bstri);\n";
      c_expr.expr &:= "}\n";
    else
      c_expr.expr &:= "bstCpy(&(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "), ";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= ");\n";
    end if;
    if has_temp_values(c_param3) then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_chr_chr (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(chartype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_chr_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "=(";
    c_expr.expr &:= c_param3.expr;
    c_expr.expr &:= ");\n";
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_chr_decr (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "--(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_chr_eq (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") == (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_chr_ge (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "((chartype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")) >= ((chartype)(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_chr_grow (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "+=(";
    c_expr.expr &:= c_param3.expr;
    c_expr.expr &:= ");\n";
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_chr_gt (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "((chartype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")) > ((chartype)(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_chr_hashcode (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(inttype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_chr_iconv (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(chartype)(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_chr_incr (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "++(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_chr_le (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "((chartype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")) <= ((chartype)(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_chr_low (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "chrLow(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_chr_lt (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "((chartype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")) < ((chartype)(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_chr_ne (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") != (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_chr_ord (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(inttype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_chr_pred (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")-1";
  end func;


const proc: process_chr_shrink (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "-=(";
    c_expr.expr &:= c_param3.expr;
    c_expr.expr &:= ");\n";
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_chr_str (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "chrStr(";
    get_std_arg(params[1], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_chr_succ (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")+1";
  end func;


const proc: process_chr_up (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "chrUp(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_chr_value (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "chrValue(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_cls_conv2 (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_cls_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if has_temp_values(c_param3) then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    if c_param3.result_expr <> "" then
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "=(";
      c_expr.expr &:= c_param3.result_expr;
      c_expr.expr &:= ");\n";
    else
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "=(";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= ");\n";
    end if;
    if has_temp_values(c_param3) then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_cls_cpy2 (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if has_temp_values(c_param3) then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    if c_param3.result_expr <> "" then
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "=";
      c_expr.expr &:= c_param3.result_expr;
      c_expr.expr &:= ";\n";
    else
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "=";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= ";\n";
    end if;
    if has_temp_values(c_param3) then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_cls_eq (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") == (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_cls_ne (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") != (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_cmd_config_value (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "cmdConfigValue(";
    get_result_arg(params[1], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_cmd_copy (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "cmdCopy(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_arg(params[2], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_cmd_getcwd (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "cmdGetcwd()";
  end func;


const proc: process_cmd_lng (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "cmdLng(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_cmd_ls (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_array_result(array_type[getExprResultType(params[1])], c_expr);
    c_expr.result_expr := "cmdLs(";
    get_result_arg(params[1], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_cmd_mkdir (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "cmdMkdir(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_cmd_move (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "cmdMove(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_arg(params[2], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_cmd_remove (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "cmdRemove(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_cmd_sh (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "cmdSh(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_drw_arc (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwArc(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[6], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_drw_arc2 (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwArc2(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[6], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_drw_background (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwBackground(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_drw_circle (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwCircle(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_drw_clear (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwClear(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_drw_color (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwColor(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_drw_copyarea (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwCopyArea(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_arg(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[6], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[7], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[8], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_drw_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if has_temp_values(c_param3) then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    if c_param3.result_expr <> "" then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= "wintype *win_ptr=&(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= ");\n";
      c_expr.expr &:= "wintype old_win=*win_ptr;\n";
      c_expr.expr &:= "*win_ptr=";
      c_expr.expr &:= c_param3.result_expr;
      c_expr.expr &:= ";\n";
      c_expr.expr &:= "drwDestr(old_win);\n";
      c_expr.expr &:= "}\n";
    else
      c_expr.expr &:= "drwCpy(&(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "), ";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= ");\n";
    end if;
    if has_temp_values(c_param3) then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_drw_eq (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ") == (";
    process_arg(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_drw_farcchord (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwFArcChord(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[6], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_drw_farcpieslice(in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwFArcPieSlice(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[6], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_drw_fcircle (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwFCircle(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_drw_fellipse (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwFEllipse(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_drw_flush (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwFlush();\n";
  end func;


const proc: process_drw_get (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_win_result(c_expr);
    c_expr.result_expr &:= "drwGet(";
    get_result_arg(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    get_std_arg(params[2], c_expr);
    c_expr.result_expr &:= ", ";
    get_std_arg(params[3], c_expr);
    c_expr.result_expr &:= ", ";
    get_std_arg(params[4], c_expr);
    c_expr.result_expr &:= ", ";
    get_std_arg(params[5], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_drw_height (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwHeight(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_drw_image (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_win_result(c_expr);
    c_expr.result_expr &:= "drwImage(";
    get_result_arg(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    get_std_arg(params[2], c_expr);
    c_expr.result_expr &:= ", 0, 0"; (* This is just a hack: This function will not work *)
    c_expr.result_expr &:= ")";
  end func;


const proc: process_drw_line (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwLine(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_drw_ne (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ") != (";
    process_arg(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_drw_new_pixmap (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_win_result(c_expr);
    c_expr.result_expr &:= "drwNewPixmap(";
    get_result_arg(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    get_std_arg(params[2], c_expr);
    c_expr.result_expr &:= ", ";
    get_std_arg(params[3], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_drw_open (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_win_result(c_expr);
    c_expr.result_expr &:= "drwOpen(";
    get_std_arg(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    get_std_arg(params[2], c_expr);
    c_expr.result_expr &:= ", ";
    get_std_arg(params[3], c_expr);
    c_expr.result_expr &:= ", ";
    get_std_arg(params[4], c_expr);
    c_expr.result_expr &:= ", ";
    get_std_arg(params[5], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_drw_parc (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwPArc(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[6], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[7], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_drw_pcircle (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwPCircle(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_drw_pfarcchord (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwPFArcChord(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[6], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[7], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_drw_pfarcpieslice (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwFArcPieSlice(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[6], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_drw_pfcircle (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwPFCircle(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_drw_pfellipse (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwPFEllipse(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[6], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_drw_pline (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwPLine(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[6], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_drw_point (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwPoint(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_drw_ppoint (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwPPoint(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_drw_prect (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwPRect(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[6], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_drw_put (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwPut(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_drw_rect (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwRect(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_drw_rgbcol (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwRgbColor(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_drw_text (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwText(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_arg(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[6], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_drw_width (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "drwWidth(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_enu_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    if c_param3.result_expr <> "" then
      # In the moment needed for GRAPH objects:
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "=(";
      c_expr.expr &:= c_param3.result_expr;
      c_expr.expr &:= ");\n";
    else
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "=(";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= ");\n";
    end if;
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_enu_eq (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") == (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_enu_iconv2 (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_enu_ne (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") != (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_enu_ord2 (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_enu_value (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "enuValue(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_fil_big_lng (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_bigint_result(c_expr);
    c_expr.result_expr &:= "filBigLng(";
    get_std_arg(params[1], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_fil_big_seek (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "filBigSeek(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_arg(params[2], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_fil_big_tell (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_bigint_result(c_expr);
    c_expr.result_expr &:= "filBigTell(";
    get_std_arg(params[1], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_fil_close (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "fclose(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_fil_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "=(";
    c_expr.expr &:= c_param3.expr;
    c_expr.expr &:= ");\n";
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_fil_eq (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") == (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_fil_eof (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "feof((FILE *)";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_fil_flush (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "fflush(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_fil_getc (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "fgetc(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_fil_gets (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "filGets(";
    get_std_arg(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    get_std_arg(params[2], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_fil_line_read (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "filLineRead(";
    get_std_arg(params[1], c_expr);
    c_expr.result_expr &:= ", &(";
    get_std_arg(params[2], c_expr);
    c_expr.result_expr &:= "))";
  end func;


const proc: process_fil_lit (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "filLit(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_fil_lng (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "filLng(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_fil_ne (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") != (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_fil_nil (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "NULL";
  end func;


const proc: process_fil_open (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "filOpen(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_fil_popen (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "filPopen(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_fil_seek (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "filSeek(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_fil_tell (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "ftell(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_fil_write (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "filWrite(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_arg(params[2], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_fil_word_read (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "filWordRead(";
    get_std_arg(params[1], c_expr);
    c_expr.result_expr &:= ", &(";
    get_std_arg(params[2], c_expr);
    c_expr.result_expr &:= "))";
  end func;


const proc: process_flt_a2tan (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "atan2(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_abs (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "fabs(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_add (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") + (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_acos (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "acos(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_asin (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "asin(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_atan (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "atan(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_ceil (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "ceil(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_cmp (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "fltCmp(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_arg(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_cos (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "cos(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;

    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "=(";
    c_expr.expr &:= c_param3.expr;
    c_expr.expr &:= ");\n";
(*
    c_expr.expr &:= "*((float * ) &(" & c_param1.expr;
    c_expr.expr &:= "))=(";
    c_expr.expr &:= c_param3.expr;
    c_expr.expr &:= ");\n";

    c_expr.expr &:= "memcpy(&(";
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "), &(";
    c_expr.expr &:= c_param3.expr;
    c_expr.expr &:= "), sizeof(float));\n";  # Assuming that sizeof(float) == sizeof(long)
*)
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_flt_dgts (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "fltDgts(";
    get_std_arg(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    get_std_arg(params[3], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_flt_div (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") / (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_eq (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") == (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_exp (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "exp(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_floor (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "floor(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_ge (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") >= (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_grow (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
      c_expr.expr &:= c_param1.expr;
    end if;
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "+=(";
    c_expr.expr &:= c_param3.expr;
    c_expr.expr &:= ");\n";
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_flt_gt (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") > (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_hashcode (in ref_list: params, inout expr_type: c_expr) is func

  local
    var integer: temp_num is 0;
  begin
    incr(c_expr.temp_num);
    temp_num := c_expr.temp_num;
    c_expr.temp_decls &:= "float2int tmp_a_";
    c_expr.temp_decls &:= str(temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.expr &:= "(tmp_a_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= ".floatvalue=(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "),tmp_a_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= ".intvalue)";
  end func;


const proc: process_flt_iflt (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(float)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_ipow (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "fltIPow(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_isnan (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "isnan(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_le (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") <= (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_log (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "log(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_log10 (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "log10(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_lt (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") < (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_mcpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
      c_expr.expr &:= c_param1.expr;
    end if;
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "*=(";
    c_expr.expr &:= c_param3.expr;
    c_expr.expr &:= ");\n";
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_flt_minus (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "-(";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_mult (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") * (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_ne (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") != (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_parse (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "fltParse(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_pow (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "pow(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_rand (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "fltRand(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_round (in ref_list: params, inout expr_type: c_expr) is func

  local
    var integer: temp_num is 0;
  begin
    incr(c_expr.temp_num);
    temp_num := c_expr.temp_num;
    c_expr.temp_decls &:= "floattype tmp_a_";
    c_expr.temp_decls &:= str(temp_num);
    c_expr.temp_decls &:= ";\n";
    (* Formula used: (a<0.0?-((inttype)(0.5-a)):(inttype)(0.5+a)) *)
    c_expr.expr &:= "(tmp_a_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "=(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "),tmp_a_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "<0.0?-((inttype)(0.5-tmp_a_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= ")):(inttype)(0.5+tmp_a_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "))";
  end func;


const proc: process_flt_sbtr (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") - (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_shrink (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "-=(";
    c_expr.expr &:= c_param3.expr;
    c_expr.expr &:= ");\n";
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_flt_sin (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "sin(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_sqrt (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "sqrt(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_str (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "fltStr(";
    get_std_arg(params[1], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_flt_tan (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "tan(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_trunc (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(inttype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_flt_value (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "fltValue(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_gkb_busy_getc (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(gkbKeyPressed() ? gkbGetc() : 512)";
  end func;


const proc: process_gkb_getc (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "gkbGetc()";
  end func;


const proc: process_gkb_gets (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "gkbGets(";
    get_std_arg(params[2], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_gkb_keypressed (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "gkbKeyPressed()";
  end func;


const proc: process_gkb_line_read (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "gkbLineRead(&(";
    get_std_arg(params[2], c_expr);
    c_expr.result_expr &:= "))";
  end func;


const proc: process_gkb_raw_getc (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "gkbRawGetc()";
  end func;


const proc: process_gkb_word_read (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "gkbWordRead(&(";
    get_std_arg(params[2], c_expr);
    c_expr.result_expr &:= "))";
  end func;


const proc: process_gkb_xpos (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "gkbXpos()";
  end func;


const proc: process_gkb_ypos (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "gkbYpos()";
  end func;


const proc: process_hsh_contains (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "hshContains(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_hsh_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param2 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param2.temp_num := c_param1.temp_num;
    process_expr(params[2], c_param2);
    if has_temp_values(c_param2) then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param2.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param2.temp_assigns;
    end if;
    if c_param2.result_expr <> "" then
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "=(";
      c_expr.expr &:= c_param2.result_expr;
      c_expr.expr &:= ");\n";
    else
      c_expr.expr &:= "hshCpy(&(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "), ";
      c_expr.expr &:= c_param2.expr;
      c_expr.expr &:= ", ";
      process_expr(params[3], c_expr);
      c_expr.expr &:= ", ";
      process_expr(params[4], c_expr);
      c_expr.expr &:= ", ";
      process_expr(params[5], c_expr);
      c_expr.expr &:= ", ";
      process_expr(params[6], c_expr);
      c_expr.expr &:= ");\n";
    end if;
    if has_temp_values(c_param2) then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param2.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_hsh_create (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param2 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param2.temp_num := c_param1.temp_num;
    process_expr(params[2], c_param2);
    if c_param2.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param2.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param2.temp_assigns;
    end if;
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "=";
    c_expr.expr &:= "hshCreate(";
    c_expr.expr &:= c_param2.expr;
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[6], c_expr);
    c_expr.expr &:= ");\n";
    if c_param2.temp_num <> 0 then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param2.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_hsh_destr (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "hshDestr(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_hsh_excl (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "hshExcl(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[6], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_hsh_for_generic (in reference: forDataVariable,
  in reference: forKeyVariable, in reference: hashTable,
  in reference: statement, in reference: dataCopyFunc,
  in reference: keyCopyFunc, inout expr_type: c_expr) is func

  local
    var integer: hash_temp_num is 0;
    var integer: counter_temp_num is 0;
    var integer: table_elem_temp_num is 0;
    var integer: helem_temp_num is 0;
    var integer: stack_temp_num is 0;
  begin
    incr(c_expr.temp_num);
    hash_temp_num := c_expr.temp_num;
    incr(c_expr.temp_num);
    counter_temp_num := c_expr.temp_num;
    incr(c_expr.temp_num);
    table_elem_temp_num := c_expr.temp_num;
    incr(c_expr.temp_num);
    helem_temp_num := c_expr.temp_num;
    incr(c_expr.temp_num);
    stack_temp_num := c_expr.temp_num;
    c_expr.expr &:= "/* hsh_for */ {\n";
    c_expr.expr &:= "hashtype hash_";
    c_expr.expr &:= str(hash_temp_num);
    c_expr.expr &:= "=";
    process_expr(hashTable, c_expr);
    c_expr.expr &:= ";\n";
    c_expr.expr &:= "memsizetype counter_";
    c_expr.expr &:= str(counter_temp_num);
    c_expr.expr &:= "=hash_";
    c_expr.expr &:= str(hash_temp_num);
    c_expr.expr &:= "->table_size;\n";
    c_expr.expr &:= "helemtype *table_elem_";
    c_expr.expr &:= str(table_elem_temp_num);
    c_expr.expr &:= "=&hash_";
    c_expr.expr &:= str(hash_temp_num);
    c_expr.expr &:= "->table[0];\n";
    c_expr.expr &:= "helemtype helem_";
    c_expr.expr &:= str(helem_temp_num);
    c_expr.expr &:= ";\n";
    c_expr.expr &:= "listtype stack_";
    c_expr.expr &:= str(stack_temp_num);
    c_expr.expr &:= "=NULL;\n";

    c_expr.expr &:= "while (counter_";
    c_expr.expr &:= str(counter_temp_num);
    c_expr.expr &:= " > 0) {\n";

    c_expr.expr &:= "helem_";
    c_expr.expr &:= str(helem_temp_num);
    c_expr.expr &:= "=*table_elem_";
    c_expr.expr &:= str(table_elem_temp_num);
    c_expr.expr &:= ";\n";

    c_expr.expr &:= "while (helem_";
    c_expr.expr &:= str(helem_temp_num);
    c_expr.expr &:= " != NULL) {\n";

    c_expr.expr &:= "if (helem_";
    c_expr.expr &:= str(helem_temp_num);
    c_expr.expr &:= "->next_greater != NULL) {\n";
    c_expr.expr &:= "push_stack(stack_";
    c_expr.expr &:= str(stack_temp_num);
    c_expr.expr &:= ", helem_";
    c_expr.expr &:= str(helem_temp_num);
    c_expr.expr &:= "->next_greater);\n";
    c_expr.expr &:= "} /* if */\n";

    if forDataVariable <> NIL then
      c_expr.expr &:= "((copyfunctype)";
      process_expr(dataCopyFunc, c_expr);
      c_expr.expr &:= ")(&(";
      process_expr(forDataVariable, c_expr);
      c_expr.expr &:= "), helem_";
      c_expr.expr &:= str(helem_temp_num);
      c_expr.expr &:= "->data.value.genericvalue);\n";
    end if;

    if forKeyVariable <> NIL then
      c_expr.expr &:= "((copyfunctype)";
      process_expr(keyCopyFunc, c_expr);
      c_expr.expr &:= ")(&(";
      process_expr(forKeyVariable, c_expr);
      c_expr.expr &:= "), helem_";
      c_expr.expr &:= str(helem_temp_num);
      c_expr.expr &:= "->key.value.genericvalue);\n";
    end if;

    process_expr(statement, c_expr);

    c_expr.expr &:= "if (helem_";
    c_expr.expr &:= str(helem_temp_num);
    c_expr.expr &:= "->next_less != NULL) {";
    c_expr.expr &:= "helem_";
    c_expr.expr &:= str(helem_temp_num);
    c_expr.expr &:= "=helem_";
    c_expr.expr &:= str(helem_temp_num);
    c_expr.expr &:= "->next_less;\n";
    c_expr.expr &:= "} else {\n";
    c_expr.expr &:= "pop_stack(stack_";
    c_expr.expr &:= str(stack_temp_num);
    c_expr.expr &:= ", helem_";
    c_expr.expr &:= str(helem_temp_num);
    c_expr.expr &:= ");\n";
    c_expr.expr &:= "} /* if */\n";

    c_expr.expr &:= "} /* while */\n";

    c_expr.expr &:= "counter_";
    c_expr.expr &:= str(counter_temp_num);
    c_expr.expr &:= "--;\n";
    c_expr.expr &:= "table_elem_";
    c_expr.expr &:= str(table_elem_temp_num);
    c_expr.expr &:= "++;\n";
    c_expr.expr &:= "} /* while */\n";
    c_expr.expr &:= "} /* hsh_for */\n";
  end func;


const proc: process_hsh_for (in ref_list: params, inout expr_type: c_expr) is func

  begin
    process_hsh_for_generic(params[1], NIL, params[2], params[3], params[4], NIL, c_expr);
  end func;


const proc: process_hsh_for_data_key (in ref_list: params, inout expr_type: c_expr) is func

  begin
    process_hsh_for_generic(params[1], params[2], params[3], params[4], params[5], params[6], c_expr);
  end func;


const proc: process_hsh_for_key (in ref_list: params, inout expr_type: c_expr) is func

  begin
    process_hsh_for_generic(NIL, params[1], params[2], params[3], NIL, params[4], c_expr);
  end func;


const proc: process_hsh_idx (in reference: procedure, in ref_list: params,
    inout expr_type: c_expr) is func

  local
    var type: proc_type is void;
    var type: result_type is void;
  begin
    proc_type := getType(procedure);
    result_type := result_type(proc_type);
    if result_type = floattype then
      c_expr.expr &:= "*(floattype *)hshIdxAddr(";
    elsif is_varfunc(proc_type) then
      c_expr.expr &:= "*hshIdxAddr(";
    else
      c_expr.expr &:= "hshIdx(";
    end if;
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_cast_from_float_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_hsh_incl (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "hshIncl(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_cast_from_float_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_cast_from_float_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[6], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[7], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[8], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_hsh_keys (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "hshKeys(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_hsh_lng (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "((hashtype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "))->size";
  end func;


const proc: process_hsh_values (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "hshValues(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_abs (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "labs(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_add (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") + (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_binom (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "intBinom(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_cmp (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "intCmp(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_arg(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_conv (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "=(";
    c_expr.expr &:= c_param3.expr;
    c_expr.expr &:= ");\n";
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_int_decr (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "--(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_int_div (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") / (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_eq (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") == (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_fact (in ref_list: params, inout expr_type: c_expr) is func

  local
    var integer: temp_num is 0;
  begin
    incr(c_expr.temp_num);
    temp_num := c_expr.temp_num;
    c_expr.temp_decls &:= "inttype tmp_";
    c_expr.temp_decls &:= str(temp_num);
    c_expr.temp_decls &:= ";\n";
    (* Formula used: (i<0||i>12?NUMERIC_ERROR:fact[i]) *)
    c_expr.expr &:= "(tmp_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "=(";
    process_expr(params[2], c_expr);
    c_expr.expr &:= "),(tmp_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "<0||tmp_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= ">12?(raise_error(NUMERIC_ERROR),0):fact[tmp_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "]))";
  end func;


const proc: process_int_ge (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") >= (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_grow (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "+=(";
    c_expr.expr &:= c_param3.expr;
    c_expr.expr &:= ");\n";
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_int_gt (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") > (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_hashcode (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_incr (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "++(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_int_log2 (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "intLog2(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_le (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") <= (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_lt (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") < (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_mcpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "*=(";
    c_expr.expr &:= c_param3.expr;
    c_expr.expr &:= ");\n";
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_int_mdiv (in ref_list: params, inout expr_type: c_expr) is func

  local
    var integer: temp_num is 0;
  begin
    incr(c_expr.temp_num);
    temp_num := c_expr.temp_num;
    c_expr.temp_decls &:= "inttype tmp_a_";
    c_expr.temp_decls &:= str(temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_decls &:= "inttype tmp_b_";
    c_expr.temp_decls &:= str(temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_decls &:= "inttype tmp_c_";
    c_expr.temp_decls &:= str(temp_num);
    c_expr.temp_decls &:= ";\n";
    (* Formula used: (c=a/b,((a>0&&b<0)||(a<0&&b>0))&&a%b!=0?c-1:c) *)
    c_expr.expr &:= "(tmp_a_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "=(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "),tmp_b_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "=(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= "),tmp_c_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "=tmp_a_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "/tmp_b_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= ",((tmp_a_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= ">0&&tmp_b_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "<0)||(tmp_a_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "<0&&tmp_b_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= ">0))&&tmp_a_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "%tmp_b_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "!=0?tmp_c_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "-1:tmp_c_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_minus (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "-(";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_mod (in ref_list: params, inout expr_type: c_expr) is func

  local
    var integer: temp_num is 0;
  begin
    incr(c_expr.temp_num);
    temp_num := c_expr.temp_num;
    c_expr.temp_decls &:= "inttype tmp_a_";
    c_expr.temp_decls &:= str(temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_decls &:= "inttype tmp_b_";
    c_expr.temp_decls &:= str(temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_decls &:= "inttype tmp_c_";
    c_expr.temp_decls &:= str(temp_num);
    c_expr.temp_decls &:= ";\n";
    (* Formula used: (c=a%b,((a>0&&b<0)||(a<0&&b>0))&&c!=0?c+b:c) *)
    c_expr.expr &:= "(tmp_a_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "=(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "),tmp_b_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "=(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= "),tmp_c_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "=tmp_a_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "%tmp_b_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= ",((tmp_a_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= ">0&&tmp_b_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "<0)||(tmp_a_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "<0&&tmp_b_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= ">0))&&tmp_c_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "!=0?tmp_c_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "+tmp_b_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= ":tmp_c_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_mult (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") * (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_ne (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") != (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_odd (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")&1";
  end func;


const proc: process_int_ord (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_parse (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "intParse(";
    process_arg(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_pow (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "intPow(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_pred (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")-1";
  end func;


const proc: process_int_rand (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "intRand(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_rem (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") % (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_sbtr (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") - (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_shrink (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "-=(";
    c_expr.expr &:= c_param3.expr;
    c_expr.expr &:= ");\n";
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_int_sqrt (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "intSqrt(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_int_str (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "intStr(";
    get_std_arg(params[1], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_int_succ (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")+1";
  end func;


const proc: process_int_value (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "intValue(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_kbd_busy_getc (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(kbdKeyPressed() ? kbdGetc() : 512)";
  end func;


const proc: process_kbd_getc (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "kbdGetc()";
  end func;


const proc: process_kbd_gets (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "kbdGets(";
    get_std_arg(params[2], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_kbd_keypressed (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "kbdKeyPressed()";
  end func;


const proc: process_kbd_line_read (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "kbdLineRead(&(";
    get_std_arg(params[2], c_expr);
    c_expr.result_expr &:= "))";
  end func;


const proc: process_kbd_raw_getc (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "kbdRawGetc()";
  end func;


const proc: process_kbd_word_read (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "kbdWordRead(&(";
    get_std_arg(params[2], c_expr);
    c_expr.result_expr &:= "))";
  end func;


const proc: process_prg_analyze (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "prg_analyze(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_prg_cpy (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "prg_cpy(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_prg_decl_objects (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "prg_decl_objects(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_prg_eq (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") == (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_prg_error_count (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "prg_error_count(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_prg_eval (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "prg_eval(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_prg_match (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "prg_match(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_prg_name (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "arg_0";
  end func;


const proc: process_prg_ne (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") != (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_prg_syobject (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "prg_syobject(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_prg_sysvar (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "prg_sysvar(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_prg_value (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "prgValue(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_addr (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "ref_addr(";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_alloc (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "refAlloc(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_arrminpos (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "refArrminpos(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_arrtolist (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "refArrtolist(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_body (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "refBody(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_category (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "refCategory(";
    get_std_arg(params[1], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_ref_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "=(";
    c_expr.expr &:= c_param3.expr;
    c_expr.expr &:= ");\n";
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_ref_deref (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "/*ref_deref*/ *((long *)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_ref_eq (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") == (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_hashcode (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(inttype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_isvar (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "refIsvar(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_itftosct (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "ref_itftosct(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_local_consts (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "refLocalConsts(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_local_vars (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "refLocalVars(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_ne (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") != (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_num (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "ref_num(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_params (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "refParams(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_resini (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "refResini(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_result (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "refResult(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_scttolist (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "refScttolist(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_select (in reference: procedure, in ref_list: params,
    inout expr_type: c_expr) is func

  local
    var type: object_type is void;
    var reference: params1 is NIL;
  begin
    object_type := getExprResultType(params[1]);
    if object_type in struct_elements and params[3] in struct_elements[object_type] then
      c_expr.expr &:= "((structtype)*(";
      process_arg(params[1], c_expr);
      c_expr.expr &:= "))->stru[";
      c_expr.expr &:= str(struct_elements[object_type][params[3]]);
      c_expr.expr &:= "]";
      if result_type(getType(procedure)) = floattype then
        c_expr.expr &:= ".value.floatvalue";
      else
        c_expr.expr &:= ".value.intvalue";
      end if;
      c_expr.expr &:= "/*->o_";
      c_expr.expr &:= str(obj_number(params[3]));
      c_expr.expr &:= "**";
      c_expr.expr &:= str(params[3]);
      c_expr.expr &:= "*/";
    else
      if result_type(getType(procedure)) = floattype then
        c_expr.expr &:= "*ref_fselect(";
      else
        c_expr.expr &:= "*ref_select(";
      end if;
      process_arg(params[1], c_expr);
      c_expr.expr &:= ", ";
      create_name(params[3], c_expr.expr);
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process_ref_setcategory (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "refSetcategory(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_ref_setparams (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "ref_setparams(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_arg(params[2], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_ref_settype (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "refSettype(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_ref_str (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "ref_str(";
    get_std_arg(params[1], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_ref_trace (in ref_list: params, inout expr_type: c_expr) is func

  local
    var reference: traceParam is NIL;
    var type: object_type is void;
  begin
    traceParam := params[1];
    object_type := getExprResultType(traceParam);
    if is_var(traceParam) then
      c_expr.expr &:= "printf(\"var %s: %s is \", ";
    else
      c_expr.expr &:= "printf(\"const %s: %s is \", ";
    end if;
    c_expr.expr &:= c_literal(str(object_type));
    c_expr.expr &:= ", ";
    c_expr.expr &:= c_literal(str(traceParam));
    c_expr.expr &:= ");\n";
    if object_type = inttype then
      c_expr.expr &:= "printf(\"<INTOBJECT> %ld\", ";
      process_expr(traceParam, c_expr);
      c_expr.expr &:= ")";
    elsif object_type = biginttype then
      c_expr.expr &:= "printf(\"<BIGINTOBJECT>\")";
    elsif object_type = chartype then
      c_expr.expr &:= "printf(\"<CHAROBJECT> %c\", ";
      process_expr(traceParam, c_expr);
      c_expr.expr &:= ")";
    elsif object_type = stritype then
      c_expr.expr &:= "printf(\"<STRIOBJECT>\"); ";
      c_expr.expr &:= "prc_print(";
      process_expr(traceParam, c_expr);
      c_expr.expr &:= ")";
    elsif object_type in bstri_types then
      c_expr.expr &:= "printf(\"<BSTRIOBJECT>\")";
    elsif object_type = floattype then
      c_expr.expr &:= "printf(\"<FLOATOBJECT> %f\", ";
      process_expr(traceParam, c_expr);
      c_expr.expr &:= ")";
    elsif object_type = typetype then
      c_expr.expr &:= "printf(\"<TYPEOBJECT> %X\", ";
      process_expr(traceParam, c_expr);
      c_expr.expr &:= ")";
    elsif object_type = proctype then
      c_expr.expr &:= "printf(\"<CALLOBJECT> %X\", ";
      process_expr(traceParam, c_expr);
      c_expr.expr &:= ")";
    elsif object_type = wintype then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= "wintype win = (wintype)(";
      process_expr(traceParam, c_expr);
      c_expr.expr &:= ");\n";
      c_expr.expr &:= "printf(\"<WINOBJECT>\");\n";
      c_expr.expr &:= "if (win == NULL) {\n";
      c_expr.expr &:= "printf(\" *NULL_WINDOW* \");\n";
      c_expr.expr &:= "} else {\n";
      c_expr.expr &:= "printf(\" window [%lu] %lu\", win->usage_count, win);\n";
      c_expr.expr &:= "}\n";
      c_expr.expr &:= "}\n";
    elsif object_type in set_types then
      c_expr.expr &:= "printf(\"<SETOBJECT>\")";
    elsif object_type in simple_pod_type then
      c_expr.expr &:= "printf(\"<simple_pod_type>\")";
    elsif object_type in array_element then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= "arraytype arr = (arraytype)(";
      process_expr(traceParam, c_expr);
      c_expr.expr &:= ");\n";
      c_expr.expr &:= "printf(\"<ARRAYOBJECT>\");\n";
      c_expr.expr &:= "if (arr == NULL) {\n";
      c_expr.expr &:= "printf(\" *NULL_ARRAY* \");\n";
      c_expr.expr &:= "} else {\n";
      c_expr.expr &:= "printf(\" array[%ld .. %ld]\", arr->min_position, arr->max_position);\n";
      c_expr.expr &:= "}\n";
      c_expr.expr &:= "}\n";
    elsif object_type in struct_elements then
      c_expr.expr &:= "printf(\"<STRUCTOBJECT>\")";
    elsif object_type in isInterfaceType then
      c_expr.expr &:= "printf(\"<INTERFACEOBJECT>\")";
    else
      c_expr.expr &:= "printf(\"< ?? >\")";
    end if;
    c_expr.expr &:= ";";
  end func;


const proc: process_ref_type (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "ref_type(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ref_value (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "refValue(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_rfl_append (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    get_create_call_arg(params[3], c_param3);
    if has_temp_values(c_param3) then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    c_expr.expr &:= "rflAppend(&(";
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "), ";
    if c_param3.result_expr <> "" then
      c_expr.expr &:= c_param3.result_expr;
    else
      c_expr.expr &:= c_param3.expr;
    end if;
    c_expr.expr &:= ");\n";
    if has_temp_values(c_param3) then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_rfl_cat (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_list_result(c_expr);
    c_expr.result_expr := "rflCat(";
    get_result_arg(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    get_result_arg(params[3], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_rfl_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if has_temp_values(c_param3) then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    if c_param3.result_expr <> "" then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= "listtype *rfl_ptr=&(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= ");\n";
      c_expr.expr &:= "listtype old_rfl=*rfl_ptr;\n";
      c_expr.expr &:= "*rfl_ptr=";
      c_expr.expr &:= c_param3.result_expr;
      c_expr.expr &:= ";\n";
      c_expr.expr &:= "rflDestr(old_rfl);\n";
      c_expr.expr &:= "}\n";
    else
      c_expr.expr &:= "rflCpy(&(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "), ";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= ");\n";
    end if;
    if has_temp_values(c_param3) then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_rfl_elem (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "rfl_elem(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_rfl_elemcpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param4 is expr_type.value;
    var expr_type: c_param6 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param4.temp_num := c_param1.temp_num;
    process_expr(params[4], c_param4);
    c_param6.temp_num := c_param4.temp_num;
    process_expr(params[6], c_param6);
    if c_param6.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param4.temp_decls;
      c_expr.expr &:= c_param6.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param4.temp_assigns;
      c_expr.expr &:= c_param6.temp_assigns;
    end if;
    c_expr.expr &:= "rflElemcpy(";
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= ", ";
    c_expr.expr &:= c_param4.expr;
    c_expr.expr &:= ", ";
    c_expr.expr &:= c_param6.expr;
    c_expr.expr &:= ");\n";
    if c_param6.temp_num <> 0 then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param4.temp_frees;
      c_expr.expr &:= c_param6.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_rfl_eq (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "rflEq(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_arg(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_rfl_for (in ref_list: params, inout expr_type: c_expr) is func

  local
    var integer: temp_num is 0;
  begin
    incr(c_expr.temp_num);
    temp_num := c_expr.temp_num;
    c_expr.temp_decls &:= "listtype tmp_elem_";
    c_expr.temp_decls &:= str(temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.expr &:= "{\nfor (tmp_elem_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= " = (";
    process_expr(params[4], c_expr);
    c_expr.expr &:= "); tmp_elem_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= " != NULL; tmp_elem_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= " = tmp_elem_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "->next) {\n";
    process_expr(params[2], c_expr);
    c_expr.expr &:= " = tmp_elem_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "->obj;\n";
    process_expr(params[6], c_expr);
    c_expr.expr &:= "}\n}\n";
  end func;


const proc: process_rfl_idx (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "rfl_idx(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_rfl_incl (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param2 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param2.temp_num := c_param1.temp_num;
    process_expr(params[2], c_param2);
    if c_param2.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param2.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param2.temp_assigns;
    end if;
    c_expr.expr &:= "rflIncl(";
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= ", ";
    c_expr.expr &:= c_param2.expr;
    c_expr.expr &:= ");\n";
    if c_param2.temp_num <> 0 then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param2.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_rfl_lng (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "rfl_lng(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_rfl_mklist (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_list_result(c_expr);
    c_expr.result_expr := "rflMklist(";
    get_std_arg(params[1], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_rfl_ne (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "rflNe(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_arg(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_rfl_pos (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "rflPos(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_rfl_setvalue (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "rflSetvalue(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_arg(params[2], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_rfl_tail (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_list_result(c_expr);
    c_expr.result_expr := "rflTail(";
    get_std_arg(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    get_std_arg(params[1], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_rfl_value (in ref_list: params, inout expr_type: c_expr) is func

  begin
    incr(c_expr.temp_num);
    c_expr.temp_decls &:= "listtype tmp_";
    c_expr.temp_decls &:= str(c_expr.temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_frees &:= "rflDestr(tmp_";
    c_expr.temp_frees &:= str(c_expr.temp_num);
    c_expr.temp_frees &:= ");\n";
    c_expr.expr &:= "(tmp_";
    c_expr.expr &:= str(c_expr.temp_num);
    c_expr.expr &:= "=rflValue(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_scr_clear (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "scrClear(";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_scr_flush (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "scrFlush();\n";
  end func;


const proc: process_scr_height (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "scrHeight()";
  end func;


const proc: process_scr_h_scl (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "scrHScroll(";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[6], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_scr_open (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "scrOpen();\n";
  end func;


const proc: process_scr_setpos (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "scrSetpos(";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_scr_v_scl (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "scrVScroll(";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[6], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_scr_width (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "scrWidth()";
  end func;


const proc: process_scr_write (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "scrWrite(";
    process_arg(params[2], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_sct_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if has_temp_values(c_param3) then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    if c_param3.result_expr <> "" then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= "structtype *struct_ptr=&(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= ");\n";
      c_expr.expr &:= "structtype old_struct=*struct_ptr;\n";
      c_expr.expr &:= "*struct_ptr=";
      c_expr.expr &:= c_param3.result_expr;
      c_expr.expr &:= ";\n";
      process_destr_declaration(getExprResultType(params[1]), global_c_expr);
      process_destr_call(getExprResultType(params[1]),
          "old_struct", c_expr.expr);
      c_expr.expr &:= "}\n";
    else
      process_cpy_declaration(getExprResultType(params[1]), global_c_expr);
      process_cpy_call(getExprResultType(params[1]),
          c_param1.expr, c_param3.expr, c_expr.expr);
      c_expr.expr &:= ";\n";
    end if;
    if has_temp_values(c_param3) then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_sct_select (in reference: procedure, in ref_list: params,
    inout expr_type: c_expr) is func

  local
    var type: object_type is void;
    var reference: params1 is NIL;
  begin
    object_type := getExprResultType(params[1]);
    if object_type in struct_elements and params[3] in struct_elements[object_type] then
      c_expr.expr &:= "((structtype)";
      process_arg(params[1], c_expr);
      c_expr.expr &:= ")->stru[";
      c_expr.expr &:= str(struct_elements[object_type][params[3]]);
      c_expr.expr &:= "]";
      if result_type(getType(procedure)) = floattype then
        c_expr.expr &:= ".value.floatvalue";
      else
        c_expr.expr &:= ".value.intvalue";
      end if;
      c_expr.expr &:= "/*->o_";
      c_expr.expr &:= str(obj_number(params[3]));
      c_expr.expr &:= "**";
      c_expr.expr &:= str(params[3]);
      c_expr.expr &:= "*/";
    else
      if result_type(getType(procedure)) = floattype then
        c_expr.expr &:= "*sct_fselect(";
      else
        c_expr.expr &:= "*sct_select(";
      end if;
      process_arg(params[1], c_expr);
      c_expr.expr &:= ", ";
      create_name(params[3], c_expr.expr);
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process_set_arrlit (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_set_result(c_expr);
    c_expr.result_expr := "setArrlit(";
    get_result_arg(params[2], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_set_baselit (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_set_result(c_expr);
    c_expr.result_expr := "setBaselit(";
    get_std_arg(params[2], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_set_card (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "setCard(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_set_conv (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_set_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if has_temp_values(c_param3) then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    if c_param3.result_expr <> "" then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= "settype *set_ptr=&(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= ");\n";
      c_expr.expr &:= "settype old_set=*set_ptr;\n";
      c_expr.expr &:= "*set_ptr=";
      c_expr.expr &:= c_param3.result_expr;
      c_expr.expr &:= ";\n";
      c_expr.expr &:= "setDestr(old_set);\n";
      c_expr.expr &:= "}\n";
    else
      c_expr.expr &:= "setCpy(&(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "), ";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= ");\n";
    end if;
    if has_temp_values(c_param3) then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_set_diff (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_set_result(c_expr);
    c_expr.result_expr := "setDiff(";
    get_result_arg(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    get_result_arg(params[3], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_set_elem (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "setElem(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_arg(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_set_eq (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "setEq(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_arg(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_set_excl (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param2 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param2.temp_num := c_param1.temp_num;
    process_expr(params[2], c_param2);
    if c_param2.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param2.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param2.temp_assigns;
    end if;
    c_expr.expr &:= "setExcl(&(";
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "), ";
    c_expr.expr &:= c_param2.expr;
    c_expr.expr &:= ");\n";
    if c_param2.temp_num <> 0 then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param2.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_set_ge (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "setGe(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_arg(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_set_gt (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "setGt(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_arg(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_set_hashcode (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "setHashCode(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_set_incl (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param2 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param2.temp_num := c_param1.temp_num;
    process_expr(params[2], c_param2);
    if c_param2.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param2.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param2.temp_assigns;
    end if;
    c_expr.expr &:= "setIncl(&(";
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "), ";
    c_expr.expr &:= c_param2.expr;
    c_expr.expr &:= ");\n";
    if c_param2.temp_num <> 0 then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param2.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_set_intersect (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_set_result(c_expr);
    c_expr.result_expr := "setIntersect(";
    get_result_arg(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    get_result_arg(params[3], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_set_le (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "setLe(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_arg(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_set_lt (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "setLt(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_arg(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_set_max (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "setMax(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_set_min (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "setMin(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_set_ne (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "setNe(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_arg(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_set_not_elem (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "setNotElem(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_arg(params[4], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_set_rand (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "setRand(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_set_symdiff (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_set_result(c_expr);
    c_expr.result_expr := "setSymdiff(";
    get_result_arg(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    get_result_arg(params[3], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_set_union (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_set_result(c_expr);
    c_expr.result_expr := "setUnion(";
    get_result_arg(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    get_result_arg(params[3], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_set_value (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "setValue(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_soc_accept (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "socAccept(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", &(";
    process_arg(params[2], c_expr);
    c_expr.expr &:= "))";
  end func;


const proc: process_soc_bind (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "socBind(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_arg(params[2], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_soc_close (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "socClose(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_soc_connect (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "socConnect(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_arg(params[2], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_soc_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "=(";
    c_expr.expr &:= c_param3.expr;
    c_expr.expr &:= ");\n";
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_soc_eq (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") == (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_soc_getc (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "socGetc(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_soc_gets (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "socGets(";
    get_std_arg(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    get_std_arg(params[2], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_soc_inet_addr (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_bstri_result(c_expr);
    c_expr.result_expr &:= "socInetAddr(";
    get_std_arg(params[1], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_soc_inet_local_addr (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_bstri_result(c_expr);
    c_expr.result_expr &:= "socInetLocalAddr(";
    get_std_arg(params[1], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_soc_inet_serv_addr (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_bstri_result(c_expr);
    c_expr.result_expr &:= "socInetServAddr(";
    get_std_arg(params[1], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_soc_line_read (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "socLineRead(";
    get_std_arg(params[1], c_expr);
    c_expr.result_expr &:= ", &(";
    get_std_arg(params[2], c_expr);
    c_expr.result_expr &:= "))";
  end func;


const proc: process_soc_listen (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "socListen(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_soc_ne (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") != (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_soc_recv (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "socRecv(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", &(";
    process_arg(params[2], c_expr);
    c_expr.expr &:= "), ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_soc_send (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "socSend(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_arg(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_soc_socket (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "socSocket(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_soc_word_read (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "socWordRead(";
    get_std_arg(params[1], c_expr);
    c_expr.result_expr &:= ", &(";
    get_std_arg(params[2], c_expr);
    c_expr.result_expr &:= "))";
  end func;


const proc: process_soc_write (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "socWrite(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_arg(params[2], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_str_append (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if has_temp_values(c_param3) then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    if c_param3.result_expr <> "" then
      c_expr.expr &:= "strAppend(&(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "), ";
      c_expr.expr &:= c_param3.result_expr;
      c_expr.expr &:= ");\n";
    else
      c_expr.expr &:= "strAppend(&(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "), ";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= ");\n";
    end if;
    if has_temp_values(c_param3) then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_str_cat (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr := "strConcat(";
    get_result_arg(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    get_result_arg(params[3], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_str_chsplit (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_array_result(array_type[getType(params[1])], c_expr);
    c_expr.result_expr := "strChSplit(";
    get_result_arg(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    get_std_arg(params[2], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_str_clit (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr := "str_clit(";
    get_result_arg(params[1], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_str_cmp (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "strCompare(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_arg(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_str_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if has_temp_values(c_param3) then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    if c_param3.result_expr <> "" then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= "stritype *stri_ptr=&(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= ");\n";
      c_expr.expr &:= "stritype old_stri=*stri_ptr;\n";
      c_expr.expr &:= "*stri_ptr=";
      c_expr.expr &:= c_param3.result_expr;
      c_expr.expr &:= ";\n";
      c_expr.expr &:= "strDestr(old_stri);\n";
      c_expr.expr &:= "}\n";
    else
      c_expr.expr &:= "strCopy(&(";
      c_expr.expr &:= c_param1.expr;
      c_expr.expr &:= "), ";
      c_expr.expr &:= c_param3.expr;
      c_expr.expr &:= ");\n";
    end if;
    if has_temp_values(c_param3) then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_str_elemcpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param4 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param4.temp_num := c_param1.temp_num;
    process_expr(params[4], c_param4);
    c_expr.expr &:= "{\n";
    if c_param4.temp_num <> 0 then
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param4.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param4.temp_assigns;
    end if;
    c_expr.expr &:= "stritype str1=";
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= ";\n";
    c_expr.expr &:= "unsigned long int pos=";
    c_expr.expr &:= c_param4.expr;
    c_expr.expr &:= ";\n";
    c_expr.expr &:= "if (pos >= 1 && pos <= str1->size) {\n";
    c_expr.expr &:= "  str1->mem[pos - 1] = (strelemtype) (";
    process_expr(params[6], c_expr);
    c_expr.expr &:= ");\n";
    c_expr.expr &:= "} else {\n";
    c_expr.expr &:= "  raise_error(RANGE_ERROR);\n";
    c_expr.expr &:= "}\n";
    if c_param4.temp_num <> 0 then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param4.temp_frees;
    end if;
    c_expr.expr &:= "}\n";
  end func;


const proc: process_str_eq (in ref_list: params, inout expr_type: c_expr) is func

  local
    var integer: temp_num is 0;
  begin
    incr(c_expr.temp_num);
    temp_num := c_expr.temp_num;
    c_expr.temp_decls &:= "stritype tmp_a_";
    c_expr.temp_decls &:= str(temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_decls &:= "stritype tmp_b_";
    c_expr.temp_decls &:= str(temp_num);
    c_expr.temp_decls &:= ";\n";
    (* Formula used: (a->size==b->size&&memcmp(a->mem,b->mem,
                     a->size*sizeof(strelemtype))==0) *)
    c_expr.expr &:= "(tmp_a_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "=(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= "),tmp_b_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "=(";
    process_arg(params[3], c_expr);
    c_expr.expr &:= "),tmp_a_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "->size==tmp_b_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "->size&&memcmp(tmp_a_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "->mem,tmp_b_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "->mem,tmp_a_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "->size*sizeof(strelemtype))==0)";
  end func;


const proc: process_str_ge (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "strGe(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_arg(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_str_gt (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "strGt(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_arg(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_str_hashcode (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "strHashCode(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_str_head (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "strHead(";
    get_result_arg(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    get_std_arg(params[4], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_str_idx (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "((stritype)(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= "))->mem[";
    process_expr(params[3], c_expr);
    c_expr.expr &:= "-1]";
  end func;


const proc: process_str_ipos (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "strIpos(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_arg(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_str_le (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "strLe(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_arg(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_str_lit (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "strLit(";
    get_result_arg(params[1], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_str_lng (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "((stritype)(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= "))->size";
  end func;


const proc: process_str_low (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "strLow(";
    get_result_arg(params[1], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_str_lpad (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "strLpad(";
    get_result_arg(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    get_std_arg(params[3], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_str_lt (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "strLt(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_arg(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_str_mult (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "strMult(";
    get_result_arg(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    get_std_arg(params[3], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_str_ne (in ref_list: params, inout expr_type: c_expr) is func

  local
    var integer: temp_num is 0;
  begin
    incr(c_expr.temp_num);
    temp_num := c_expr.temp_num;
    c_expr.temp_decls &:= "stritype tmp_a_";
    c_expr.temp_decls &:= str(temp_num);
    c_expr.temp_decls &:= ";\n";
    c_expr.temp_decls &:= "stritype tmp_b_";
    c_expr.temp_decls &:= str(temp_num);
    c_expr.temp_decls &:= ";\n";
    (* Formula used: (a->size!=b->size||memcmp(a->mem,b->mem,
                     a->size*sizeof(strelemtype))!=0) *)
    c_expr.expr &:= "(tmp_a_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "=(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= "),tmp_b_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "=(";
    process_arg(params[3], c_expr);
    c_expr.expr &:= "),tmp_a_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "->size!=tmp_b_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "->size||memcmp(tmp_a_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "->mem,tmp_b_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "->mem,tmp_a_";
    c_expr.expr &:= str(temp_num);
    c_expr.expr &:= "->size*sizeof(strelemtype))!=0)";
  end func;


const proc: process_str_pos (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "strPos(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_arg(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_str_range (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "strRange(";
    get_result_arg(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    get_std_arg(params[3], c_expr);
    c_expr.result_expr &:= ", ";
    get_std_arg(params[5], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_str_repl (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "strRepl(";
    get_result_arg(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    get_result_arg(params[2], c_expr);
    c_expr.result_expr &:= ", ";
    get_result_arg(params[3], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_str_rpad (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "strRpad(";
    get_result_arg(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    get_std_arg(params[3], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_str_rpos (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "strRpos(";
    process_arg(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_arg(params[2], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_str_split (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_array_result(array_type[getType(params[1])], c_expr);
    c_expr.result_expr := "strSplit(";
    get_result_arg(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    get_result_arg(params[2], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_str_str (in ref_list: params, inout expr_type: c_expr) is func

  begin
    process_expr(params[1], c_expr);
  end func;


const proc: process_str_substr (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "strSubstr(";
    get_result_arg(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    get_std_arg(params[3], c_expr);
    c_expr.result_expr &:= ", ";
    get_std_arg(params[5], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_str_tail (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "strTail(";
    get_result_arg(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    get_std_arg(params[3], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_str_trim (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "strTrim(";
    get_result_arg(params[1], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_str_up (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "strUp(";
    get_result_arg(params[1], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_str_value (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "strValue(";
    get_std_arg(params[1], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_tim_await (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "timAwait(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[4], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[5], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[6], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[7], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[8], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_tim_now (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "timNow(&(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= "), &(";
    process_expr(params[2], c_expr);
    c_expr.expr &:= "), &(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= "), &(";
    process_expr(params[4], c_expr);
    c_expr.expr &:= "), &(";
    process_expr(params[5], c_expr);
    c_expr.expr &:= "), &(";
    process_expr(params[6], c_expr);
    c_expr.expr &:= "), &(";
    process_expr(params[7], c_expr);
    c_expr.expr &:= "), &(";
    process_expr(params[8], c_expr);
    c_expr.expr &:= "));\n";
  end func;


const proc: process_typ_cpy (in ref_list: params, inout expr_type: c_expr) is func

  local
    var expr_type: c_param1 is expr_type.value;
    var expr_type: c_param3 is expr_type.value;
  begin
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= "{\n";
      c_expr.expr &:= c_param1.temp_decls;
      c_expr.expr &:= c_param3.temp_decls;
      c_expr.expr &:= c_param1.temp_assigns;
      c_expr.expr &:= c_param3.temp_assigns;
    end if;
    c_expr.expr &:= c_param1.expr;
    c_expr.expr &:= "=(";
    c_expr.expr &:= c_param3.expr;
    c_expr.expr &:= ");\n";
    if c_param3.temp_num <> 0 then
      c_expr.expr &:= c_param1.temp_frees;
      c_expr.expr &:= c_param3.temp_frees;
      c_expr.expr &:= "}\n";
    end if;
  end func;


const proc: process_typ_eq (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") == (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_typ_hashcode (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(inttype)(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_typ_isderived (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "typIsDerived(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_typ_isfunc (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "typIsFunc(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_typ_isvarfunc (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "typIsVarfunc(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_typ_matchobj (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "typMatchobj(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_typ_meta (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "typMeta(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_typ_ne (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ") != (";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_typ_num (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "typNum(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_typ_result (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "typResult(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_typ_str (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "typStr(";
    get_std_arg(params[1], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_typ_value (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "typValue(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_typ_varconv (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "(";
    process_expr(params[3], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ut8_getc (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "ut8Getc(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ")";
  end func;


const proc: process_ut8_gets (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "ut8Gets(";
    get_std_arg(params[1], c_expr);
    c_expr.result_expr &:= ", ";
    get_std_arg(params[2], c_expr);
    c_expr.result_expr &:= ")";
  end func;


const proc: process_ut8_line_read (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "ut8LineRead(";
    get_std_arg(params[1], c_expr);
    c_expr.result_expr &:= ", &(";
    get_std_arg(params[2], c_expr);
    c_expr.result_expr &:= "))";
  end func;


const proc: process_ut8_seek (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "ut8Seek(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_expr(params[2], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_ut8_word_read (in ref_list: params, inout expr_type: c_expr) is func

  begin
    prepare_stri_result(c_expr);
    c_expr.result_expr &:= "ut8WordRead(";
    get_std_arg(params[1], c_expr);
    c_expr.result_expr &:= ", &(";
    get_std_arg(params[2], c_expr);
    c_expr.result_expr &:= "))";
  end func;


const proc: process_ut8_write (in ref_list: params, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "ut8Write(";
    process_expr(params[1], c_expr);
    c_expr.expr &:= ", ";
    process_arg(params[2], c_expr);
    c_expr.expr &:= ");\n";
  end func;


const proc: process_unknown_action (in string: action_name, inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "/* ACTOBJECT { ";
    c_expr.expr &:= action_name;
    c_expr.expr &:= " }*/";
  end func;


const proc: process_action (in reference: procedure, in ref_list: params,
    inout expr_type: c_expr) is func

  local
    var ACTION: current_action is action "PRC_NOOP";
    var string: action_name is "";
    var string: action_prefix is "";
  begin
    current_action := getValue(procedure, ACTION);
    action_name := str(current_action);
    action_prefix := action_name[ .. 3];
    if action_prefix = "ACT" then
      if action_name = "ACT_CPY" then
        process_act_cpy(params, c_expr);
      elsif action_name = "ACT_STR" then
        process_act_str(params, c_expr);
      elsif action_name = "ACT_VALUE" then
        process_act_value(params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "ARR" then
      if action_name = "ARR_APPEND" then
        process_arr_append(params, c_expr);
      elsif action_name = "ARR_ARRLIT" then
        process_arr_arrlit(params, c_expr);
      elsif action_name = "ARR_ARRLIT2" then
        process_arr_arrlit2(params, c_expr);
      elsif action_name = "ARR_BASELIT" then
        process_arr_baselit(procedure, params, c_expr);
      elsif action_name = "ARR_BASELIT2" then
        process_arr_baselit2(procedure, params, c_expr);
      elsif action_name = "ARR_CAT" then
        process_arr_cat(params, c_expr);
      elsif action_name = "ARR_CONV" then
        process_arr_conv(params, c_expr);
      elsif action_name = "ARR_CPY" then
        process_arr_cpy(params, c_expr);
      elsif action_name = "ARR_CREATE" then
        process_arr_create(procedure, params, c_expr);
      elsif action_name = "ARR_DESTR" then
        process_arr_destr(procedure, params, c_expr);
      elsif action_name = "ARR_EXTEND" then
        process_arr_extend(params, c_expr);
      elsif action_name = "ARR_GEN" then
        process_arr_gen(procedure, params, c_expr);
      elsif action_name = "ARR_HEAD" then
        process_arr_head(params, c_expr);
      elsif action_name = "ARR_IDX" then
        process_arr_idx(procedure, params, c_expr);
      elsif action_name = "ARR_LNG" then
        process_arr_lng(params, c_expr);
      elsif action_name = "ARR_RANGE" then
        process_arr_range(params, c_expr);
      elsif action_name = "ARR_SORT" then
        process_arr_sort(params, c_expr);
      elsif action_name = "ARR_TIMES" then
        process_arr_times(procedure, params, c_expr);
      elsif action_name = "ARR_TAIL" then
        process_arr_tail(params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "BIG" then
      if action_name = "BIG_ABS" then
        process_big_abs(params, c_expr);
      elsif action_name = "BIG_ADD" then
        process_big_add(params, c_expr);
      elsif action_name = "BIG_CLIT" then
        process_big_clit(params, c_expr);
      elsif action_name = "BIG_CMP" then
        process_big_cmp(params, c_expr);
      elsif action_name = "BIG_CPY" then
        process_big_cpy(params, c_expr);
      elsif action_name = "BIG_DECR" then
        process_big_decr(params, c_expr);
      elsif action_name = "BIG_DIV" then
        process_big_div(params, c_expr);
      elsif action_name = "BIG_EQ" then
        process_big_eq(params, c_expr);
      elsif action_name = "BIG_GE" then
        process_big_ge(params, c_expr);
      elsif action_name = "BIG_GROW" then
        process_big_grow(params, c_expr);
      elsif action_name = "BIG_GT" then
        process_big_gt(params, c_expr);
      elsif action_name = "BIG_HASHCODE" then
        process_big_hashcode(params, c_expr);
      elsif action_name = "BIG_ICONV" then
        process_big_iconv(params, c_expr);
      elsif action_name = "BIG_INCR" then
        process_big_incr(params, c_expr);
      elsif action_name = "BIG_IPOW" then
        process_big_ipow(params, c_expr);
      elsif action_name = "BIG_LE" then
        process_big_le(params, c_expr);
      elsif action_name = "BIG_LOG2" then
        process_big_log2(params, c_expr);
      elsif action_name = "BIG_LT" then
        process_big_lt(params, c_expr);
      elsif action_name = "BIG_MCPY" then
        process_big_mcpy(params, c_expr);
      elsif action_name = "BIG_MDIV" then
        process_big_mdiv(params, c_expr);
      elsif action_name = "BIG_MINUS" then
        process_big_minus(params, c_expr);
      elsif action_name = "BIG_MOD" then
        process_big_mod(params, c_expr);
      elsif action_name = "BIG_MULT" then
        process_big_mult(params, c_expr);
      elsif action_name = "BIG_NE" then
        process_big_ne(params, c_expr);
      elsif action_name = "BIG_ODD" then
        process_big_odd(params, c_expr);
      elsif action_name = "BIG_ORD" then
        process_big_ord(params, c_expr);
      elsif action_name = "BIG_PARSE" then
        process_big_parse(params, c_expr);
      elsif action_name = "BIG_SBTR" then
        process_big_sbtr(params, c_expr);
      elsif action_name = "BIG_SHRINK" then
        process_big_shrink(params, c_expr);
      elsif action_name = "BIG_PRED" then
        process_big_pred(params, c_expr);
      elsif action_name = "BIG_RAND" then
        process_big_rand(params, c_expr);
      elsif action_name = "BIG_REM" then
        process_big_rem(params, c_expr);
      elsif action_name = "BIG_STR" then
        process_big_str(params, c_expr);
      elsif action_name = "BIG_SUCC" then
        process_big_succ(params, c_expr);
      elsif action_name = "BIG_VALUE" then
        process_big_value(params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "BLN" then
      if action_name = "BLN_AND" then
        process_bln_and(params, c_expr);
      elsif action_name = "BLN_CPY" then
        process_bln_cpy(params, c_expr);
      elsif action_name = "BLN_EQ" then
        process_bln_eq(params, c_expr);
      elsif action_name = "BLN_GE" then
        process_bln_ge(params, c_expr);
      elsif action_name = "BLN_GT" then
        process_bln_gt(params, c_expr);
      elsif action_name = "BLN_ICONV" then
        process_bln_iconv(params, c_expr);
      elsif action_name = "BLN_LE" then
        process_bln_le(params, c_expr);
      elsif action_name = "BLN_LT" then
        process_bln_lt(params, c_expr);
      elsif action_name = "BLN_NE" then
        process_bln_ne(params, c_expr);
      elsif action_name = "BLN_NOT" then
        process_bln_not(params, c_expr);
      elsif action_name = "BLN_OR" then
        process_bln_or(params, c_expr);
      elsif action_name = "BLN_ORD" then
        process_bln_ord(params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "BST" then
      if action_name = "BST_CPY" then
        process_bst_cpy(params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "CHR" then
      if action_name = "CHR_CHR" then
        process_chr_chr(params, c_expr);
      elsif action_name = "CHR_CPY" then
        process_chr_cpy(params, c_expr);
      elsif action_name = "CHR_EQ" then
        process_chr_eq(params, c_expr);
      elsif action_name = "CHR_DECR" then
        process_chr_decr(params, c_expr);
      elsif action_name = "CHR_GE" then
        process_chr_ge(params, c_expr);
      elsif action_name = "CHR_GROW" then
        process_chr_grow(params, c_expr);
      elsif action_name = "CHR_GT" then
        process_chr_gt(params, c_expr);
      elsif action_name = "CHR_HASHCODE" then
        process_chr_hashcode(params, c_expr);
      elsif action_name = "CHR_ICONV" then
        process_chr_iconv(params, c_expr);
      elsif action_name = "CHR_INCR" then
        process_chr_incr(params, c_expr);
      elsif action_name = "CHR_LE" then
        process_chr_le(params, c_expr);
      elsif action_name = "CHR_LOW" then
        process_chr_low(params, c_expr);
      elsif action_name = "CHR_LT" then
        process_chr_lt(params, c_expr);
      elsif action_name = "CHR_NE" then
        process_chr_ne(params, c_expr);
      elsif action_name = "CHR_ORD" then
        process_chr_ord(params, c_expr);
      elsif action_name = "CHR_PRED" then
        process_chr_pred(params, c_expr);
      elsif action_name = "CHR_SHRINK" then
        process_chr_shrink(params, c_expr);
      elsif action_name = "CHR_STR" then
        process_chr_str(params, c_expr);
      elsif action_name = "CHR_SUCC" then
        process_chr_succ(params, c_expr);
      elsif action_name = "CHR_UP" then
        process_chr_up(params, c_expr);
      elsif action_name = "CHR_VALUE" then
        process_chr_value(params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "CLS" then
      if action_name = "CLS_CONV2" then
        process_cls_conv2(params, c_expr);
      elsif action_name = "CLS_CPY" then
        process_cls_cpy(params, c_expr);
      elsif action_name = "CLS_CPY2" then
        process_cls_cpy2(params, c_expr);
      elsif action_name = "CLS_EQ" then
        process_cls_eq(params, c_expr);
      elsif action_name = "CLS_NE" then
        process_cls_ne(params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "CMD" then
      if action_name = "CMD_CONFIG_VALUE" then
        process_cmd_config_value(params, c_expr);
      elsif action_name = "CMD_COPY" then
        process_cmd_copy(params, c_expr);
      elsif action_name = "CMD_GETCWD" then
        process_cmd_getcwd(params, c_expr);
      elsif action_name = "CMD_LNG" then
        process_cmd_lng(params, c_expr);
      elsif action_name = "CMD_LS" then
        process_cmd_ls(params, c_expr);
      elsif action_name = "CMD_MKDIR" then
        process_cmd_mkdir(params, c_expr);
      elsif action_name = "CMD_MOVE" then
        process_cmd_move(params, c_expr);
      elsif action_name = "CMD_REMOVE" then
        process_cmd_remove(params, c_expr);
      elsif action_name = "CMD_SH" then
        process_cmd_sh(params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "DCL" then
      if action_name = "DCL_CONST" then
        write_object_declaration := FALSE;
      elsif action_name = "DCL_FWD" then
        write_object_declaration := FALSE;
      elsif action_name = "DCL_GLOBAL" then
        write_object_declaration := FALSE;
      elsif action_name = "DCL_VAR" then
        write_object_declaration := FALSE;
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "DRW" then
      if action_name = "DRW_ARC" then
        process_drw_arc(params, c_expr);
      elsif action_name = "DRW_ARC2" then
        process_drw_arc2(params, c_expr);
      elsif action_name = "DRW_BACKGROUND" then
        process_drw_background(params, c_expr);
      elsif action_name = "DRW_CIRCLE" then
        process_drw_circle(params, c_expr);
      elsif action_name = "DRW_CLEAR" then
        process_drw_clear(params, c_expr);
      elsif action_name = "DRW_COLOR" then
        process_drw_color(params, c_expr);
      elsif action_name = "DRW_COPYAREA" then
        process_drw_copyarea(params, c_expr);
      elsif action_name = "DRW_CPY" then
        process_drw_cpy(params, c_expr);
      elsif action_name = "DRW_EQ" then
        process_drw_eq(params, c_expr);
      elsif action_name = "DRW_FARCCHORD" then
        process_drw_farcchord(params, c_expr);
      elsif action_name = "DRW_FARCPIESLICE" then
        process_drw_farcpieslice(params, c_expr);
      elsif action_name = "DRW_FCIRCLE" then
        process_drw_fcircle(params, c_expr);
      elsif action_name = "DRW_FELLIPSE" then
        process_drw_fellipse(params, c_expr);
      elsif action_name = "DRW_FLUSH" then
        process_drw_flush(params, c_expr);
      elsif action_name = "DRW_GET" then
        process_drw_get(params, c_expr);
      elsif action_name = "DRW_HEIGHT" then
        process_drw_height(params, c_expr);
      elsif action_name = "DRW_IMAGE" then
        process_drw_image(params, c_expr);
      elsif action_name = "DRW_LINE" then
        process_drw_line(params, c_expr);
      elsif action_name = "DRW_NE" then
        process_drw_ne(params, c_expr);
      elsif action_name = "DRW_NEW_PIXMAP" then
        process_drw_new_pixmap(params, c_expr);
      elsif action_name = "DRW_OPEN" then
        process_drw_open(params, c_expr);
      elsif action_name = "DRW_PARC" then
        process_drw_parc(params, c_expr);
      elsif action_name = "DRW_PCIRCLE" then
        process_drw_pcircle(params, c_expr);
      elsif action_name = "DRW_PFARCCHORD" then
        process_drw_pfarcchord(params, c_expr);
      elsif action_name = "DRW_PFARCPIESLICE" then
        process_drw_pfarcpieslice(params, c_expr);
      elsif action_name = "DRW_PFCIRCLE" then
        process_drw_pfcircle(params, c_expr);
      elsif action_name = "DRW_PFELLIPSE" then
        process_drw_pfellipse(params, c_expr);
      elsif action_name = "DRW_FELLIPSE" then
        process_drw_fellipse(params, c_expr);
      elsif action_name = "DRW_PLINE" then
        process_drw_pline(params, c_expr);
      elsif action_name = "DRW_POINT" then
        process_drw_point(params, c_expr);
      elsif action_name = "DRW_PPOINT" then
        process_drw_ppoint(params, c_expr);
      elsif action_name = "DRW_PRECT" then
        process_drw_prect(params, c_expr);
      elsif action_name = "DRW_PUT" then
        process_drw_put(params, c_expr);
      elsif action_name = "DRW_RECT" then
        process_drw_rect(params, c_expr);
      elsif action_name = "DRW_RGBCOL" then
        process_drw_rgbcol(params, c_expr);
      elsif action_name = "DRW_TEXT" then
        process_drw_text(params, c_expr);
      elsif action_name = "DRW_WIDTH" then
        process_drw_width(params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "ENU" then
      if action_name = "ENU_CPY" then
        process_enu_cpy(params, c_expr);
      elsif action_name = "ENU_EQ" then
        process_enu_eq(params, c_expr);
      elsif action_name = "ENU_ICONV2" then
        process_enu_iconv2(params, c_expr);
      elsif action_name = "ENU_NE" then
        process_enu_ne(params, c_expr);
      elsif action_name = "ENU_ORD2" then
        process_enu_ord2(params, c_expr);
      elsif action_name = "ENU_VALUE" then
        process_enu_value(params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "FIL" then
      if action_name = "FIL_BIG_LNG" then
        process_fil_big_lng(params, c_expr);
      elsif action_name = "FIL_BIG_SEEK" then
        process_fil_big_seek(params, c_expr);
      elsif action_name = "FIL_BIG_TELL" then
        process_fil_big_tell(params, c_expr);
      elsif action_name = "FIL_CLOSE" then
        process_fil_close(params, c_expr);
      elsif action_name = "FIL_CPY" then
        process_fil_cpy(params, c_expr);
      elsif action_name = "FIL_EQ" then
        process_fil_eq(params, c_expr);
      elsif action_name = "FIL_EOF" then
        process_fil_eof(params, c_expr);
      elsif action_name = "FIL_FLUSH" then
        process_fil_flush(params, c_expr);
      elsif action_name = "FIL_GETC" then
        process_fil_getc(params, c_expr);
      elsif action_name = "FIL_GETS" then
        process_fil_gets(params, c_expr);
      elsif action_name = "FIL_LINE_READ" then
        process_fil_line_read(params, c_expr);
      elsif action_name = "FIL_LIT" then
        process_fil_lit(params, c_expr);
      elsif action_name = "FIL_LNG" then
        process_fil_lng(params, c_expr);
      elsif action_name = "FIL_NE" then
        process_fil_ne(params, c_expr);
      elsif action_name = "FIL_NIL" then
        process_fil_nil(params, c_expr);
      elsif action_name = "FIL_OPEN" then
        process_fil_open(params, c_expr);
      elsif action_name = "FIL_POPEN" then
        process_fil_popen(params, c_expr);
      elsif action_name = "FIL_SEEK" then
        process_fil_seek(params, c_expr);
      elsif action_name = "FIL_TELL" then
        process_fil_tell(params, c_expr);
      elsif action_name = "FIL_WRITE" then
        process_fil_write(params, c_expr);
      elsif action_name = "FIL_WORD_READ" then
        process_fil_word_read(params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "FLT" then
      if action_name = "FLT_A2TAN" then
        process_flt_a2tan(params, c_expr);
      elsif action_name = "FLT_ABS" then
        process_flt_abs(params, c_expr);
      elsif action_name = "FLT_ADD" then
        process_flt_add(params, c_expr);
      elsif action_name = "FLT_ACOS" then
        process_flt_acos(params, c_expr);
      elsif action_name = "FLT_ASIN" then
        process_flt_asin(params, c_expr);
      elsif action_name = "FLT_ATAN" then
        process_flt_atan(params, c_expr);
      elsif action_name = "FLT_CEIL" then
        process_flt_ceil(params, c_expr);
      elsif action_name = "FLT_CMP" then
        process_flt_cmp(params, c_expr);
      elsif action_name = "FLT_COS" then
        process_flt_cos(params, c_expr);
      elsif action_name = "FLT_CPY" then
        process_flt_cpy(params, c_expr); 
      elsif action_name = "FLT_DGTS" then
        process_flt_dgts(params, c_expr);
      elsif action_name = "FLT_DIV" then
        process_flt_div(params, c_expr);
      elsif action_name = "FLT_EQ" then
        process_flt_eq(params, c_expr);
      elsif action_name = "FLT_EXP" then
        process_flt_exp(params, c_expr);
      elsif action_name = "FLT_FLOOR" then
        process_flt_floor(params, c_expr);
      elsif action_name = "FLT_GE" then
        process_flt_ge(params, c_expr);
      elsif action_name = "FLT_GROW" then
        process_flt_grow(params, c_expr);
      elsif action_name = "FLT_GT" then
        process_flt_gt(params, c_expr);
      elsif action_name = "FLT_HASHCODE" then
        process_flt_hashcode(params, c_expr);
      elsif action_name = "FLT_IFLT" then
        process_flt_iflt(params, c_expr);
      elsif action_name = "FLT_IPOW" then
        process_flt_ipow(params, c_expr);
      elsif action_name = "FLT_ISNAN" then
        process_flt_isnan(params, c_expr);
      elsif action_name = "FLT_LE" then
        process_flt_le(params, c_expr);
      elsif action_name = "FLT_LOG" then
        process_flt_log(params, c_expr);
      elsif action_name = "FLT_LOG10" then
        process_flt_log10(params, c_expr);
      elsif action_name = "FLT_LT" then
        process_flt_lt(params, c_expr);
      elsif action_name = "FLT_MCPY" then
        process_flt_mcpy(params, c_expr);
      elsif action_name = "FLT_MINUS" then
        process_flt_minus(params, c_expr);
      elsif action_name = "FLT_MULT" then
        process_flt_mult(params, c_expr);
      elsif action_name = "FLT_NE" then
        process_flt_ne(params, c_expr);
      elsif action_name = "FLT_PARSE" then
        process_flt_parse(params, c_expr);
      elsif action_name = "FLT_POW" then
        process_flt_pow(params, c_expr);
      elsif action_name = "FLT_RAND" then
        process_flt_rand(params, c_expr);
      elsif action_name = "FLT_ROUND" then
        process_flt_round(params, c_expr);
      elsif action_name = "FLT_SBTR" then
        process_flt_sbtr(params, c_expr);
      elsif action_name = "FLT_SHRINK" then
        process_flt_shrink(params, c_expr);
      elsif action_name = "FLT_SIN" then
        process_flt_sin(params, c_expr);
      elsif action_name = "FLT_SQRT" then
        process_flt_sqrt(params, c_expr);
      elsif action_name = "FLT_STR" then
        process_flt_str(params, c_expr);
      elsif action_name = "FLT_TAN" then
        process_flt_tan(params, c_expr);
      elsif action_name = "FLT_TRUNC" then
        process_flt_trunc(params, c_expr);
      elsif action_name = "FLT_VALUE" then
        process_flt_value(params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "GKB" then
      if action_name = "GKB_BUSY_GETC" then
        process_gkb_busy_getc(params, c_expr);
      elsif action_name = "GKB_GETC" then
        process_gkb_getc(params, c_expr);
      elsif action_name = "GKB_GETS" then
        process_gkb_gets(params, c_expr);
      elsif action_name = "GKB_KEYPRESSED" then
        process_gkb_keypressed(params, c_expr);
      elsif action_name = "GKB_LINE_READ" then
        process_gkb_line_read(params, c_expr);
      elsif action_name = "GKB_RAW_GETC" then
        process_gkb_raw_getc(params, c_expr);
      elsif action_name = "GKB_WORD_READ" then
        process_gkb_word_read(params, c_expr);
      elsif action_name = "GKB_XPOS" then
        process_gkb_xpos(params, c_expr);
      elsif action_name = "GKB_YPOS" then
        process_gkb_ypos(params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "HSH" then
      if action_name = "HSH_CONTAINS" then
        process_hsh_contains(params, c_expr);
      elsif action_name = "HSH_CPY" then
        process_hsh_cpy(params, c_expr);
      elsif action_name = "HSH_CREATE" then
        process_hsh_create(params, c_expr);
      elsif action_name = "HSH_DESTR" then
        process_hsh_destr(params, c_expr);
      elsif action_name = "HSH_EXCL" then
        process_hsh_excl(params, c_expr);
      elsif action_name = "HSH_FOR" then
        process_hsh_for(params, c_expr);
      elsif action_name = "HSH_FOR_DATA_KEY" then
        process_hsh_for_data_key(params, c_expr);
      elsif action_name = "HSH_FOR_KEY" then
        process_hsh_for_key(params, c_expr);
      elsif action_name = "HSH_IDX" then
        process_hsh_idx(procedure, params, c_expr);
      elsif action_name = "HSH_INCL" then
        process_hsh_incl(params, c_expr);
      elsif action_name = "HSH_KEYS" then
        process_hsh_keys(params, c_expr);
      elsif action_name = "HSH_LNG" then
        process_hsh_lng(params, c_expr);
      elsif action_name = "HSH_VALUES" then
        process_hsh_values(params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "INT" then
      if action_name = "INT_ABS" then
        process_int_abs(params, c_expr);
      elsif action_name = "INT_ADD" then
        process_int_add(params, c_expr);
      elsif action_name = "INT_BINOM" then
        process_int_binom(params, c_expr);
      elsif action_name = "INT_CMP" then
        process_int_cmp(params, c_expr);
      elsif action_name = "INT_CONV" then
        process_int_conv(params, c_expr);
      elsif action_name = "INT_CPY" then
        process_int_cpy(params, c_expr);
      elsif action_name = "INT_DECR" then
        process_int_decr(params, c_expr);
      elsif action_name = "INT_DIV" then
        process_int_div(params, c_expr);
      elsif action_name = "INT_EQ" then
        process_int_eq(params, c_expr);
      elsif action_name = "INT_FACT" then
        process_int_fact(params, c_expr);
      elsif action_name = "INT_GE" then
        process_int_ge(params, c_expr);
      elsif action_name = "INT_GROW" then
        process_int_grow(params, c_expr);
      elsif action_name = "INT_GT" then
        process_int_gt(params, c_expr);
      elsif action_name = "INT_HASHCODE" then
        process_int_hashcode(params, c_expr);
      elsif action_name = "INT_INCR" then
        process_int_incr(params, c_expr);
      elsif action_name = "INT_LOG2" then
        process_int_log2(params, c_expr);
      elsif action_name = "INT_LE" then
        process_int_le(params, c_expr);
      elsif action_name = "INT_LT" then
        process_int_lt(params, c_expr);
      elsif action_name = "INT_MCPY" then
        process_int_mcpy(params, c_expr);
      elsif action_name = "INT_MDIV" then
        process_int_mdiv(params, c_expr);
      elsif action_name = "INT_MINUS" then
        process_int_minus(params, c_expr);
      elsif action_name = "INT_MOD" then
        process_int_mod(params, c_expr);
      elsif action_name = "INT_MULT" then
        process_int_mult(params, c_expr);
      elsif action_name = "INT_NE" then
        process_int_ne(params, c_expr);
      elsif action_name = "INT_ODD" then
        process_int_odd(params, c_expr);
      elsif action_name = "INT_ORD" then
        process_int_ord(params, c_expr);
      elsif action_name = "INT_PARSE" then
        process_int_parse(params, c_expr);
      elsif action_name = "INT_RAND" then
        process_int_rand(params, c_expr);
      elsif action_name = "INT_POW" then
        process_int_pow(params, c_expr);
      elsif action_name = "INT_PRED" then
        process_int_pred(params, c_expr);
      elsif action_name = "INT_REM" then
        process_int_rem(params, c_expr);
      elsif action_name = "INT_SBTR" then
        process_int_sbtr(params, c_expr);
      elsif action_name = "INT_SHRINK" then
        process_int_shrink(params, c_expr);
      elsif action_name = "INT_SQRT" then
        process_int_sqrt(params, c_expr);
      elsif action_name = "INT_STR" then
        process_int_str(params, c_expr);
      elsif action_name = "INT_SUCC" then
        process_int_succ(params, c_expr);
      elsif action_name = "INT_VALUE" then
        process_int_value(params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "KBD" then
      if action_name = "KBD_BUSY_GETC" then
        process_kbd_busy_getc(params, c_expr);
      elsif action_name = "KBD_GETC" then
        process_kbd_getc(params, c_expr);
      elsif action_name = "KBD_GETS" then
        process_kbd_gets(params, c_expr);
      elsif action_name = "KBD_KEYPRESSED" then
        process_kbd_keypressed(params, c_expr);
      elsif action_name = "KBD_LINE_READ" then
        process_kbd_line_read(params, c_expr);
      elsif action_name = "KBD_RAW_GETC" then
        process_kbd_raw_getc(params, c_expr);
      elsif action_name = "KBD_WORD_READ" then
        process_kbd_word_read(params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "PRC" then
      if action_name = "PRC_ARGS" then
        process_prc_args(params, c_expr);
      elsif action_name = "PRC_BLOCK" then
        process_prc_block(params, c_expr);
      elsif action_name = "PRC_CASE" then
        process_prc_case(params, c_expr);
      elsif action_name = "PRC_CASE_DEF" then
        process_prc_case_def(params, c_expr);
      elsif action_name = "PRC_DYNAMIC" then
        process_prc_dynamic(procedure, params, c_expr);
      elsif action_name = "PRC_EXIT" then
        process_prc_exit(params, c_expr);
      elsif action_name = "PRC_FOR_DOWNTO" then
        process_prc_for_downto(params, c_expr);
      elsif action_name = "PRC_FOR_TO" then
        process_prc_for_to(params, c_expr);
      elsif action_name = "PRC_HSIZE" then
        process_prc_hsize(params, c_expr);
      elsif action_name = "PRC_IF" then
        process_prc_if(params, c_expr);
      elsif action_name = "PRC_IF_ELSIF" then
        process_prc_if_elsif(params, c_expr);
      elsif action_name = "PRC_NOOP" then
        process_prc_noop(procedure, params, c_expr);
      elsif action_name = "PRC_PRINT" then
        process_prc_print(params, c_expr);
      elsif action_name = "PRC_RAISE" then
        process_prc_raise(params, c_expr);
      elsif action_name = "PRC_REPEAT" then
        process_prc_repeat(params, c_expr);
      elsif action_name = "PRC_WHILE" then
        process_prc_while(params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "PRG" then
      if action_name = "PRG_ANALYZE" then
        process_prg_analyze(params, c_expr);
      elsif action_name = "PRG_CPY" then
        process_prg_cpy(params, c_expr);
      elsif action_name = "PRG_DECL_OBJECTS" then
        process_prg_decl_objects(params, c_expr);
      elsif action_name = "PRG_EQ" then
        process_prg_eq(params, c_expr);
      elsif action_name = "PRG_ERROR_COUNT" then
        process_prg_error_count(params, c_expr);
      elsif action_name = "PRG_EVAL" then
        process_prg_eval(params, c_expr);
      elsif action_name = "PRG_MATCH" then
        process_prg_match(params, c_expr);
      elsif action_name = "PRG_NAME" then
        process_prg_name(params, c_expr);
      elsif action_name = "PRG_NE" then
        process_prg_ne(params, c_expr);
      elsif action_name = "PRG_SYOBJECT" then
        process_prg_syobject(params, c_expr);
      elsif action_name = "PRG_SYSVAR" then
        process_prg_sysvar(params, c_expr);
      elsif action_name = "PRG_VALUE" then
        process_prg_value(params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "REF" then
      if action_name = "REF_ADDR" then
        process_ref_addr(params, c_expr);
      elsif action_name = "REF_ALLOC" then
        process_ref_alloc(params, c_expr);
      elsif action_name = "REF_ARRMINPOS" then
        process_ref_arrminpos(params, c_expr);
      elsif action_name = "REF_ARRTOLIST" then
        process_ref_arrtolist(params, c_expr);
      elsif action_name = "REF_BODY" then
        process_ref_body(params, c_expr);
      elsif action_name = "REF_CATEGORY" then
        process_ref_category(params, c_expr);
      elsif action_name = "REF_CPY" then
        process_ref_cpy(params, c_expr);
      elsif action_name = "REF_DEREF" then
        process_ref_deref(params, c_expr);
      elsif action_name = "REF_EQ" then
        process_ref_eq(params, c_expr);
      elsif action_name = "REF_HASHCODE" then
        process_ref_hashcode(params, c_expr);
      elsif action_name = "REF_ISVAR" then
        process_ref_isvar(params, c_expr);
      elsif action_name = "REF_ITFTOSCT" then
        process_ref_itftosct(params, c_expr);
      elsif action_name = "REF_LOCAL_CONSTS" then
        process_ref_local_consts(params, c_expr);
      elsif action_name = "REF_LOCAL_VARS" then
        process_ref_local_vars(params, c_expr);
      elsif action_name = "REF_NE" then
        process_ref_ne(params, c_expr);
      elsif action_name = "REF_NUM" then
        process_ref_num(params, c_expr);
      elsif action_name = "REF_PARAMS" then
        process_ref_params(params, c_expr);
      elsif action_name = "REF_RESINI" then
        process_ref_resini(params, c_expr);
      elsif action_name = "REF_RESULT" then
        process_ref_result(params, c_expr);
      elsif action_name = "REF_SCTTOLIST" then
        process_ref_scttolist(params, c_expr);
      elsif action_name = "REF_SELECT" then
        process_ref_select(procedure, params, c_expr);
      elsif action_name = "REF_SETCATEGORY" then
        process_ref_setcategory(params, c_expr);
      elsif action_name = "REF_SETPARAMS" then
        process_ref_setparams(params, c_expr);
      elsif action_name = "REF_SETTYPE" then
        process_ref_settype(params, c_expr);
      elsif action_name = "REF_STR" then
        process_ref_str(params, c_expr);
      elsif action_name = "REF_TRACE" then
        process_ref_trace(params, c_expr);
      elsif action_name = "REF_TYPE" then
        process_ref_type(params, c_expr);
      elsif action_name = "REF_VALUE" then
        process_ref_value(params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "RFL" then
      if action_name = "RFL_APPEND" then
        process_rfl_append(params, c_expr);
      elsif action_name = "RFL_CAT" then
        process_rfl_cat(params, c_expr);
      elsif action_name = "RFL_CPY" then
        process_rfl_cpy(params, c_expr);
      elsif action_name = "RFL_ELEM" then
        process_rfl_elem(params, c_expr);
      elsif action_name = "RFL_ELEMCPY" then
        process_rfl_elemcpy(params, c_expr);
      elsif action_name = "RFL_EQ" then
        process_rfl_eq(params, c_expr);
      elsif action_name = "RFL_FOR" then
        process_rfl_for(params, c_expr);
      elsif action_name = "RFL_IDX" then
        process_rfl_idx(params, c_expr);
      elsif action_name = "RFL_INCL" then
        process_rfl_incl(params, c_expr);
      elsif action_name = "RFL_LNG" then
        process_rfl_lng(params, c_expr);
      elsif action_name = "RFL_MKLIST" then
        process_rfl_mklist(params, c_expr);
      elsif action_name = "RFL_NE" then
        process_rfl_ne(params, c_expr);
      elsif action_name = "RFL_POS" then
        process_rfl_pos(params, c_expr);
      elsif action_name = "RFL_SETVALUE" then
        process_rfl_setvalue(params, c_expr);
      elsif action_name = "RFL_TAIL" then
        process_rfl_tail(params, c_expr);
      elsif action_name = "RFL_VALUE" then
        process_rfl_value(params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "SCR" then
      if action_name = "SCR_CLEAR" then
        process_scr_clear(params, c_expr);
      elsif action_name = "SCR_FLUSH" then
        process_scr_flush(params, c_expr);
      elsif action_name = "SCR_HEIGHT" then
        process_scr_height(params, c_expr);
      elsif action_name = "SCR_H_SCL" then
        process_scr_h_scl(params, c_expr);
      elsif action_name = "SCR_OPEN" then
        process_scr_open(params, c_expr);
      elsif action_name = "SCR_SETPOS" then
        process_scr_setpos(params, c_expr);
      elsif action_name = "SCR_V_SCL" then
        process_scr_v_scl(params, c_expr);
      elsif action_name = "SCR_WIDTH" then
        process_scr_width(params, c_expr);
      elsif action_name = "SCR_WRITE" then
        process_scr_write(params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "SCT" then
      if action_name = "SCT_CPY" then
        process_sct_cpy(params, c_expr);
      elsif action_name = "SCT_SELECT" then
        process_sct_select(procedure, params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "SET" then
      if action_name = "SET_ARRLIT" then
        process_set_arrlit(params, c_expr);
      elsif action_name = "SET_BASELIT" then
        process_set_baselit(params, c_expr);
      elsif action_name = "SET_CARD" then
        process_set_card(params, c_expr);
      elsif action_name = "SET_CONV" then
        process_set_conv(params, c_expr);
      elsif action_name = "SET_CPY" then
        process_set_cpy(params, c_expr);
      elsif action_name = "SET_DIFF" then
        process_set_diff(params, c_expr);
      elsif action_name = "SET_ELEM" then
        process_set_elem(params, c_expr);
      elsif action_name = "SET_EQ" then
        process_set_eq(params, c_expr);
      elsif action_name = "SET_EXCL" then
        process_set_excl(params, c_expr);
      elsif action_name = "SET_GE" then
        process_set_ge(params, c_expr);
      elsif action_name = "SET_GT" then
        process_set_gt(params, c_expr);
      elsif action_name = "SET_HASHCODE" then
        process_set_hashcode(params, c_expr);
      elsif action_name = "SET_INCL" then
        process_set_incl(params, c_expr);
      elsif action_name = "SET_INTERSECT" then
        process_set_intersect(params, c_expr);
      elsif action_name = "SET_LE" then
        process_set_le(params, c_expr);
      elsif action_name = "SET_LT" then
        process_set_lt(params, c_expr);
      elsif action_name = "SET_MAX" then
        process_set_max(params, c_expr);
      elsif action_name = "SET_MIN" then
        process_set_min(params, c_expr);
      elsif action_name = "SET_NE" then
        process_set_ne(params, c_expr);
      elsif action_name = "SET_NOT_ELEM" then
        process_set_not_elem(params, c_expr);
      elsif action_name = "SET_RAND" then
        process_set_rand(params, c_expr);
      elsif action_name = "SET_SYMDIFF" then
        process_set_symdiff(params, c_expr);
      elsif action_name = "SET_UNION" then
        process_set_union(params, c_expr);
      elsif action_name = "SET_VALUE" then
        process_set_value(params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "SOC" then
      if action_name = "SOC_ACCEPT" then
        process_soc_accept(params, c_expr);
      elsif action_name = "SOC_BIND" then
        process_soc_bind(params, c_expr);
      elsif action_name = "SOC_CLOSE" then
        process_soc_close(params, c_expr);
      elsif action_name = "SOC_CONNECT" then
        process_soc_connect(params, c_expr);
      elsif action_name = "SOC_CPY" then
        process_soc_cpy(params, c_expr);
      elsif action_name = "SOC_EQ" then
        process_soc_eq(params, c_expr);
      elsif action_name = "SOC_GETC" then
        process_soc_getc(params, c_expr);
      elsif action_name = "SOC_GETS" then
        process_soc_gets(params, c_expr);
      elsif action_name = "SOC_INET_ADDR" then
        process_soc_inet_addr(params, c_expr);
      elsif action_name = "SOC_INET_LOCAL_ADDR" then
        process_soc_inet_local_addr(params, c_expr);
      elsif action_name = "SOC_INET_SERV_ADDR" then
        process_soc_inet_serv_addr(params, c_expr);
      elsif action_name = "SOC_LINE_READ" then
        process_soc_line_read(params, c_expr);
      elsif action_name = "SOC_LISTEN" then
        process_soc_listen(params, c_expr);
      elsif action_name = "SOC_NE" then
        process_soc_ne(params, c_expr);
      elsif action_name = "SOC_RECV" then
        process_soc_recv(params, c_expr);
      elsif action_name = "SOC_SEND" then
        process_soc_send(params, c_expr);
      elsif action_name = "SOC_SOCKET" then
        process_soc_socket(params, c_expr);
      elsif action_name = "SOC_WORD_READ" then
        process_soc_word_read(params, c_expr);
      elsif action_name = "SOC_WRITE" then
        process_soc_write(params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "STR" then
      if action_name = "STR_APPEND" then
        process_str_append(params, c_expr);
      elsif action_name = "STR_CAT" then
        process_str_cat(params, c_expr);
      elsif action_name = "STR_CHSPLIT" then
        process_str_chsplit(params, c_expr);
      elsif action_name = "STR_CLIT" then
        process_str_clit(params, c_expr);
      elsif action_name = "STR_CMP" then
        process_str_cmp(params, c_expr);
      elsif action_name = "STR_CPY" then
        process_str_cpy(params, c_expr);
      elsif action_name = "STR_ELEMCPY" then
        process_str_elemcpy(params, c_expr);
      elsif action_name = "STR_EQ" then
        process_str_eq(params, c_expr);
      elsif action_name = "STR_GE" then
        process_str_ge(params, c_expr);
      elsif action_name = "STR_GT" then
        process_str_gt(params, c_expr);
      elsif action_name = "STR_HASHCODE" then
        process_str_hashcode(params, c_expr);
      elsif action_name = "STR_HEAD" then
        process_str_head(params, c_expr);
      elsif action_name = "STR_IDX" then
        process_str_idx(params, c_expr);
      elsif action_name = "STR_IPOS" then
        process_str_ipos(params, c_expr);
      elsif action_name = "STR_LE" then
        process_str_le(params, c_expr);
      elsif action_name = "STR_LIT" then
        process_str_lit(params, c_expr);
      elsif action_name = "STR_LNG" then
        process_str_lng(params, c_expr);
      elsif action_name = "STR_LOW" then
        process_str_low(params, c_expr);
      elsif action_name = "STR_LPAD" then
        process_str_lpad(params, c_expr);
      elsif action_name = "STR_LT" then
        process_str_lt(params, c_expr);
      elsif action_name = "STR_MULT" then
        process_str_mult(params, c_expr);
      elsif action_name = "STR_NE" then
        process_str_ne(params, c_expr);
      elsif action_name = "STR_POS" then
        process_str_pos(params, c_expr);
      elsif action_name = "STR_RANGE" then
        process_str_range(params, c_expr);
      elsif action_name = "STR_REPL" then
        process_str_repl(params, c_expr);
      elsif action_name = "STR_RPAD" then
        process_str_rpad(params, c_expr);
      elsif action_name = "STR_RPOS" then
        process_str_rpos(params, c_expr);
      elsif action_name = "STR_SPLIT" then
        process_str_split(params, c_expr);
      elsif action_name = "STR_STR" then
        process_str_str(params, c_expr);
      elsif action_name = "STR_SUBSTR" then
        process_str_substr(params, c_expr);
      elsif action_name = "STR_TAIL" then
        process_str_tail(params, c_expr);
      elsif action_name = "STR_TRIM" then
        process_str_trim(params, c_expr);
      elsif action_name = "STR_UP" then
        process_str_up(params, c_expr);
      elsif action_name = "STR_VALUE" then
        process_str_value(params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "TIM" then
      if action_name = "TIM_AWAIT" then
        process_tim_await(params, c_expr);
      elsif action_name = "TIM_NOW" then
        process_tim_now(params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "TYP" then
      if action_name = "TYP_CPY" then
        process_typ_cpy(params, c_expr);
      elsif action_name = "TYP_EQ" then
        process_typ_eq(params, c_expr);
      elsif action_name = "TYP_HASHCODE" then
        process_typ_hashcode(params, c_expr);
      elsif action_name = "TYP_ISDERIVED" then
        process_typ_isderived(params, c_expr);
      elsif action_name = "TYP_ISFUNC" then
        process_typ_isfunc(params, c_expr);
      elsif action_name = "TYP_ISVARFUNC" then
        process_typ_isvarfunc(params, c_expr);
      elsif action_name = "TYP_MATCHOBJ" then
        process_typ_matchobj(params, c_expr);
      elsif action_name = "TYP_META" then
        process_typ_meta(params, c_expr);
      elsif action_name = "TYP_NE" then
        process_typ_ne(params, c_expr);
      elsif action_name = "TYP_NUM" then
        process_typ_num(params, c_expr);
      elsif action_name = "TYP_RESULT" then
        process_typ_result(params, c_expr);
      elsif action_name = "TYP_STR" then
        process_typ_str(params, c_expr);
      elsif action_name = "TYP_VALUE" then
        process_typ_value(params, c_expr);
      elsif action_name = "TYP_VARCONV" then
        process_typ_varconv(params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    elsif action_prefix = "UT8" then
      if action_name = "UT8_GETC" then
        process_ut8_getc(params, c_expr);
      elsif action_name = "UT8_GETS" then
        process_ut8_gets(params, c_expr);
      elsif action_name = "UT8_LINE_READ" then
        process_ut8_line_read(params, c_expr);
      elsif action_name = "UT8_SEEK" then
        process_ut8_seek(params, c_expr);
      elsif action_name = "UT8_WORD_READ" then
        process_ut8_word_read(params, c_expr);
      elsif action_name = "UT8_WRITE" then
        process_ut8_write(params, c_expr);
      else
        process_unknown_action(action_name, c_expr);
      end if;
    else
      process_unknown_action(action_name, c_expr);
    end if;
  end func;


const func boolean: valueIsAtHeap (in type: aType) is func

  result
    var boolean: result is FALSE;
  begin
    if  aType = biginttype or
        aType = stritype or
        aType = wintype or
        aType in array_element or
        aType in struct_elements or
        aType in isHashType or
        aType in isInterfaceType then
      result := TRUE;
    end if;
  end func;


const func boolean: valueIsAtHeap (in reference: a_param) is
  return valueIsAtHeap(getType(a_param));


const func boolean: isPointerParam (in reference: a_param) is func

  result
    var boolean: result is TRUE;
  begin
    result := category(a_param) = "REFPARAMOBJECT" and
        (not valueIsAtHeap(a_param) or is_var(a_param));
  end func;


const func boolean: isCopyParam (in reference: a_param) is func

  result
    var boolean: result is TRUE;
  begin
    result := category(a_param) = "VALUEPARAMOBJECT" and
        valueIsAtHeap(a_param) and is_var(a_param);
  end func;


const func boolean: canTakeAddress (in reference: an_expression) is func

  result
    var boolean: result is TRUE;
  local
    var string: category is "";
    var string: action_name is "";
  begin
    category := category(an_expression);
    if (category = "INTOBJECT" or
        category = "CHAROBJECT" or
        category = "FLOATOBJECT") and
        not is_var(an_expression) then
      result := FALSE;
    end if;
    if is_func(getType(an_expression)) then
      result := FALSE;
    end if;
    if category = "CALLOBJECT" then
      if category(getValue(an_expression, ref_list)[1]) = "ACTOBJECT" then
        action_name := str(getValue(getValue(an_expression, ref_list)[1], ACTION));
        if  action_name = "ARR_IDX" or
            action_name = "SCT_SELECT" then
          result := TRUE;
        end if;
      end if;
    end if;
  end func;


const proc: process_constenumobject (in reference: procedure, in ref_list: params,
    inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "/*constenumobject*/";
    noop_params(params(procedure), params, c_expr);
  end func;


const func boolean: param_list_okay (in ref_list: formal_params) is func

  result
    var boolean: okay is TRUE;
  local
    var reference: obj is NIL;
    var string: category is "";
  begin
    for obj range formal_params do
      category := category(obj);
      if category <> "SYMBOLOBJECT" and category <> "TYPEOBJECT" then
        if                                  # getType(obj) = typetype or
            getType(obj) = proctype then
          okay := FALSE;
        end if;
      end if;
    end for;
  end func;


const proc: process_local_declaration (in reference: current_object, in reference: object_value,
    inout expr_type: c_expr) is func

  local
    var string: category is "";
    var expr_type: c_value is expr_type.value;
    var string: param_name is "";
    var string: param_value is "";
  begin
    declare_type_if_necessary(getType(current_object), global_c_expr);
    c_expr.temp_decls &:= type_name(getType(current_object));
    c_expr.temp_decls &:= " o_";
    create_name(current_object, c_expr.temp_decls);
    category := category(object_value);
    if category = "TYPEOBJECT" then
      c_expr.temp_decls &:= "=NULL";
    elsif category = "INTOBJECT" then
      c_expr.temp_decls &:= "=";
      c_expr.temp_decls &:= str(getValue(object_value, integer));
    elsif category = "BIGINTOBJECT" then
      if getValue(object_value, bigInteger) not in bigint_const_table then
        bigint_const_table @:= [getValue(object_value, bigInteger)] length(bigint_const_table);
      end if;
      c_expr.temp_assigns &:= "o_";
      create_name(current_object, c_expr.temp_assigns);
      c_expr.temp_assigns &:= "=bigCreate(big[";
      c_expr.temp_assigns &:= str(bigint_const_table[getValue(object_value, bigInteger)]);
      c_expr.temp_assigns &:= "] /* ";
      c_expr.temp_assigns &:= str(getValue(object_value, bigInteger));
      c_expr.temp_assigns &:= " */);\n";
      c_expr.temp_frees &:= "bigDestr(o_";
      create_name(current_object, c_expr.temp_frees);
      c_expr.temp_frees  &:= ");\n";
    elsif category = "CHAROBJECT" then
      c_expr.temp_decls &:= "=";
      c_expr.temp_decls &:= c_literal(getValue(object_value, char));
    elsif category = "FLOATOBJECT" then
      c_expr.temp_decls &:= "=";
      c_expr.temp_decls &:= str(getValue(object_value, float));
    elsif category = "STRIOBJECT" then
      if getValue(object_value, string) not in stri_const_table then
        stri_const_table @:= [getValue(object_value, string)] length(stri_const_table);
      end if;
      c_expr.temp_assigns &:= "o_";
      create_name(current_object, c_expr.temp_assigns);
      c_expr.temp_assigns &:= "=strCreate(str[";
      c_expr.temp_assigns &:= str(stri_const_table[getValue(object_value, string)]);
      c_expr.temp_assigns &:= "] /* ";
      c_expr.temp_assigns &:= replace(c_literal(getValue(object_value, string)), "*/", "* /");
      c_expr.temp_assigns &:= " */);\n";
      c_expr.temp_frees &:= "strDestr(o_";
      create_name(current_object, c_expr.temp_frees);
      c_expr.temp_frees  &:= ");\n";
    elsif category = "BSTRIOBJECT" then
      c_expr.temp_assigns &:= "o_";
      create_name(current_object, c_expr.temp_assigns);
      c_expr.temp_assigns &:= "=bstCreate(&empty_bst);\n";
      c_expr.temp_frees &:= "bstDestr(o_";
      create_name(current_object, c_expr.temp_frees);
      c_expr.temp_frees  &:= ");\n";
    elsif category = "SETOBJECT" then
      if getValue(object_value, bitset) not in set_const_table then
        set_const_table @:= [getValue(object_value, bitset)] length(set_const_table);
      end if;
      c_expr.temp_assigns &:= "o_";
      create_name(current_object, c_expr.temp_assigns);
      c_expr.temp_assigns &:= "=setCreate(set[";
      c_expr.temp_assigns &:= str(set_const_table[getValue(object_value, bitset)]);
      c_expr.temp_assigns &:= "]);\n";
      c_expr.temp_frees &:= "setDestr(o_";
      create_name(current_object, c_expr.temp_frees);
      c_expr.temp_frees  &:= ");\n";
    elsif category = "REFOBJECT" then
      c_expr.temp_decls &:= "=";
      reference_value(getValue(object_value, reference), c_value);
      c_expr.temp_decls &:= c_value.expr;
    elsif category = "REFLISTOBJECT" then
      c_expr.temp_decls &:= "=";
      ref_list_value(getValue(object_value, ref_list), c_value);
      c_expr.temp_decls &:= c_value.expr;
    elsif category = "FILEOBJECT" then
      c_expr.temp_decls &:= "=NULL";
    elsif category = "SOCKETOBJECT" then
      c_expr.temp_decls &:= "=-1";
    elsif category = "ARRAYOBJECT" then
      if object_value not in const_table then
        const_table @:= [object_value] length(const_table);
      end if;
      process_create_declaration(getType(current_object), global_c_expr);
      process_destr_declaration(getType(current_object), global_c_expr);
      c_expr.temp_assigns &:= "o_";
      create_name(current_object, c_expr.temp_assigns);
      c_expr.temp_assigns &:= "=";
      param_value := "arr[";
      param_value &:= str(const_table[object_value]);
      param_value &:= "]";
      process_create_call(getType(current_object),
          param_value, c_expr.temp_assigns);
      c_expr.temp_assigns &:= ";\n";
      param_name := "o_";
      create_name(current_object, param_name);
      process_destr_call(getType(current_object),
          param_name, c_expr.temp_frees);
    elsif category = "STRUCTOBJECT" then
      if object_value not in const_table then
        const_table @:= [object_value] length(const_table);
      end if;
      process_create_declaration(getType(current_object), global_c_expr);
      process_destr_declaration(getType(current_object), global_c_expr);
      c_expr.temp_assigns &:= "o_";
      create_name(current_object, c_expr.temp_assigns);
      c_expr.temp_assigns &:= "=";
      param_value := "sct[";
      param_value &:= str(const_table[object_value]);
      param_value &:= "]";
      process_create_call(getType(current_object),
          param_value, c_expr.temp_assigns);
      c_expr.temp_assigns &:= ";\n";
      param_name := "o_";
      create_name(current_object, param_name);
      process_destr_call(getType(current_object),
          param_name, c_expr.temp_frees);
    elsif category = "HASHOBJECT" then
      c_expr.temp_assigns &:= "o_";
      create_name(current_object, c_expr.temp_assigns);
      c_expr.temp_assigns &:= "=hshEmpty();\n";
      # c_expr.temp_frees &:= "hshDestr(o_";
      # create_name(current_object, c_expr.temp_frees);
      # c_expr.temp_frees  &:= ");\n";
    elsif category = "CLASSOBJECT" then
      if object_value not in const_table then
        const_table @:= [object_value] length(const_table);
      end if;
      c_expr.temp_assigns &:= "o_";
      create_name(current_object, c_expr.temp_assigns);
      c_expr.temp_assigns &:= "=itf[";
      c_expr.temp_assigns &:= str(const_table[object_value]);
      c_expr.temp_assigns &:= "];\n";
    elsif category = "WINOBJECT" then
      c_expr.temp_decls &:= "=NULL";
      c_expr.temp_frees &:= "drwDestr(o_";
      create_name(current_object, c_expr.temp_frees);
      c_expr.temp_frees  &:= ");\n";
    elsif category = "CONSTENUMOBJECT" then
      c_expr.temp_decls &:= "=";
      c_expr.temp_decls &:= enum_value(getValue(object_value, reference));
    elsif category = "VARENUMOBJECT" then
      c_expr.temp_decls &:= "=";
      c_expr.temp_decls &:= enum_value(getValue(object_value, reference));
    elsif category = "ENUMLITERALOBJECT" then
      c_expr.temp_decls &:= "=o_";
      create_name(object_value, c_expr.temp_decls);
    elsif category = "CALLOBJECT" then
      param_name := "o_";
      create_name(current_object, param_name);
      c_value.temp_num := c_expr.temp_num;
      get_create_call_arg(object_value, c_value);
      c_expr.temp_num := c_value.temp_num;
      c_expr.temp_decls &:= c_value.temp_decls;
      c_expr.temp_assigns &:= c_value.temp_assigns;
      c_expr.temp_frees &:= c_value.temp_frees;
      c_expr.temp_assigns &:= param_name;
      c_expr.temp_assigns &:= "=";
      c_expr.temp_assigns &:= c_value.result_expr;
      c_expr.temp_assigns &:= ";\n";
      process_destr_declaration(getType(current_object), global_c_expr);
      process_destr_call(getType(current_object),
          param_name, c_expr.temp_frees);
    elsif category = "ACTOBJECT" then
      c_expr.temp_decls &:= "=NULL";
    else
      c_expr.temp_decls &:= "/* ";
      c_expr.temp_decls &:= category;
      c_expr.temp_decls &:= " */";
    end if;
    c_expr.temp_decls &:= ";\n";
  end func;


const proc: process_local_var_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var ref_list: objects is ref_list.EMPTY;
    var reference: obj is NIL;
  begin
    objects := local_vars(current_object);
    for obj range objects do
      process_local_declaration(obj, getValue(obj, reference), c_expr);
    end for;
  end func;


const proc: push_object_value (in reference: obj, in reference: value) is func

  local
    var integer: length is 0;
    var integer: number is 0;
  begin
    length := length(object_value);
    number := obj_number(obj);
    if length < number then
      object_value := object_value & number - length times ref_list.EMPTY;
    end if;
    incl(object_value[number], value);
  end func;


const proc: pop_object_value (in reference: obj) is func

  local
    var integer: length is 0;
    var integer: number is 0;
  begin
    number := obj_number(obj);
    object_value[number] := object_value[number][2 ..];
  end func;


const proc: push_macro_param (in reference: formal_param,
    in reference: actual_param, inout expr_type: c_expr) is func

  local
    var string: category is "";
    var type: param_type is void;
    var integer: temp_num is 0;
  begin
    category := category(formal_param);
    if category <> "SYMBOLOBJECT" then
      param_type := getType(formal_param);
      if param_type = proctype then
        c_expr.expr &:= "/* proc param o_";
        c_expr.expr &:= str(obj_number(formal_param));
        c_expr.expr &:= " ";
        c_expr.expr &:= str(formal_param);
        c_expr.expr &:= "*/\n";
        push_object_value(formal_param, actual_param);
(*
      elsif param_type = typetype then
        c_expr.expr &:= "/* type param o_";
        c_expr.expr &:= str(obj_number(formal_param));
        c_expr.expr &:= " ";
        c_expr.expr &:= str(formal_param);
        c_expr.expr &:= "*/\n";
*)
      else
        c_expr.expr &:= type_name(param_type);
        if isPointerParam(formal_param) then
          c_expr.expr &:= " *o_";
          create_name(formal_param, c_expr.expr);
          c_expr.expr &:= "=";
          if category(actual_param) = "REFPARAMOBJECT" then
            c_expr.expr &:= "o_";
            create_name(actual_param, c_expr.expr);
            c_expr.expr &:= ";\n";
          elsif canTakeAddress(actual_param) then
            c_expr.expr &:= "&(";
            process_expr(actual_param, c_expr);
            c_expr.expr &:= ");\n";
          else
            incr(c_expr.temp_num);
            temp_num := c_expr.temp_num;
            c_expr.temp_decls &:= "long tmp_";
            c_expr.temp_decls &:= str(temp_num);
            c_expr.temp_decls &:= ";\n";
            c_expr.expr &:= "(tmp_";
            c_expr.expr &:= str(temp_num);
            c_expr.expr &:= "=";
            process_arg(actual_param, c_expr);
            c_expr.expr &:= ", &tmp_";
            c_expr.expr &:= str(temp_num);
            c_expr.expr &:= ");\n";
          end if;
        else
          c_expr.expr &:= " o_";
          create_name(formal_param, c_expr.expr);
          c_expr.expr &:= "=";
          process_arg(actual_param, c_expr);
          c_expr.expr &:= ";\n";
        end if;
      end if;
    end if;
  end func;


const proc: push_macro_params (in ref_list: formal_params,
    in ref_list: actual_params, inout expr_type: c_expr) is func

  local
    var integer: number is 0;
  begin
    for number range 1 to length(formal_params) do
      push_macro_param(formal_params[number], actual_params[number], c_expr);
    end for;
  end func;


const proc: pop_macro_param (in reference: formal_param,
    inout expr_type: c_expr) is func

  local
    var string: category is "";
    var type: param_type is void;
  begin
    category := category(formal_param);
    if category <> "SYMBOLOBJECT" then
      param_type := getType(formal_param);
      if param_type = proctype then
        c_expr.expr &:= "/* end proc param o_";
        c_expr.expr &:= str(obj_number(formal_param));
        c_expr.expr &:= " ";
        c_expr.expr &:= str(formal_param);
        c_expr.expr &:= "*/\n";
        pop_object_value(formal_param);
      end if;
    end if;
  end func;


const proc: pop_macro_params (in ref_list: formal_params,
    inout expr_type: c_expr) is func

  local
    var integer: number is 0;
  begin
    for number range 1 to length(formal_params) do
      pop_macro_param(formal_params[number], c_expr);
    end for;
  end func;


const proc: process_macro (in reference: procedure,
    in ref_list: formal_params, in ref_list: actual_params,
    inout expr_type: c_expr) is func

  local
    var type: result_type is void;
    var expr_type: macro_decls is expr_type.value;
    var reference: result_object is NIL;
  begin
    result_type := result_type(getType(procedure));
    if result_type = voidtype then
      c_expr.expr &:= "/* macro o_";
      c_expr.expr &:= str(obj_number(procedure));
      c_expr.expr &:= " ";
      c_expr.expr &:= str(procedure);
      c_expr.expr &:= "*/ {\n";
      c_expr.expr &:= "/* macro params */\n";
      push_macro_params(formal_params, actual_params, c_expr);
      c_expr.expr &:= "/* macro local_vars */\n";
      process_local_var_declaration(procedure, macro_decls);
      c_expr.expr &:= macro_decls.temp_decls;
      c_expr.expr &:= macro_decls.temp_assigns;
      c_expr.expr &:= "/* macro body */\n";
      process_expr(body(procedure), c_expr);
      c_expr.expr &:= macro_decls.temp_frees;
      pop_macro_params(formal_params, c_expr);
      c_expr.expr &:= "\n} /* macro o_";
      c_expr.expr &:= str(obj_number(procedure));
      c_expr.expr &:= " ";
      c_expr.expr &:= str(procedure);
      c_expr.expr &:= "*/\n";
    else
      c_expr.expr &:= "/* macro o_";
      c_expr.expr &:= str(obj_number(procedure));
      c_expr.expr &:= " ";
      c_expr.expr &:= str(procedure);
      c_expr.expr &:= "*/ (\n";
      macro_decls.temp_num := c_expr.temp_num;
      push_macro_params(formal_params, actual_params, macro_decls);
      process_local_var_declaration(procedure, macro_decls);
      result_object := func_result(procedure);
      if result_object <> NIL then
        macro_decls.expr &:= type_name(getType(result_object));
        macro_decls.expr &:= " o_";
        create_name(result_object, macro_decls.expr);
        macro_decls.expr &:= ";\n";
      end if;
      c_expr.temp_num := macro_decls.temp_num;
      c_expr.temp_decls &:= macro_decls.temp_decls;
      c_expr.temp_assigns &:= macro_decls.temp_assigns;
      c_expr.temp_assigns &:= macro_decls.expr;
      c_expr.temp_frees &:= macro_decls.temp_frees;
      process_expr(body(procedure), c_expr);
      pop_macro_params(formal_params, c_expr);
      c_expr.expr &:= "\n) /* macro o_";
      c_expr.expr &:= str(obj_number(procedure));
      c_expr.expr &:= " ";
      c_expr.expr &:= str(procedure);
      c_expr.expr &:= "*/\n";
    end if;
  end func;


const proc: call_params (in ref_list: formal_params,
    in ref_list: actual_params, inout expr_type: c_expr) is func

  local
    var integer: number is 0;
    var reference: formal_param is NIL;
    var reference: actual_param is NIL;
    var string: category is "";
    var boolean: first_element is TRUE;
    var integer: temp_num is 0;
  begin
    for number range 1 to length(formal_params) do
      formal_param := formal_params[number];
      actual_param := actual_params[number];
      category := category(formal_param);
      if category <> "SYMBOLOBJECT" then
        if category = "TYPEOBJECT" then
          c_expr.expr &:= "/* attr t_";
          c_expr.expr &:= str(type_number(getValue(formal_param, type)));
          c_expr.expr &:= " ";
          c_expr.expr &:= str(getValue(formal_param, type));
          c_expr.expr &:= "*/ ";
        else
          if first_element then
            first_element := FALSE;
          else
            c_expr.expr &:= ", ";
          end if;
          if isPointerParam(formal_param) then
            if category(actual_param) = "REFPARAMOBJECT" then
              c_expr.expr &:= "o_";
              create_name(actual_param, c_expr.expr);
            elsif canTakeAddress(actual_param) then
              c_expr.expr &:= "&(";
              process_expr(actual_param, c_expr);
              c_expr.expr &:= ")";
            else
              c_expr.expr &:= "/* ";
              c_expr.expr &:= category(actual_param);
              c_expr.expr &:= " */";
              incr(c_expr.temp_num);
              temp_num := c_expr.temp_num;
              c_expr.temp_decls &:= "long tmp_";
              c_expr.temp_decls &:= str(temp_num);
              c_expr.temp_decls &:= ";\n";
              c_expr.expr &:= "(tmp_";
              c_expr.expr &:= str(temp_num);
              c_expr.expr &:= "=";
              process_arg(actual_param, c_expr);
              c_expr.expr &:= ", &tmp_";
              c_expr.expr &:= str(temp_num);
              c_expr.expr &:= ")";
            end if;
          else
            process_arg(actual_param, c_expr);
          end if;
        end if;
      end if;
    end for;
  end func;


const proc: process_procedure (in reference: procedure,
    in ref_list: formal_params, in ref_list: actual_params,
    inout expr_type: c_expr) is func

  local
    var type: procedure_type is void;
    var type: result_type is void;
    var expr_type: c_params is expr_type.value;
  begin
    procedure_type := getType(procedure);
    result_type := result_type(procedure_type);
    if valueIsAtHeap(result_type) and not is_varfunc(procedure_type) then
      prepare_typed_result(result_type, c_expr);
      if is_varfunc(procedure_type) then
        c_expr.result_expr &:= "*o_";
      else
        c_expr.result_expr &:= "o_";
      end if;
      create_name(procedure, c_expr.result_expr);
      c_expr.result_expr &:= "(";
      c_params.temp_num := c_expr.temp_num;
      call_params(formal_params, actual_params, c_params);
      c_expr.temp_num := c_params.temp_num;
      c_expr.temp_decls &:= c_params.temp_decls;
      c_expr.temp_decls &:= c_params.temp_assigns;
      c_expr.temp_frees &:= c_params.temp_frees;
      c_expr.result_expr &:= c_params.expr;
      c_expr.result_expr &:= ")";
    elsif result_type = voidtype then
      call_params(formal_params, actual_params, c_params);
      if c_params.temp_num <> 0 then
        c_expr.expr &:= "{\n";
        c_expr.expr &:= c_params.temp_decls;
        c_expr.expr &:= c_params.temp_assigns;
      end if;
      if is_varfunc(procedure_type) then
        c_expr.expr &:= "*o_";
      else
        c_expr.expr &:= "o_";
      end if;
      create_name(procedure, c_expr.expr);
      c_expr.expr &:= "(";
      c_expr.expr &:= c_params.expr;
      c_expr.expr &:= ")";
      c_expr.expr &:= ";\n";
      if c_params.temp_num <> 0 then
        c_expr.expr &:= c_params.temp_frees;
        c_expr.expr &:= "}\n";
      end if;
    else
      if is_varfunc(procedure_type) then
        c_expr.expr &:= "*o_";
      else
        c_expr.expr &:= "o_";
      end if;
      create_name(procedure, c_expr.expr);
      c_expr.expr &:= "(";
      call_params(formal_params, actual_params, c_expr);
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process_call (in reference: current_expression, inout expr_type: c_expr) is func

  local
    var ref_list: params is ref_list.EMPTY;
    var reference: procedure is NIL;
    var string: category is "";
    var type: result_type is void;
    var ref_list: formal_params is ref_list.EMPTY;
    var expr_type: c_body is expr_type.value;
    var reference: obj is NIL;
    var boolean: first_element is TRUE;
  begin
    # c_expr.expr &:= "/* ";
    # c_expr.expr &:= str(current_expression);
    # c_expr.expr &:= " */";
    params := getValue(current_expression, ref_list);
    procedure := params[1];
    params := params[2 ..];
    category := category(procedure);
    if category = "ACTOBJECT" then
      process_action(procedure, params, c_expr);
    elsif category = "BLOCKOBJECT" then
      result_type := result_type(getType(procedure));
      formal_params := params(procedure);
      if procedure in function_declared then                # param_list_okay(formal_params) then
        process_procedure(procedure, formal_params, params, c_expr);
      else
        process_macro(procedure, formal_params, params, c_expr);
      end if;
    elsif category = "REFPARAMOBJECT" then
      c_expr.expr &:= "/* body o_";
      c_expr.expr &:= str(obj_number(procedure));
      c_expr.expr &:= " ";
      c_expr.expr &:= str(procedure);
      c_expr.expr &:= "*/ {\n";
      if obj_number(procedure) <= length(object_value) then
        process_expr(object_value[obj_number(procedure)][1], c_body);
        c_expr.expr &:= c_body.temp_decls;
        c_expr.expr &:= c_body.temp_assigns;
        c_expr.expr &:= c_body.expr;
        c_expr.expr &:= ";\n";
        c_expr.expr &:= c_body.temp_frees;
      else
        c_expr.expr &:= "/* object ";
        c_expr.expr &:= str(obj_number(procedure));
        c_expr.expr &:= " not defined */\n";
      end if;
      c_expr.expr &:= "} /* body o_";
      c_expr.expr &:= str(obj_number(procedure));
      c_expr.expr &:= " ";
      c_expr.expr &:= str(procedure);
      c_expr.expr &:= "*/\n";
    elsif category = "CONSTENUMOBJECT" then
      (* process_constenumobject(procedure, params, c_expr); *)
      process_expr(procedure, c_expr);
    elsif category = "INTOBJECT" then
      process_expr(procedure, c_expr);
    elsif category = "BIGINTOBJECT" then
      process_expr(procedure, c_expr);
    elsif category = "CHAROBJECT" then
      process_expr(procedure, c_expr);
    elsif category = "STRIOBJECT" then
      process_expr(procedure, c_expr);
    elsif category = "BSTRIOBJECT" then
      process_expr(procedure, c_expr);
    elsif category = "HASHOBJECT" then
      process_expr(procedure, c_expr);
    elsif category = "SETOBJECT" then
      process_expr(procedure, c_expr);
    elsif category = "STRUCTOBJECT" then
      process_expr(procedure, c_expr);
    elsif category = "WINOBJECT" then
      process_expr(procedure, c_expr);
    elsif category = "PROGOBJECT" then
      process_expr(procedure, c_expr);
    elsif category = "ENUMLITERALOBJECT" then
      process_expr(procedure, c_expr);
    elsif category = "REFOBJECT" then
      c_expr.expr &:= "o_";
      create_name(procedure, c_expr.expr);
    elsif category = "REFLISTOBJECT" then
      c_expr.expr &:= "o_";
      create_name(procedure, c_expr.expr);
    else
      c_expr.expr &:= "/*[ ";
      c_expr.expr &:= category;
      c_expr.expr &:= " ]*/";
      c_expr.expr &:= "o_";
      create_name(procedure, c_expr.expr);
      c_expr.expr &:= "(";
      for obj range params do
        category := category(obj);
        if category <> "SYMBOLOBJECT" then
          if first_element then
            first_element := FALSE;
          else
            c_expr.expr &:= ", ";
          end if;
          process_expr(obj, c_expr);
        end if;
      end for;
      c_expr.expr &:= ")";
    end if;
  end func;


const proc: process_expr (in reference: current_expression, inout expr_type: c_expr) is func

  local
    var string: category is "";
    var reference: obj is NIL;
  begin
    category := category(current_expression);
    if category = "MATCHOBJECT" then
      process_call(current_expression, c_expr);
    elsif category = "CALLOBJECT" then
      process_call(current_expression, c_expr);
    elsif category = "BLOCKOBJECT" then
      c_expr.expr &:= "o_";
      create_name(current_expression, c_expr.expr);
      c_expr.expr &:= "()";
      if result_type(getType(current_expression)) = voidtype then
        c_expr.expr &:= ";\n";
      end if;
    elsif category = "ACTOBJECT" then
      process_action(current_expression, ref_list.EMPTY, c_expr);
    elsif category = "LOCALVOBJECT" then
      c_expr.expr &:= "o_";
      create_name(current_expression, c_expr.expr);
    elsif category = "VALUEPARAMOBJECT" then
      c_expr.expr &:= "o_";
      create_name(current_expression, c_expr.expr);
    elsif category = "REFPARAMOBJECT" then
      if isPointerParam(current_expression) then
        if obj_number(current_expression) <= length(object_value) and
            length(object_value[obj_number(current_expression)]) > 0 then
          c_expr.expr &:= "/* body o_";
          c_expr.expr &:= str(obj_number(current_expression));
          c_expr.expr &:= " ";
          c_expr.expr &:= str(current_expression);
          c_expr.expr &:= "*/ {\n";
          process_expr(object_value[obj_number(current_expression)][1], c_expr);
          c_expr.expr &:= "\n} /* body o_";
          c_expr.expr &:= str(obj_number(current_expression));
          c_expr.expr &:= " ";
          c_expr.expr &:= str(current_expression);
          c_expr.expr &:= "*/\n";
        else
          c_expr.expr &:= "(*o_";
          create_name(current_expression, c_expr.expr);
          c_expr.expr &:= ")";
        end if;
      else
        c_expr.expr &:= "o_";
        create_name(current_expression, c_expr.expr);
      end if;
    elsif category = "RESULTOBJECT" then
      c_expr.expr &:= "o_";
      create_name(current_expression, c_expr.expr);
    elsif category = "TYPEOBJECT" then
      if is_var(current_expression) then
        c_expr.expr &:= "o_";
        create_name(current_expression, c_expr.expr);
      else
        c_expr.expr &:= "NULL/*";
        c_expr.expr &:= str(current_expression);
        c_expr.expr &:= "*/";
      end if;
    elsif category = "INTOBJECT" then
      if is_var(current_expression) then
        c_expr.expr &:= "o_";
        create_name(current_expression, c_expr.expr);
      else
        c_expr.expr &:= str(getValue(current_expression, integer));
      end if;
    elsif category = "BIGINTOBJECT" then
      if is_var(current_expression) then
        c_expr.expr &:= "o_";
        create_name(current_expression, c_expr.expr);
      else
        if getValue(current_expression, bigInteger) not in bigint_const_table then
          bigint_const_table @:= [getValue(current_expression, bigInteger)] length(bigint_const_table);
        end if;
        c_expr.expr &:= "big[";
        c_expr.expr &:= str(bigint_const_table[getValue(current_expression, bigInteger)]);
        c_expr.expr &:= "] /* ";
        c_expr.expr &:= str(getValue(current_expression, bigInteger));
        c_expr.expr &:= " */";
      end if;
    elsif category = "FLOATOBJECT" then
      if is_var(current_expression) then
        c_expr.expr &:= "o_";
        create_name(current_expression, c_expr.expr);
      elsif getValue(current_expression, float) = Infinity then
        c_expr.expr &:= "(1.0 / 0.0)";
      elsif isnan(getValue(current_expression, float)) then
        c_expr.expr &:= "(0.0 / 0.0)";
      else
        c_expr.expr &:= str(getValue(current_expression, float));
      end if;
    elsif category = "CHAROBJECT" then
      if is_var(current_expression) then
        c_expr.expr &:= "o_";
        create_name(current_expression, c_expr.expr);
      else
        c_expr.expr &:= c_literal(getValue(current_expression, char));
      end if;
    elsif category = "STRIOBJECT" then
      if is_var(current_expression) then
        c_expr.expr &:= "o_";
        create_name(current_expression, c_expr.expr);
      else
        if getValue(current_expression, string) not in stri_const_table then
          stri_const_table @:= [getValue(current_expression, string)] length(stri_const_table);
        end if;
        c_expr.expr &:= "str[";
        c_expr.expr &:= str(stri_const_table[getValue(current_expression, string)]);
        c_expr.expr &:= "] /* ";
        c_expr.expr &:= replace(c_literal(getValue(current_expression, string)), "*/", "* /");
        c_expr.expr &:= " */";
      end if;
    elsif category = "BSTRIOBJECT" then
      if is_var(current_expression) then
        c_expr.expr &:= "o_";
        create_name(current_expression, c_expr.expr);
      else
        c_expr.expr &:= "&empty_bst";
      end if;
    elsif category = "REFOBJECT" then
      if is_var(current_expression) then
        c_expr.expr &:= "o_";
        create_name(current_expression, c_expr.expr);
      else
        if getValue(current_expression, reference) = NIL then
          c_expr.expr &:= "NULL";
        else
          c_expr.expr &:= "&(";
          process_expr(getValue(current_expression, reference), c_expr);
          c_expr.expr &:= ")";
        end if;
      end if;
    elsif category = "REFLISTOBJECT" then
      c_expr.expr &:= "o_";
      create_name(current_expression, c_expr.expr);
    elsif category = "ARRAYOBJECT" then
      c_expr.expr &:= "o_";
      create_name(current_expression, c_expr.expr);
    elsif category = "HASHOBJECT" then
      c_expr.expr &:= "o_";
      create_name(current_expression, c_expr.expr);
    elsif category = "SETOBJECT" then
      if is_var(current_expression) then
        c_expr.expr &:= "o_";
        create_name(current_expression, c_expr.expr);
      else
        if getValue(current_expression, bitset) not in set_const_table then
          set_const_table @:= [getValue(current_expression, bitset)] length(set_const_table);
        end if;
        c_expr.expr &:= "set[";
        c_expr.expr &:= str(set_const_table[getValue(current_expression, bitset)]);
        c_expr.expr &:= "]";
      end if;
    elsif category = "STRUCTOBJECT" then
      c_expr.expr &:= "o_";
      create_name(current_expression, c_expr.expr);
    elsif category = "CLASSOBJECT" then
      c_expr.expr &:= "o_";
      create_name(current_expression, c_expr.expr);
    elsif category = "FILEOBJECT" then
      c_expr.expr &:= "o_";
      create_name(current_expression, c_expr.expr);
    elsif category = "SOCKETOBJECT" then
      c_expr.expr &:= "o_";
      create_name(current_expression, c_expr.expr);
    elsif category = "WINOBJECT" then
      if is_var(current_expression) then
        c_expr.expr &:= "o_";
        create_name(current_expression, c_expr.expr);
      else
        c_expr.expr &:= "/*WINOBJECT*/ NULL";
      end if;
    elsif category = "PROGOBJECT" then
      if is_var(current_expression) then
        c_expr.expr &:= "o_";
        create_name(current_expression, c_expr.expr);
      else
        if getValue(current_expression, program) = program.EMPTY then
          c_expr.expr &:= "/*program.EMPTY*/NULL";
        else
          c_expr.expr &:= "o_";
          create_name(current_expression, c_expr.expr);
        end if;
      end if;
    elsif category = "CONSTENUMOBJECT" then
      c_expr.expr &:= "o_";
      create_name(current_expression, c_expr.expr);
    elsif category = "VARENUMOBJECT" then
      c_expr.expr &:= "o_";
      create_name(current_expression, c_expr.expr);
    elsif category = "ENUMLITERALOBJECT" then
      c_expr.expr &:= "o_";
      create_name(current_expression, c_expr.expr);
    elsif category = "EXPROBJECT" then
      c_expr.expr &:= "o_";
      create_name(current_expression, c_expr.expr);
    elsif category = "SYMBOLOBJECT" then
      c_expr.expr &:= "/* SYMBOLOBJECT ";
      c_expr.expr &:= str(current_expression);
      c_expr.expr &:= " */";
    else
      c_expr.expr &:= "/* ";
      c_expr.expr &:= category;
      c_expr.expr &:= " */";
    end if;
  end func;


const proc: process_param_declaration (in reference: formal_param, inout expr_type: c_expr) is func

  local
    var string: param_name is "";
  begin
    c_expr.expr &:= type_name(getType(formal_param));
    if isPointerParam(formal_param) then
      c_expr.expr &:= " *o_";
      create_name(formal_param, c_expr.expr);
    elsif isCopyParam(formal_param) then
      create_name(formal_param, param_name);
      c_expr.expr &:= " in_var_o_";
      c_expr.expr &:= param_name;
      c_expr.temp_decls &:= type_name(getType(formal_param));
      c_expr.temp_decls &:= " o_";
      c_expr.temp_decls &:= param_name;
      c_expr.temp_decls &:= ";\n";
      c_expr.temp_assigns &:= "o_";
      c_expr.temp_assigns &:= param_name;
      c_expr.temp_assigns &:= "=";
      process_create_call(getType(formal_param),
          "in_var_o_" & param_name, c_expr.temp_assigns);
      c_expr.temp_assigns &:= ";\n";
      process_destr_call(getType(formal_param),
          "o_" & param_name, c_expr.temp_frees);
    else
      c_expr.expr &:= " o_";
      create_name(formal_param, c_expr.expr);
    end if;
  end func;


const proc: process_param_list_declaration (in ref_list: formal_params, inout expr_type: c_expr) is func

  local
    var reference: formal_param is NIL;
    var string: category is "";
    var boolean: first_element is TRUE;
  begin
    for formal_param range formal_params do
      category := category(formal_param);
      if category <> "SYMBOLOBJECT" then
        if category = "TYPEOBJECT" then
          c_expr.expr &:= "/* attr t_";
          c_expr.expr &:= str(type_number(getValue(formal_param, type)));
          c_expr.expr &:= " ";
          c_expr.expr &:= str(getValue(formal_param, type));
          c_expr.expr &:= "*/ ";
        else
          if first_element then
            first_element := FALSE;
          else
            c_expr.expr &:= ", ";
          end if;
          process_param_declaration(formal_param, c_expr);
        end if;
      end if;
    end for;
    if first_element then
      c_expr.expr &:= "void";
    end if;
  end func;


const proc: process_result_declaration (in reference: result_object, in reference: result_init,
    inout expr_type: c_expr) is func

  begin
    if result_object <> NIL then
      process_local_declaration(result_object, result_init, c_expr);
    end if;
  end func;


const proc: process_return (in reference: result_object,
    inout expr_type: c_expr) is func

  begin
    if result_object <> NIL then
      c_expr.expr &:= "return(o_";
      create_name(result_object, c_expr.expr);
      c_expr.expr &:= ");\n";
    end if;
  end func;


const proc: process_local_consts (in reference: current_object,
    inout expr_type: c_expr) is forward;


const proc: process_func_declaration (in reference: procedure,
    inout expr_type: c_expr) is func

  local
    var expr_type: c_param_list is expr_type.value;
    var expr_type: c_result is expr_type.value;
    var expr_type: c_local_vars is expr_type.value;
    var expr_type: c_proc_body is expr_type.value;
    var type: procedure_type is void;
    var type: result_type is void;
    var ref_list: param_list is ref_list.EMPTY;
    var reference: result_object is NIL;
    var reference: result_init is NIL;
  begin
    procedure_type := getType(procedure);
    result_type := result_type(procedure_type);
    param_list := params(procedure);
    if param_list_okay(param_list) then
      # Try to process the function declaration always.
      # The variable write_object_declaration is used to
      # decide if the function declaration should be written
      function_declared @:= [procedure] TRUE;
      process_local_consts(procedure, c_expr);
      c_expr.expr &:= "static ";
      c_expr.expr &:= type_name(result_type);
      if is_varfunc(getType(procedure)) then
        c_expr.expr &:= " /*varfunc*/ *o_";
      else
        c_expr.expr &:= " o_";
      end if;
      create_name(procedure, c_expr.expr);
      c_expr.expr &:= " (";
      process_param_list_declaration(param_list, c_param_list);
      c_expr.expr &:= c_param_list.expr;
      c_expr.expr &:= ")\n";
      c_expr.expr &:= "{\n";
      result_object := func_result(procedure);
      if procedure_type <> proctype and result_object = NIL then
        process_expr(body(procedure), c_proc_body);
        if c_proc_body.temp_num <> 0 or c_param_list.temp_decls <> "" then
          c_expr.expr &:= type_name(result_type);
          if is_varfunc(getType(procedure)) then
            c_expr.expr &:= " *result;\n";
          else
            c_expr.expr &:= " result;\n";
          end if;
          c_expr.expr &:= c_param_list.temp_decls;
          c_expr.expr &:= c_proc_body.temp_decls;
          c_expr.expr &:= c_param_list.temp_assigns;
          c_expr.expr &:= c_proc_body.temp_assigns;
          if is_varfunc(getType(procedure)) then
            c_expr.expr &:= "result=&(";
          else
            c_expr.expr &:= "result=(";
          end if;
          if c_proc_body.result_expr <> "" then
            c_expr.expr &:= c_proc_body.result_expr;
          else
            c_expr.expr &:= c_proc_body.expr;
          end if;
          c_expr.expr &:= ");\n";
          c_expr.expr &:= c_param_list.temp_frees;
          c_expr.expr &:= c_proc_body.temp_frees;
          c_expr.expr &:= "return(result);\n";
        else
          if is_varfunc(getType(procedure)) then
            c_expr.expr &:= "return &(";
          else
            c_expr.expr &:= "return(";
          end if;
          if c_proc_body.result_expr <> "" then
            c_expr.expr &:= c_proc_body.result_expr;
          else
            c_expr.expr &:= c_proc_body.expr;
          end if;
          c_expr.expr &:= ");\n";
        end if;
      else
        result_init := func_res_init(procedure);
        process_result_declaration(result_object, result_init, c_result);
        process_local_var_declaration(procedure, c_local_vars);
        process_expr(body(procedure), c_proc_body);
        c_expr.expr &:= c_param_list.temp_decls;
        c_expr.expr &:= c_result.temp_decls;
        c_expr.expr &:= c_local_vars.temp_decls;
        c_expr.expr &:= c_proc_body.temp_decls;
        c_expr.expr &:= c_param_list.temp_assigns;
        c_expr.expr &:= c_result.temp_assigns;
        c_expr.expr &:= c_local_vars.temp_assigns;
        c_expr.expr &:= c_proc_body.temp_assigns;
        c_expr.expr &:= c_proc_body.expr;
        c_expr.expr &:= c_param_list.temp_frees;
        c_expr.expr &:= c_local_vars.temp_frees;
        c_expr.expr &:= c_proc_body.temp_frees;
        process_return(result_object, c_expr);
      end if;
      c_expr.expr &:= "}\n\n";
      if write_object_declaration then
        count_declarations;
      else
        excl(function_declared, procedure);
        c_expr.expr &:= "/* declare macro o_";
        c_expr.expr &:= str(obj_number(procedure));
        c_expr.expr &:= " ";
        c_expr.expr &:= str(procedure);
        c_expr.expr &:= "*/\n";
      end if;
    else
      c_expr.expr &:= "/* declare macro o_";
      c_expr.expr &:= str(obj_number(procedure));
      c_expr.expr &:= " ";
      c_expr.expr &:= str(procedure);
      c_expr.expr &:= "*/\n";
    end if;
  end func;


const proc: process_forward_declaration (in reference: fwd_ref,
    inout expr_type: c_expr) is func

  local
    var reference: current_object is NIL;
    var expr_type: c_param_list is expr_type.value;
    var type: current_type is void;
    var type: result_type is void;
    var ref_list: param_list is ref_list.EMPTY;
    var reference: result_object is NIL;
    var reference: result_init is NIL;
    var string: category is "";
  begin
    current_object := getValue(fwd_ref, reference);
    current_type := getType(current_object);
    if is_func(current_type) or is_varfunc(current_type) then
      result_type := result_type(current_type);
      param_list := params(current_object);
      if param_list_okay(param_list) then
        # Forward declared procedures cannot (at the moment) be macros 
        function_declared @:= [current_object] TRUE;
        c_expr.expr &:= "static ";
        c_expr.expr &:= type_name(result_type);
        if is_varfunc(current_type) then
          c_expr.expr &:= " *o_";
        else
          c_expr.expr &:= " o_";
        end if;
        create_name(current_object, c_expr.expr);
        c_expr.expr &:= " (";
        process_param_list_declaration(param_list, c_param_list);
        c_expr.expr &:= c_param_list.expr;
        c_expr.expr &:= ");\n\n";
      end if;
    else
      category := category(current_object);
      if category = "ARRAYOBJECT" then
        c_expr.expr &:= "arraytype o_";
      else
        c_expr.expr &:= type_name(current_type);
        c_expr.expr &:= " o_";
      end if;
      create_name(current_object, c_expr.expr);
      c_expr.expr &:= ";\n\n";
    end if;
  end func;


const proc: process_type_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var type: aType is void;
  begin
    if is_var(current_object) then
      c_expr.expr &:= "typetype o_";
      create_name(current_object, c_expr.expr);
      c_expr.expr &:= "=NULL";
      c_expr.expr &:= ";\n\n";
    else
      aType := getValue(current_object, type);
      if is_derived(aType) and
          meta(aType) in isInterfaceType and
          aType not in isInterfaceType then
        isInterfaceType @:= [aType] TRUE;
      end if;
      declare_type_if_necessary(aType, c_expr);
    end if;
    count_declarations;
  end func;


const proc: process_int_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  begin
    if is_var(current_object) then
      c_expr.expr &:= "inttype o_";
      create_name(current_object, c_expr.expr);
      c_expr.expr &:= "=";
      c_expr.expr &:= str(getValue(current_object, integer));
      c_expr.expr &:= ";\n\n";
      count_declarations;
    end if;
  end func;


const proc: process_bigint_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  begin
    if is_var(current_object) then
      c_expr.expr &:= "biginttype o_";
      create_name(current_object, c_expr.expr);
      c_expr.expr &:= ";\n\n";
      if getValue(current_object, bigInteger) not in bigint_const_table then
        bigint_const_table @:= [getValue(current_object, bigInteger)] length(bigint_const_table);
      end if;
      global_init.expr &:= "o_";
      create_name(current_object, global_init.expr);
      global_init.expr &:= "=bigCreate(big[";
      global_init.expr &:= str(bigint_const_table[getValue(current_object, bigInteger)]);
      global_init.expr &:= "] /* ";
      global_init.expr &:= str(getValue(current_object, bigInteger));
      global_init.expr &:= " */";
      global_init.expr &:= ");\n";
      count_declarations;
    end if;
  end func;


const proc: process_char_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  begin
    if is_var(current_object) then
      c_expr.expr &:= "chartype o_";
      create_name(current_object, c_expr.expr);
      c_expr.expr &:= "=";
      c_expr.expr &:= c_literal(getValue(current_object, char));
      c_expr.expr &:= ";\n\n";
      count_declarations;
    end if;
  end func;


const proc: process_stri_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  begin
    if is_var(current_object) then
      c_expr.expr &:= "stritype o_";
      create_name(current_object, c_expr.expr);
      c_expr.expr &:= ";\n\n";
      if getValue(current_object, string) not in stri_const_table then
        stri_const_table @:= [getValue(current_object, string)] length(stri_const_table);
      end if;
      global_init.expr &:= "o_";
      create_name(current_object, global_init.expr);
      global_init.expr &:= "=strCreate(str[";
      global_init.expr &:= str(stri_const_table[getValue(current_object, string)]);
      global_init.expr &:= "] /* ";
      global_init.expr &:= replace(c_literal(getValue(current_object, string)), "*/", "* /");
      global_init.expr &:= " */";
      global_init.expr &:= ");\n";
      count_declarations;
    end if;
  end func;


const proc: process_bstri_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  begin
    if is_var(current_object) then
      c_expr.expr &:= "bstritype o_";
      create_name(current_object, c_expr.expr);
      c_expr.expr &:= ";\n\n";
      global_init.expr &:= "o_";
      create_name(current_object, global_init.expr);
      global_init.expr &:= "=bstCreate(&empty_bst);\n";
      count_declarations;
    end if;
  end func;


const proc: process_float_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  begin
    if is_var(current_object) then
      c_expr.expr &:= "floattype o_";
      create_name(current_object, c_expr.expr);
      c_expr.expr &:= "=";
      c_expr.expr &:= str(getValue(current_object, float));
      c_expr.expr &:= ";\n\n";
      count_declarations;
    end if;
  end func;


const proc: action_address (in reference: procedure, inout expr_type: c_expr) is func

  local
    var ACTION: current_action is action "PRC_NOOP";
    var string: action_name is "";
    var type: object_type is void;
  begin
    current_action := getValue(procedure, ACTION);
    action_name := str(current_action);
    if action_name = "ARR_CREATE" then
      object_type := getType(params(procedure)[1]);
      process_create_declaration(object_type, global_c_expr);
      c_expr.expr &:= "&create_";
      c_expr.expr &:= str(type_number(object_type));
    elsif action_name = "ARR_DESTR" then
      object_type := getType(params(procedure)[1]);
      process_destr_declaration(object_type, global_c_expr);
      c_expr.expr &:= "&destr_";
      c_expr.expr &:= str(type_number(object_type));
    elsif action_name = "ARR_CPY" then
      object_type := getType(params(procedure)[1]);
      process_cpy_declaration(object_type, global_c_expr);
      c_expr.expr &:= "&cpy_";
      c_expr.expr &:= str(type_number(object_type));
    elsif action_name = "BIG_CMP" then
      c_expr.expr &:= "&bigCmp";
    elsif action_name = "BIG_CPY" then
      c_expr.expr &:= "&bigCpy";
    elsif action_name = "BIG_CREATE" then
      c_expr.expr &:= "&bigCreate";
    elsif action_name = "BIG_DESTR" then
      c_expr.expr &:= "&bigDestr";
    elsif action_name = "BLN_CPY" then
      c_expr.expr &:= "&blnCpy";
    elsif action_name = "BLN_CREATE" then
      c_expr.expr &:= "&blnCreate";
    elsif action_name = "CHR_CMP" then
      c_expr.expr &:= "&chrCmp";
    elsif action_name = "CHR_CPY" then
      c_expr.expr &:= "&chrCpy";
    elsif action_name = "CHR_CREATE" then
      c_expr.expr &:= "&chrCreate";
    elsif action_name = "DRW_CMP" then
      c_expr.expr &:= "&drwCmp";
    elsif action_name = "DRW_CPY" then
      c_expr.expr &:= "&drwCpy";
    elsif action_name = "DRW_CREATE" then
      c_expr.expr &:= "&drwCreate";
    elsif action_name = "DRW_DESTR" then
      c_expr.expr &:= "&drwDestr";
    elsif action_name = "FLT_CMP" then
      c_expr.expr &:= "&fltCmp";
    elsif action_name = "FLT_CPY" then
      c_expr.expr &:= "&fltCpy";
    elsif action_name = "FLT_CREATE" then
      c_expr.expr &:= "&fltCreate";
    elsif action_name = "INT_CMP" then
      c_expr.expr &:= "&intCmp";
    elsif action_name = "INT_CPY" then
      c_expr.expr &:= "&intCpy";
    elsif action_name = "INT_CREATE" then
      c_expr.expr &:= "&intCreate";
    elsif action_name = "PRC_NOOP" then
      c_expr.expr &:= "&prcNoop";
    elsif action_name = "REF_CREATE" then
      c_expr.expr &:= "&refCreate";
    elsif action_name = "REF_CPY" then
      c_expr.expr &:= "&refCpy";
    elsif action_name = "REF_CMP" then
      c_expr.expr &:= "&refCmp";
    elsif action_name = "SCT_CREATE" then
      object_type := getType(params(procedure)[1]);
      process_create_declaration(object_type, global_c_expr);
      c_expr.expr &:= "&create_";
      c_expr.expr &:= str(type_number(object_type));
    elsif action_name = "SCT_DESTR" then
      object_type := getType(params(procedure)[1]);
      process_destr_declaration(object_type, global_c_expr);
      c_expr.expr &:= "&destr_";
      c_expr.expr &:= str(type_number(object_type));
    elsif action_name = "SCT_CPY" then
      object_type := getType(params(procedure)[1]);
      process_cpy_declaration(object_type, global_c_expr);
      c_expr.expr &:= "&cpy_";
      c_expr.expr &:= str(type_number(object_type));
    elsif action_name = "SET_CMP" then
      c_expr.expr &:= "&setCmp";
    elsif action_name = "SET_CPY" then
      c_expr.expr &:= "&setCpy";
    elsif action_name = "SET_CREATE" then
      c_expr.expr &:= "&setCreate";
    elsif action_name = "SET_DESTR" then
      c_expr.expr &:= "&setDestr";
    elsif action_name = "STR_CREATE" then
      c_expr.expr &:= "&strCreate";
    elsif action_name = "STR_CMP" then
      c_expr.expr &:= "&strCompare";
    elsif action_name = "STR_CPY" then
      c_expr.expr &:= "&strCopy";
    elsif action_name = "STR_DESTR" then
      c_expr.expr &:= "&strDestr";
    else
      c_expr.expr &:= "NULL /* ACTOBJECT { ";
      c_expr.expr &:= action_name;
      c_expr.expr &:= " }*/";
    end if;
  end func;


const proc: process_reference_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var reference: curr_expr is NIL;
    var string: category is "";
  begin
    (* if is_var(current_object) then *)
      c_expr.expr &:= "void *o_";
      create_name(current_object, c_expr.expr);
      c_expr.expr &:= "=";
      if getValue(current_object, reference) = NIL then
        c_expr.expr &:= "NULL";
      else
        curr_expr := getValue(current_object, reference);
        category := category(curr_expr);
        if category = "ACTOBJECT" then
          action_address(curr_expr, c_expr);
        elsif category = "BLOCKOBJECT" then
          c_expr.expr &:= "&o_";
          create_name(curr_expr, c_expr.expr);
        else
          c_expr.expr &:= "/* ";
          c_expr.expr &:= category;
          c_expr.expr &:= " */";
          block
            c_expr.expr &:= "&(";
            process_expr(getValue(current_object, reference), c_expr);
            c_expr.expr &:= ")";
          exception
            catch RANGE_ERROR:
              c_expr.expr &:= "/*RANGE_ERROR*/";
              curr_expr := getValue(current_object, reference);
              writeln("] ");
              TRACE(curr_expr);
              writeln;
          end block;
        end if;
      end if;
      c_expr.expr &:= ";\n\n";
      count_declarations;
    (* end if; *)
  end func;


const proc: process_ref_list_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var reference: element is NIL;
    var boolean: first_element is TRUE;
  begin
    if TRUE then
      if length(getValue(current_object, ref_list)) = 0 then
        c_expr.expr &:= "void *o_";
        create_name(current_object, c_expr.expr);
        c_expr.expr &:= "=";
        c_expr.expr &:= "NULL";
      else
        c_expr.expr &:= "void *o_";
        create_name(current_object, c_expr.expr);
        c_expr.expr &:= "[]=";
        c_expr.expr &:= "{";
        for element range getValue(current_object, ref_list) do
          if first_element then
            first_element := FALSE;
          else
            c_expr.expr &:= ", ";
          end if;
          c_expr.expr &:= "&(";
          process_expr(element, c_expr);
          c_expr.expr &:= ")";
        end for;
        c_expr.expr &:= "}";
      end if;
      c_expr.expr &:= ";\n\n";
      count_declarations;
    end if;
  end func;


const proc: process_file_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "filetype o_";
    create_name(current_object, c_expr.expr);
    c_expr.expr &:= "=NULL;\n\n";
    count_declarations;
  end func;


const proc: process_socket_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "sockettype o_";
    create_name(current_object, c_expr.expr);
    c_expr.expr &:= "=-1;\n\n";
    count_declarations;
  end func;


const proc: process_array_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var string: param_value is "";
  begin
    c_expr.expr &:= "arraytype o_";
    create_name(current_object, c_expr.expr);
    c_expr.expr &:= ";\n\n";
    if current_object not in const_table then
      const_table @:= [current_object] length(const_table);
    end if;
    global_init.expr &:= "o_";
    create_name(current_object, global_init.expr);
    global_init.expr &:= "=";
    param_value := "arr[";
    param_value &:= str(const_table[current_object]);
    param_value &:= "]";
    if is_var(current_object) then
      process_create_declaration(getType(current_object), global_c_expr);
      process_create_call(getType(current_object),
          param_value, global_init.expr);
    else
      global_init.expr &:= param_value;
    end if;
    global_init.expr &:= ";\n";
    count_declarations;
  end func;


const proc: process_hash_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "hashtype o_";
    create_name(current_object, c_expr.expr);
    c_expr.expr &:= "=NULL";
    c_expr.expr &:= ";\n\n";
    global_init.expr &:= "o_";
    create_name(current_object, global_init.expr);
    global_init.expr &:= "=hshEmpty();\n";
    count_declarations;
  end func;


const proc: process_set_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  begin
    if is_var(current_object) then
      c_expr.expr &:= "settype o_";
      create_name(current_object, c_expr.expr);
      c_expr.expr &:= ";\n\n";
      if getValue(current_object, bitset) not in set_const_table then
        set_const_table @:= [getValue(current_object, bitset)] length(set_const_table);
      end if;
      global_init.expr &:= "o_";
      create_name(current_object, global_init.expr);
      global_init.expr &:= "=setCreate(set[";
      global_init.expr &:= str(set_const_table[getValue(current_object, bitset)]);
      global_init.expr &:= "]);\n";
      count_declarations;
    end if;
  end func;


const proc: process_struct_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var string: param_value is "";
  begin
    c_expr.expr &:= "structtype o_";
    create_name(current_object, c_expr.expr);
    c_expr.expr &:= ";\n\n";
    if current_object not in const_table then
      const_table @:= [current_object] length(const_table);
    end if;
    global_init.expr &:= "o_";
    create_name(current_object, global_init.expr);
    global_init.expr &:= "=";
    param_value := "sct[";
    param_value &:= str(const_table[current_object]);
    param_value &:= "]";
    if is_var(current_object) then
      process_create_declaration(getType(current_object), global_c_expr);
      process_create_call(getType(current_object),
          param_value, global_init.expr);
    else
      global_init.expr &:= param_value;
    end if;
    global_init.expr &:= ";\n";
    count_declarations;
  end func;


const proc: process_class_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  begin
    c_expr.expr &:= "interfacetype o_";
    create_name(current_object, c_expr.expr);
    c_expr.expr &:= ";\n\n";
    if current_object not in const_table then
      const_table @:= [current_object] length(const_table);
    end if;
    global_init.expr &:= "o_";
    create_name(current_object, global_init.expr);
    global_init.expr &:= "=itf[";
    global_init.expr &:= str(const_table[current_object]);
    global_init.expr &:= "];\n";
    count_declarations;
  end func;


const proc: process_win_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  begin
    if is_var(current_object) then
      c_expr.expr &:= "wintype o_";
      create_name(current_object, c_expr.expr);
      c_expr.expr &:= "=";
      c_expr.expr &:= "NULL";
      c_expr.expr &:= ";\n\n";
      count_declarations;
    end if;
  end func;


const proc: process_prog_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  begin
    if is_var(current_object) then
      c_expr.expr &:= "progtype o_";
      create_name(current_object, c_expr.expr);
      c_expr.expr &:= "=";
      c_expr.expr &:= "NULL";
      c_expr.expr &:= ";\n\n";
      count_declarations;
    end if;
  end func;


const proc: process_enum_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  begin
    if is_var(current_object) then
      declare_type_if_necessary(getType(current_object), c_expr);
      c_expr.expr &:= type_name(getType(current_object));
      c_expr.expr &:= " o_";
      create_name(current_object, c_expr.expr);
      c_expr.expr &:= "=";
      c_expr.expr &:= enum_value(getValue(current_object, reference));
      c_expr.expr &:= ";\n\n";
    else
      declare_type_if_necessary(getType(current_object), c_expr);
      c_expr.expr &:= type_name(getType(current_object));
      c_expr.expr &:= " o_";
      create_name(current_object, c_expr.expr);
      c_expr.expr &:= "=";
      c_expr.expr &:= enum_value(getValue(current_object, reference));
      c_expr.expr &:= ";\n\n";
    end if;
    count_declarations;
  end func;


const proc: process_enum_literal_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var type: enum_type is void;
  begin
    enum_type := getType(current_object);
    if enum_type not in enum_literal then
      enum_literal @:= [enum_type] element_number_hash.EMPTY_HASH;
    end if;
    if current_object not in enum_literal[enum_type] then
      enum_literal[enum_type] @:= [current_object] length(enum_literal[enum_type]);
    end if;
    declare_type_if_necessary(getType(current_object), c_expr);
    c_expr.expr &:= type_name(getType(current_object));
    c_expr.expr &:= " o_";
    create_name(current_object, c_expr.expr);
    c_expr.expr &:= "=";
    c_expr.expr &:= enum_value(current_object);
    c_expr.expr &:= ";\n\n";
    count_declarations;
  end func;


const proc: print_parameter_list (in ref_list: formal_params,
    inout expr_type: c_expr) is func

  local
    var reference: formal_param is NIL;
    var string: category is "";
    var boolean: first_element is TRUE;
    var type: param_type is void;
    var type: implementationType is void;
  begin
    for formal_param range formal_params do
      category := category(formal_param);
      if category <> "SYMBOLOBJECT" then
        if first_element then
          first_element := FALSE;
        else
          c_expr.expr &:= " printf(\", \");\n";
        end if;
        param_type := getType(formal_param);
        if param_type in implements then
          c_expr.expr &:= " /*# ";
          for implementationType range implements[param_type] do
            c_expr.expr &:= "t_";
            c_expr.expr &:= str(type_number(implementationType));
            c_expr.expr &:= "**";
            c_expr.expr &:= str(implementationType);
            c_expr.expr &:= "  ";
          end for;
          c_expr.expr &:= " */ ";
        end if;
        c_expr.expr &:= "printf(";
        c_expr.expr &:= c_literal(category & " ");
        c_expr.expr &:= "); ";
        if param_type = stritype then
          c_expr.expr &:= "printf(\"stritype \"); ";
          c_expr.expr &:= "prc_print(";
        elsif param_type = chartype then
          c_expr.expr &:= "printf(\"chartype \"); ";
          c_expr.expr &:= "printf(\"%c\", ";
        elsif param_type = inttype then
          c_expr.expr &:= "printf(\"inttype \"); ";
          c_expr.expr &:= "printf(\"%ld\", ";
        elsif param_type = floattype then
          c_expr.expr &:= "printf(\"floattype \"); ";
          c_expr.expr &:= "printf(\"%f\", ";
        elsif param_type = typetype then
          c_expr.expr &:= "printf(\"typetype \"); ";
          c_expr.expr &:= "printf(\"%X\", ";
        elsif param_type = proctype then
          c_expr.expr &:= "printf(\"proctype \"); ";
          c_expr.expr &:= "printf(\"%X\", ";
        elsif param_type = voidtype then
          c_expr.expr &:= "printf(\"voidtype \"); ";
          c_expr.expr &:= "printf(\"%X\", ";
        else
          c_expr.expr &:= "printf(\"";
          c_expr.expr &:= "t_";
          c_expr.expr &:= str(type_number(param_type));
          c_expr.expr &:= "/*";
          c_expr.expr &:= str(param_type);
          c_expr.expr &:= "*/ \"); ";
          c_expr.expr &:= "printf(\"%X\", ";
        end if;
        if isPointerParam(formal_param) then
          c_expr.expr &:= "(o_";
          create_name(formal_param, c_expr.expr);
          c_expr.expr &:= "?*o_";
          create_name(formal_param, c_expr.expr);
          c_expr.expr &:= ":0)";
        else
          c_expr.expr &:= "o_";
          create_name(formal_param, c_expr.expr);
        end if;
        c_expr.expr &:= ");";
      end if;
    end for;
  end func;


const proc: process_dynamic_parameter_list (in ref_list: actual_params,
    in reference: matched_object, inout expr_type: c_expr) is func

  local
    var ref_list: formal_params is ref_list.EMPTY;
    var reference: formal_param is NIL;
    var reference: actual_param is NIL;
    var string: category is "";
    var boolean: first_element is TRUE;
    var type: param_type is void;
    var type: implementationType is void;
    var integer: number is 0;
  begin
    formal_params := params(matched_object);
    for number range 1 to length(formal_params) do
      formal_param := formal_params[number];
      actual_param := actual_params[number];
      category := category(actual_param);
      if category <> "SYMBOLOBJECT" and
          category(formal_param) <> "SYMBOLOBJECT" then
        if first_element then
          first_element := FALSE;
        else
          c_expr.expr &:= ", ";
        end if;
        if not is_var(actual_param) and is_var(formal_param) then
          c_expr.expr &:= "/* SHOULD NOT HAPPEN &o_";
          create_name(actual_param, c_expr.expr);
          c_expr.expr &:= " */";
        elsif isPointerParam(actual_param) = isPointerParam(formal_param) then
          c_expr.expr &:= "o_";
          create_name(actual_param, c_expr.expr);
        elsif isPointerParam(actual_param) and not isPointerParam(formal_param) then
          c_expr.expr &:= "*o_";
          create_name(actual_param, c_expr.expr);
        else # if not is_var(formal_param) or is_var(actual_param) then
          c_expr.expr &:= "&o_";
          create_name(actual_param, c_expr.expr);
        end if;
      end if;
    end for;
  end func;


const proc: process_dynamic_action_call (in ref_list: actual_params,
    in reference: matched_object, inout expr_type: c_expr) is func

  local
    var expr_type: c_action_expr is expr_type.value;
  begin
    # c_expr.expr &:= "/* ";
    # c_expr.expr &:= str(getValue(matched_object, ACTION));
    # c_expr.expr &:= " */ ";
    c_action_expr.temp_num := c_expr.temp_num;
    process_action(matched_object, actual_params, c_action_expr);
    c_expr.temp_num := c_action_expr.temp_num;
    c_expr.temp_decls &:= c_action_expr.temp_decls;
    c_expr.temp_assigns &:= c_action_expr.temp_assigns;
    c_expr.temp_frees &:= c_action_expr.temp_frees;
    if c_action_expr.result_expr <> "" then
      c_expr.expr &:= c_action_expr.result_expr;
    else
      c_expr.expr &:= c_action_expr.expr;
    end if;
  end func;


const proc: process_dynamic_call (in reference: current_object,
    in reference: matched_object, in ref_list: actual_params,
    inout expr_type: c_expr) is func

  local
    var string: category is "";
  begin
    if matched_object <> NIL then
      category := category(matched_object);
      if category = "BLOCKOBJECT" then
        if result_type(getType(current_object)) <> voidtype then
          c_expr.expr &:= "return ";
        end if;
        c_expr.expr &:= "o_";
        create_name(matched_object, c_expr.expr);
        c_expr.expr &:= "(";
        process_dynamic_parameter_list(actual_params, matched_object, c_expr);
        c_expr.expr &:= ");\n";
      elsif category = "ACTOBJECT" then
        if result_type(getType(current_object)) <> voidtype then
          c_expr.expr &:= "return ";
          if is_varfunc(getType(current_object)) then
            c_expr.expr &:= "&(";
          end if;
        end if;
        process_dynamic_action_call(actual_params, matched_object, c_expr);
        if result_type(getType(current_object)) <> voidtype then
          if is_varfunc(getType(current_object)) then
            c_expr.expr &:= ")";
          end if;
          c_expr.expr &:= ";\n";
        end if;
      elsif category = "INTOBJECT" or
          category = "BIGINTOBJECT" or
          category = "FLOATOBJECT" or
          category = "CHAROBJECT" or
          category = "STRIOBJECT" or
          category = "BSTRIOBJECT" or
          category = "SETOBJECT" or
          category = "CONSTENUMOBJECT" then
        c_expr.expr &:= "return ";
        process_expr(matched_object, c_expr);
        c_expr.expr &:= ";\n";
      else
        c_expr.expr &:= "/* ";
        c_expr.expr &:= category;
        c_expr.expr &:= " */\n";
      end if;
    else
      c_expr.expr &:= "/* NOT FOUND */\n";
    end if;
  end func;


const proc: process_dynamic_condition (in reference: current_object,
    inout ref_list: formal_params, in var integer: paramNum,
    inout expr_type: c_expr) is forward;


const proc: process_dynamic_param_implements (in reference: current_object,
    inout ref_list: formal_params, in var integer: paramNum,
    in type: param_type, inout expr_type: c_expr) is func

  local
    var reference: formal_param is NIL;
    var type: implementationType is void;
  begin
    formal_param := formal_params[paramNum];
    for implementationType range implements[param_type] do
      c_expr.expr &:= "if (";
      if isPointerParam(formal_param) then
        c_expr.expr &:= "((interfacetype) *o_";
        create_name(formal_param, c_expr.expr);
        c_expr.expr &:= ")->type_num";
      else
        c_expr.expr &:= "((interfacetype) o_";
        create_name(formal_param, c_expr.expr);
        c_expr.expr &:= ")->type_num";
      end if;
      c_expr.expr &:= "==";
      c_expr.expr &:= str(type_number(implementationType));
      c_expr.expr &:= "/*";
      c_expr.expr &:= str(implementationType);
      c_expr.expr &:= "*/";
      c_expr.expr &:= ") {\n";

      setType(formal_params[paramNum], implementationType);
      process_dynamic_condition(current_object,
          formal_params, paramNum, c_expr);
      setType(formal_params[paramNum], param_type);
      c_expr.expr &:= "} else ";
    end for;
    c_expr.expr &:= "{\n";
    c_expr.expr &:= "printf(\"type_num=%d\\n\", ";
    if isPointerParam(formal_param) then
      c_expr.expr &:= "((interfacetype) *o_";
      create_name(formal_param, c_expr.expr);
      c_expr.expr &:= ")->type_num";
    else
      c_expr.expr &:= "((interfacetype) o_";
      create_name(formal_param, c_expr.expr);
      c_expr.expr &:= ")->type_num";
    end if;
    c_expr.expr &:= ");\n";
    c_expr.expr &:= "printf(\"o_";
    create_name(current_object, c_expr.expr);
    c_expr.expr &:= "(\");\n";
    print_parameter_list(formal_params, c_expr);
    c_expr.expr &:= "printf(\")\\n\");\n";
    c_expr.expr &:= "}\n";
  end func;


const proc: process_dynamic_param_enumeration (in reference: current_object,
    inout ref_list: formal_params, in var integer: paramNum,
    in type: param_type, inout expr_type: c_expr) is func

  local
    var reference: formal_param is NIL;
    var reference: enumLiteral is NIL;
    var integer: enumLiteralNumber is 0;
    var reference: backupParam is NIL;
  begin
    formal_param := formal_params[paramNum];
    c_expr.expr &:= "switch (";
    if isPointerParam(formal_param) then
      c_expr.expr &:= "*o_";
      create_name(formal_param, c_expr.expr);
    else
      c_expr.expr &:= "o_";
      create_name(formal_param, c_expr.expr);
    end if;
    c_expr.expr &:= ") {\n";
    for enumLiteralNumber key enumLiteral range enum_literal[param_type] do
      c_expr.expr &:= "case ";
      c_expr.expr &:= str(enumLiteralNumber);
      c_expr.expr &:= ": {\n";

      backupParam := formal_params[paramNum];
      formal_params @:= [paramNum] enumLiteral;
      process_dynamic_condition(current_object,
          formal_params, paramNum, c_expr);
      formal_params @:= [paramNum] backupParam;
      c_expr.expr &:= "} break;\n";
    end for;
    c_expr.expr &:= "default: {\n";
    c_expr.expr &:= "printf(\"literal_num=%d\\n\", ";
    if isPointerParam(formal_param) then
      c_expr.expr &:= "*o_";
      create_name(formal_param, c_expr.expr);
    else
      c_expr.expr &:= "o_";
      create_name(formal_param, c_expr.expr);
    end if;
    c_expr.expr &:= ");\n";
    c_expr.expr &:= "printf(\"o_";
    create_name(current_object, c_expr.expr);
    c_expr.expr &:= "(\");\n";
    print_parameter_list(formal_params, c_expr);
    c_expr.expr &:= "printf(\")\\n\");\n";
    c_expr.expr &:= "} break;\n";
    c_expr.expr &:= "}\n";
  end func;


const proc: process_dynamic_condition (in reference: current_object,
    inout ref_list: formal_params, in var integer: paramNum,
    inout expr_type: c_expr) is func

  local
    var reference: formal_param is NIL;
    var string: category is "";
    var type: param_type is void;
    var ref_list: param_list is ref_list.EMPTY;
    var reference: matched_object is NIL;
  begin
    incr(paramNum);
    if paramNum <= length(formal_params) then
      formal_param := formal_params[paramNum];
      category := category(formal_param);
      if category <> "SYMBOLOBJECT" then
        param_type := getType(formal_param);
        if param_type in implements then
          process_dynamic_param_implements(current_object,
              formal_params, paramNum, param_type, c_expr);
        elsif param_type in enum_literal then
          process_dynamic_param_enumeration(current_object,
              formal_params, paramNum, param_type, c_expr);
        else
          process_dynamic_condition(current_object,
              formal_params, paramNum, c_expr);
        end if;
      else
        process_dynamic_condition(current_object,
            formal_params, paramNum, c_expr);
      end if;
    else
      param_list := formal_params;
      matched_object := match(prog, param_list);
      process_dynamic_call(current_object, matched_object, formal_params, c_expr);
    end if;
  end func;


const proc: process_dynamic_decision (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var expr_type: c_param_list is expr_type.value;
    var expr_type: c_proc_body is expr_type.value;
    var type: object_type is void;
    var type: result_type is void;
    var ref_list: param_list is ref_list.EMPTY;
  begin
    object_type := getType(current_object);
    if is_func(object_type) or is_varfunc(object_type) then
      result_type := result_type(object_type);
      if result_type <> typetype then
        c_expr.expr &:= "/* DYNAMIC */ ";
        c_expr.expr &:= type_name(result_type);
        if is_varfunc(object_type) then
          c_expr.expr &:= " *o_";
        else
          c_expr.expr &:= " o_";
        end if;
        create_name(current_object, c_expr.expr);
        param_list := params(current_object);
        c_expr.expr &:= " (";
        process_param_list_declaration(param_list, c_param_list);
        c_expr.expr &:= c_param_list.expr;
        c_expr.expr &:= ")\n";
        c_expr.expr &:= "{\n";
        process_dynamic_condition(current_object,
            param_list, 0, c_proc_body);
        c_expr.expr &:= c_proc_body.temp_decls;
        c_expr.expr &:= c_proc_body.temp_assigns;
        c_expr.expr &:= c_proc_body.expr;
        c_expr.expr &:= "}\n\n";
      end if;
    end if;
  end func;


const proc: process_dynamic_decisions (inout expr_type: c_expr) is func

  local
    var reference: current_object is NIL;
  begin
    for current_object range dynamic_functions do
      process_dynamic_decision(current_object, c_expr);
    end for;
  end func;


const proc: process_dynamic_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var expr_type: c_param_list is expr_type.value;
    var type: object_type is void;
    var type: result_type is void;
    var ref_list: param_list is ref_list.EMPTY;
  begin
    object_type := getType(current_object);
    if is_func(object_type) or is_varfunc(object_type) then
      result_type := result_type(object_type);
      if result_type <> typetype then
        dynamic_functions &:= make_list(current_object);
        c_expr.expr &:= "/* DYNAMIC */ ";
        c_expr.expr &:= type_name(result_type);
        if is_varfunc(object_type) then
          c_expr.expr &:= " *o_";
        else
          c_expr.expr &:= " o_";
        end if;
        create_name(current_object, c_expr.expr);
        param_list := params(current_object);
        c_expr.expr &:= " (";
        process_param_list_declaration(param_list, c_param_list);
        c_expr.expr &:= c_param_list.expr;
        c_expr.expr &:= ");\n";
      end if;
    end if;
  end func;


const proc: create_func_addr(in type: arrayType, inout expr_type: c_expr) is func
  local
    var type: baseType is void;
  begin
(*
    main_obj := sys_var(prog, "main");
    baseType := base_type(arrayType);
(ref baseType param) ::= (in baseType param)
*)
    c_expr.expr &:= "NULL";
  end func;


const proc: destroy_func_addr(in type: arrayType, inout expr_type: c_expr) is func
  local
    var type: baseType is void;
  begin
(*
    main_obj := sys_var(prog, "main");
    baseType := base_type(arrayType);
(ref baseType param) ::= (in baseType param)
*)
    c_expr.expr &:= "NULL";
  end func;


const proc: copy_func_addr(in type: arrayType, inout expr_type: c_expr) is func
  local
    var type: baseType is void;
  begin
(*
    main_obj := sys_var(prog, "main");
    baseType := base_type(arrayType);
(ref baseType param) ::= (in baseType param)
*)
    c_expr.expr &:= "NULL";
  end func;


const func type: base_type (in type: array_type) is func
  result
    var type: result is void;
  local
    var ref_list: param_list is ref_list.EMPTY;
    var reference: matched_object is NIL;
  begin
    param_list := make_list(match_obj(array_type));
    param_list &:= make_list(syobject(prog, "base_type"));
    matched_object := match(prog, param_list);
    if matched_object <> NIL and category(matched_object) = "TYPEOBJECT" then
      result := getValue(matched_object, type);
    end if;
  end func;


const proc: process_arr_create_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var ref_list: params is ref_list.EMPTY;
    var type: base_type is void;
    var type: object_type is void;
    var element_number_hash: element_number is element_number_hash.EMPTY_HASH;
    var element_type_hash: element_type is element_type_hash.EMPTY_HASH;
  begin
    params := params(current_object);
    object_type := getType(params[1]);
    base_type := base_type(object_type);
    if base_type <> void then
      if object_type not in array_element then
        array_element @:= [object_type] base_type;
      end if;
      if base_type not in array_type then
        array_type @:= [base_type] object_type;
      end if;
    end if;
  end func;


const proc: process_arr_gen_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var ref_list: params is ref_list.EMPTY;
    var type: result_type is void;
    var type: object_type is void;
    var element_number_hash: element_number is element_number_hash.EMPTY_HASH;
    var element_type_hash: element_type is element_type_hash.EMPTY_HASH;
  begin
    result_type := result_type(getType(current_object));
    params := params(current_object);
    object_type := getType(params[1]);
    if result_type not in array_element then
      array_element @:= [result_type] object_type;
    end if;
    if object_type not in array_type then
      array_type @:= [object_type] result_type;
    end if;
    c_expr.expr &:= "/* ACTION ARR_GEN for type ";
    c_expr.expr &:= "t_";
    c_expr.expr &:= str(type_number(result_type));
    c_expr.expr &:= "**";
    c_expr.expr &:= str(result_type);
    c_expr.expr &:= " element is ";
    c_expr.expr &:= "t_";
    c_expr.expr &:= str(type_number(object_type));
    c_expr.expr &:= "**";
    c_expr.expr &:= str(object_type);
    c_expr.expr &:= "*/\n\n";
  end func;


const proc: process_arr_idx_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var ref_list: params is ref_list.EMPTY;
    var type: result_type is void;
    var type: object_type is void;
    var element_number_hash: element_number is element_number_hash.EMPTY_HASH;
    var element_type_hash: element_type is element_type_hash.EMPTY_HASH;
  begin
    result_type := result_type(getType(current_object));
    params := params(current_object);
    object_type := getType(params[1]);
    if object_type not in array_element then
      array_element @:= [object_type] result_type;
    end if;
    if result_type not in array_type then
      array_type @:= [result_type] object_type;
    end if;
    c_expr.expr &:= "/* ACTION ARR_IDX for type ";
    c_expr.expr &:= "t_";
    c_expr.expr &:= str(type_number(object_type));
    c_expr.expr &:= "**";
    c_expr.expr &:= str(object_type);
    c_expr.expr &:= " element is ";
    c_expr.expr &:= "t_";
    c_expr.expr &:= str(type_number(result_type));
    c_expr.expr &:= "**";
    c_expr.expr &:= str(result_type);
    c_expr.expr &:= "*/\n\n";
  end func;


const proc: process_arr_times_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var ref_list: params is ref_list.EMPTY;
    var type: result_type is void;
    var type: object_type is void;
    var integer: number is 0;
    var reference: struct_elem is NIL;
  begin
    result_type := result_type(getType(current_object));
    params := params(current_object);
    object_type := getType(params[3]);
    process_create_declaration(object_type, c_expr);
    c_expr.expr &:= type_name(result_type);
    c_expr.expr &:= " times_";
    c_expr.expr &:= str(type_number(result_type));
    c_expr.expr &:= " (inttype n, ";
    c_expr.expr &:= type_name(object_type);
    c_expr.expr &:= " b)\n";
    c_expr.expr &:= "{\n";
    c_expr.expr &:= type_name(result_type);
    c_expr.expr &:= " a;\n";
    c_expr.expr &:= "unsigned long i;\n";
    c_expr.expr &:= "if (n  < 0) {\n";
    c_expr.expr &:= "raise_error(RANGE_ERROR);\n";
    c_expr.expr &:= "} else {\n";
    c_expr.expr &:= "a=malloc(sizeof(struct arraystruct) - sizeof(long) + n * sizeof(long));\n";
    c_expr.expr &:= "((arraytype)a)->min_position = 1;\n";
    c_expr.expr &:= "((arraytype)a)->max_position = n;\n";
    c_expr.expr &:= "for (i = 0; i < n; i++) {\n";
    if object_type = floattype then
      c_expr.expr &:= "((arraytype)a)->arr[i].value.floatvalue=";
    else
      c_expr.expr &:= "((arraytype)a)->arr[i].value.intvalue=";
    end if;
    process_create_call(object_type, "b", c_expr.expr);
    c_expr.expr &:= ";\n";
    c_expr.expr &:= "}\n";
    c_expr.expr &:= "}\n";
    c_expr.expr &:= "return(a);\n";
    c_expr.expr &:= "}\n\n";
  end func;


const proc: process_bln_cpy_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var ref_list: params is ref_list.EMPTY;
    var type: booltype is void;
  begin
    params := params(current_object);
    booltype := getType(params[1]);
    if booltype not in simple_pod_type then
      simple_pod_type @:= [booltype] TRUE;
    end if;
  end func;


const proc: process_cls_cpy_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var ref_list: params is ref_list.EMPTY;
    var type: itf_type is void;
  begin
    params := params(current_object);
    itf_type := getType(params[1]);
    if itf_type not in isInterfaceType then
      isInterfaceType @:= [itf_type] TRUE;
    end if;
  end func;


const proc: addImplementationToInterface (in type: implementationType, in type: interfaceType) is func

  begin
    if interfaceType in implements then
      implements[interfaceType] &:= [] (implementationType);
    else
      implements @:= [interfaceType] [] (implementationType);
    end if;
    if implementationType in interfaceOfType then
      interfaceOfType[implementationType] &:= [] (interfaceType);
    else
      interfaceOfType @:= [implementationType] [] (interfaceType);
    end if;
  end func;


const proc: process_cls_cpy2_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var ref_list: params is ref_list.EMPTY;
    var type: interfaceType is void;
    var type: implementationType is void;
  begin
    params := params(current_object);
    interfaceType := getType(params[1]);
    implementationType := getType(params[3]);
    addImplementationToInterface(implementationType, interfaceType);
    c_expr.expr &:= "/* cls_cpy2: t_";
    c_expr.expr &:= str(type_number(interfaceType));
    c_expr.expr &:= "**";
    c_expr.expr &:= str(interfaceType);
    c_expr.expr &:= " := t_";
    c_expr.expr &:= str(type_number(implementationType));
    c_expr.expr &:= "**";
    c_expr.expr &:= str(implementationType);
    c_expr.expr &:= "*/\n";
  end func;


const proc: process_drw_cpy_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var ref_list: params is ref_list.EMPTY;
  begin
    params := params(current_object);
    wintype := getType(params[1]);
  end func;


const proc: process_fil_cpy_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var ref_list: params is ref_list.EMPTY;
    var type: filetype is void;
  begin
    params := params(current_object);
    filetype := getType(params[1]);
    if filetype not in simple_pod_type then
      simple_pod_type @:= [filetype] TRUE;
    end if;
  end func;


const proc: process_soc_cpy_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var ref_list: params is ref_list.EMPTY;
    var type: sockettype is void;
  begin
    params := params(current_object);
    sockettype := getType(params[1]);
    if sockettype not in simple_pod_type then
      simple_pod_type @:= [sockettype] TRUE;
    end if;
  end func;


const proc: process_hsh_cpy_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var ref_list: params is ref_list.EMPTY;
    var type: hash_type is void;
  begin
    params := params(current_object);
    hash_type := getType(params[1]);
    if hash_type not in isHashType then
      isHashType @:= [hash_type] TRUE;
    end if;
  end func;


const proc: process_ref_cpy_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var ref_list: params is ref_list.EMPTY;
    var type: reftype is void;
  begin
    params := params(current_object);
    reftype := getType(params[1]);
    if reftype not in simple_pod_type then
      simple_pod_type @:= [reftype] TRUE;
    end if;
  end func;


const proc: addStructElem (in type: structType, in type: elemType, in reference: elementOfStruct) is func

  local
    var element_number_hash: element_number is element_number_hash.EMPTY_HASH;
    var element_type_hash: element_type is element_type_hash.EMPTY_HASH;
  begin
    if structType in struct_elements then
      if elementOfStruct not in struct_elements[structType] then
        struct_elements[structType] @:= [elementOfStruct] length(struct_elements[structType]);
      end if;
      if elementOfStruct not in struct_element_type[structType] then
        struct_element_type[structType] @:= [elementOfStruct] elemType;
      end if;
    else
      element_number @:= [elementOfStruct] 0;
      struct_elements @:= [structType] element_number;
      element_type @:= [elementOfStruct] elemType;
      struct_element_type @:= [structType] element_type;
    end if;
  end func;


const proc: process_sct_cpy_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var ref_list: params is ref_list.EMPTY;
    var type: sct_type is void;
    var type: meta_type is void;
    var type: interfaceType is void;
    var number_element_hash: elements is number_element_hash.EMPTY_HASH;
    var reference: elementOfStruct is NIL;
    var integer: number is 0;
  begin
    params := params(current_object);
    sct_type := getType(params[1]);
    if is_derived(sct_type) then
      meta_type := meta(sct_type);
      if meta_type in struct_elements then
        elements := flip(struct_elements[meta_type]);
        for number range 0 to pred(length(elements)) do
          elementOfStruct := elements[number][1];
          addStructElem(sct_type, struct_element_type[meta_type][elementOfStruct], elementOfStruct);
        end for;
      end if;
      if meta_type in interfaceOfType then
        for interfaceType range interfaceOfType[meta_type] do
          addImplementationToInterface(sct_type, interfaceType);
        end for;
      end if;
    end if;
  end func;


const proc: process_sct_select_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var ref_list: params is ref_list.EMPTY;
    var type: elemType is void;
    var type: structType is void;
    var reference: elementOfStruct is NIL;
    var element_number_hash: element_number is element_number_hash.EMPTY_HASH;
    var element_type_hash: element_type is element_type_hash.EMPTY_HASH;
  begin
    elemType := result_type(getType(current_object));
    params := params(current_object);
    structType := getType(params[1]);
    elementOfStruct := params[3];
    addStructElem(structType, elemType, elementOfStruct);
    c_expr.expr &:= "/* struct element t_";
    c_expr.expr &:= str(type_number(elemType));
    c_expr.expr &:= "**";
    c_expr.expr &:= str(elemType);
    c_expr.expr &:= "** t_";
    c_expr.expr &:= str(type_number(structType));
    c_expr.expr &:= "**";
    c_expr.expr &:= str(structType);
    c_expr.expr &:= "**->o_";
    c_expr.expr &:= str(obj_number(elementOfStruct));
    c_expr.expr &:= "**";
    c_expr.expr &:= str(elementOfStruct);
    c_expr.expr &:= " = ";
    c_expr.expr &:= str(struct_elements[structType][elementOfStruct]);
    c_expr.expr &:= " */\n";
  end func;


const proc: process_set_cpy_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var ref_list: params is ref_list.EMPTY;
  begin
    params := params(current_object);
    set_types @:= [getType(params[1])] TRUE;
  end func;


const proc: process_bst_cpy_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var ref_list: params is ref_list.EMPTY;
  begin
    params := params(current_object);
    bstri_types @:= [getType(params[1])] TRUE;
  end func;


const proc: process_action_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var ACTION: current_action is action "PRC_NOOP";
    var string: action_name is "";
    var type: object_type is void;
  begin
    current_action := getValue(current_object, ACTION);
    action_name := str(current_action);
    if action_name = "PRC_DYNAMIC" then
      process_dynamic_declaration(current_object, c_expr);
      count_declarations;
    elsif action_name = "ARR_CREATE" then
      process_arr_create_declaration(current_object, c_expr);
      count_declarations;
    elsif action_name = "ARR_GEN" then
      process_arr_gen_declaration(current_object, c_expr);
      count_declarations;
    elsif action_name = "ARR_IDX" then
      process_arr_idx_declaration(current_object, c_expr);
      count_declarations;
    elsif action_name = "ARR_TIMES" then
      process_arr_times_declaration(current_object, c_expr);
      count_declarations;
    elsif action_name = "BLN_CPY" then
      process_bln_cpy_declaration(current_object, c_expr);
      count_declarations;
    elsif action_name = "CLS_CPY" then
      process_cls_cpy_declaration(current_object, c_expr);
      count_declarations;
    elsif action_name = "CLS_CPY2" then
      process_cls_cpy2_declaration(current_object, c_expr);
      count_declarations;
    elsif action_name = "DRW_CPY" then
      process_drw_cpy_declaration(current_object, c_expr);
      count_declarations;
    elsif action_name = "FIL_CPY" then
      process_fil_cpy_declaration(current_object, c_expr);
      count_declarations;
    elsif action_name = "SOC_CPY" then
      process_soc_cpy_declaration(current_object, c_expr);
      count_declarations;
    elsif action_name = "HSH_CPY" then
      process_hsh_cpy_declaration(current_object, c_expr);
      count_declarations;
    elsif action_name = "REF_CPY" then
      process_ref_cpy_declaration(current_object, c_expr);
      count_declarations;
    elsif action_name = "SCT_CPY" then
      process_sct_cpy_declaration(current_object, c_expr);
      count_declarations;
    elsif action_name = "SCT_SELECT" then
      process_sct_select_declaration(current_object, c_expr);
      count_declarations;
    elsif action_name = "SET_CPY" then
      process_set_cpy_declaration(current_object, c_expr);
      count_declarations;
    elsif action_name = "BST_CPY" then
      process_bst_cpy_declaration(current_object, c_expr);
      count_declarations;
(*
    else
      c_expr.expr &:= "/* ACTION ";
      c_expr.expr &:= action_name;
      c_expr.expr &:= " */";
*)
    end if;
  end func;


const proc: process_object_declaration (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var string: category is "";
  begin
    category := category(current_object);
    if category = "BLOCKOBJECT" then
      process_func_declaration(current_object, c_expr);
    elsif category = "TYPEOBJECT" then
      process_type_declaration(current_object, c_expr);
    elsif category = "INTOBJECT" then
      process_int_declaration(current_object, c_expr);
    elsif category = "BIGINTOBJECT" then
      process_bigint_declaration(current_object, c_expr);
    elsif category = "CHAROBJECT" then
      process_char_declaration(current_object, c_expr);
    elsif category = "STRIOBJECT" then
      process_stri_declaration(current_object, c_expr);
    elsif category = "BSTRIOBJECT" then
      process_bstri_declaration(current_object, c_expr);
    elsif category = "FLOATOBJECT" then
      process_float_declaration(current_object, c_expr);
    elsif category = "REFOBJECT" then
      process_reference_declaration(current_object, c_expr);
    elsif category = "REFLISTOBJECT" then
      process_ref_list_declaration(current_object, c_expr);
    elsif category = "FILEOBJECT" then
      process_file_declaration(current_object, c_expr);
    elsif category = "SOCKETOBJECT" then
      process_socket_declaration(current_object, c_expr);
    elsif category = "ARRAYOBJECT" then
      process_array_declaration(current_object, c_expr);
    elsif category = "HASHOBJECT" then
      process_hash_declaration(current_object, c_expr);
    elsif category = "SETOBJECT" then
      process_set_declaration(current_object, c_expr);
    elsif category = "STRUCTOBJECT" then
      process_struct_declaration(current_object, c_expr);
    elsif category = "CLASSOBJECT" then
      process_class_declaration(current_object, c_expr);
    elsif category = "WINOBJECT" then
      process_win_declaration(current_object, c_expr);
    elsif category = "PROGOBJECT" then
      process_prog_declaration(current_object, c_expr);
    elsif category = "CONSTENUMOBJECT" then
      process_enum_declaration(current_object, c_expr);
    elsif category = "VARENUMOBJECT" then
      process_enum_declaration(current_object, c_expr);
    elsif category = "ENUMLITERALOBJECT" then
      process_enum_literal_declaration(current_object, c_expr);
    elsif category = "ACTOBJECT" then
      process_action_declaration(current_object, c_expr);
    elsif category = "FWDREFOBJECT" then
      process_forward_declaration(current_object, c_expr);
    else
      c_expr.expr &:= "/* ";
      c_expr.expr &:= category;
      c_expr.expr &:= " */\n";
    end if;
  end func;


const proc: replace_locals_from_outside (inout reference: current_expression,
    in ref_list: local_objects, inout ref_list: additional_act_params,
    inout ref_list: additional_form_params) is func
  local
    var ref_list: params is ref_list.EMPTY;
    var integer: paramNum is 0;
    var reference: obj is NIL;
    var string: category is "";
    var reference: formalRefParam is NIL;
  begin
    params := getValue(current_expression, ref_list);
    for paramNum range 2 to length(params) do
      obj := params[paramNum];
      category := category(obj);
      if category = "MATCHOBJECT" or
          category = "CALLOBJECT" then
        replace_locals_from_outside(obj, local_objects,
            additional_act_params, additional_form_params);
      elsif category = "LOCALVOBJECT" or category = "VALUEPARAMOBJECT" or
	      category = "REFPARAMOBJECT" or category = "RESULTOBJECT" then
        if obj not in local_objects then
          if obj in additional_act_params then
            formalRefParam := additional_form_params[pos(additional_act_params, obj)];
          else
            additional_act_params &:= make_list(obj);
            formalRefParam := alloc(obj);
            setCategory(formalRefParam, "REFPARAMOBJECT");
            additional_form_params &:= make_list(formalRefParam);
          end if;
          params @:= [paramNum] formalRefParam;
        end if;
      end if;
    end for;
    setValue(current_expression, params);
  end func;


const proc: change_calls_from_local_function (inout reference: current_expression,
    in reference: local_function_obj, in ref_list: additional_form_params) is func
  local
    var ref_list: params is ref_list.EMPTY;
    var integer: paramNum is 0;
    var reference: obj is NIL;
    var string: category is "";
  begin
    params := getValue(current_expression, ref_list);
    for paramNum range 2 to length(params) do
      obj := params[paramNum];
      category := category(obj);
      if category = "MATCHOBJECT" or
          category = "CALLOBJECT" then
        change_calls_from_local_function(obj, local_function_obj, additional_form_params);
      elsif obj = local_function_obj then
        obj := alloc(obj);
        setCategory(obj, "MATCHOBJECT");
        setValue(obj, make_list(params[paramNum]) & additional_form_params);
        params @:= [paramNum] obj;
        setValue(current_expression, params);
      end if;
    end for;
    if params[1] = local_function_obj then
	  params &:= additional_form_params;
      setValue(current_expression, params);
    end if;
  end func;


const proc: change_calls_from_global_function (inout reference: current_expression,
    in reference: local_function_obj, in ref_list: additional_act_params) is func
  local
    var ref_list: params is ref_list.EMPTY;
    var integer: paramNum is 0;
    var reference: obj is NIL;
    var string: category is "";
  begin
    params := getValue(current_expression, ref_list);
    for paramNum range 2 to length(params) do
      obj := params[paramNum];
      category := category(obj);
      if category = "MATCHOBJECT" or
          category = "CALLOBJECT" then
        change_calls_from_global_function(obj, local_function_obj, additional_act_params);
      elsif obj = local_function_obj then
        obj := alloc(obj);
        setCategory(obj, "MATCHOBJECT");
        setValue(obj, make_list(params[paramNum]) & additional_act_params);
        params @:= [paramNum] obj;
        setValue(current_expression, params);
      end if;
    end for;
    if params[1] = local_function_obj then
	  params &:= additional_act_params;
      setValue(current_expression, params);
    end if;
  end func;


const proc: fix_local_function (in reference: global_function,
    in reference: local_function, inout expr_type: c_expr) is func

  local
    var reference: body_expression is NIL;
    var ref_list: local_objects is ref_list.EMPTY;
    var string: category is "";
    var ref_list: additional_act_params is ref_list.EMPTY;
    var ref_list: additional_form_params is ref_list.EMPTY;
    var reference: obj is NIL;
  begin
    for obj range local_consts(local_function) do
      if category(obj) = "BLOCKOBJECT" then
        fix_local_function(local_function, obj, c_expr);
      end if;
    end for;
    body_expression := body(local_function);
    local_objects := params(local_function) & local_vars(local_function) &
        make_list(func_result(local_function));
    category := category(body_expression);
    if category = "MATCHOBJECT" or
        category = "CALLOBJECT" then
      replace_locals_from_outside(body_expression, local_objects,
          additional_act_params, additional_form_params);
      setParams(local_function, params(local_function) & additional_form_params);
      change_calls_from_local_function(body_expression, local_function, additional_form_params);
      for obj range local_consts(global_function) do
        if obj <> local_function and category(obj) = "BLOCKOBJECT" then
          # c_expr.expr &:= "/* local function */ o_";
          # create_name(obj, c_expr.expr);
          # c_expr.expr &:= ";\n";
          body_expression := body(obj);
          change_calls_from_local_function(body_expression, local_function, additional_act_params);
        end if;
      end for;
      body_expression := body(global_function);
      change_calls_from_global_function(body_expression, local_function, additional_act_params);
    end if;
  end func;


const proc: process_local_consts (in reference: current_object,
    inout expr_type: c_expr) is func

  local
    var ref_list: objects is ref_list.EMPTY;
    var reference: obj is NIL;
  begin
    objects := local_consts(current_object);
    for obj range objects do
      if category(obj) = "BLOCKOBJECT" then
        c_expr.expr &:= "/* local function */\n";
        fix_local_function(current_object, obj, c_expr);
      end if;
      process_object_declaration(obj, c_expr);
    end for;
  end func;


const proc: process_object (in reference: current_object) is func

  local
    var expr_type: c_expr is expr_type.value;
  begin
    write_object_declaration := TRUE;
    process_object_declaration(current_object, c_expr);
    c_prog << global_c_expr.expr;
    if write_object_declaration then
      c_prog << c_expr.expr;
(*
    else
      c_prog << "#ifdef WRITE_OBJECT_DECLARATION\n";
      c_prog << c_expr.expr;
      c_prog << "#endif\n";
*)
    end if;
    global_c_expr := expr_type.value;
  end func;


const proc: write_file_head is func

  begin
    c_prog << temp_marker & "\n";
    c_prog << "#include <stdlib.h>\n";
    c_prog << "#include <stdio.h>\n";
    c_prog << "#include <string.h>\n";
    c_prog << "#include <setjmp.h>\n";
    c_prog << "#include <signal.h>\n";
    c_prog << "typedef long booltype;\n";
    c_prog << "typedef long typetype;\n";
    c_prog << "typedef long int inttype;\n";
    c_prog << "typedef float floattype;\n";
    c_prog << "typedef unsigned long int chartype;\n";
    c_prog << "typedef unsigned short int bigdigittype;\n";
    c_prog << "typedef unsigned long int strelemtype;\n";
    c_prog << "typedef unsigned long int bitsettype;\n";
    c_prog << "typedef unsigned long int memsizetype;\n";
    c_prog << "typedef void *generictype;\n";
    c_prog << "typedef union {\n";
    c_prog << "  generictype genericvalue;\n";
    c_prog << "  inttype     intvalue;\n";
    c_prog << "  floattype   floatvalue;\n";
    c_prog << "} valueunion;\n";
    c_prog << "typedef struct rtlObjectstruct {\n";
    c_prog << "  valueunion value;\n";
    c_prog << "} rtlObjecttype;\n";
    c_prog << "typedef FILE *filetype;\n";
    c_prog << "typedef int *sockettype;\n";
    c_prog << "typedef struct list {\n";
    c_prog << "  struct list *next;\n";
    c_prog << "  long obj;\n";
    c_prog << "} *listtype;\n";
    c_prog << "typedef struct {\n";
    c_prog << "  memsizetype size;\n";
    c_prog << "  bigdigittype bigdigits[1];\n";
    c_prog << "} *biginttype;\n";
    c_prog << "typedef struct stri {\n";
    c_prog << "  memsizetype size;\n";
    c_prog << "  strelemtype mem[1];\n";
    c_prog << "} *stritype;\n";
    c_prog << "typedef struct bstri {\n";
    c_prog << "  memsizetype size;\n";
    c_prog << "  unsigned char mem[1];\n";
    c_prog << "} *bstritype;\n";
    c_prog << "typedef struct arraystruct {\n";
    c_prog << "  inttype min_position;\n";
    c_prog << "  inttype max_position;\n";
    c_prog << "  rtlObjecttype arr[1];\n";
    c_prog << "} *arraytype;\n";
    c_prog << "typedef struct helemstruct *helemtype;\n";
    c_prog << "struct helemstruct {\n";
    c_prog << "  helemtype next_less;\n";
    c_prog << "  helemtype next_greater;\n";
    c_prog << "  rtlObjecttype key;\n";
    c_prog << "  rtlObjecttype data;\n";
    c_prog << "};\n";
    c_prog << "typedef struct hashstruct {\n";
    c_prog << "  int bits;\n";
    c_prog << "  int mask;\n";
    c_prog << "  int table_size;\n";
    c_prog << "  memsizetype size;\n";
    c_prog << "  helemtype table[1];\n";
    c_prog << "} *hashtype;\n";
    c_prog << "typedef inttype (*comparetype) (generictype, generictype);\n";
    c_prog << "typedef generictype (*createfunctype) (generictype);\n";
    c_prog << "typedef void (*destrfunctype) (generictype);\n";
    c_prog << "typedef void (*copyfunctype) (generictype *, generictype);\n";
    c_prog << "typedef struct {\n";
    c_prog << "  inttype min_position;\n";
    c_prog << "  inttype max_position;\n";
    c_prog << "  bitsettype bitset[1];\n";
    c_prog << "} *settype;\n";
    c_prog << "typedef struct structstruct {\n";
    c_prog << "  unsigned long int type_num;\n";
    c_prog << "  rtlObjecttype stru[1];\n";
    c_prog << "} *structtype;\n";
    c_prog << "typedef structtype interfacetype;\n";
    c_prog << "typedef struct {\n";
    c_prog << "  unsigned long usage_count;\n";
    c_prog << "} *wintype;\n";
    c_prog << "typedef inttype progtype;\n";
    c_prog << "typedef union {\n";
    c_prog << "  floattype floatvalue;\n";
    c_prog << "  inttype intvalue;\n";
    c_prog << "} float2int;\n";
    c_prog << "stritype       arg_0;\n";
    c_prog << "arraytype      arg_v;\n";
    c_prog << "biginttype     big[];\n";
    c_prog << "stritype       str[];\n";
    c_prog << "settype        set[];\n";
    c_prog << "arraytype     *arr;\n";
    c_prog << "structtype    *sct;\n";
    c_prog << "interfacetype *itf;\n";
    c_prog << "float2int      flt2int;\n";
    c_prog << "unsigned long int hs;\n";
    c_prog << "\n";
    c_prog << "struct bstri empty_bst = {0, 0};\n";
    c_prog << "static inttype fact[] = {\n";
    c_prog << "    1, 1, 2, 6, 24, 120, 720, 5040, 40320,\n";
    c_prog << "    362880, 3628800, 39916800, 479001600\n";
    c_prog << "  };\n";
    c_prog << "#define OKAY_NO_ERROR 0\n";
    c_prog << "#define MEMORY_ERROR  1\n";
    c_prog << "#define NUMERIC_ERROR 2\n";
    c_prog << "#define RANGE_ERROR   3\n";
    c_prog << "#define IO_ERROR      4\n";
    c_prog << "#define CREATE_ERROR  5\n";
    c_prog << "#define DESTROY_ERROR 6\n";
    c_prog << "#define COPY_ERROR    7\n";
    c_prog << "#define IN_ERROR      8\n";
    c_prog << "#define FILE_ERROR    9\n";
    c_prog << "static char *exception_name[] = {\n";
    c_prog << "    \"OKAY_NO_ERROR\",\n";
    c_prog << "    \"MEMORY_ERROR\",\n";
    c_prog << "    \"NUMERIC_ERROR\",\n";
    c_prog << "    \"RANGE_ERROR\",\n";
    c_prog << "    \"IO_ERROR\",\n";
    c_prog << "    \"CREATE_ERROR\",\n";
    c_prog << "    \"DESTROY_ERROR\",\n";
    c_prog << "    \"COPY_ERROR\",\n";
    c_prog << "    \"IN_ERROR\",\n";
    c_prog << "    \"FILE_ERROR\",\n";
    c_prog << "  };\n";
    c_prog << "#define push_stack(stack,elem) \\\n";
    c_prog << "{\\\n";
    c_prog << "  listtype new_head = (listtype) malloc(sizeof(struct list));\\\n";
    c_prog << "  if (new_head == NULL) {\\\n";
    c_prog << "    raise_error(MEMORY_ERROR);\\\n";
    c_prog << "  } else {\\\n";
    c_prog << "    new_head->next = stack;\\\n";
    c_prog << "    new_head->obj = elem;\\\n";
    c_prog << "    stack = new_head;\\\n";
    c_prog << "  }\\\n";
    c_prog << "}\n";
    c_prog << "#define pop_stack(stack,elem) \\\n";
    c_prog << "{\\\n";
    c_prog << "  listtype old_head = stack;\\\n";
    c_prog << "  if (old_head == NULL) {\\\n";
    c_prog << "    elem = NULL;\\\n";
    c_prog << "  } else {\\\n";
    c_prog << "    stack = old_head->next;\\\n";
    c_prog << "    elem = old_head->obj;\\\n";
    c_prog << "    free(old_head);\\\n";
    c_prog << "  }\\\n";
    c_prog << "}\n";
    # c_prog << "sigjmp_buf catch_position;\n";
    c_prog << "jmp_buf catch_position;\n";
    c_prog << "stritype    act_str (void *a)                             {printf(\"act_str\\n\");}\n";
    c_prog << "void        arrAppend (arraytype *, arraytype);\n";
    c_prog << "arraytype   arrArrlit (arraytype);\n";
    c_prog << "arraytype   arrArrlit2 (inttype, arraytype);\n";
    c_prog << "arraytype   arrBaselit (long);\n";
    c_prog << "arraytype   arrBaselit2 (inttype, long);\n";
    c_prog << "arraytype   arrCat (arraytype, arraytype);\n";
    c_prog << "arraytype   arrExtend (arraytype, inttype);\n";
    c_prog << "arraytype   arrGen (inttype, inttype);\n";
    c_prog << "arraytype   arrHead (arraytype, inttype);\n";
    c_prog << "arraytype   arrRange (arraytype, inttype, inttype);\n";
    c_prog << "arraytype   arrSort (arraytype, void * );\n";
    c_prog << "arraytype   arrTail (arraytype, inttype);\n";
    c_prog << "biginttype  bigAbs (biginttype);\n";
    c_prog << "biginttype  bigAdd (biginttype, biginttype);\n";
    c_prog << "inttype     bigCmp (biginttype, biginttype);\n";
    c_prog << "void        bigCpy (biginttype *, biginttype);\n";
    c_prog << "biginttype  bigCreate (biginttype);\n";
    c_prog << "void        bigDecr (biginttype *);\n";
    c_prog << "void        bigDestr (biginttype);\n";
    c_prog << "biginttype  bigDiv (biginttype, biginttype);\n";
    c_prog << "booltype    bigEq (biginttype, biginttype);\n";
    c_prog << "void        bigGrow (biginttype *, biginttype);\n";
    c_prog << "void        bigIncr (biginttype *);\n";
    c_prog << "biginttype  bigIPow (biginttype, inttype);\n";
    c_prog << "biginttype  bigMDiv (biginttype, biginttype);\n";
    c_prog << "biginttype  bigMinus (biginttype);\n";
    c_prog << "biginttype  bigMod (biginttype, biginttype);\n";
    c_prog << "biginttype  bigMult (biginttype, biginttype);\n";
    c_prog << "booltype    bigNe (biginttype, biginttype);\n";
    c_prog << "inttype     bigOrd (biginttype);\n";
    c_prog << "biginttype  bigParse (stritype);\n";
    c_prog << "void        blnCpy (booltype *, booltype);\n";
    c_prog << "booltype    blnCreate (booltype);\n";
    c_prog << "inttype     chrCmp (chartype, chartype);\n";
    c_prog << "void        chrCpy (chartype *, chartype);\n";
    c_prog << "chartype    chrCreate (chartype);\n";
    c_prog << "chartype    chrLow (chartype);\n";
    c_prog << "stritype    chrStr (chartype);\n";
    c_prog << "chartype    chrUp (chartype);\n";
    c_prog << "void        cmdCopy (stritype, stritype);\n";
    c_prog << "stritype    cmdGetcwd (void);\n";
    c_prog << "inttype     cmdLng (stritype);\n";
    c_prog << "arraytype   cmdLs (stritype);\n";
    c_prog << "void        cmdMove (stritype, stritype);\n";
    c_prog << "void        cmdRemove (stritype);\n";
    c_prog << "void        cmdSh (stritype);\n";
    c_prog << "void        drwArc (wintype, inttype, inttype, inttype, floattype, floattype);\n";
    c_prog << "void        drwArc2 (wintype, inttype, inttype, inttype, inttype, inttype);\n";
    c_prog << "void        drwCircle (wintype, inttype, inttype, inttype);\n";
    c_prog << "void        drwClear (wintype, inttype);\n";
    c_prog << "void        drwColor (inttype);\n";
    c_prog << "void        drwCopyArea (wintype, wintype, inttype, inttype, inttype, inttype, inttype, inttype);\n";
    c_prog << "void        drwCpy (wintype *, wintype);\n";
    c_prog << "wintype     drwCreate (wintype);\n";
    c_prog << "void        drwDestr (wintype);\n";
    c_prog << "void        drwFArcChord (wintype, inttype, inttype, inttype, floattype, floattype);\n";
    c_prog << "void        drwFArcPieSlice (wintype, inttype, inttype, inttype, floattype, floattype);\n";
    c_prog << "void        drwFCircle (wintype, inttype, inttype, inttype);\n";
    c_prog << "void        drwFEllipse (wintype, inttype, inttype, inttype, inttype);\n";
    c_prog << "void        drwFlush (void);\n";
    c_prog << "wintype     drwGet (wintype, inttype, inttype, inttype, inttype);\n";
    c_prog << "inttype     drwHeight (wintype);\n";
    c_prog << "wintype     drwImage (wintype, inttype *, inttype, inttype);\n";
    c_prog << "void        drwLine (wintype, inttype, inttype, inttype, inttype);\n";
    c_prog << "wintype     drwOpen (inttype, inttype, inttype, inttype, stritype);\n";
    c_prog << "void        drwPArc (wintype, inttype, inttype, inttype, floattype, floattype, inttype);\n";
    c_prog << "void        drwPCircle (wintype, inttype, inttype, inttype, inttype);\n";
    c_prog << "void        drwPFArcChord (wintype, inttype, inttype, inttype, floattype, floattype, inttype);\n";
    c_prog << "void        drwPFArcPieSlice (wintype, inttype, inttype, inttype, floattype, floattype, inttype);\n";
    c_prog << "void        drwPFCircle (wintype, inttype, inttype, inttype, inttype);\n";
    c_prog << "void        drwPFEllipse (wintype, inttype, inttype, inttype, inttype, inttype);\n";
    c_prog << "void        drwPLine (wintype, inttype, inttype, inttype, inttype, inttype);\n";
    c_prog << "void        drwPoint (wintype, inttype, inttype);\n";
    c_prog << "void        drwPPoint (wintype, inttype, inttype, inttype);\n";
    c_prog << "void        drwPRect (wintype, inttype, inttype, inttype, inttype, inttype);\n";
    c_prog << "void        drwPut (wintype, wintype, inttype, inttype);\n";
    c_prog << "void        drwRect (wintype, inttype, inttype, inttype, inttype);\n";
    c_prog << "inttype     drwRgbColor (inttype, inttype, inttype);\n";
    c_prog << "void        drwText (wintype, inttype, inttype, stritype, inttype, inttype);\n";
    c_prog << "inttype     drwWidth (wintype);\n";
    c_prog << "inttype     enuValue (void *a)                            {printf(\"enuValue\\n\");}\n";
    c_prog << "biginttype  filBigLng (filetype);\n";
    c_prog << "void        filBigSeek (filetype, biginttype);\n";
    c_prog << "biginttype  filBigTell (filetype);\n";
    c_prog << "stritype    filGets (filetype, inttype);\n";
    c_prog << "stritype    filLineRead (filetype, chartype *);\n";
    c_prog << "inttype     filLng (filetype );\n";
    c_prog << "filetype    filOpen (stritype, stritype);\n";
    c_prog << "void        filSeek (filetype, inttype);\n";
    c_prog << "stritype    filWordRead (filetype, chartype *);\n";
    c_prog << "void        filWrite (filetype, stritype);\n";
    c_prog << "floattype   fltValue (void * );\n";
    c_prog << "inttype     fltCmp (floattype, floattype);\n";
    c_prog << "void        fltCpy (floattype *, floattype);\n";
    c_prog << "floattype   fltCreate (floattype);\n";
    c_prog << "stritype    fltDgts (floattype, inttype);\n";
    c_prog << "floattype   fltIPow (floattype, inttype);\n";
    c_prog << "floattype   fltParse (stritype);\n";
    c_prog << "floattype   fltPow (floattype, floattype);\n";
    c_prog << "floattype   fltRand (floattype, floattype);\n";
    c_prog << "stritype    fltStr (floattype);\n";
    c_prog << "chartype    gkbGetc (void);\n";
    c_prog << "stritype    gkbGets (inttype);\n";
    c_prog << "inttype     gkbKeyPressed (void);\n";
    c_prog << "stritype    gkbLineRead (chartype *);\n";
    c_prog << "chartype    gkbRawGetc (void);\n";
    c_prog << "stritype    gkbWordRead (chartype *);\n";
    c_prog << "booltype    hshContains (hashtype, generictype, inttype, comparetype);\n";
    c_prog << "void        hshCpy (hashtype *, hashtype, createfunctype, destrfunctype, createfunctype, destrfunctype);\n";
    c_prog << "hashtype    hshCreate (hashtype, createfunctype, destrfunctype, createfunctype, destrfunctype);\n";
    c_prog << "void        hshDestr (hashtype, destrfunctype, destrfunctype);\n";
    c_prog << "hashtype    hshEmpty (void);\n";
    c_prog << "void        hshExcl (hashtype, generictype, inttype, comparetype, destrfunctype, destrfunctype);\n";
    c_prog << "generictype hshIdx (hashtype, generictype, inttype, comparetype);\n";
    c_prog << "generictype *hshIdxAddr (hashtype, generictype, inttype, comparetype);\n";
    c_prog << "void        hshIncl (hashtype, generictype, generictype, inttype, comparetype, createfunctype, createfunctype, copyfunctype);\n";
    c_prog << "arraytype   hshKeys (hashtype, createfunctype, destrfunctype);\n";
    c_prog << "arraytype   hshValues (hashtype, createfunctype, destrfunctype);\n";
    c_prog << "inttype     intBinom (inttype, inttype);\n";
    c_prog << "inttype     intCmp (inttype, inttype);\n";
    c_prog << "void        intCpy (inttype *, inttype);\n";
    c_prog << "inttype     intCreate (inttype);\n";
    c_prog << "inttype     intLd (inttype);\n";
    c_prog << "inttype     intParse (stritype);\n";
    c_prog << "inttype     intPow (inttype, inttype);\n";
    c_prog << "inttype     intRand (inttype, inttype);\n";
    c_prog << "inttype     intSqrt (inttype);\n";
    c_prog << "stritype    intStr (inttype);\n";
    c_prog << "chartype    kbdGetc (void);\n";
    c_prog << "stritype    kbdGets (inttype);\n";
    c_prog << "inttype     kbdKeyPressed (void);\n";
    c_prog << "stritype    kbdLineRead (chartype *);\n";
    c_prog << "chartype    kbdRawGetc (void);\n";
    c_prog << "stritype    kbdWordRead (chartype *);\n";
    c_prog << "inttype     prc_hsize (void)                              {printf(\"prc_hsize\\n\");}\n";
    c_prog << "void        prcNoop (void)                                {printf(\"prcNoop\\n\");}\n";
    c_prog << "void        prc_print (stritype stri) {\n\
              \char *str1;\n\
              \str1 = cp_to_cstri(stri);\n\
              \if (str1 != NULL) {\n\
              \  fputs(str1, stdout);\n\
              \  fflush(stdout);\n\
              \  free(str1);\n\
              \}\n\
              \}\n";
    c_prog << "long        ref_addr (void *a)                            {printf(\"ref_addr\\n\");}\n";
    c_prog << "inttype     refCmp (void *a, void *b)                     {printf(\"refCmp\\n\");}\n";
    c_prog << "void        refCpy (void *a, void *b)                     {printf(\"refCpy\\n\");}\n";
    c_prog << "void *      refCreate (void *a)                           {printf(\"refCreate\\n\");}\n";
    c_prog << "void *      ref_itftosct (void *a)                        {printf(\"ref_itftosct\\n\");}\n";
    c_prog << "long *      ref_select (void *a, inttype b)               {printf(\"ref_select\\n\");}\n";
    c_prog << "float *     ref_fselect (void *a, inttype b)              {printf(\"ref_fselect\\n\");}\n";
    c_prog << "stritype    ref_str (void *a)                             {printf(\"ref_str\\n\");}\n";
    c_prog << "inttype     ref_type (void *a)                            {printf(\"ref_type\\n\");}\n";
    c_prog << "void        rflAppend (listtype *, listtype);\n";
    c_prog << "void        rflCpy (listtype *, listtype);\n";
    c_prog << "inttype     rfl_elem (void *a, void *b)                   {printf(\"rfl_elem\\n\");}\n";
    c_prog << "booltype    rflEq (listtype, listtype);\n";
    c_prog << "void *      rfl_idx (void *a, inttype b)                  {printf(\"rfl_idx\\n\");}\n";
    c_prog << "inttype     rfl_lng (void *a)                             {printf(\"rfl_lng\\n\");}\n";
    c_prog << "booltype    rflNe (listtype, listtype);\n";
    c_prog << "void        scrClear (inttype, inttype, inttype, inttype);\n";
    c_prog << "void        scrCursor (booltype);\n";
    c_prog << "void        scrFlush (void);\n";
    c_prog << "int         scrHeight (void);\n";
    c_prog << "void        scrHScroll (inttype, inttype, inttype, inttype, inttype);\n";
    c_prog << "int         scrOpen (void);\n";
    c_prog << "void        scrSetpos (inttype, inttype);\n";
    c_prog << "void        scrShut (void);\n";
    c_prog << "void        scrVScroll (inttype, inttype, inttype, inttype, inttype);\n";
    c_prog << "int         scrWidth (void);\n";
    c_prog << "void        scrWrite (stritype stri);\n";
    c_prog << "void        sctCreate (structtype a, structtype b)        {printf(\"sctCreate\\n\");}\n";
    c_prog << "void        sct_cpy (structtype a, structtype b)          {printf(\"sct_cpy\\n\");}\n";
    c_prog << "long *      sct_select (void *a, inttype b)               {printf(\"sct_select\\n\");}\n";
    c_prog << "float *     sct_fselect (void *a, inttype b)              {printf(\"sct_fselect\\n\");}\n";
    c_prog << "settype     setArrlit (inttype);\n";
    c_prog << "settype     setBaselit (inttype);\n";
    c_prog << "inttype     setCard (settype);\n";
    c_prog << "inttype     setCmp (settype, settype);\n";
    c_prog << "void        setCpy (settype *, settype);\n";
    c_prog << "settype     setCreate (settype);\n";
    c_prog << "void        setDestr (settype);\n";
    c_prog << "settype     setDiff (settype, settype);\n";
    c_prog << "inttype     setElem (inttype, settype);\n";
    c_prog << "booltype    setEq (settype, settype);\n";
    c_prog << "void        setExcl (settype *, inttype);\n";
    c_prog << "booltype    setGe (settype, settype);\n";
    c_prog << "booltype    setGt (settype, settype);\n";
    c_prog << "inttype     setHashCode (settype);\n";
    c_prog << "void        setIncl (settype *, inttype);\n";
    c_prog << "settype     setIntersect (settype, settype);\n";
    c_prog << "booltype    setLe (settype, settype);\n";
    c_prog << "booltype    setLt (settype, settype);\n";
    c_prog << "inttype     setMax (settype);\n";
    c_prog << "inttype     setMin (settype);\n";
    c_prog << "booltype    setNe (settype, settype);\n";
    c_prog << "inttype     setNotElem (inttype, settype);\n";
    c_prog << "inttype     setRand (settype);\n";
    c_prog << "settype     setSymdiff (settype, settype);\n";
    c_prog << "settype     setUnion (settype, settype);\n";
    c_prog << "void        strAppend (stritype *, stritype);\n";
    c_prog << "arraytype   strChSplit (stritype, chartype);\n";
    c_prog << "inttype     strCompare (stritype, stritype);\n";
    c_prog << "stritype    strConcat (stritype, stritype);\n";
    c_prog << "stritype    str_clit (stritype a)                         {printf(\"str_clit\\n\");}\n";
    c_prog << "void        strCopy (stritype *, stritype);\n";
    c_prog << "stritype    strCreate (stritype);\n";
    c_prog << "void        strDestr (stritype);\n";
    c_prog << "booltype    strGe (stritype, stritype);\n";
    c_prog << "booltype    strGt (stritype, stritype);\n";
    c_prog << "inttype     strHashCode (stritype);\n";
    c_prog << "stritype    strHead (stritype, inttype);\n";
    c_prog << "inttype     strIpos (stritype, stritype, inttype);\n";
    c_prog << "booltype    strLe (stritype, stritype);\n";
    c_prog << "stritype    strLit (stritype);\n";
    c_prog << "stritype    strLow (stritype);\n";
    c_prog << "stritype    strLpad (stritype, inttype);\n";
    c_prog << "booltype    strLt (stritype, stritype);\n";
    c_prog << "stritype    strMult (stritype, inttype);\n";
    c_prog << "inttype     strPos (stritype, stritype);\n";
    c_prog << "stritype    strRange (stritype, inttype, inttype);\n";
    c_prog << "stritype    strRepl (stritype, stritype, stritype);\n";
    c_prog << "stritype    strRpad (stritype, inttype);\n";
    c_prog << "inttype     strRpos (stritype, stritype);\n";
    c_prog << "arraytype   strSplit (stritype, stritype);\n";
    c_prog << "stritype    strSubstr (stritype, inttype, inttype);\n";
    c_prog << "stritype    strTail (stritype, inttype);\n";
    c_prog << "stritype    strTrim (stritype);\n";
    c_prog << "stritype    strUp (stritype);\n";
    c_prog << "stritype    cstri_to_stri (char *);\n";
    c_prog << "char *      str_to_cstri (stritype a)                     {printf(\"str_to_cstri\\n\");}\n";
    c_prog << "void        timAwait (inttype, inttype, inttype, inttype, inttype, inttype, inttype, inttype);\n";
    c_prog << "void        timNow (inttype, inttype, inttype, inttype, inttype, inttype, inttype, inttype);\n";
    c_prog << "stritype    typStr (int);\n";
    c_prog << "inttype     typValue (int a)                              {printf(\"typValue\\n\");}\n";
    c_prog << "chartype    ut8Getc (filetype);\n";
    c_prog << "stritype    ut8Gets (filetype, inttype);\n";
    c_prog << "stritype    ut8LineRead (filetype, chartype *);\n";
    c_prog << "void        ut8Seek (filetype, inttype);\n";
    c_prog << "stritype    ut8WordRead (filetype, chartype *);\n";
    c_prog << "void        ut8Write (filetype, stritype);\n";
    # c_prog << "void       raise_error (int a)                           {printf(\"raise_error(%d)\\n\", a); siglongjmp(catch_position, a); }\n";
    # c_prog << "void        raise_error (int a)                           {siglongjmp(catch_position, a); }\n";
    c_prog << "void        raise_error (int a)                           {longjmp(catch_position, a); }\n";
(*
    c_prog << "stritype    act_str (void * );\n";
    c_prog << "arraytype   arrHead (arraytype a, inttype b)              {printf(\"arrHead\\n\");}\n";
    c_prog << "arraytype   arrRange (arraytype a, inttype b, inttype c)  {printf(\"arrRange\\n\");}\n";
    c_prog << "arraytype   arrSort (arraytype a, void *b)                {printf(\"arrSort\\n\");}\n";
    c_prog << "arraytype   arrTail (arraytype a, inttype b)              {printf(\"arrTail\\n\");}\n";
    c_prog << "inttype     enuValue (void * );\n";
    c_prog << "void        hsh_create (hashtype *, hashtype, void *, void *, void *, void * );\n";
    c_prog << "void        hsh_destr (hashtype, void *, void * );\n";
    c_prog << "void        hsh_cpy (hashtype *, hashtype, void *, void *, void *, void * );\n";
    c_prog << "inttype     hsh_contains ();\n";
    c_prog << "void        hsh_incl ();\n";
    c_prog << "void        hsh_excl ();\n";
    c_prog << "inttype     prc_hsize (void);\n";
    c_prog << "void        prcNoop (void);\n";
    c_prog << "long        ref_addr (void * );\n";
    c_prog << "long *      ref_select (void *, inttype);\n";
    c_prog << "float *     ref_fselect (void *, inttype);\n";
    c_prog << "stritype    ref_str (void * );\n";
    c_prog << "void        rflAppend (listtype *a, listtype b)           {printf(\"rflAppend\\n\");}\n";
    c_prog << "void        rflCpy (listtype *a, listtype b)              {printf(\"rflCpy\\n\");}\n";
    c_prog << "inttype     rfl_elem (void *, void * );\n";
    c_prog << "void *      rfl_idx (void, inttype);\n";
    c_prog << "inttype     rfl_lng (void * );\n";
    c_prog << "void        sct_cpy (structtype, structtype);\n";
    c_prog << "long *      sct_select (void *, inttype);\n";
    c_prog << "float *     sct_fselect (void *, inttype);\n";
    c_prog << "stritype    str_clit (stritype);\n";
    c_prog << "char *      str_to_cstri (stritype);\n";
    c_prog << "stritype    typStr (int a)                                {printf(\"typStr\\n\");}\n";
*)
    c_prog << "\n";
    c_prog << "\n";
    c_prog << "static void activate_signal_handlers (void);\n";
    c_prog << "\n";
    c_prog << "\n";
    c_prog << "static void handle_signals (int sig_num)\n";
    c_prog << "\n";
    c_prog << "  {\n";
    c_prog << "    int ch;\n";
    c_prog << "    char *sig_name;\n";
    c_prog << "    char buffer[20];\n";
    c_prog << "\n";
    c_prog << "    if (sig_num == SIGABRT) {\n";
    c_prog << "      sig_name = \"ABORT\";\n";
    c_prog << "    } else if (sig_num == SIGFPE) {\n";
    c_prog << "      sig_name = \"FPE\";\n";
    c_prog << "    } else if (sig_num == SIGILL) {\n";
    c_prog << "      sig_name = \"ILL\";\n";
    c_prog << "    } else if (sig_num == SIGINT) {\n";
    c_prog << "      sig_name = \"INTR\";\n";
    c_prog << "    } else if (sig_num == SIGSEGV) {\n";
    c_prog << "      sig_name = \"SEGV\";\n";
    c_prog << "    } else if (sig_num == SIGTERM) {\n";
    c_prog << "      sig_name = \"TERM\";\n";
    c_prog << "    } else {\n";
    c_prog << "      sprintf(buffer, \"%d\", sig_num);\n";
    c_prog << "      sig_name = buffer;\n";
    c_prog << "    } /* if */\n";
    c_prog << "    printf(\"\\n*** SIGNAL %s RAISED\\n\", sig_name);\n";
    c_prog << "    printf(\"\\n*** (Type RETURN to continue or '*' to terminate)\\n\");\n";
    c_prog << "    ch = fgetc(stdin);\n";
    c_prog << "    if (ch == '*') {\n";
    c_prog << "      exit(1);\n";
    c_prog << "    } /* if */\n";
    c_prog << "    activate_signal_handlers();\n";
    c_prog << "  }\n";
    c_prog << "\n";
    c_prog << "\n";
    c_prog << "static void handle_term_signal (int sig_num)\n";
    c_prog << "\n";
    c_prog << "  {\n";
    c_prog << "    printf(\"\\n*** SIGNAL TERM RAISED\\n\");\n";
    c_prog << "    printf(\"\\n*** Program terminated\\n\");\n";
    c_prog << "    exit(1);\n";
    c_prog << "  }\n";
    c_prog << "\n";
    c_prog << "\n";
    c_prog << "static void handle_fpe_signal (int sig_num)\n";
    c_prog << "\n";
    c_prog << "  {\n";
    c_prog << "    signal(SIGFPE, handle_fpe_signal);\n";
    c_prog << "    raise_error(NUMERIC_ERROR);\n";
    c_prog << "  }\n";
    c_prog << "\n";
    c_prog << "\n";
    c_prog << "static void activate_signal_handlers (void)\n";
    c_prog << "\n";
    c_prog << "  {\n";
    c_prog << "    signal(SIGABRT, handle_signals);\n";
    c_prog << "    signal(SIGFPE, handle_fpe_signal);\n";
    c_prog << "    signal(SIGILL, handle_signals);\n";
    c_prog << "    signal(SIGINT, handle_signals);\n";
    c_prog << "    signal(SIGSEGV, handle_signals);\n";
    c_prog << "    signal(SIGTERM, handle_term_signal);\n";
    c_prog << "  }\n";
    c_prog << "\n";
    c_prog << "\n";
  end func;


const proc: write_call_of_main (in program: prog, inout expr_type: c_expr) is func

  local
    var reference: main_obj is NIL;
  begin
    main_obj := sys_var(prog, "main");
    if main_obj <> NIL then
      c_expr.expr &:= "o_";
      create_name(main_obj, c_expr.expr);
      c_expr.expr &:= "();\n";
    else
      writeln(" *** MAIN not declared.\n");
    end if;
  end func;


const proc: walk_const_list (in ref_list: const_list, inout ref_list: sorted_list) is func
  local
    var reference: current_object is NIL;
    var reference: struct_of_interface is NIL;
    var string: category is "";
  begin
    for current_object range const_list do
      category := category(current_object);
      if category = "BIGINTOBJECT" then
        if getValue(current_object, bigInteger) not in bigint_const_table then
          bigint_const_table @:= [getValue(current_object, bigInteger)] length(bigint_const_table);
        end if;
      elsif category = "STRIOBJECT" then
        if getValue(current_object, string) not in stri_const_table then
          stri_const_table @:= [getValue(current_object, string)] length(stri_const_table);
        end if;
      elsif category = "ARRAYOBJECT" then
        if current_object not in const_table then
          const_table @:= [current_object] length(const_table);
        end if;
        walk_const_list(array_to_list(current_object), sorted_list);
        sorted_list &:= make_list(current_object);
      elsif category = "STRUCTOBJECT" then
        if current_object not in const_table then
          const_table @:= [current_object] length(const_table);
        end if;
        walk_const_list(struct_to_list(current_object), sorted_list);
        sorted_list &:= make_list(current_object);
      elsif category = "CLASSOBJECT" then
        if current_object not in const_table then
          const_table @:= [current_object] length(const_table);
        end if;
        struct_of_interface := interface_to_struct(current_object);
        if struct_of_interface not in const_table then
          const_table @:= [struct_of_interface] length(const_table);
          walk_const_list(struct_to_list(struct_of_interface), sorted_list);
          sorted_list &:= make_list(struct_of_interface);
        elsif const_table[struct_of_interface] >= const_table[current_object] then
          sorted_list &:= make_list(struct_of_interface);
        end if;
        sorted_list &:= make_list(current_object);
      end if;
    end for;
  end func;


const proc: init_const_value (in reference: current_object, inout expr_type: c_expr) is func
  local
    var string: category is "";
  begin
    category := category(current_object);
    if category = "INTOBJECT" then
      c_expr.expr &:= ".value.intvalue=";
      c_expr.expr &:= str(getValue(current_object, integer));
    elsif category = "BIGINTOBJECT" then
      c_expr.expr &:= ".value.intvalue=";
      c_expr.expr &:= "big[";
      c_expr.expr &:= str(bigint_const_table[getValue(current_object, bigInteger)]);
      c_expr.expr &:= "] /* ";
      c_expr.expr &:= str(getValue(current_object, bigInteger));
      c_expr.expr &:= " */";
    elsif category = "CHAROBJECT" then
      c_expr.expr &:= ".value.intvalue=";
      c_expr.expr &:= c_literal(getValue(current_object, char));
    elsif category = "STRIOBJECT" then
      c_expr.expr &:= ".value.intvalue=";
      c_expr.expr &:= "str[";
      c_expr.expr &:= str(stri_const_table[getValue(current_object, string)]);
      c_expr.expr &:= "] /* ";
      c_expr.expr &:= replace(c_literal(getValue(current_object, string)), "*/", "* /");
      c_expr.expr &:= " */";
    elsif category = "BSTRIOBJECT" then
      c_expr.expr &:= ".value.intvalue=";
      c_expr.expr &:= "&empty_bst";
    elsif category = "SETOBJECT" then
      c_expr.expr &:= ".value.intvalue=";
      c_expr.expr &:= "set[";
      c_expr.expr &:= str(set_const_table[getValue(current_object, bitset)]);
      c_expr.expr &:= "]";
    elsif category = "FLOATOBJECT" then
      c_expr.expr &:= ".value.floatvalue=";
      c_expr.expr &:= str(getValue(current_object, float));
    elsif category = "REFOBJECT" then
      c_expr.expr &:= ".value.intvalue=";
      if getValue(current_object, reference) = NIL then
        c_expr.expr &:= "NULL";
      else
        c_expr.expr &:= "&(";
        process_expr(getValue(current_object, reference), c_expr);
        c_expr.expr &:= ")";
      end if;
    elsif category = "FILEOBJECT" then
      c_expr.expr &:= ".value.intvalue=";
      c_expr.expr &:= literal(getValue(current_object, PRIMITIVE_FILE));
    elsif category = "SOCKETOBJECT" then
      c_expr.expr &:= ".value.intvalue=";
      c_expr.expr &:= "-1";
    elsif category = "WINOBJECT" then
      c_expr.expr &:= ".value.intvalue=";
      c_expr.expr &:= "NULL";
    elsif category = "CONSTENUMOBJECT" then
      c_expr.expr &:= ".value.intvalue=";
      c_expr.expr &:= enum_value(getValue(current_object, reference));
    elsif category = "VARENUMOBJECT" then
      c_expr.expr &:= ".value.intvalue=";
      c_expr.expr &:= enum_value(getValue(current_object, reference));
    elsif category = "ARRAYOBJECT" then
      c_expr.expr &:= ".value.intvalue=";
      c_expr.expr &:= "arr[";
      c_expr.expr &:= str(const_table[current_object]);
      c_expr.expr &:= "]";
    elsif category = "STRUCTOBJECT" then
      c_expr.expr &:= ".value.intvalue=";
      c_expr.expr &:= "sct[";
      c_expr.expr &:= str(const_table[current_object]);
      c_expr.expr &:= "]";
    elsif category = "HASHOBJECT" then
      c_expr.expr &:= ".value.intvalue=";
      c_expr.expr &:= "hshEmpty()";
    elsif category = "CLASSOBJECT" then
      c_expr.expr &:= ".value.intvalue=";
      c_expr.expr &:= "itf[";
      c_expr.expr &:= str(const_table[current_object]);
      c_expr.expr &:= "] /* ";
      c_expr.expr &:= category;
      c_expr.expr &:= " */";
    else
      c_expr.expr &:= "/* ";
      c_expr.expr &:= category;
      c_expr.expr &:= " */";
    end if;
  end func;


const proc: init_bigint_constants (inout expr_type: c_expr) is func
  local
    var bigint_index_hash: bigint_index is bigint_index_hash.EMPTY_HASH;
    var bigInteger: big1 is bigInteger.value;
    var integer: number is 0;
    var char: ch is ' ';
  begin
    bigint_index := flip(bigint_const_table);
    for number range sort(keys(bigint_index)) do
      big1 := bigint_index[number][1];
      c_expr.expr &:= "/* big[";
      c_expr.expr &:= str(number);
      c_expr.expr &:= "] */ static bigdigittype big_";
      c_expr.expr &:= str(number);
      c_expr.expr &:= "[]=";
      c_expr.expr &:= c_literal(big1);
      c_expr.expr &:= ";\n";
    end for;
    if length(bigint_const_table) > 0 then
      c_expr.expr &:= "biginttype big[]={\n";
      for number range sort(keys(bigint_index)) do
        c_expr.expr &:= "(biginttype) big_";
        c_expr.expr &:= str(number);
        c_expr.expr &:= ",\n";
      end for;
      c_expr.expr &:= "};\n\n";
    end if;
  end func;


const proc: init_string_constants (inout expr_type: c_expr) is func
  local
    var stri_index_hash: stri_index is stri_index_hash.EMPTY_HASH;
    var string: stri is "";
    var integer: number is 0;
    var char: ch is ' ';
  begin
    stri_index := flip(stri_const_table);
    for number range sort(keys(stri_index)) do
      stri := stri_index[number][1];
      c_expr.expr &:= "/* str[";
      c_expr.expr &:= str(number);
      c_expr.expr &:= "] */ static strelemtype stri_";
      c_expr.expr &:= str(number);
      c_expr.expr &:= "[]={";
      c_expr.expr &:= str(length(stri));
      c_expr.expr &:= ",";
      for ch range stri do
        c_expr.expr &:= c_literal(ch);
        c_expr.expr &:= ",";
      end for;
      c_expr.expr &:= "};\n";
    end for;
    if length(stri_const_table) > 0 then
      c_expr.expr &:= "stritype str[]={\n";
      for number range sort(keys(stri_index)) do
        c_expr.expr &:= "(stritype) stri_";
        c_expr.expr &:= str(number);
        c_expr.expr &:= ",\n";
      end for;
      c_expr.expr &:= "};\n\n";
    end if;
  end func;


const proc: init_set_constants (inout expr_type: c_expr) is func
  local
    var set_index_hash: set_index is set_index_hash.EMPTY_HASH;
    var bitset: set1 is EMPTY_SET;
    var integer: min_position is 0;
    var integer: max_position is 0;
    var integer: number is 0;
    var integer: elem_num is 0;
    var integer: byte_num is 0;
    var integer: bit_num is 0;
    var integer: hex_digit is 0;
    var string: hex_num is "";
  begin
    set_index := flip(set_const_table);
    for number range sort(keys(set_index)) do
      set1 := set_index[number][1];
      c_expr.expr &:= "/* set[";
      c_expr.expr &:= str(number);
      c_expr.expr &:= "] */ static bitsettype set_";
      c_expr.expr &:= str(number);
      c_expr.expr &:= "[]={";
      if set1 = EMPTY_SET then
        c_expr.expr &:= "0,0,0,";
      else
        min_position := min(set1) div 32;
        max_position := max(set1) div 32;
        c_expr.expr &:= str(min_position);
        c_expr.expr &:= ",";
        c_expr.expr &:= str(max_position);
        c_expr.expr &:= ",";
        for elem_num range min_position to max_position do
          hex_num := "";
          for byte_num range 0 to 3 do
            hex_digit := 0;
            for bit_num range 0 to 3 do
              if elem_num * 32 + byte_num * 8 + bit_num in set1 then
                hex_digit +:= 2 ** bit_num;
              end if;
            end for;
            hex_num  := "0123456789ABCDEF"[succ(hex_digit) len 1] & hex_num;
            hex_digit := 0;
            for bit_num range 4 to 7 do
              if elem_num * 32 + byte_num * 8 + bit_num in set1 then
                hex_digit +:= 2 ** (bit_num - 4);
              end if;
            end for;
            hex_num  := "0123456789ABCDEF"[succ(hex_digit) len 1] & hex_num;
          end for;
          c_expr.expr &:= "0x";
          c_expr.expr &:= hex_num;
          c_expr.expr &:= ",";
        end for;
      end if;
      c_expr.expr &:= "};\n";
    end for;
    if length(set_const_table) > 0 then
      c_expr.expr &:= "settype set[]={\n";
      for number range sort(keys(set_index)) do
        c_expr.expr &:= "(settype) set_";
        c_expr.expr &:= str(number);
        c_expr.expr &:= ",\n";
      end for;
      c_expr.expr &:= "};\n\n";
    end if;
  end func;


const proc: generate_main (in program: prog) is func

  local
    var expr_type: c_expr is expr_type.value;
    var stri_index_hash: stri_index is stri_index_hash.EMPTY_HASH;
    var const_index_hash: const_index is const_index_hash.EMPTY_HASH;
    var reference: const_object is NIL;
    var reference: struct_of_interface is NIL;
    var integer: number is 0;
    var integer: elem_num is 0;
    var ref_list: array_list is ref_list.EMPTY;
    var ref_list: struct_list is ref_list.EMPTY;
    var ref_list: sorted_list is ref_list.EMPTY;
  begin
    process_dynamic_decisions(c_expr);
    const_index := flip(const_table);
    for number range sort(keys(const_index)) do
      const_object := const_index[number][1];
      if category(const_object) = "ARRAYOBJECT" then
        walk_const_list(array_to_list(const_object), sorted_list);
        sorted_list &:= make_list(const_object);
      elsif category(const_object) = "STRUCTOBJECT" then
        walk_const_list(struct_to_list(const_object), sorted_list);
        sorted_list &:= make_list(const_object);
      elsif category(const_object) = "CLASSOBJECT" then
        if const_object not in const_table then
          const_table @:= [const_object] length(const_table);
        end if;
        struct_of_interface := interface_to_struct(const_object);
        if struct_of_interface not in const_table then
          const_table @:= [struct_of_interface] length(const_table);
          walk_const_list(struct_to_list(struct_of_interface), sorted_list);
          sorted_list &:= make_list(struct_of_interface);
        elsif const_table[struct_of_interface] >= const_table[const_object] then
          sorted_list &:= make_list(struct_of_interface);
        end if;
        sorted_list &:= make_list(const_object);
      end if;
    end for;
    writeln("after walk_const_list");
    init_bigint_constants(c_expr);
    init_string_constants(c_expr);
    init_set_constants(c_expr);

    c_expr.expr &:= "int main (int argc, char **argv)\n";
    c_expr.expr &:= "\n";
    c_expr.expr &:= "{\n";
    c_expr.expr &:= "int fail_value;\n";
    c_expr.expr &:= "if ((fail_value = setjmp(catch_position)) == 0) {\n";

    c_expr.expr &:= "arg_0 = cstri_to_stri(argv[0]);\n";
    c_expr.expr &:= "arg_v = malloc(sizeof(struct arraystruct) - sizeof(long) + argc * sizeof(long));\n";
    c_expr.expr &:= "arg_v->min_position = 1;\n";
    c_expr.expr &:= "arg_v->max_position = argc - 1;\n";
    c_expr.expr &:= "{\n";
    c_expr.expr &:= "  int number;\n";
    c_expr.expr &:= "  for (number = 1; number < argc; number++) {\n";
    c_expr.expr &:= "    arg_v->arr[number-1].value.intvalue=cstri_to_stri(argv[number]);\n";
    c_expr.expr &:= "  }\n";
    c_expr.expr &:= "}\n";

    c_expr.expr &:= "arr = malloc(";
    c_expr.expr &:= str(length(const_table));
    c_expr.expr &:= " * sizeof(arraytype));\n";
    c_expr.expr &:= "sct = arr;\n";
    c_expr.expr &:= "itf = arr;\n";
    for const_object range sorted_list do
      number := const_table[const_object];
      if category(const_object) = "ARRAYOBJECT" then
        array_list := array_to_list(const_object);
        c_expr.expr &:= "arr[";
        c_expr.expr &:= str(number);
        c_expr.expr &:= "]=malloc(sizeof(struct arraystruct) - sizeof(long) + ";
        c_expr.expr &:= str(length(array_list));
        c_expr.expr &:= " * sizeof(long));\n";
        c_expr.expr &:= "arr[";
        c_expr.expr &:= str(number);
        c_expr.expr &:= "]->min_position=";
        c_expr.expr &:= str(array_min_position(const_object));
        c_expr.expr &:= ";\n";
        c_expr.expr &:= "arr[";
        c_expr.expr &:= str(number);
        c_expr.expr &:= "]->max_position=";
        c_expr.expr &:= str(pred(array_min_position(const_object) + length(array_list)));
        c_expr.expr &:= ";\n";
        for elem_num range 1 to length(array_list) do
          c_expr.expr &:= "arr[";
          c_expr.expr &:= str(number);
          c_expr.expr &:= "]->arr[";
          c_expr.expr &:= str(pred(elem_num));
          c_expr.expr &:= "]";
          init_const_value(array_list[elem_num], c_expr);
          c_expr.expr &:= ";\n";
        end for;
      elsif category(const_object) = "STRUCTOBJECT" then
        struct_list := struct_to_list(const_object);
        c_expr.expr &:= "sct[";
        c_expr.expr &:= str(number);
        c_expr.expr &:= "]=malloc(sizeof(struct structstruct) - sizeof(long) + ";
        c_expr.expr &:= str(length(struct_list));
        c_expr.expr &:= " * sizeof(long));\n";
        c_expr.expr &:= "sct[";
        c_expr.expr &:= str(number);
        c_expr.expr &:= "]->type_num=";
        c_expr.expr &:= str(type_number(getType(const_object)));
        c_expr.expr &:= "/*";
        c_expr.expr &:= str(getType(const_object));
        c_expr.expr &:= "*/";
        c_expr.expr &:= ";\n";
        for elem_num range 1 to length(struct_list) do
          c_expr.expr &:= "sct[";
          c_expr.expr &:= str(number);
          c_expr.expr &:= "]->stru[";
          c_expr.expr &:= str(pred(elem_num));
          c_expr.expr &:= "]";
          init_const_value(struct_list[elem_num], c_expr);
          c_expr.expr &:= ";\n";
        end for;
      elsif category(const_object) = "CLASSOBJECT" then
        struct_of_interface := interface_to_struct(const_object);
        c_expr.expr &:= "itf[";
        c_expr.expr &:= str(number);
        c_expr.expr &:= "]";
        if category(struct_of_interface) = "STRUCTOBJECT" then
          c_expr.expr &:= "=";
          c_expr.expr &:= "sct[";
          c_expr.expr &:= str(const_table[struct_of_interface]);
          c_expr.expr &:= "]";
        else
          c_expr.expr &:= " /* = ";
          c_expr.expr &:= category(struct_of_interface);
          c_expr.expr &:= " */";
        end if;
        c_expr.expr &:= ";\n";
      else
        c_expr.expr &:= "/* const ";
        c_expr.expr &:= category(const_object);
        c_expr.expr &:= " [";
        c_expr.expr &:= str(number);
        c_expr.expr &:= "] */\n";
      end if;
    end for;
    c_expr.expr &:= "activate_signal_handlers();\n";
    c_expr.expr &:= global_init.temp_decls;
    c_expr.expr &:= global_init.temp_assigns;
    c_expr.expr &:= global_init.expr;
    write_call_of_main(prog, c_expr);
    c_expr.expr &:= global_init.temp_frees;
    c_expr.expr &:= "return 0;\n";
    c_expr.expr &:= "} else {\n";
    c_expr.expr &:= "  if (fail_value >= 0 && fail_value < sizeof(exception_name) / sizeof(char *)) {\n";
    c_expr.expr &:= "    printf(\"\\n*** Uncaught EXCEPTION %s raised\\n\",\n";
    c_expr.expr &:= "        exception_name[fail_value]);\n";
    c_expr.expr &:= "  } else {\n";
    c_expr.expr &:= "    printf(\"\\n*** Uncaught EXCEPTION %d raised\\n\",\n";
    c_expr.expr &:= "        fail_value);\n";
    c_expr.expr &:= "  }\n";
    c_expr.expr &:= "  return 1;\n";
    c_expr.expr &:= "}\n";
    c_expr.expr &:= "}\n";
    c_prog << c_expr.expr;
    count_declarations;
  end func;


const proc: init_systypes (in program: prog) is func

  local
    var reference: type_ref is NIL;
    var reference: ref_to_empty is NIL;
  begin
    type_ref := sys_var(prog, "type");
    if type_ref <> NIL then
      typetype := getValue(type_ref, type);
    end if;
    type_ref := sys_var(prog, "proc");
    if type_ref <> NIL then
      proctype := getValue(type_ref, type);
    end if;
    type_ref := sys_var(prog, "integer");
    if type_ref <> NIL then
      inttype := getValue(type_ref, type);
    end if;
    type_ref := sys_var(prog, "bigInteger");
    if type_ref <> NIL then
      biginttype := getValue(type_ref, type);
    end if;
    type_ref := sys_var(prog, "char");
    if type_ref <> NIL then
      chartype := getValue(type_ref, type);
    end if;
    type_ref := sys_var(prog, "string");
    if type_ref <> NIL then
      stritype := getValue(type_ref, type);
    end if;
    type_ref := sys_var(prog, "float");
    if type_ref <> NIL then
      floattype := getValue(type_ref, type);
    end if;
    ref_to_empty := sys_var(prog, "empty");
    if ref_to_empty <> NIL then
      voidtype := getType(ref_to_empty);
    end if;
  end func;


const func string: temp_name (in string: source) is func
  result
    var string: result is "";
  begin
    if rpos(source, "/") = 0 then
      result := "tmp_" & source;
    else
      result := source[.. rpos(source, "/")] &
          "tmp_" & source[succ(rpos(source, "/")) ..];
    end if;
  end func;


const func boolean: file_exists (in string: file_name) is func
  result
    var boolean: result is FALSE;
  local
    var file: a_file is STD_NULL;
  begin
    a_file := open(file_name, "r");
    if a_file <> STD_NULL then
      close(a_file);
      result := TRUE;
    end if;
  end func;


const proc: pass_1 (in string: source, inout program: prog,
    inout boolean: okay) is func

  begin
    if source <> "" then
      writeln("Compiling the program ...");
      prog := analyze(source);
      if prog = program.EMPTY then
        okay := FALSE;
      elsif error_count(prog) <> 0 then
        write(error_count(prog) <& " error");
        if error_count(prog) > 1 then
          write("s");
        end if;
        writeln(" found");
        okay := FALSE;
      end if;
    else
      okay := FALSE;
    end if;
  end func;


const proc: pass_2 (in string: source, in program: prog,
    inout boolean: okay) is func

  local
    var reference: main_object is NIL;
    var ref_list: declared_objects is ref_list.EMPTY;
    var reference: obj is NIL;
  begin
    if okay then
      main_object := sys_var(prog, "main");
      if main_object <> NIL then
(*      The temporary tmp_*.c file is marked with a temp_marker.
        In the future there will be a check for the temp_marker,
        before the file is overwritten.
        c_prog := open(temp_name(source) & ".c", "r");
        if c_prog <> STD_NULL then
          if getln(c_prog) <> temp_marker then
            write("*** The file ");
            write(literal(temp_name(source) & ".c"));
            writeln(" was not created by the compiler.");
            write("*** Remove the file ");
            write(literal(temp_name(source) & ".c"));
            writeln(" manually and restart the compiler.");
            okay := FALSE;
          end if;
          close(c_prog);
        end if;
*)
        if okay then
          c_prog := open(temp_name(source) & ".c", "w");
          if c_prog <> STD_NULL then
            writeln("Generating code ...");
            init_systypes(prog);
            write_file_head();
            declared_objects := declared_objects(prog);
            for obj range declared_objects do
              process_object(obj);
            end for;
            generate_main(prog);
            close(c_prog);
            writeln;
          else
            write("*** Cannot open temp file ");
            write(literal(temp_name(source) & ".c"));
            writeln(".");
            okay := FALSE;
          end if;
        end if;
      else
        writeln("*** main not found.");
        okay := FALSE;
      end if;
    end if;
  end func;


const proc: pass_3 (in string: source, in program: prog,
    inout boolean: okay) is func

  local
    const string: OBJECT_FILE_EXTENSION is     configValue("OBJECT_FILE_EXTENSION");
    const string: EXECUTABLE_FILE_EXTENSION is configValue("EXECUTABLE_FILE_EXTENSION");
    const string: C_COMPILER is                configValue("C_COMPILER");
    const string: REDIRECT_C_ERRORS is         configValue("REDIRECT_C_ERRORS");
    const string: LINKER_LIBS is               configValue("LINKER_LIBS");
    var string: optimize is "";
    var string: compile_cmd is "";
    var string: link_cmd is "";
  begin
    if okay then
      writeln("Calling the C compiler ...");
      remove(temp_name(source) & OBJECT_FILE_EXTENSION);
      if "-O" in compiler_option then
        optimize := " -O" & compiler_option["-O"];
      end if;
      compile_cmd := C_COMPILER & " -w" & optimize & " -c " &
          temp_name(source) & ".c " &
          REDIRECT_C_ERRORS &
          temp_name(source) & ".cerrs";
      writeln(compile_cmd);
      flush(OUT);
      cmd_sh(compile_cmd);
      if not file_exists(temp_name(source) & OBJECT_FILE_EXTENSION) then
        writeln("*** Errors in " <& literal(temp_name(source) & ".c ") <&
            " - see " <& literal(temp_name(source) & ".cerrs"));
      else
        remove(temp_name(source) & ".cerrs");
        remove(source & EXECUTABLE_FILE_EXTENSION);
        writeln("Calling the linker ...");
        link_cmd := C_COMPILER & " " &
            temp_name(source) & OBJECT_FILE_EXTENSION &
            " " & LINKER_LIBS &
            " -o " & source & " " &
            REDIRECT_C_ERRORS &
            temp_name(source) & ".lerrs";
        writeln(link_cmd);
        flush(OUT);
        cmd_sh(link_cmd);
        if not file_exists(source & EXECUTABLE_FILE_EXTENSION) then
          writeln("*** Linker errors with " <&
              literal(temp_name(source) & OBJECT_FILE_EXTENSION) <&
              " - see " <& literal(temp_name(source) & ".lerrs"));
        else
          remove(temp_name(source) & ".lerrs");
        end if;
        remove(temp_name(source) & OBJECT_FILE_EXTENSION);
      end if;
    end if;
  end func;


const proc: main is func

  local
    var integer: number is 0;
    var string: curr_arg is "";
    var string: source is "";
    var boolean: okay is TRUE;

  begin
    writeln("SEED7 COMPILER Version 2.0  Copyright (c) 1990-2007 Thomas Mertes");
    if length(argv(PROGRAM)) >= 1 then
      number := 1;
      while number <= length(argv(PROGRAM)) do
        curr_arg := argv(PROGRAM)[number];
        if length(curr_arg) >= 2 and curr_arg[1] = '-' then
          compiler_option @:= [curr_arg[.. 2]] curr_arg[3 ..];
        elsif source = "" then
          source := curr_arg;
        end if;
        incr(number);
      end while;
      write("Source: ");
      writeln(source);
    else
      write("Source? ");
      readln(source);
    end if;
    if lower(source[length(source) - 3 ..]) = ".sd7" then
      source := source[.. length(source) - 4];
    end if;
    pass_1(source, prog, okay);
    pass_2(source, prog, okay);
    pass_3(source, prog, okay);
  end func;
