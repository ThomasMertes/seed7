
(********************************************************************)
(*                                                                  *)
(*  tarx.sd7      Simple tar program                                *)
(*  Copyright (C) 1994, 2004, 2005  Thomas Mertes                   *)
(*                                                                  *)
(*  This program is free software; you can redistribute it and/or   *)
(*  modify it under the terms of the GNU General Public License as  *)
(*  published by the Free Software Foundation; either version 2 of  *)
(*  the License, or (at your option) any later version.             *)
(*                                                                  *)
(*  This program is distributed in the hope that it will be useful, *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of  *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *)
(*  GNU General Public License for more details.                    *)
(*                                                                  *)
(*  You should have received a copy of the GNU General Public       *)
(*  License along with this program; if not, write to the           *)
(*  Free Software Foundation, Inc., 51 Franklin Street,             *)
(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)
(*                                                                  *)
(********************************************************************)


$ include "seed7_05.s7i";
  include "time.s7i";
  include "getf.s7i";


const type: header is new struct
    var string: name is "";
    var integer: mode is 0;
    var integer: uid is 0;
    var integer: gid is 0;
    var integer: size is 0;
    var integer: mtime is 0;
    var integer: chksum is 0;
    var char: typeflag is ' ';
    var string: linkname is "";
    var string: magic is "";
    var string: version is "";
    var string: uname is "";
    var string: gname is "";
    var integer: devmajor is 0;
    var integer: devminor is 0;
    var string: prefix is "";
  end struct;


const proc: check (ref file: out_file, ref header: head) is func
  local
    var string: stri is "";
  begin
    write("name: ");
    writeln(head.name);
    write("mode: ");
    writeln(head.mode);
    write("uid: ");
    writeln(head.uid);
    write("gid: ");
    writeln(head.gid);
    write("size: ");
    writeln(head.size);
    write("mtime: ");
    writeln(head.mtime);
    write("chksum: ");
    writeln(head.chksum);
    write("typeflag: ");
    writeln(head.typeflag);
    write("linkname: ");
    writeln(head.linkname);
    write("magic: ");
    writeln(head.magic);
    write("version: ");
    writeln(head.version);
    write("uname: ");
    writeln(head.uname);
    write("gname: ");
    writeln(head.gname);
    write("devmajor: ");
    writeln(head.devmajor);
    write("devminor: ");
    writeln(head.devminor);
    write("prefix: ");
    writeln(head.prefix);
  end func;


const func string: gets0 (inout file: in_file, in integer: leng) is func
  result
    var string: stri is "";
  local
    var integer: zerobyte is 0;
  begin
    stri := gets(in_file, leng);
    zerobyte := pos(stri, "\0\");
    if zerobyte <> 0 then
      stri := stri[ .. pred(zerobyte)];
    end if;
  end func;


const func integer: getoct (inout file: in_file, in integer: leng) is func
  result
    var integer: result is 0;
  local
    var string: stri is "";
  begin
    stri := gets(in_file, leng);
    while stri[1 .. 1] = " " do
      stri := stri[2 .. ];
    end while;
    if stri <> "" and stri[1] >= '0' and stri[1] <= '9' then
      result := ord(stri[1]) - ord('0');
      stri := stri[2 .. ];
      while stri <> "" and stri[1] >= '0' and stri[1] <= '9' do
        result := 8 * result + ord(stri[1]) - ord('0');
        stri := stri[2 .. ];
      end while;
    end if;
  end func;


const proc: puts0 (inout string: out_stri, in string: stri, in integer: leng) is func
  begin
    out_stri &:= stri[ .. leng];
    if length(stri) < leng then
      out_stri &:= "\0\" mult leng - length(stri);
    end if;
  end func;


const proc: putspc (inout string: out_stri, in string: stri, in integer: leng) is func
  begin
    out_stri &:= stri[ .. leng];
    if length(stri) < leng then
      out_stri &:= " " mult leng - length(stri);
    end if;
  end func;


const proc: putoct (inout string: out_stri, in var integer: number, in integer: leng) is func
  local
    var string: stri is "";
  begin
    while number <> 0 do
      stri := str(number rem 8) & stri;
      number := number div 8;
    end while;
    out_stri &:= "0" mult pred(leng - length(stri)) <& stri <& "\0\";
  end func;


const func integer: chksum (in string: stri) is func
  result
    var integer: result is 0;
  local
    var char: ch is ' ';
  begin
    for ch range stri do
      result +:= ord(ch);
    end for;
    result := result rem 2 ** 16;
  end func;


const proc: read (inout file: in_file, inout header: head) is func
  local
    var string: stri is "";
  begin
    head.name :=     gets0(in_file,   100);
    head.mode :=     getoct(in_file,    8);
    head.uid :=      getoct(in_file,    8);
    head.gid :=      getoct(in_file,    8);
    head.size :=     getoct(in_file,   12);
    head.mtime :=    getoct(in_file,   12);
    head.chksum :=   getoct(in_file,    8);
    head.typeflag := getc(in_file); (*  1*)
    head.linkname := gets0(in_file,   100);
    head.magic :=    gets0(in_file,     6);
    head.version :=  gets(in_file,      2);
    head.uname :=    gets0(in_file,    32);
    head.gname :=    gets0(in_file,    32);
    head.devmajor := getoct(in_file,    8);
    head.devminor := getoct(in_file,    8);
    head.prefix :=   gets0(in_file,   155);
    stri :=          gets(in_file,     12);
  end func;


const proc: write (inout file: out_file, ref header: head) is func
  local
    var string: out_stri is "";
    var string: chksum is "";
  begin
    puts0  (out_stri, head.name,      100);
    putoct (out_stri, head.mode,        8);
    putoct (out_stri, head.uid,         8);
    putoct (out_stri, head.gid,         8);
    putoct (out_stri, head.size,       12);
    putoct (out_stri, head.mtime,      12);
    putspc (out_stri, "",               8);
    out_stri &:= str(head.typeflag); (* 1*)
    puts0  (out_stri, head.linkname,  100);
    puts0  (out_stri, head.magic,       6);
    putspc (out_stri, head.version,     2);
    puts0  (out_stri, head.uname,      32);
    puts0  (out_stri, head.gname,      32);
    putoct (out_stri, head.devmajor,    8);
    putoct (out_stri, head.devminor,    8);
    puts0  (out_stri, head.prefix,    155);
    puts0  (out_stri, "",              12);
    putoct (chksum,   chksum(out_stri), 8);
    out_stri := out_stri[ .. 148] & chksum & out_stri[157 .. ];
    out_file << out_stri;
  end func;


const proc: status (in string: stri, inout header: head) is func
  begin
    head.name :=     stri;
    head.mode :=     33261; (*!!*)
    head.uid :=      100;
    head.gid :=      100;
    head.size :=     file_size(stri);
    head.mtime :=    0;
    head.chksum :=   0;
    head.typeflag := '0';
    head.linkname := "";
    head.magic :=    "ustar";
    head.version :=  "  ";
    head.uname :=    "";
    head.gname :=    "";
    head.devmajor := 0;
    head.devminor := 0;
    head.prefix :=   "";
  end func;


const proc: write_rwx (in integer: mode) is func
  begin
    if (mode div 4) mod 2 <> 0 then
      write("r");
    else
      write("-");
    end if;
    if (mode div 2) mod 2 <> 0 then
      write("w");
    else
      write("-");
    end if;
    if mode mod 2 <> 0 then
      write("x");
    else
      write("-");
    end if;
  end func;


const proc: write_mode (in integer: mode) is func
  begin
    write_rwx((mode div 64) mod 8);
    write_rwx((mode div 8) mod 8);
    write_rwx(mode mod 8);
  end func;


const func time: mtime_to_time (in var integer: mtime) is func
  result
    var time: result is time.value;
  local
    const integer: normal_year_seconds is 365 * 24 * 60 * 60;
    const integer: leap_year_seconds is 366 * 24 * 60 * 60;
    const array integer: normal_year_months is [] (
        31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31);
    const array integer: leap_year_months is [] (
        31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31);
    const integer: day_seconds is 24 * 60 * 60;
    const integer: hour_seconds is 60 * 60;
  begin
    result.year := 1970;
    while mtime >= leap_year_seconds do
      if leap_year(result.year) then
        mtime -:= leap_year_seconds;
      else
        mtime -:= normal_year_seconds;
      end if;
      incr(result.year);
    end while;
    if mtime >= normal_year_seconds and
        not leap_year(result.year) then
      mtime -:= normal_year_seconds;
      incr(result.year);
    end if;
    result.month := 1;
    if leap_year(result.year) then
      while mtime >= leap_year_months[result.month] * day_seconds do
        mtime -:= leap_year_months[result.month] * day_seconds;
        incr(result.month);
      end while;
    else
      while mtime >= normal_year_months[result.month] * day_seconds do
        mtime -:= normal_year_months[result.month] * day_seconds;
        incr(result.month);
      end while;
    end if;
    result.day :=    mtime div day_seconds + 1;
    mtime :=         mtime rem day_seconds;
    result.hour :=   mtime div hour_seconds + 1;
    mtime :=         mtime rem hour_seconds;
    result.minute := mtime div 60;
    mtime :=         mtime rem 60;
    result.second := mtime;
  end func;


const func integer: time_to_mtime (in time: aTime) is func
  result
    var integer: result is 0;
  local
    const integer: normal_year_seconds is 365 * 24 * 60 * 60;
    const integer: leap_year_seconds is 366 * 24 * 60 * 60;
    const array integer: normal_year_months is [] (
        31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31);
    const array integer: leap_year_months is [] (
        31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31);
    const integer: day_seconds is 24 * 60 * 60;
    const integer: hour_seconds is 60 * 60;
    var integer: number is 0;
  begin
    for number range 1970 to pred(aTime.year) do
      if leap_year(number) then
        result +:= leap_year_seconds;
      else
        result +:= normal_year_seconds;
      end if;
    end for;
    if leap_year(aTime.year) then
      for number range 1 to pred(aTime.month) do
        result +:= leap_year_months[number] * day_seconds;
      end for;
    else
      for number range 1 to pred(aTime.month) do
        result +:= normal_year_months[number] * day_seconds;
      end for;
    end if;
    result +:= pred(aTime.day) * day_seconds +
        pred(aTime.hour) * hour_seconds +
        aTime.minute * 60 +
        aTime.second;
  end func;


const proc: tar_tell (in string: in_file_name, in boolean: do_view,
    in array string: arg_list) is func
  local
    var file: in_file is STD_NULL;
    var string: stri is "";
    var header: head is header.value;
  begin
    in_file := open(in_file_name, "r");
    if in_file <> STD_NULL then
      read(in_file, head);
      repeat
        if do_view then
          if head.typeflag = '5' then
            write("d");
          else
            write("-");
          end if;
          write_mode(head.mode);
          write(" ");
          write(head.uname);
          write("/");
          write(head.gname);
          write(head.size lpad 11);
          write(" ");
          write(mtime_to_time(head.mtime));
          write(" ");
        end if;
        writeln(head.name);
        (* check(OUT, head);
        readln; *)
        if head.size <> 0 then
          seek(in_file, tell(in_file) + succ(pred(head.size) div 512) * 512);
        end if;
        read(in_file, head);
      until head.name = "";
    else
      write("tarx: Cannot open \"");
      write(in_file_name);
      writeln("\".");
    end if;
  end func;


const proc: tar_xtract (in string: in_file_name, in boolean: do_view,
    in array string: arg_list) is func
  local
    var file: in_file is STD_NULL;
    var string: stri is "";
    var header: head is header.value;
  begin
    in_file := open(in_file_name, "r");
    if in_file <> STD_NULL then
      read(in_file, head);
      repeat
        if do_view then
          write("x ");
          writeln(head.name);
        end if;
        if head.typeflag = '5' then
          mkdir(head.name);
        else
          if head.size <> 0 then
            stri := gets(in_file, succ(pred(head.size) div 512) * 512);
            putf(head.name, stri[ .. head.size]);
          end if;
        end if;
        read(in_file, head);
      until head.name = "";
    end if;
  end func;


const proc: tar_create (inout file: out_file, in boolean: do_view,
    in string: path, in array string: arg_list) is func
  local
    var string: name is "";
    var array string: dir_content is 0 times "";
    var string: stri is "";
    var header: head is header.value;
  begin
    for name range arg_list do
      name := path & name;
      if do_view then
        write("c ");
        writeln(name);
      end if;
      dir_content := read_dir(name);
      if length(dir_content) <> 0 then
        status(name & "/", head);
        head.typeflag := '5';
        head.size :=     0;
        write(out_file, head);
        tar_create(out_file, do_view, name & "/", dir_content);
      else
        stri := getf(name);
        status(name, head);
        write(out_file, head);
        out_file << stri;
        if (succ(pred(head.size) div 512) * 512) - length(stri) >= 0 then
          out_file << " " mult (succ(pred(head.size) div 512) * 512) - length(stri);
        end if;
      end if;
    end for;
  end func;


const proc: tar_create (in string: out_file_name, in boolean: do_view,
    in array string: arg_list) is func
  local
    var file: out_file is STD_NULL;
  begin
    out_file := open(out_file_name, "w");
    if out_file <> STD_NULL then
      tar_create(out_file, do_view, "", arg_list);
    end if;
  end func;


const proc: main is func
  local
    var string: option is "";
    var char: command is ' ';
    var string: file_name is "";
    var boolean: do_view is FALSE;
    var boolean: file_arg is FALSE;
    var array string: arg_list is 0 times "";
    var integer: number is 0;
    var integer: mtime is 0;
  begin
    if length(argv(PROGRAM)) >= 1 then
      option := argv(PROGRAM)[1];
      if option[1] = '-' then
        option := option [2 .. ];
      end if;
      command := option[1];
      if command in {'t', 'x', 'c'} then
        option := option [2 .. ];
        while option <> "" do
          if option[1] = 'v' then
            do_view := TRUE;
          end if;
          if option[1] = 'f' then
            file_arg := TRUE;
          end if;
          option := option [2 .. ];
        end while;
        if file_arg then
          if length(argv(PROGRAM)) >= 2 then
            file_name := argv(PROGRAM)[2];
            arg_list := argv(PROGRAM)[3 .. ];
          else
            writeln("tarx: The option 'f' needs a file name.");
            command := ' ';
          end if;
        else
          file_name := "/dev/flp";
          arg_list := argv(PROGRAM)[2 .. ];
        end if;
        case command of
          when {'t'}:
            tar_tell(file_name, do_view, arg_list);
          when {'x'}:
            tar_xtract(file_name, do_view, arg_list);
          when {'c'}:
            tar_create(file_name, do_view, arg_list);
        end case;
      else
        write("tarx: Illegal option '");
        write(command);
        writeln("'. Legal options are 't', 'x' or 'c'.");
      end if;
    else
      writeln("tarx: One of the options 't', 'x' or 'c' must be specified.");
    end if;
  end func;
