
(********************************************************************)
(*                                                                  *)
(*  panic.sd7     Catch aliens in traps game                        *)
(*  Copyright (C) 2004, 2005  Thomas Mertes                         *)
(*                                                                  *)
(*  This program is free software; you can redistribute it and/or   *)
(*  modify it under the terms of the GNU General Public License as  *)
(*  published by the Free Software Foundation; either version 2 of  *)
(*  the License, or (at your option) any later version.             *)
(*                                                                  *)
(*  This program is distributed in the hope that it will be useful, *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of  *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *)
(*  GNU General Public License for more details.                    *)
(*                                                                  *)
(*  You should have received a copy of the GNU General Public       *)
(*  License along with this program; if not, write to the Free      *)
(*  Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,  *)
(*  MA 02111-1307 USA                                               *)
(*                                                                  *)
(********************************************************************)


$ include "seed7_05.s7i";
  include "time.s7i";
  include "float.s7i";
  include "keybd.s7i";
  include "draw.s7i";


const integer: NUM_LEVELS is 6;
const integer: SPEED is 1;
const integer: FALL_SPEED is 2 * SPEED;
const integer: FIELD_ELEM_STEP is 2;
const integer: PICTURE_SCALE is 2;
const integer: AREA_LINES is 161;
const integer: AREA_COLUMNS is 267;
const integer: WIN_HEIGHT is (AREA_LINES + 34) * FIELD_ELEM_STEP;
const integer: WIN_WIDTH is (AREA_COLUMNS + 16) * FIELD_ELEM_STEP;
const integer: FIELD_BORDER is SPEED;
const integer: FIELD_LINES is AREA_LINES + 2 * FIELD_BORDER;
const integer: FIELD_COLUMNS is AREA_COLUMNS + 2 * FIELD_BORDER;
const integer: FIELD_X_START is (1 - FIELD_BORDER) * FIELD_ELEM_STEP;
const integer: FIELD_Y_START is (17 - FIELD_BORDER) * FIELD_ELEM_STEP;
const integer: FULL_MOTION is 0;
const integer: CATCH_MOTION is 1;
const integer: LEAVE_MOTION is 2;
const integer: TRAP_DEPTH is 9;
const duration: TIME_IN_HOLE is 17 . SECONDS;

const type: holeType is new enum
    no_hole, hole_depth1, hole_depth2, hole_depth3, hole_depth4, hole_finished,
    hole_part, hole_unfinished, hole_bottom, hole_entering, hole_leaving,
    hole_filled, hole_pound1, hole_pound2, hole_pound3, hole_pound4, hole_pounded
  end enum;

const func string: str (in holeType: aHole) is
  return [](
    "no_hole", "hole_depth1", "hole_depth2", "hole_depth3", "hole_depth4", "hole_finished",
    "hole_part", "hole_unfinished", "hole_bottom", "hole_entering", "hole_leaving",
    "hole_filled", "hole_pound1", "hole_pound2", "hole_pound3", "hole_pound4", "hole_pounded"
  )[succ(ord(aHole))];

enable_output(holeType);

const array array integer: round_description is [](
  [](3, 0, 0, 2000, 0),
  [](5, 0, 0, 2000, 0),
  [](8, 0, 0, 2000, 0),
  [](2, 1, 0, 3000, 1),
  [](4, 1, 0, 3000, 0),
  [](7, 1, 0, 3000, 0),
  [](1, 1, 1, 3000, 0),
  [](3, 1, 1, 4000, 0),
  [](6, 1, 1, 4000, 0),
  [](0, 2, 1, 4000, 0),
  [](2, 2, 1, 4000, 0),
  [](5, 2, 1, 5000, 0),
  [](0, 2, 1, 5000, 0),
  [](1, 3, 1, 5000, 0),
  [](4, 3, 1, 5000, 0),
  [](0, 2, 1, 6000, 0), (* ? *)
  [](0, 4, 1, 6000, 0), (* ? *)
  [](3, 4, 1, 6000, 0), (* ? *)
  [](0, 2, 1, 6000, 0), (* ? *)
  [](0, 4, 1, 7000, 0), (* ? *)
  [](2, 5, 1, 7000, 0), (* ? *)
  [](0, 2, 1, 7000, 0), (* ? *)
  [](0, 4, 1, 7000, 0), (* ? *)
  [](1, 6, 1, 8000, 0), (* ? *)
  [](0, 2, 1, 8000, 0), (* ? *)
  [](0, 4, 1, 8000, 0), (* ? *)
  [](0, 7, 1, 8000, 0), (* ? *)
  [](0, 1, 2, 9000, 0), (* ? *)
  [](0, 3, 2, 9000, 0), (* ? *)
  [](0, 6, 2, 9000, 0), (* ? *)
  [](0, 0, 3, 9000, 0), (* ? *)
  [](0, 2, 3, 9000, 0), (* ? *)
  [](0, 5, 3, 9000, 0), (* ? *)
  [](0, 0, 3, 9000, 0), (* ? *)
  [](0, 1, 4, 9000, 0), (* ? *)
  [](0, 4, 4, 9000, 0), (* ? *)
  [](0, 0, 3, 9000, 0), (* ? *)
  [](0, 0, 5, 9000, 0), (* ? *)
  [](0, 3, 5, 9000, 0), (* ? *)
  [](0, 0, 3, 9000, 0), (* ? *)
  [](0, 0, 5, 9000, 0), (* ? *)
  [](0, 2, 6, 9000, 0), (* ? *)
  [](0, 0, 3, 9000, 0), (* ? *)
  [](0, 0, 5, 9000, 0), (* ? *)
  [](0, 1, 7, 9000, 0), (* ? *)
  [](0, 0, 3, 9000, 0), (* ? *)
  [](0, 0, 5, 9000, 0), (* ? *)
  [](0, 0, 8, 9000, 0));(* ? *)

const type: ladderLayout is array array integer;

const array ladderLayout: layout_description is [](
  []([](1, 6,   8), [](1, 2,  48), [](1, 3,  96), [](1, 6, 256), [](2, 3, 160),
     [](2, 4, 200), [](3, 5,  80), [](5, 6,  64), [](5, 6, 160)),
  []([](1, 4,   8), [](1, 2,  72), [](1, 6, 128), [](1, 2, 192), [](2, 5, 176),
     [](3, 4,  40), [](3, 5,  80), [](3, 6, 260), [](5, 6,   8)),
  []([](1, 2,   8), [](1, 2, 192), [](2, 4,  96), [](2, 6, 176), [](2, 4, 236),
     [](3, 4,   8), [](4, 5,  44), [](5, 6,   8), [](5, 6, 104), [](5, 6, 260)),
  []([](1, 6,   8), [](1, 3,  64), [](1, 2, 128), [](1, 6, 236), [](3, 6, 164),
     [](4, 5,  64), [](5, 6, 106))
  );

var array array PRIMITIVE_WINDOW: monster_pixmap is 3 times 0 times PRIMITIVE_WINDOW.value;
var array PRIMITIVE_WINDOW: player_left_pixmap is 0 times PRIMITIVE_WINDOW.value;
var array PRIMITIVE_WINDOW: player_right_pixmap is 0 times PRIMITIVE_WINDOW.value;
var array PRIMITIVE_WINDOW: player_up_pixmap is 0 times PRIMITIVE_WINDOW.value;
var array PRIMITIVE_WINDOW: player_down_pixmap is 0 times PRIMITIVE_WINDOW.value;
var array PRIMITIVE_WINDOW: player_falling_pixmap is 0 times PRIMITIVE_WINDOW.value;
var array PRIMITIVE_WINDOW: player_dig_left_pixmap is 0 times PRIMITIVE_WINDOW.value;
var array PRIMITIVE_WINDOW: player_dig_right_pixmap is 0 times PRIMITIVE_WINDOW.value;
var array PRIMITIVE_WINDOW: digit_pixmap is 0 times PRIMITIVE_WINDOW.value;
var PRIMITIVE_WINDOW: player_reserve_pixmap is PRIMITIVE_WINDOW.value;
var PRIMITIVE_WINDOW: score_text_pixmap is PRIMITIVE_WINDOW.value;
var PRIMITIVE_WINDOW: bonus_text_pixmap is PRIMITIVE_WINDOW.value;
var PRIMITIVE_WINDOW: hiscore_text_pixmap is PRIMITIVE_WINDOW.value;

const type: pixmap_array is array PRIMITIVE_WINDOW;

const type: screenObj is new struct
    var integer: line is 1;
    var integer: column is 1;
    var integer: height is 0;
    var integer: width is 0;
    var integer: line_direction is 0;
    var integer: column_direction is 0;
    var boolean: moving is TRUE;
    var boolean: falling is FALSE;
    var integer: motionIndex is 0;
    var integer: motionSpeed is FULL_MOTION;
    var integer: actual_pixmap_index is 1;
    var pixmap_array: pixmap is 0 times PRIMITIVE_WINDOW.value;
    var PRIMITIVE_WINDOW: saved_pixmap is PRIMITIVE_WINDOW.value;
  end struct;

const type: playerObj is sub screenObj struct
    var char:    command is ' ';
    var boolean: living is TRUE;
    var boolean: digging is FALSE;
    var integer: dig_direction is 0;
    var integer: face_direction is 1;
  end struct;

const type: monsterObj is sub screenObj struct
    var integer: category is 1;
    var integer: saved_column_direction is 0;
    var time:    action_time is time.value;
    var integer: holes_passed is 0;
    var integer: basePoints is 0;
    var integer: points is 0;
    var boolean: catching is FALSE;
  end struct;

const type: gameObj is new struct
    var integer: num_players is 0;
    var integer: round_number is 0;
    var integer: round_bonus is 0;
    var integer: num_monsters is 0;
    var integer: score is 0;
    var integer: hiScore is 0;
    var time: turn_time is time.value;
    var boolean: round_finished is FALSE;
    var boolean: restart is FALSE;
    var boolean: quit is FALSE;
  end struct;

var array monsterObj: monster is 0 times monsterObj.value;
var playerObj: player is playerObj.value;
var gameObj: game is gameObj.value;

const array integer: level_line is [](
    1, 33, 65, 97, 129, 161
  );

var array array boolean: field is FIELD_LINES times FIELD_COLUMNS times FALSE;
var array array holeType: hole_status is FIELD_LINES times FIELD_COLUMNS times no_hole;

var text: scr is STD_NULL;

(*
const array string: player_right_1 is [](
  "    XXXXX     ",
  "    XX XXX    ",
  "    XXXXX   XX",
  "     XXX    XX",
  "      X    XX ",
  "  XXXXXXXXXX  ",
  " XX  XXX      ",
  "XX   XXX      ",
  "XX   XXX      ",
  "     XXX      ",
  "    XXXXX     ",
  "   XX   XX    ",
  "   XX  XX     ",
  "  XX   XX     ",
  "  XX     X    ",
  "  XXX         ");


const array string: player_right_2 is [](
  "    XXXXX     ",
  "    XX XXX    ",
  "    XXXXX     ",
  "     XXX    XX",
  "      X     XX",
  "  XXXXXXXXXXX ",
  " XX  XXX  XX  ",
  "XX   XXX      ",
  "XX   XXX      ",
  "     XXX      ",
  "     XXX      ",
  "    XX XX     ",
  "   XX   XX    ",
  "  XX    XX    ",
  " XX     XXX   ",
  " XXX          ");


const array string: player_right_3 is [](
  "    XXXXX     ",
  "    XX XXX    ",
  "    XXXXX     ",
  "     XXX    XX",
  "      X     XX",
  "  XXXXXXXXXXX ",
  " XX  XXX  XX  ",
  "XX   XXX      ",
  "XX   XXX      ",
  "     XXX      ",
  "     XXX      ",
  "    XX XX     ",
  "   XX  XX     ",
  "  XX    XX    ",
  " XX     XX    ",
  "  XX    XXX   ");


const array string: player_right_4 is [](
  "    XXXXX     ",
  "    XX XXX    ",
  "    XXXXX     ",
  "     XXX      ",
  "      X     XX",
  "  XXXXXXXX  XX",
  " XX  XXX XXXX ",
  " XX  XXX      ",
  "  XX XXX      ",
  "     XXX      ",
  "     XXX      ",
  "    XXXX      ",
  "   XXX XX     ",
  "XXXX   XX     ",
  "X      XX     ",
  "       XXX    ");


const array string: player_right_5 is [](
  "    XXXXX     ",
  "    XX XXX    ",
  "    XXXXX     ",
  "     XXX      ",
  "      X       ",
  "   XXXXXXX  XX",
  "  XX XXX XX XX",
  " XX  XXX  XXX ",
  "  XX XXX      ",
  "     XXX      ",
  "     XXX      ",
  "     XXX      ",
  "XXXXXXXX      ",
  "X     XX      ",
  "      XX      ",
  "      XXX     ");


const array string: player_right_6 is [](
  "    XXXXX     ",
  "    XX XXX    ",
  "    XXXXX     ",
  "     XXX      ",
  "      X       ",
  "   XXXXXXX  XX",
  "  XX XXX XX XX",
  " XX  XXX  XXX ",
  "  XX XXX      ",
  "     XXX      ",
  "     XXX      ",
  "     XXX      ",
  "  XXXXXX      ",
  "  X  XX       ",
  "     XX       ",
  "     XXX      ");


const array string: player_right_7 is [](
  "    XXXXX     ",
  "    XX XXX    ",
  "    XXXXX     ",
  "     XXX      ",
  "      X       ",
  "   XXXXXXX  XX",
  "  XX XXX XX XX",
  " XX  XXX  XXX ",
  "  XX XXX      ",
  "     XXXX     ",
  "     XX XX    ",
  "     XXXX     ",
  "    XXXX      ",
  "    XXXXX     ",
  "    XX        ",
  "    XXX       ");


const array string: player_right_8 is [](
  "    XXXXX     ",
  "    XX XXX    ",
  "    XXXXX   XX",
  "     XXX    XX",
  "      X    XX ",
  "  XXXXXXXXXX  ",
  " XX  XXX      ",
  "XX   XXX      ",
  "XX   XXX      ",
  "    XXXXX     ",
  "    XX  XX    ",
  "    XX  XX    ",
  "   XX  XX     ",
  "   XX   XX    ",
  "   XX         ",
  "   XXX        ");


const array string: player_right_9 is [](
  "    XXXXX     ",
  "    XX XXX    ",
  "    XXXXX   XX",
  "     XXX    XX",
  "      X    XX ",
  "  XXXXXXXXXX  ",
  " XX  XXX      ",
  "XX   XXX      ",
  "XX   XXX      ",
  "     XXXX     ",
  "     XX XXX   ",
  "     XX   XX  ",
  "    XX   XX   ",
  "    XX   XX   ",
  "    XX     X  ",
  "    XXX       ");


const array string: player_right_10 is [](
  "    XXXXX     ",
  "    XX XXX    ",
  "    XXXXX     ",
  "     XXX    XX",
  "      X     XX",
  "  XXXXXXXXXXX ",
  " XX  XXX  XX  ",
  "XX   XXX      ",
  "XX   XXX      ",
  "     XXXX     ",
  "     XX XX    ",
  "    XX   XX   ",
  "    XX   XX   ",
  "   XX    XX   ",
  "   XX    XXX  ",
  "   XXX        ");
*)


const array string: player_right_1 is [](
  "    XXXXX     ",
  "    XX XXX    ",
  "    XXXXX   XX",
  "     XXX    XX",
  "      X    XX ",
  "  XXXXXXXXXX  ",
  " XX  XXX      ",
  "XX   XXX      ",
  "XX   XXX      ",
  "    XXXXXXXX  ",
  "    XX    XX  ",
  "    XX    XX  ",
  "    XX    XX  ",
  "    XX    XXX ",
  "    XX        ",
  "    XXX       ");


const array string: player_right_2 is [](
  "    XXXXX     ",
  "    XX XXX    ",
  "    XXXXX     ",
  "     XXX      ",
  "      X       ",
  "   XXXXXXX  XX",
  "  XX XXX XX XX",
  " XX  XXX  XXX ",
  "  XX XXX      ",
  "    XXXXXX    ",
  "    XX  XX    ",
  "    XX  XX    ",
  "XXXXXX  XX    ",
  "X       XX    ",
  "        XX    ",
  "        XXX   ");


const array string: player_left_1 is [](
  "     XXXXX    ",
  "    XXX XX    ",
  "XX   XXXXX    ",
  "XX    XXX     ",
  " XX    X      ",
  "  XXXXXXXXXX  ",
  "      XXX  XX ",
  "      XXX   XX",
  "      XXX   XX",
  "  XXXXXXXX    ",
  "  XX    XX    ",
  "  XX    XX    ",
  "  XX    XX    ",
  " XXX    XX    ",
  "        XX    ",
  "       XXX    ");


const array string: player_left_2 is [](
  "     XXXXX    ",
  "    XXX XX    ",
  "     XXXXX    ",
  "      XXX     ",
  "       X      ",
  "XX  XXXXXXX   ",
  "XX XX XXX XX  ",
  " XXX  XXX  XX ",
  "      XXX XX  ",
  "    XXXXXX    ",
  "    XX  XX    ",
  "    XX  XX    ",
  "    XX  XXXXXX",
  "    XX       X",
  "    XX        ",
  "   XXX        ");


const array string: player_falling is [](
  " XX  XXX    ",
  " XX XXXXX   ",
  " XX XXXXX   ",
  " XX  XXX    ",
  "  XX  X     ",
  "   XXXXXXXX ",
  "     XXX  XX",
  "     XXX  XX",
  "     XXX  XX",
  " XXXXXXXX XX",
  " XX    XX   ",
  " XX    XX   ",
  " XX    XX   ",
  "       XX   ",
  "       XX   ",
  "       XX   ");


const array string: player_dig_right_1 is [](
  " XXXXX       ",
  " XX XXX      ",
  " XXXXX       ",
  "  XXX        ",
  "   X         ",
  " XXXXXX      ",
  " XXXX XX     ",
  "  XXXX XX    ",
  "  XXXXXXX    ",
  "  XXX  XX    ",
  " XX XX  XX   ",
  " XX XX   XX  ",
  " XX XX    XXX",
  " XX XX    XXX",
  " XX XX     XX",
  "XXX XXX     X");


const array string: player_dig_right_2 is [](
  " XXXXX     XX",
  " XX XXX   XXX",
  " XXXXX   XXXX",
  "  XXX   XX   ",
  "   X   XX    ",
  "  XXXXXXX    ",
  "  XXX  XX    ",
  "  XXXXXX     ",
  "  XXX        ",
  "  XXX        ",
  " XX XX       ",
  " XX XX       ",
  " XX XX       ",
  " XX XX       ",
  " XX XX       ",
  "XXX XXX      ");


const array string: player_dig_left_1 is [](
  "       XXXXX ",
  "      XXX XX ",
  "       XXXXX ",
  "        XXX  ",
  "         X   ",
  "      XXXXXX ",
  "     XX XXXX ",
  "    XX XXXX  ",
  "    XXXXXXX  ",
  "    XX  XXX  ",
  "   XX  XX XX ",
  "  XX   XX XX ",
  "XXX    XX XX ",
  "XXX    XX XX ",
  "XX     XX XX ",
  "X     XXX XXX");


const array string: player_dig_left_2 is [](
  "XX     XXXXX ",
  "XXX   XXX XX ",
  "XXXX   XXXXX ",
  "   XX   XXX  ",
  "    XX   X   ",
  "    XXXXXXX  ",
  "    XX  XXX  ",
  "     XXXXXX  ",
  "        XXX  ",
  "        XXX  ",
  "       XX XX ",
  "       XX XX ",
  "       XX XX ",
  "       XX XX ",
  "       XX XX ",
  "      XXX XXX");

const array string: player_up_down_1 is [](
  "    XXXXX XXX",
  "    XXXXX XXX",
  "    XXXXX XXX",
  "     XXX  XXX",
  "      X XXX  ",
  "  XXXXXXXXX  ",
  "XXX  XXX     ",
  "XXX  XXX     ",
  "XXX XXXXX    ",
  "XXX XXXXXXXXX",
  "    XX    XXX",
  "    XX    XXX",
  "    XXX   XXX",
  "    XXX      ",
  "    XX       ",
  "    XX       ");


const array string: player_up_down_2 is [](
  "XXX  XXX     ",
  "XXX XXXXX    ",
  "XXX XXXXX    ",
  "XXX XXXXX    ",
  "  XX  X      ",
  "   XXXXXXXX  ",
  "    XXXXX XXX",
  "    XXXXX XXX",
  "     XXX  XXX",
  "XXXXXXXXX XXX",
  "XXX   XXX    ",
  "XXX   XXX    ",
  "XXX    XX    ",
  "       XX    ",
  "      XXX    ",
  "      XXX    ");


const array string: monster1_1 is [](
  "B           B",
  "B           B",
  "BBBBB   BBBBB",
  "     OOO     ",
  "   OOOOOOO   ",
  " O      B  O ",
  " O      B  O ",
  " O         O ",
  " OOOOOOOOOOO ",
  "   O     O   ");


const array string: monster1_2 is [](
  "B           B",
  "BB         BB",
  "B BBB   BBB B",
  "     OOO     ",
  "   OOOOOOO   ",
  " O     B   O ",
  " O     B   O ",
  " O         O ",
  " OOOOOOOOOOO ",
  "   OO   OO   ");


const array string: monster1_3 is [](
  "B           B",
  "BBBB     BBBB",
  "B   B   B   B",
  "     OOO     ",
  "   OOOOOOO   ",
  " O    B    O ",
  " O    B    O ",
  " O         O ",
  " OOOOOOOOOOO ",
  "  O O   O O  ");


const array string: monster1_4 is [](
  "BBB       BBB",
  "B  B     B  B",
  "    B   B    ",
  "     OOO     ",
  "   OOOOOOO   ",
  " O   B     O ",
  " O   B     O ",
  " O         O ",
  " OOOOOOOOOOO ",
  "  O  O O  O  ");


const array string: monster1_5 is [](
  "BBB       BBB",
  "B   B   B   B",
  "    B   B    ",
  "     OOO     ",
  "   OOOOOOO   ",
  " O  B      O ",
  " O  B      O ",
  " O         O ",
  " OOOOOOOOOOO ",
  " O   OOO   O ");


const array string: monster2_1 is [](
  "  G       G  ",
  "  G       G  ",
  "GGGGG   GGGGG",
  "GGGGG   GGGGG",
  "G  M  G  M  G",
  "G     G     G",
  "GGGGGGGGGGGGG",
  "  GGGGGGGGG  ",
  "  OOO   OOO  ",
  "OOO       OOO");


const array string: monster2_2 is [](
  "G           G",
  "GGG       GGG",
  "GGG       GGG",
  "GGGGG   GGGGG",
  "G     G     G",
  "G  M  G  M  G",
  "GGGGGGGGGGGGG",
  "  GGGGGGGGG  ",
  "  OOO   OOO  ",
  "    O   O    ");


const array string: monster3_1 is [](
  "  B       B  ",
  "  BBB   BBB  ",
  "BBBBB   BBBBB",
  "BBBBB   BBBBB",
  "  B  OOO  B  ",
  "  B  OOO  B  ",
  "  BBB   BBB  ",
  "  B   B   B  ",
  "    BBBBB    ",
  "    B   B    ");


const array string: monster3_2 is [](
  "B           B",
  "BBB       BBB",
  "BBB       BBB",
  "BBB  OOO  BBB",
  "  B  OOO  B  ",
  "  B       B  ",
  "  BBB   BBB  ",
  "  B   B   B  ",
  "B     B     B",
  "B           B");


const array string: player_reserve is [](
  "  XXX  ",
  "  XXX  ",
  "X  X  X",
  " XXXXX ",
  "   X   ",
  "  XXX  ",
  " X   X ",
  "X     X");


const array string: score_text is [](
  " XXX    XXX        ",
  "G   G  M   M       ",
  "G      M           ",
  " XXX   M      XXXXX",
  "    G  M           ",
  "G   G  M   M       ",
  " XXX    XXX        ");


const array string: bonus_text is [](
  "XXXX    XXX   M   M  G   G   XXX        ",
  "M   M  G   G  M   M  G   G  M   M       ",
  "M   M  G   G  XX  M  G   G  M           ",
  "XXXX   G   G  MMMMM  G   G   XXX   XXXXX",
  "M   M  G   G  M  XX  G   G      M       ",
  "M   M  G   G  M   M  G   G  M   M       ",
  "XXXX    XXX   M   M   XXX    XXX        ");


const array string: hiscore_text is [](
  "M   M   XXX        ",
  "M   M    G         ",
  "M   M    G         ",
  "XXXXX    G    XXXXX",
  "M   M    G         ",
  "M   M    G         ",
  "M   M   XXX        ");


const array string: zero is [](
  "     ",
  " XXX ",
  "M   M",
  "M   M",
  "M   M",
  "M   M",
  " XXX ");


const array string: one is [](
  "  XX ",
  " MMM ",
  "   M ",
  "   M ",
  "   M ",
  "   M ",
  "  XXX");


const array string: two is [](
  " XXX ",
  "G   G",
  "    G",
  "   M ",
  " XX  ",
  "G    ",
  "XXXXX");


const array string: three is [](
  " XXX ",
  "M   M",
  "    M",
  "  XX ",
  "    M",
  "M   M",
  " XXX ");


const array string: four is [](
  "G    ",
  "G    ",
  "G  M ",
  "XXXXX",
  "   M ",
  "   M ",
  "   M ");


const array string: five is [](
  "XXXX ",
  "M    ",
  "M    ",
  "XXXX ",
  "    M",
  "    M",
  "XXXX ");


const array string: six is [](
  " XXX ",
  "G   G",
  "G    ",
  "XXXX ",
  "G   G",
  "G   G",
  " XXX ");


const array string: seven is [](
  "XXXXX",
  "M   M",
  "    M",
  "   G ",
  "   G ",
  "  M  ",
  "  M  ");


const array string: eight is [](
  " XXX ",
  "G   G",
  "G   G",
  " XXX ",
  "G   G",
  "G   G",
  " XXX ");


const array string: nine is [](
  " XXX ",
  "M   M",
  "M   M",
  " XXXX",
  "    M",
  "M   M",
  " XXX ");


const func PRIMITIVE_WINDOW: create_pixmap (in array string: pattern,
    in integer: scale) is func
  result
    var PRIMITIVE_WINDOW: result is PRIMITIVE_WINDOW.value;
  local
    var integer: height is 0;
    var integer: width is 0;
    var integer: line is 0;
    var integer: column is 0;
    var color: col is black;
  begin
    height := length(pattern);
    width := length(pattern[1]);
    result := newPixmap(width * scale, height * scale);
    clear(result, black);
    for line range 1 to height do
      for column range 1 to width do
        case pattern[line][column] of
          when {' '}: col := black;
          when {'R'}: col := light_red;
          when {'G'}: col := light_green;
          when {'B'}: col := light_blue;
          when {'Y'}: col := yellow;
          when {'M'}: col := light_magenta;
          when {'O'}: col := orange;
          when {'r'}: col := dark_red;
          when {'g'}: col := dark_green;
          when {'c'}: col := light_cyan;
          when {'X'}: col := white;
          when {'x'}: col := light_gray;
          when {'b'}: col := brown;
          otherwise:  col := black;
        end case;
        rect(result,
            pred(column) * scale,
            pred(line) * scale,
            scale, scale, col);
      end for;
    end for;
  end func;


const proc: init_pictures is func
  local
    var integer: number is 0;
  begin
    monster_pixmap[1] := 8 times PRIMITIVE_WINDOW.value;
(*
    monster_pixmap[1][1] := create_pixmap(monster1_1, PICTURE_SCALE);
    monster_pixmap[1][2] := create_pixmap(monster1_2, PICTURE_SCALE);
    monster_pixmap[1][3] := create_pixmap(monster1_3, PICTURE_SCALE);
    monster_pixmap[1][4] := create_pixmap(monster1_4, PICTURE_SCALE);
    monster_pixmap[1][5] := create_pixmap(monster1_5, PICTURE_SCALE);
    monster_pixmap[1][6] := monster_pixmap[1][4];
    monster_pixmap[1][7] := monster_pixmap[1][3];
    monster_pixmap[1][8] := monster_pixmap[1][2];
*)
    monster_pixmap[1][1] := create_pixmap(monster1_1, PICTURE_SCALE);
    monster_pixmap[1][2] := monster_pixmap[1][1];
    monster_pixmap[1][3] := monster_pixmap[1][1];
    monster_pixmap[1][4] := monster_pixmap[1][1];
    monster_pixmap[1][5] := create_pixmap(monster1_5, PICTURE_SCALE);
    monster_pixmap[1][6] := monster_pixmap[1][5];
    monster_pixmap[1][7] := monster_pixmap[1][5];
    monster_pixmap[1][8] := monster_pixmap[1][5];
    monster_pixmap[2] := 8 times PRIMITIVE_WINDOW.value;
    monster_pixmap[2][1] := create_pixmap(monster2_1, PICTURE_SCALE);
    monster_pixmap[2][2] := monster_pixmap[2][1];
    monster_pixmap[2][3] := monster_pixmap[2][1];
    monster_pixmap[2][4] := monster_pixmap[2][1];
    monster_pixmap[2][5] := create_pixmap(monster2_2, PICTURE_SCALE);
    monster_pixmap[2][6] := monster_pixmap[2][5];
    monster_pixmap[2][7] := monster_pixmap[2][5];
    monster_pixmap[2][8] := monster_pixmap[2][5];
    monster_pixmap[3] := 8 times PRIMITIVE_WINDOW.value;
    monster_pixmap[3][1] := create_pixmap(monster3_1, PICTURE_SCALE);
    monster_pixmap[3][2] := monster_pixmap[3][1];
    monster_pixmap[3][3] := monster_pixmap[3][1];
    monster_pixmap[3][4] := monster_pixmap[3][1];
    monster_pixmap[3][5] := create_pixmap(monster3_2, PICTURE_SCALE);
    monster_pixmap[3][6] := monster_pixmap[3][5];
    monster_pixmap[3][7] := monster_pixmap[3][5];
    monster_pixmap[3][8] := monster_pixmap[3][5];
(*
    player_right_pixmap := 8 times PRIMITIVE_WINDOW.value;
    player_right_pixmap[1] := create_pixmap(player_right_1, PICTURE_SCALE);
    player_right_pixmap[2] := create_pixmap(player_right_2, PICTURE_SCALE);
    player_right_pixmap[3] := create_pixmap(player_right_3, PICTURE_SCALE);
    player_right_pixmap[4] := create_pixmap(player_right_4, PICTURE_SCALE);
    player_right_pixmap[5] := create_pixmap(player_right_5, PICTURE_SCALE);
    player_right_pixmap[6] := create_pixmap(player_right_6, PICTURE_SCALE);
    player_right_pixmap[7] := create_pixmap(player_right_7, PICTURE_SCALE);
    player_right_pixmap[8] := create_pixmap(player_right_8, PICTURE_SCALE);
*)
    player_right_pixmap := 6 times PRIMITIVE_WINDOW.value;
    player_right_pixmap[1] := create_pixmap(player_right_1, PICTURE_SCALE);
    player_right_pixmap[2] := player_right_pixmap[1];
    player_right_pixmap[3] := player_right_pixmap[1];
    player_right_pixmap[4] := create_pixmap(player_right_2, PICTURE_SCALE);
    player_right_pixmap[5] := player_right_pixmap[4];
    player_right_pixmap[6] := player_right_pixmap[4];
    player_left_pixmap := 6 times PRIMITIVE_WINDOW.value;
    player_left_pixmap[1] := create_pixmap(player_left_1, PICTURE_SCALE);
    player_left_pixmap[2] := player_left_pixmap[1];
    player_left_pixmap[3] := player_left_pixmap[1];
    player_left_pixmap[4] := create_pixmap(player_left_2, PICTURE_SCALE);
    player_left_pixmap[5] := player_left_pixmap[4];
    player_left_pixmap[6] := player_left_pixmap[4];
    player_up_pixmap := 6 times PRIMITIVE_WINDOW.value;
    player_up_pixmap[1] := create_pixmap(player_up_down_1, PICTURE_SCALE);
    player_up_pixmap[2] := player_up_pixmap[1];
    player_up_pixmap[3] := player_up_pixmap[1];
    player_up_pixmap[4] := create_pixmap(player_up_down_2, PICTURE_SCALE);
    player_up_pixmap[5] := player_up_pixmap[4];
    player_up_pixmap[6] := player_up_pixmap[4];
    player_down_pixmap := 6 times PRIMITIVE_WINDOW.value;
    player_down_pixmap[1] := create_pixmap(player_up_down_1, PICTURE_SCALE);
    player_down_pixmap[2] := player_down_pixmap[1];
    player_down_pixmap[3] := player_down_pixmap[1];
    player_down_pixmap[4] := create_pixmap(player_up_down_2, PICTURE_SCALE);
    player_down_pixmap[5] := player_down_pixmap[4];
    player_down_pixmap[6] := player_down_pixmap[4];
    player_falling_pixmap := 1 times PRIMITIVE_WINDOW.value;
    player_falling_pixmap[1] := create_pixmap(player_falling, PICTURE_SCALE);
    player_dig_right_pixmap := 22 times PRIMITIVE_WINDOW.value;
    player_dig_right_pixmap[1] := create_pixmap(player_dig_right_1, PICTURE_SCALE);
    player_dig_right_pixmap[2] := player_dig_right_pixmap[1];
    player_dig_right_pixmap[3] := player_dig_right_pixmap[1];
    player_dig_right_pixmap[4] := player_dig_right_pixmap[1];
    player_dig_right_pixmap[5] := player_dig_right_pixmap[1];
    player_dig_right_pixmap[6] := player_dig_right_pixmap[1];
    player_dig_right_pixmap[7] := player_dig_right_pixmap[1];
    player_dig_right_pixmap[8] := player_dig_right_pixmap[1];
    player_dig_right_pixmap[9] := player_dig_right_pixmap[1];
    player_dig_right_pixmap[10] := player_dig_right_pixmap[1];
    player_dig_right_pixmap[11] := player_dig_right_pixmap[1];
    player_dig_right_pixmap[12] := create_pixmap(player_dig_right_2, PICTURE_SCALE);
    player_dig_right_pixmap[13] := player_dig_right_pixmap[12];
    player_dig_right_pixmap[14] := player_dig_right_pixmap[12];
    player_dig_right_pixmap[15] := player_dig_right_pixmap[12];
    player_dig_right_pixmap[16] := player_dig_right_pixmap[12];
    player_dig_right_pixmap[17] := player_dig_right_pixmap[12];
    player_dig_right_pixmap[18] := player_dig_right_pixmap[12];
    player_dig_right_pixmap[19] := player_dig_right_pixmap[12];
    player_dig_right_pixmap[20] := player_dig_right_pixmap[12];
    player_dig_right_pixmap[21] := player_dig_right_pixmap[12];
    player_dig_right_pixmap[22] := player_dig_right_pixmap[12];
    player_dig_left_pixmap := 22 times PRIMITIVE_WINDOW.value;
    player_dig_left_pixmap[1] := create_pixmap(player_dig_left_1, PICTURE_SCALE);
    player_dig_left_pixmap[2] := player_dig_left_pixmap[1];
    player_dig_left_pixmap[3] := player_dig_left_pixmap[1];
    player_dig_left_pixmap[4] := player_dig_left_pixmap[1];
    player_dig_left_pixmap[5] := player_dig_left_pixmap[1];
    player_dig_left_pixmap[6] := player_dig_left_pixmap[1];
    player_dig_left_pixmap[7] := player_dig_left_pixmap[1];
    player_dig_left_pixmap[8] := player_dig_left_pixmap[1];
    player_dig_left_pixmap[9] := player_dig_left_pixmap[1];
    player_dig_left_pixmap[10] := player_dig_left_pixmap[1];
    player_dig_left_pixmap[11] := player_dig_left_pixmap[1];
    player_dig_left_pixmap[12] := create_pixmap(player_dig_left_2, PICTURE_SCALE);
    player_dig_left_pixmap[13] := player_dig_left_pixmap[12];
    player_dig_left_pixmap[14] := player_dig_left_pixmap[12];
    player_dig_left_pixmap[15] := player_dig_left_pixmap[12];
    player_dig_left_pixmap[16] := player_dig_left_pixmap[12];
    player_dig_left_pixmap[17] := player_dig_left_pixmap[12];
    player_dig_left_pixmap[18] := player_dig_left_pixmap[12];
    player_dig_left_pixmap[19] := player_dig_left_pixmap[12];
    player_dig_left_pixmap[20] := player_dig_left_pixmap[12];
    player_dig_left_pixmap[21] := player_dig_left_pixmap[12];
    player_dig_left_pixmap[22] := player_dig_left_pixmap[12];
    digit_pixmap := [0](
      create_pixmap(zero,  PICTURE_SCALE),
      create_pixmap(one,   PICTURE_SCALE),
      create_pixmap(two,   PICTURE_SCALE),
      create_pixmap(three, PICTURE_SCALE),
      create_pixmap(four,  PICTURE_SCALE),
      create_pixmap(five,  PICTURE_SCALE),
      create_pixmap(six,   PICTURE_SCALE),
      create_pixmap(seven, PICTURE_SCALE),
      create_pixmap(eight, PICTURE_SCALE),
      create_pixmap(nine,  PICTURE_SCALE));
    player_reserve_pixmap := create_pixmap(player_reserve, PICTURE_SCALE);
    score_text_pixmap := create_pixmap(score_text, PICTURE_SCALE);
    bonus_text_pixmap := create_pixmap(bonus_text, PICTURE_SCALE);
    hiscore_text_pixmap := create_pixmap(hiscore_text, PICTURE_SCALE);
  end func;


const proc: pause_game is func
  local
    var time: pause_time is time.value;
    var duration: pause_duration is duration.value;
    var integer: number is 0;
    var char: cmd is ' ';
  begin
    pause_time := time(NOW);
    repeat
      cmd := getc(KEYBOARD);
      if cmd in {'Q', 'q'} then
        game.quit := TRUE;
      end if;
    until cmd in {'\e', 'P', 'p'} or game.quit;
    pause_duration := time(NOW) - pause_time;
    for number range 1 to length(monster) do
      if monster[number].action_time <> time.value then
        monster[number].action_time +:= pause_duration;
      end if;
    end for;
    if game.turn_time <> time.value then
      game.turn_time +:= pause_duration;
    end if;
  end func;


const proc: game_command (in char: cmd) is func
  begin
    case cmd of
      when {KEY_CTL_R}:
        game.round_finished := TRUE;
        game.restart := TRUE;
      when {'Q', 'q'}:
        game.quit := TRUE;
      when {'Y', 'y'}:
        writeln(heapsize(PROGRAM));
      when {'\e', 'P', 'p'}:
        pause_game;
    end case;
  end func;


const proc: draw_number (in integer: line, in integer: column, in string: num_stri) is func
  local
    var integer: index is 0;
    var char: ch is ' ';
  begin
    for index range 1 to length(num_stri) do
      ch := num_stri[index];
      if ch = ' ' then
        rect(succ((column + index - 2) * 7) * FIELD_ELEM_STEP,
            succ((pred(line) * 8 + 2)       * FIELD_ELEM_STEP),
            5                               * FIELD_ELEM_STEP,
            7                               * FIELD_ELEM_STEP,
            black);
      else
        put(succ((column + index - 2) * 7) * FIELD_ELEM_STEP,
            succ((pred(line) * 8 + 2)      * FIELD_ELEM_STEP),
            digit_pixmap[ord(ch) - ord('0')], PSET);
      end if;
    end for;
  end func;


const func PRIMITIVE_WINDOW: number_pixmap (in string: num_stri) is func
  result
    var PRIMITIVE_WINDOW: result is PRIMITIVE_WINDOW.value;
  local
    var integer: index is 0;
    var char: ch is ' ';
  begin
    result := newPixmap(
        (7 * length(num_stri) + 2) * PICTURE_SCALE,
        11                         * PICTURE_SCALE);
    clear(result, black);
    for index range 1 to length(num_stri) do
      ch := num_stri[index];
      if ch <> ' ' then
        put(result,
            (2 + pred(index) * 7) * PICTURE_SCALE,
            2                     * PICTURE_SCALE,
            digit_pixmap[ord(ch) - ord('0')], PSET);
      end if;
    end for;
  end func;


const proc: draw_level (in integer: line) is func
  local
    var integer: number is 0;
  begin
    rect(2            * FIELD_ELEM_STEP,
         (17 + line)  * FIELD_ELEM_STEP,
         5            * FIELD_ELEM_STEP,
         2            * FIELD_ELEM_STEP,
         light_green);
    number := 10;
    while number < AREA_COLUMNS do
      rect(number       * FIELD_ELEM_STEP,
           (17 + line)  * FIELD_ELEM_STEP,
           11           * FIELD_ELEM_STEP,
           2            * FIELD_ELEM_STEP,
           light_green);
      number +:= 14;
    end while;
    rect(number                   * FIELD_ELEM_STEP,
         (17 + line)              * FIELD_ELEM_STEP,
         WIN_WIDTH - (number + 2) * FIELD_ELEM_STEP,
         2                        * FIELD_ELEM_STEP,
         light_green);
    number := 2;
    while number < AREA_COLUMNS do
      rect(number        * FIELD_ELEM_STEP,
           (20 + line)   * FIELD_ELEM_STEP,
           11            * FIELD_ELEM_STEP,
           3             * FIELD_ELEM_STEP,
           light_green);
      number +:= 14;
    end while;
    rect(number                   * FIELD_ELEM_STEP,
         (20 + line)              * FIELD_ELEM_STEP,
         WIN_WIDTH - (number + 2) * FIELD_ELEM_STEP,
         3                        * FIELD_ELEM_STEP,
         light_green);
  end func;


const proc: draw_base_level (in integer: line) is func
  begin
    rect(2             * FIELD_ELEM_STEP,
         (17 + line)   * FIELD_ELEM_STEP,
         WIN_WIDTH - 4 * FIELD_ELEM_STEP,
         2             * FIELD_ELEM_STEP,
         orange);
  end func;


const proc: mark_level (in integer: line) is func
  local
    var integer: number is 0;
  begin
    for number range succ(FIELD_BORDER) to FIELD_COLUMNS - FIELD_BORDER do
      field[FIELD_BORDER + line][number] := TRUE;
    end for;
  end func;


const proc: draw_level_piece (in integer: line, in integer: column) is func
  local
    var integer: col1 is 0;
    var integer: col2 is 0;
    var integer: len1 is 0;
    var integer: len2 is 0;
  begin
    col1 := 6 + (column + 3) div 14 * 14;
    if col1 >= column then
      rect(column              * FIELD_ELEM_STEP,
           (16 + line)         * FIELD_ELEM_STEP,
           (col1 - column + 1) * FIELD_ELEM_STEP,
           2                   * FIELD_ELEM_STEP,
           light_green);
    end if;
    col2 := 10 + (column + 3) div 14 * 14;
    len2 := column + 13 - col2;
    if len2 > 11 then
      len2 := 11;
    end if;
    if col2 >= column (* and col2 + 13 <= column *) then
      rect(col2                 * FIELD_ELEM_STEP,
           (16 + line)          * FIELD_ELEM_STEP,
           len2                 * FIELD_ELEM_STEP,
           2                    * FIELD_ELEM_STEP,
           light_green);
    end if;
    col1 := -2 + (column + 11) div 14 * 14;
    if col1 >= column then
      rect(column              * FIELD_ELEM_STEP,
           (19 + line)         * FIELD_ELEM_STEP,
           (col1 - column + 1) * FIELD_ELEM_STEP,
           3                   * FIELD_ELEM_STEP,
           light_green);
    end if;
    col2 := 2 + (column + 11) div 14 * 14;
    len2 := column + 13 - col2;
    if len2 > 11 then
      len2 := 11;
    end if;
    if col2 >= column (* and col2 + 13 <= column *) then
      rect(col2                 * FIELD_ELEM_STEP,
           (19 + line)          * FIELD_ELEM_STEP,
           len2                 * FIELD_ELEM_STEP,
           3                    * FIELD_ELEM_STEP,
           light_green);
    end if;
  end func;


const proc: draw_hole (in integer: line, in integer: column,
    in holeType: curr_hole_status) is func
  begin
    draw_level_piece(line, column);
    case curr_hole_status of
      when {hole_depth1}:
        rect((2 + column) * FIELD_ELEM_STEP,
             (16 + line)  * FIELD_ELEM_STEP,
             9            * FIELD_ELEM_STEP,
             1            * FIELD_ELEM_STEP,
             black);
        rect((4 + column) * FIELD_ELEM_STEP,
             (17 + line)  * FIELD_ELEM_STEP,
             5            * FIELD_ELEM_STEP,
             1            * FIELD_ELEM_STEP,
             black);
      when {hole_depth2}:
        rect(column       * FIELD_ELEM_STEP,
             (16 + line)  * FIELD_ELEM_STEP,
             13           * FIELD_ELEM_STEP,
             1            * FIELD_ELEM_STEP,
             black);
        rect((2 + column) * FIELD_ELEM_STEP,
             (17 + line)  * FIELD_ELEM_STEP,
             9            * FIELD_ELEM_STEP,
             1            * FIELD_ELEM_STEP,
             black);
        rect((4 + column) * FIELD_ELEM_STEP,
             (18 + line)  * FIELD_ELEM_STEP,
             5            * FIELD_ELEM_STEP,
             1            * FIELD_ELEM_STEP,
             black);
      when {hole_depth3}:
        rect(column       * FIELD_ELEM_STEP,
             (16 + line)  * FIELD_ELEM_STEP,
             13           * FIELD_ELEM_STEP,
             2            * FIELD_ELEM_STEP,
             black);
        rect((2 + column) * FIELD_ELEM_STEP,
             (18 + line)  * FIELD_ELEM_STEP,
             9            * FIELD_ELEM_STEP,
             1            * FIELD_ELEM_STEP,
             black);
        rect((4 + column) * FIELD_ELEM_STEP,
             (19 + line)  * FIELD_ELEM_STEP,
             5            * FIELD_ELEM_STEP,
             1            * FIELD_ELEM_STEP,
             black);
      when {hole_depth4}:
        rect(column       * FIELD_ELEM_STEP,
             (16 + line)  * FIELD_ELEM_STEP,
             13           * FIELD_ELEM_STEP,
             3            * FIELD_ELEM_STEP,
             black);
        rect((2 + column) * FIELD_ELEM_STEP,
             (19 + line)  * FIELD_ELEM_STEP,
             9            * FIELD_ELEM_STEP,
             1            * FIELD_ELEM_STEP,
             black);
        rect((4 + column) * FIELD_ELEM_STEP,
             (20 + line)  * FIELD_ELEM_STEP,
             5            * FIELD_ELEM_STEP,
             1            * FIELD_ELEM_STEP,
             black);
      when {hole_finished}:
        rect(column       * FIELD_ELEM_STEP,
             (16 + line)  * FIELD_ELEM_STEP,
             13           * FIELD_ELEM_STEP,
             6            * FIELD_ELEM_STEP,
             black);
    end case;
  end func;


const proc: draw_ladder (in integer: line1, in integer: line2, in integer: column) is func
  local
    var integer: number is 0;
  begin
    rect((1 + column)        * FIELD_ELEM_STEP,
         (7 + line1)         * FIELD_ELEM_STEP,
         13                  * FIELD_ELEM_STEP,
         (line2- line1 + 10) * FIELD_ELEM_STEP,
         black);
    rect((1 + column)        * FIELD_ELEM_STEP,
         (7 + line1)         * FIELD_ELEM_STEP,
         1                   * FIELD_ELEM_STEP,
         (line2- line1 + 10) * FIELD_ELEM_STEP,
         light_magenta);
    rect((13 + column)       * FIELD_ELEM_STEP,
         (7 + line1)         * FIELD_ELEM_STEP,
         1                   * FIELD_ELEM_STEP,
         (line2- line1 + 10) * FIELD_ELEM_STEP,
         light_magenta);
    for number range line1 - 8 to line2 - 4 step 4 do
      rect((2 + column)  * FIELD_ELEM_STEP,
           (17 + number) * FIELD_ELEM_STEP,
           11            * FIELD_ELEM_STEP,
           2             * FIELD_ELEM_STEP,
           light_magenta);
    end for;
  end func;


const proc: mark_ladder (in integer: line1, in integer: line2,
    in integer: column) is func
  local
    var integer: number is 0;
  begin
    for number range line1 to line2 do
      field[FIELD_BORDER + number][FIELD_BORDER + column] := TRUE;
    end for;
  end func;


const proc: set_ladder (in integer: line1, in integer: line2,
    in integer: column) is func
  local
    var integer: number is 0;
  begin
    mark_ladder(line1, line2, column);
    draw_ladder(line1, line2, column);
  end func;


const proc: init_ladders (in ladderLayout: layout_descr) is func
  local
    var integer: number is 0;
  begin
    for number range 1 to length(layout_descr) do
      set_ladder(level_line[layout_descr[number][1]],
                 level_line[layout_descr[number][2]],
                 layout_descr[number][3]);
    end for;
  end func;


const proc: change_direction (inout screenObj: monster) is func
  local
    var integer: num_directions is 0;
    var integer: random_direction is 0;
  begin
    num_directions := 0;
    if field[pred(monster.line)][monster.column] then
      incr(num_directions);
    end if;
    if field[succ(monster.line)][monster.column] then
      incr(num_directions);
    end if;
    if field[monster.line][pred(monster.column)] then
      incr(num_directions);
    end if;
    if field[monster.line][succ(monster.column)] then
      incr(num_directions);
    end if;
    if num_directions >= 1 then
      random_direction := rand(1, num_directions);
      if field[pred(monster.line)][monster.column] then
        decr(random_direction);
        if random_direction = 0 then
          monster.line_direction := -SPEED;
          monster.column_direction := 0;
        end if;
      end if;
      if field[succ(monster.line)][monster.column] then
        decr(random_direction);
        if random_direction = 0 then
          monster.line_direction := SPEED;
          monster.column_direction := 0;
        end if;
      end if;
      if field[monster.line][pred(monster.column)] then
        decr(random_direction);
        if random_direction = 0 then
          monster.line_direction := 0;
          monster.column_direction := -SPEED;
        end if;
      end if;
      if field[monster.line][succ(monster.column)] then
        decr(random_direction);
        if random_direction = 0 then
          monster.line_direction := 0;
          monster.column_direction := SPEED;
        end if;
      end if;
    end if;
  end func;


const func boolean: collision (in screenObj: obj1, in screenObj: obj2) is func
  result
    var boolean: result is FALSE;
  begin
    if obj1.line + obj1.line_direction >= obj2.line - obj2.height and
        obj1.line - obj1.height + obj1.line_direction <= obj2.line and
        obj1.column + obj1.width + obj1.column_direction >= obj2.column and
        obj1.column + obj1.column_direction <= obj2.column + obj2.width then
      result := TRUE;
    end if;
  end func;


const func boolean: collision2 (in screenObj: obj1, in screenObj: obj2) is func
  result
    var boolean: result is FALSE;
  begin
    if obj1.line + obj1.line_direction > obj2.line - obj2.height + obj2.line_direction and
        obj1.line - obj1.height + obj1.line_direction < obj2.line + obj2.line_direction and
        obj1.column + obj1.width + obj1.column_direction > obj2.column + obj2.column_direction and
        obj1.column + obj1.column_direction < obj2.column + obj2.width + obj2.column_direction or
        obj1.line + obj1.line_direction > obj2.line - obj2.height and
        obj1.line - obj1.height + obj1.line_direction < obj2.line and
        obj1.column + obj1.width + obj1.column_direction > obj2.column and
        obj1.column + obj1.column_direction < obj2.column + obj2.width then
      result := TRUE;
    end if;
  end func;


const proc: avoid_monster_collision (inout screenObj: screenObject) is func
  local
    var integer: number is 0;
    var boolean: collision_found is FALSE;
  begin
    for number range 1 to length(monster) do
      if (screenObject.line <> monster[number].line or
          screenObject.column <> monster[number].column) and
          collision(screenObject, monster[number]) then
        if collision_found then
          if screenObject.column >= monster[number].column then
            if screenObject.column_direction < 0 then
              screenObject.column_direction := 0;
            end if;
          else
            if screenObject.column_direction > 0 then
              screenObject.column_direction := 0;
            end if;
          end if;
          if screenObject.line >= monster[number].line then
            if screenObject.line_direction < 0 then
              screenObject.line_direction := 0;
            end if;
          else
            if screenObject.line_direction > 0 then
              screenObject.line_direction := 0;
            end if;
          end if;
        else
          collision_found := TRUE;
          if screenObject.column_direction <> 0 then
            if screenObject.column >= monster[number].column then
              screenObject.column_direction := SPEED;
            else
              screenObject.column_direction := -SPEED;
            end if;
          elsif screenObject.line_direction <> 0 then
            if screenObject.line >= monster[number].line then
              screenObject.line_direction := SPEED;
            else
              screenObject.line_direction := -SPEED;
            end if;
          end if;
        end if;
      end if;
    end for;
  end func;


const proc: move (inout screenObj: screenObject) is func
  begin
    if screenObject.moving and screenObject.motionIndex = 0 then
      incr(screenObject.actual_pixmap_index);
      if screenObject.actual_pixmap_index > length(screenObject.pixmap) then
        screenObject.actual_pixmap_index := 1;
      end if;
      if screenObject.line_direction <> 0 or screenObject.column_direction <> 0 or
          width(screenObject.saved_pixmap) <> screenObject.width * PICTURE_SCALE then
        put(FIELD_X_START + screenObject.column * FIELD_ELEM_STEP,
            FIELD_Y_START + screenObject.line * FIELD_ELEM_STEP - screenObject.height * PICTURE_SCALE,
            screenObject.saved_pixmap, PSET);
        screenObject.line +:= screenObject.line_direction;
        screenObject.column +:= screenObject.column_direction;
        screenObject.saved_pixmap := getPixmap(
            FIELD_X_START + screenObject.column * FIELD_ELEM_STEP,
            FIELD_Y_START + screenObject.line * FIELD_ELEM_STEP - screenObject.height * PICTURE_SCALE,
            screenObject.width * PICTURE_SCALE,
            screenObject.height * PICTURE_SCALE);
      end if;
      put(FIELD_X_START + screenObject.column * FIELD_ELEM_STEP,
          FIELD_Y_START + screenObject.line * FIELD_ELEM_STEP - screenObject.height * PICTURE_SCALE,
          screenObject.pixmap[screenObject.actual_pixmap_index], PSET);
      screenObject.motionIndex := screenObject.motionSpeed;
    elsif screenObject.motionIndex > 0 then
      decr(screenObject.motionIndex);
    end if;
  end func;


const proc: visible (inout screenObj: screenObject) is func
  begin
    screenObject.saved_pixmap := getPixmap(
        FIELD_X_START + screenObject.column * FIELD_ELEM_STEP,
        FIELD_Y_START + screenObject.line * FIELD_ELEM_STEP - screenObject.height * PICTURE_SCALE,
        screenObject.width * PICTURE_SCALE,
        screenObject.height * PICTURE_SCALE);
    put(FIELD_X_START + screenObject.column * FIELD_ELEM_STEP,
        FIELD_Y_START + screenObject.line * FIELD_ELEM_STEP - screenObject.height * PICTURE_SCALE,
        screenObject.pixmap[screenObject.actual_pixmap_index], PSET);
  end func;


const proc: invisible (inout screenObj: screenObject) is func
  begin
    put(FIELD_X_START + screenObject.column * FIELD_ELEM_STEP,
        FIELD_Y_START + screenObject.line * FIELD_ELEM_STEP - screenObject.height * PICTURE_SCALE,
        screenObject.saved_pixmap, PSET);
  end func;


const proc: place (inout screenObj: screenObject,
    in integer: line, in integer: column) is func
  begin
    screenObject.line := line;
    screenObject.column := column;
    visible(screenObject);
  end func;


const proc: jump (inout screenObj: screenObject,
    in integer: line, in integer: column) is func
  begin
    invisible(screenObject);
    screenObject.line := line;
    screenObject.column := column;
    visible(screenObject);
  end func;


const proc: die (inout screenObj: screenObject) is func
  begin
    screenObject.moving := FALSE;
    screenObject.line := -100;
    screenObject.column := -100;
    decr(game.num_monsters);
    if game.num_monsters = 0 then
      game.round_finished := TRUE;
    end if;
  end func;


const proc: save_overlapping (inout screenObj: screenObject) is func
  local
    var integer: number is 0;
  begin
    for number range 1 to length(monster) do
      if (screenObject.line <> monster[number].line or
          screenObject.column <> monster[number].column) and
          collision(screenObject, monster[number]) then
        invisible(monster[number]);
      end if;
    end for;
    if collision(screenObject, player) then
      invisible(player);
    end if;
  end func;


const proc: restore_overlapping (inout screenObj: screenObject) is func
  local
    var integer: number is 0;
  begin
    for number range 1 to length(monster) do
      if (screenObject.line <> monster[number].line or
          screenObject.column <> monster[number].column) and
          collision(screenObject, monster[number]) then
        visible(monster[number]);
      end if;
    end for;
    if collision(screenObject, player) then
      visible(player);
    end if;
  end func;


const proc: redraw_hole (in integer: line, in integer: column, inout monsterObj: currObject) is func
  begin
    invisible(currObject);
    draw_hole(line, column, no_hole);
    visible(currObject);
  end func;


const proc: mark_hole (in integer: line, in integer: column,
    in holeType: curr_hole_status) is func
  local
    var integer: depth is 0;
  begin
    hole_status[line][column] := curr_hole_status;
    case curr_hole_status of
      when {no_hole}:
        for depth range 1 to TRAP_DEPTH do
          hole_status[line + depth][column] := no_hole;
        end for;
      when {hole_depth1}:
        hole_status[line + 1][column] := hole_part;
        hole_status[line + 2][column] := hole_unfinished;
      when {hole_depth2}:
        hole_status[line + 1][column] := hole_part;
        hole_status[line + 2][column] := hole_part;
        hole_status[line + 3][column] := hole_unfinished;
      when {hole_depth3}:
        hole_status[line + 1][column] := hole_part;
        hole_status[line + 2][column] := hole_part;
        hole_status[line + 3][column] := hole_part;
        hole_status[line + 4][column] := hole_unfinished;
      when {hole_depth4}:
        hole_status[line + 1][column] := hole_part;
        hole_status[line + 2][column] := hole_part;
        hole_status[line + 3][column] := hole_part;
        hole_status[line + 4][column] := hole_part;
        hole_status[line + 5][column] := hole_unfinished;
      when {hole_finished}:
        for depth range 1 to pred(TRAP_DEPTH) do
          hole_status[line + depth][column] := hole_part;
        end for;
        hole_status[line + TRAP_DEPTH][column] := hole_bottom;
    end case;
  end func;


const proc: fall_at_monsters (inout monsterObj: currObject) is func
  local
    var integer: number is 0;
    var boolean: collision_found is FALSE;
  begin
    for number range 1 to length(monster) do
      if (currObject.line <> monster[number].line or
          currObject.column <> monster[number].column) and
          collision(currObject, monster[number]) then
        if hole_status[monster[number].line - TRAP_DEPTH][monster[number].column] >= hole_filled then
          if monster[number].column = currObject.column then
            currObject.basePoints +:= 100 * monster[number].category;
            incr(currObject.holes_passed);
            invisible(monster[number]);
            die(monster[number]);
          else
            hole_status[monster[number].line - TRAP_DEPTH][monster[number].column] := hole_pounded;
            decr(currObject.line_direction);
          end if;
        else
          currObject.points +:= 100 * monster[number].category;
          invisible(monster[number]);
          die(monster[number]);
        end if;
      end if;
    end for;
  end func;


const proc: check_falling (inout monsterObj: currObject, in holeType: curr_hole_status) is func
  local
    var integer: number is 0;
  begin
    if field[currObject.line][currObject.column] and
        (curr_hole_status < hole_finished or curr_hole_status = hole_leaving) then
      if currObject.line_direction <> 0 then
        currObject.line_direction := 0;
        if curr_hole_status = hole_leaving then
          mark_hole(currObject.line, currObject.column, no_hole);
          draw_hole(currObject.line, currObject.column, no_hole);
        end if;
        currObject.action_time := time(NOW) + 100000 . MYCRO_SECONDS;
      elsif time(NOW) >= currObject.action_time then
        game.score +:= currObject.points;
        draw_number(24, 10, game.score lpad 6);
        if game.score > game.hiScore then
          game.hiScore := game.score;
          draw_number(24, 35, game.hiScore lpad 6);
        end if;
        if currObject.category <= currObject.holes_passed then
          invisible(currObject);
          currObject.pixmap := [](number_pixmap(str(currObject.points)));
          currObject.actual_pixmap_index := 1;
          currObject.height := height(currObject.pixmap[1]) div PICTURE_SCALE;
          currObject.width := width(currObject.pixmap[1]) div PICTURE_SCALE;
          currObject.line -:= 10;
          currObject.column -:= 6;
          save_overlapping(currObject);
          visible(currObject);
          restore_overlapping(currObject);
          currObject.action_time := time(NOW) + 1 . SECONDS;
        else
          currObject.falling := FALSE;
        end if;
        currObject.points := 0;
      end if;
    else
      if currObject.points > 0 then
        currObject.line_direction := 1;
        while currObject.line_direction <= FALL_SPEED and
            currObject.line + currObject.line_direction <= length(field) and
            not field[currObject.line + currObject.line_direction][currObject.column] do
          incr(currObject.line_direction);
        end while;
        fall_at_monsters(currObject);
        for number range 1 to currObject.line_direction do
          if hole_status[currObject.line - number][currObject.column] = hole_finished or
              hole_status[currObject.line - number][currObject.column] = hole_entering or
              hole_status[currObject.line - number][currObject.column] >= hole_filled then
            mark_hole(currObject.line - number, currObject.column, no_hole);
            redraw_hole(currObject.line - number, currObject.column, currObject);
            incr(currObject.holes_passed);
            currObject.points +:= currObject.basePoints;
          end if;
        end for;
      elsif time(NOW) >= currObject.action_time then
        save_overlapping(currObject);
        invisible(currObject);
        restore_overlapping(currObject);
        die(currObject);
      end if;
    end if;
  end func;


const proc: set_direction (inout monsterObj: currObject,
    in integer: line, in integer: column) is func
  begin
    if abs(currObject.line - line) >= abs(currObject.column - column) then
      if currObject.line < line then
        currObject.line_direction := 1;
      elsif currObject.line = line then
        currObject.line_direction := 0;
      else
        currObject.line_direction := -1;
      end if;
      if abs(currObject.line - line) > abs(currObject.column - column) then
        currObject.column_direction := 0;
      end if;
    elsif abs(currObject.line - line) <= abs(currObject.column - column) then
      if currObject.column < column then
        currObject.column_direction := 1;
      elsif currObject.column = column then
        currObject.column_direction := 0;
      else
        currObject.column_direction := -1;
      end if;
      if abs(currObject.line - line) < abs(currObject.column - column) then
        currObject.line_direction := 0;
      end if;
    end if;
  end func;


const proc: player_collision (inout monsterObj: currObject) is func
  begin
    if player.living then
      player.line_direction := 0;
      player.column_direction := 0;
      player.moving := FALSE;
      player.motionSpeed := CATCH_MOTION;
      player.living := FALSE;
      player.command := ' ';
      currObject.catching := TRUE;
      set_direction(currObject, player.line - 6, player.column);
    elsif currObject.catching then
      if currObject.line_direction <> 0 or currObject.column_direction <> 0 then
        if currObject.line <> player.line - 6 or currObject.column <> player.column then
          set_direction(currObject, player.line - 6, player.column);
        else
          currObject.line_direction := 0;
          currObject.column_direction := 0;
          if game.num_players > 1 then
            currObject.action_time := time(NOW) + 5 . SECONDS;
          else
            currObject.action_time := time.value;
          end if;
        end if;
      elsif currObject.action_time <> time.value and
          time(NOW) >= currObject.action_time then
        game.round_finished := TRUE;
      end if;
    else
      if currObject.column_direction <> 0 then
        if currObject.column >= player.column then
          currObject.column_direction := SPEED;
        else
          currObject.column_direction := -SPEED;
        end if;
      elsif currObject.line_direction <> 0 then
        if currObject.line >= player.line then
          currObject.line_direction := SPEED;
        else
          currObject.line_direction := -SPEED;
        end if;
      end if;
    end if;
  end func;


const proc: check_hole (inout monsterObj: currObject, in holeType: curr_hole_status) is func
  local
    var integer: number is 0;
  begin
    if curr_hole_status < hole_finished then
      currObject.saved_column_direction := currObject.column_direction;
      currObject.line_direction := SPEED;
      currObject.column_direction := 0;
    elsif curr_hole_status = hole_finished then
      currObject.saved_column_direction := currObject.column_direction;
      currObject.column_direction := 0;
      if collision2(currObject, player) then
        player_collision(currObject);
      else
        currObject.line_direction := SPEED;
        hole_status[currObject.line][currObject.column] := hole_entering;
      end if;
    elsif curr_hole_status = hole_leaving then
      currObject.line_direction := 0;
      currObject.column_direction := currObject.saved_column_direction;
      currObject.motionSpeed := FULL_MOTION;
      mark_hole(currObject.line, currObject.column, no_hole);
    elsif curr_hole_status = hole_part then
      noop;
    elsif curr_hole_status = hole_unfinished then
      for number range 1 to TRAP_DEPTH do
        if currObject.line - number >= 1 and
            hole_status[currObject.line - number][currObject.column] in
            {hole_depth1, hole_depth2, hole_depth3, hole_depth4} then
          hole_status[currObject.line - number][currObject.column] := hole_leaving;
          redraw_hole(currObject.line - number, currObject.column, currObject);
        end if;
      end for;
      currObject.line_direction := -SPEED;
      currObject.motionSpeed := LEAVE_MOTION;
    elsif curr_hole_status = hole_bottom then
      if currObject.line_direction <> 0 then
        currObject.line_direction := 0;
        currObject.column_direction := 0;
        currObject.action_time := time(NOW) + TIME_IN_HOLE;
        hole_status[currObject.line - TRAP_DEPTH][currObject.column] := hole_filled;
      elsif hole_status[currObject.line - TRAP_DEPTH][currObject.column] = hole_pounded then
        mark_hole(currObject.line - TRAP_DEPTH, currObject.column, no_hole);
        redraw_hole(currObject.line - TRAP_DEPTH, currObject.column, currObject);
        currObject.line_direction := FALL_SPEED;
        currObject.falling := TRUE;
        currObject.holes_passed := 1;
        currObject.basePoints := 100 * currObject.category;
        currObject.points := currObject.basePoints;
      else
        if time(NOW) >= currObject.action_time then
          hole_status[currObject.line - TRAP_DEPTH][currObject.column] := hole_leaving;
          redraw_hole(currObject.line - TRAP_DEPTH, currObject.column, currObject);
          currObject.line_direction := -SPEED;
          currObject.motionSpeed := LEAVE_MOTION;
          if player.falling and collision2(currObject, player) then
            player_collision(currObject);
          end if;
        end if;
      end if;
    end if;
  end func;


const proc: check_direction (inout monsterObj: currObject) is func
  local
    var holeType: curr_hole_status is no_hole;
    var integer: number is 0;
  begin
    if currObject.moving then
      if currObject.line >= 1 then
        curr_hole_status := hole_status[currObject.line][currObject.column];
      end if;
      if currObject.catching then
        player_collision(currObject);
      elsif currObject.falling then
        check_falling(currObject, curr_hole_status);
      elsif curr_hole_status <> no_hole then
        check_hole(currObject, curr_hole_status);
      elsif collision2(currObject, player) then
        player_collision(currObject);
      elsif currObject.column_direction <> 0 then
        if field[pred(currObject.line)][currObject.column] or
            field[succ(currObject.line)][currObject.column] then
          change_direction(currObject);
        elsif not field[currObject.line]
            [currObject.column + currObject.column_direction] then
          currObject.column_direction := -currObject.column_direction;
        else
          avoid_monster_collision(currObject);
        end if;
      elsif currObject.line_direction <> 0 then
        if field[currObject.line][pred(currObject.column)] or
            field[currObject.line][succ(currObject.column)] then
          change_direction(currObject);
        elsif not field[currObject.line + currObject.line_direction]
            [currObject.column] then
          currObject.line_direction := -currObject.line_direction;
        else
          avoid_monster_collision(currObject);
        end if;
      else
        change_direction(currObject);
        check_direction(currObject);
      end if;
    end if;
  end func;


const proc: place_monster (inout screenObj: screenObject,
    in integer: number, in integer: line) is func
  local
    var boolean: place_is_ok is FALSE;
    var integer: num is 0;
  begin
    screenObject.line := FIELD_BORDER + line;
    repeat
      screenObject.column := rand(succ(FIELD_BORDER), FIELD_COLUMNS - FIELD_BORDER) div SPEED * SPEED;
      place_is_ok := TRUE;
      for num range 1 to pred(number) do
        if collision(screenObject, monster[num]) then
          place_is_ok := FALSE;
        end if;
      end for;
    until place_is_ok;
    place(screenObject, FIELD_BORDER + line, screenObject.column);
  end func;


const proc: draw_reserve (in var integer: num_players) is func
  local
    var integer: number is 0;
  begin
    if num_players > 5 then
      num_players := 5;
    end if;
    for number range 1 to num_players do
      put((number * 7 - 6) * FIELD_ELEM_STEP,
          succ(186         * FIELD_ELEM_STEP),
          player_reserve_pixmap, PSET);
    end for;
    for number range succ(num_players) to 4 do
      rect((number * 7 - 6) * FIELD_ELEM_STEP,
          succ(186          * FIELD_ELEM_STEP),
          7                 * FIELD_ELEM_STEP,
          8                 * FIELD_ELEM_STEP,
          black);
    end for;
  end func;


const proc: init_round (in integer: num_round) is func
  local
    var time: start_time is time.value;
    var integer: number is 0;
    var char: cmd is ' ';
  begin
    start_time := time(NOW);
    game.round_finished := FALSE;
    field := FIELD_LINES times FIELD_COLUMNS times FALSE;
    hole_status := FIELD_LINES times FIELD_COLUMNS times no_hole;
    for number range 1 to pred(NUM_LEVELS) do
      mark_level(level_line[number]);
      draw_level(level_line[number]);
    end for;
    mark_level(level_line[NUM_LEVELS]);
    draw_base_level(level_line[NUM_LEVELS]);
    init_ladders(layout_description[rand(1, 4)]);
    rect(1   * FIELD_ELEM_STEP,
         182 * FIELD_ELEM_STEP,
         223 * FIELD_ELEM_STEP,
         3   * FIELD_ELEM_STEP,
         light_blue);
    rect(226 * FIELD_ELEM_STEP,
         182 * FIELD_ELEM_STEP,
         41  * FIELD_ELEM_STEP,
         3   * FIELD_ELEM_STEP,
         orange);
    draw_reserve(game.num_players);
    put(succ(6 * 7) * FIELD_ELEM_STEP,
        succ(186    * FIELD_ELEM_STEP),
        score_text_pixmap, PSET);
    if game.score <> 0 then
      draw_number(24, 10, game.score lpad 6);
    end if;
    game.round_bonus := round_description[num_round][4];
    put(succ(17 * 7) * FIELD_ELEM_STEP,
        succ(186    * FIELD_ELEM_STEP),
        bonus_text_pixmap, PSET);
    draw_number(24, 24, game.round_bonus lpad 4);
    put(succ(31 * 7) * FIELD_ELEM_STEP,
        succ(186    * FIELD_ELEM_STEP),
        hiscore_text_pixmap, PSET);
    if game.hiScore <> 0 then
      draw_number(24, 35, game.hiScore lpad 6);
    end if;
    game.num_monsters := round_description[num_round][1] +
      round_description[num_round][2] +
      round_description[num_round][3];
    monster := game.num_monsters times monsterObj.value;
    for number range 1 to game.num_monsters do
      if number <= round_description[num_round][1] then
        monster[number].pixmap := monster_pixmap[1];
        monster[number].category := 1;
      elsif number <= round_description[num_round][1] + round_description[num_round][2] then
        monster[number].pixmap := monster_pixmap[2];
        monster[number].category := 2;
      else
        monster[number].pixmap := monster_pixmap[3];
        monster[number].category := 3;
      end if;
      monster[number].actual_pixmap_index := rand(1, length(monster[number].pixmap));
      monster[number].height := height(monster[number].pixmap[1]) div PICTURE_SCALE;
      monster[number].width := width(monster[number].pixmap[1]) div PICTURE_SCALE;
    end for;
    DRAW_FLUSH;
    game_command(busy_getc(KEYBOARD));
    if not game.round_finished and not game.quit then
      await(start_time + 500000 . MYCRO_SECONDS);
    end if;
    number := 1;
    while number <= game.num_monsters and not game.round_finished and not game.quit do
      start_time := time(NOW);
      place_monster(monster[number], number, level_line[rand(1, pred(NUM_LEVELS))]);
      change_direction(monster[number]);
      incr(number);
      DRAW_FLUSH;
      game_command(busy_getc(KEYBOARD));
      if not game.round_finished and not game.quit then
        await(start_time + 500000 . MYCRO_SECONDS);
      end if;
    end while;
    if not game.round_finished and not game.quit then
      draw_reserve(pred(game.num_players));
      player := playerObj.value;
      player.moving := FALSE;
      player.pixmap := player_right_pixmap;
      player.actual_pixmap_index := 1;
      player.height := height(player.pixmap[1]) div PICTURE_SCALE;
      player.width := width(player.pixmap[1]) div PICTURE_SCALE;
      place(player, FIELD_BORDER + level_line[length(level_line)], 136 div SPEED * SPEED);
    end if;
  end func;


const proc: dig_hole (inout playerObj: playerObject,
    in integer: line, in integer: column) is func
  local
    var holeType: curr_hole_status is no_hole;
  begin
    curr_hole_status := hole_status[line][column];
    if curr_hole_status >= hole_finished then
      playerObject.command := ' ';
    elsif curr_hole_status < hole_finished then
      incr(curr_hole_status);
      mark_hole(line, column, curr_hole_status);
      draw_hole(line, column, curr_hole_status);
      if curr_hole_status = hole_finished then
        playerObject.command := ' ';
      end if;
    end if;
  end func;


const proc: shut_hole (inout playerObj: playerObject,
    in integer: line, in integer: column) is func
  local
    var holeType: curr_hole_status is no_hole;
  begin
    curr_hole_status := hole_status[line][column];
    if curr_hole_status = no_hole then
      playerObject.command := ' ';
    elsif curr_hole_status <= hole_finished then
      decr(curr_hole_status);
      mark_hole(line, column, curr_hole_status);
      draw_hole(line, column, curr_hole_status);
      if curr_hole_status = no_hole then
        playerObject.command := ' ';
      end if;
    elsif curr_hole_status >= hole_filled and curr_hole_status < hole_pounded then
      incr(curr_hole_status);
      hole_status[line][column] := curr_hole_status;
      if curr_hole_status = hole_pounded then
        playerObject.command := ' ';
      end if;
    end if;
  end func;


const proc: do_dig (inout playerObj: playerObject) is func
  begin
    if playerObject.digging and playerObject.actual_pixmap_index = 1 then
      if playerObject.dig_direction > 0 then
        if playerObject.face_direction < 0 then
          dig_hole(playerObject, playerObject.line, playerObject.column - 13);
        else
          dig_hole(playerObject, playerObject.line, playerObject.column + 13);
        end if;
      else
        if playerObject.face_direction < 0 then
          shut_hole(playerObject, playerObject.line, playerObject.column - 13);
        else
          shut_hole(playerObject, playerObject.line, playerObject.column + 13);
        end if;
      end if;
    end if;
  end func;


const func boolean: hole_position_ok (in integer: line, in integer: column) is func
  result
    var boolean: result is TRUE;
  local
    var integer: col is 0;
  begin
    if line = FIELD_BORDER + level_line[NUM_LEVELS] then
      result := FALSE;
    elsif column - 2 < 1 or column + 2 > length(field[line]) then
      result := FALSE;
    elsif hole_status[line][column] = no_hole then
      for col range column - 14 to column + 14 do
        if col >= 1 and col <= length(field[line]) and
            (field[pred(line)][col] or
            field[succ(line)][col] or
            hole_status[line][col] <> no_hole) then
          result := FALSE;
        end if;
      end for;
    end if;
    if column rem 4 <> 0 then
      result := FALSE;
    end if;
  end func;


const func integer: ladder_up_direction (inout playerObj: playerObject) is func
  result
    var integer: result is 0;
  local
    var integer: col is 0;
  begin
    for col range playerObject.column - 12 to playerObject.column - 1 do
      if col >= 1 and col <= length(field[playerObject.line]) and
          field[pred(playerObject.line)][col] then
        result := -1;
      end if;
    end for;
    for col range playerObject.column + 1 to playerObject.column + 13 do
      if col >= 1 and col <= length(field[playerObject.line]) and
          field[pred(playerObject.line)][col] then
        result := 1;
      end if;
    end for;
  end func;


const func integer: ladder_down_direction (inout playerObj: playerObject) is func
  result
    var integer: result is 0;
  local
    var integer: col is 0;
  begin
    for col range playerObject.column - 12 to playerObject.column - 1 do
      if col >= 1 and col <= length(field[playerObject.line]) and
          field[succ(playerObject.line)][col] then
        result := -1;
      end if;
    end for;
    for col range playerObject.column + 1 to playerObject.column + 13 do
      if col >= 1 and col <= length(field[playerObject.line]) and
          field[succ(playerObject.line)][col] then
        result := 1;
      end if;
    end for;
  end func;


const func integer: level_direction (inout playerObj: playerObject) is func
  result
    var integer: result is 0;
  local
    var integer: lin is 0;
  begin
    for lin range playerObject.line - 15 to playerObject.line - 1 do
      if lin >= 1 and lin <= length(field) and
          field[lin][succ(playerObject.column)] then
        result := -1;
      end if;
    end for;
    for lin range playerObject.line + 1 to playerObject.line + 6 do
      if lin >= 1 and lin <= length(field) and
          field[lin][succ(playerObject.column)] then
        result := 1;
      end if;
    end for;
  end func;


const func integer: hole_direction (inout playerObj: playerObject) is func
  result
    var integer: result is 0;
  local
    var integer: col is 0;
  begin
    for col range playerObject.column - 14 downto playerObject.column - 20 do
      if col >= 1 and col <= length(hole_status[playerObject.line]) and
          hole_status[playerObject.line][col] <> no_hole then
        result := -1;
      end if;
    end for;
    for col range playerObject.column + 14 to playerObject.column + 20 do
      if col >= 1 and col <= length(hole_status[playerObject.line]) and
          hole_status[playerObject.line][col] <> no_hole then
        result := 1;
      end if;
    end for;
  end func;


const proc: stop (inout playerObj: playerObject) is func
  begin
    playerObject.line_direction := 0;
    playerObject.column_direction := 0;
    playerObject.moving := FALSE;
    playerObject.digging := FALSE;
  end func;


const proc: left (inout playerObj: playerObject) is func
  begin
    if playerObject.column_direction <> -SPEED then
      playerObject.line_direction := 0;
      playerObject.column_direction := -SPEED;
      playerObject.face_direction := -1;
      playerObject.moving := TRUE;
      playerObject.digging := FALSE;
      playerObject.actual_pixmap_index := 1;
      playerObject.pixmap := player_left_pixmap;
      playerObject.width := 14;
    end if;
  end func;


const proc: right (inout playerObj: playerObject) is func
  begin
    if playerObject.column_direction <> SPEED then
      playerObject.line_direction := 0;
      playerObject.column_direction := SPEED;
      playerObject.face_direction := 1;
      playerObject.moving := TRUE;
      playerObject.digging := FALSE;
      playerObject.actual_pixmap_index := 1;
      playerObject.pixmap := player_right_pixmap;
      playerObject.width := 14;
    end if;
  end func;


const proc: up (inout playerObj: playerObject) is func
  begin
    if playerObject.line_direction <> -SPEED then
      playerObject.line_direction := -SPEED;
      playerObject.column_direction := 0;
      playerObject.face_direction := 0;
      playerObject.moving := TRUE;
      playerObject.digging := FALSE;
      playerObject.actual_pixmap_index := 1;
      playerObject.pixmap := player_up_pixmap;
      playerObject.width := 13;
    end if;
  end func;


const proc: down (inout playerObj: playerObject) is func
  begin
    if playerObject.line_direction <> SPEED then
      playerObject.line_direction := SPEED;
      playerObject.column_direction := 0;
      playerObject.face_direction := 0;
      playerObject.moving := TRUE;
      playerObject.digging := FALSE;
      playerObject.actual_pixmap_index := 1;
      playerObject.pixmap := player_down_pixmap;
      playerObject.width := 13;
    end if;
  end func;


const proc: dig_left (inout playerObj: playerObject) is func
  begin
    if not playerObject.digging or playerObject.dig_direction <> 1 then
      playerObject.line_direction := 0;
      playerObject.column_direction := 0;
      playerObject.moving := TRUE;
      playerObject.digging := TRUE;
      playerObject.dig_direction := 1;
      playerObject.actual_pixmap_index := 1;
      playerObject.pixmap := player_dig_left_pixmap;
      playerObject.width := 13;
    end if;
  end func;


const proc: dig_right (inout playerObj: playerObject) is func
  begin
    if not playerObject.digging or playerObject.dig_direction <> 1 then
      playerObject.line_direction := 0;
      playerObject.column_direction := 0;
      playerObject.moving := TRUE;
      playerObject.digging := TRUE;
      playerObject.dig_direction := 1;
      playerObject.actual_pixmap_index := 1;
      playerObject.pixmap := player_dig_right_pixmap;
      playerObject.width := 13;
    end if;
  end func;


const proc: shut_left (inout playerObj: playerObject) is func
  begin
    if not playerObject.digging or playerObject.dig_direction <> -1 then
      playerObject.line_direction := 0;
      playerObject.column_direction := 0;
      playerObject.moving := TRUE;
      playerObject.digging := TRUE;
      playerObject.dig_direction := -1;
      playerObject.actual_pixmap_index := 1;
      playerObject.pixmap := player_dig_left_pixmap;
      playerObject.width := 13;
    end if;
  end func;


const proc: shut_right (inout playerObj: playerObject) is func
  begin
    if not playerObject.digging or playerObject.dig_direction <> -1 then
      playerObject.line_direction := 0;
      playerObject.column_direction := 0;
      playerObject.moving := TRUE;
      playerObject.digging := TRUE;
      playerObject.dig_direction := -1;
      playerObject.actual_pixmap_index := 1;
      playerObject.pixmap := player_dig_right_pixmap;
      playerObject.width := 13;
    end if;
  end func;


const proc: go_horizontally (inout playerObj: playerObject, in integer: direction) is func
  begin
    if direction = -1 then
      left(playerObject);
    elsif direction = 1 then
      right(playerObject);
    end if;
  end func;


const proc: go_vertically (inout playerObj: playerObject, in integer: direction) is func
  begin
    if direction = -1 then
      up(playerObject);
    elsif direction = 1 then
      down(playerObject);
    end if;
  end func;


const proc: player_falling (inout playerObj: playerObject) is func
  local
    var integer: number is 0;
  begin
    if field[playerObject.line][playerObject.column] and
        hole_status[playerObject.line][playerObject.column] <= hole_depth4 then
      playerObject.line_direction := 0;
      playerObject.falling := FALSE;
    else
      playerObject.line_direction := SPEED;
      for number range 1 to length(monster) do
        if collision2(monster[number], playerObject) then
          playerObject.line_direction := 0;
          if monster[number].line_direction = 0 and
              monster[number].column_direction = 0 then
            if playerObject.command = KEY_LEFT then
              if pred(playerObject.column) >= succ(FIELD_BORDER) then
                left(playerObject);
              else
                stop(playerObject);
              end if;
            elsif playerObject.command = KEY_RIGHT then
              if succ(playerObject.column) <= FIELD_COLUMNS - FIELD_BORDER then
                right(playerObject);
              else
                stop(playerObject);
              end if;
            elsif playerObject.command = ' ' then
              stop(playerObject);
            end if;
          end if;
        end if;
      end for;
    end if;
  end func;


const proc: process_command (inout playerObj: playerObject) is func
  begin
    if playerObject.command = KEY_UP then
      if field[pred(playerObject.line)][playerObject.column] then
        up(playerObject);
      elsif playerObject.column_direction = 0 then
        go_horizontally(playerObject, ladder_up_direction(playerObject));
      end if
    elsif playerObject.command = KEY_DOWN then
      if field[succ(playerObject.line)][playerObject.column] then
        down(playerObject);
      elsif playerObject.column_direction = 0 then
        go_horizontally(playerObject, ladder_down_direction(playerObject));
      end if;
    elsif playerObject.command = KEY_LEFT then
      if field[playerObject.line][pred(playerObject.column)] then
        left(playerObject);
      elsif playerObject.line_direction = 0 then
        go_vertically(playerObject, level_direction(playerObject));
      end if;
    elsif playerObject.command = KEY_RIGHT then
      if field[playerObject.line][succ(playerObject.column)] then
        right(playerObject);
      elsif playerObject.line_direction = 0 then
        go_vertically(playerObject, level_direction(playerObject));
      end if;
    elsif playerObject.command = 'A' then
      if playerObject.face_direction < 0 and
          hole_position_ok(playerObject.line, playerObject.column - 13) then
        dig_left(playerObject);
      elsif playerObject.face_direction > 0 and
          hole_position_ok(playerObject.line, playerObject.column + 13) then
        dig_right(playerObject);
      elsif playerObject.column_direction = 0 and
          playerObject.line <> FIELD_BORDER + level_line[NUM_LEVELS] then
        go_horizontally(playerObject, playerObject.face_direction);
      end if;
    elsif playerObject.command = 'S' then
      if playerObject.face_direction < 0 and
          playerObject.column > 13 and
          hole_status[playerObject.line][playerObject.column - 13] <> no_hole then
        shut_left(playerObject);
      elsif playerObject.face_direction > 0 and
          playerObject.column + 13 <= length(hole_status[playerObject.line]) and
          hole_status[playerObject.line][playerObject.column + 13] <> no_hole then
        shut_right(playerObject);
      elsif playerObject.column_direction = 0 and
          playerObject.face_direction = hole_direction(playerObject) then
        go_horizontally(playerObject, playerObject.face_direction);
      end if;
    elsif playerObject.command = ' ' then
      stop(playerObject);
    end if;
  end func;


const proc: stop_at_hole (inout playerObj: playerObject) is func
  begin
    if playerObject.command not in {'A', 'S'} then
      if playerObject.face_direction < 0 then
        if playerObject.column > 13 and
            hole_status[playerObject.line][playerObject.column - 13] not in
            {no_hole, hole_finished} then
          playerObject.moving := FALSE;
          playerObject.column_direction := 0;
        end if;
      elsif playerObject.face_direction > 0 then
        if playerObject.column + 13 <= length(hole_status[playerObject.line]) and
            hole_status[playerObject.line][playerObject.column + 13] not in
            {no_hole, hole_finished} then
          playerObject.moving := FALSE;
          playerObject.column_direction := 0;
          if player.width > 13 then
            player.width := 13;
          end if;
        elsif player.width > 13 and
            playerObject.column +  player.width <= length(hole_status[playerObject.line]) and
            hole_status[playerObject.line][playerObject.column +  player.width] not in
            {no_hole, hole_finished} then
          playerObject.moving := FALSE;
          playerObject.column_direction := 0;
        end if;
      end if;
    end if;
  end func;


const proc: process (inout playerObj: playerObject) is func
  begin
    if playerObject.falling then
      player_falling(playerObject);
    elsif hole_status[playerObject.line][playerObject.column] = hole_finished then
      playerObject.line_direction := SPEED;
      playerObject.column_direction := 0;
      playerObject.falling := TRUE;
      playerObject.face_direction := 0;
      playerObject.pixmap := player_falling_pixmap
    else
      process_command(playerObject);
      stop_at_hole(playerObject);
      if not field[playerObject.line][playerObject.column + playerObject.column_direction] then
        playerObject.moving := FALSE;
        playerObject.column_direction := 0;
      end if;
      if not field[playerObject.line + playerObject.line_direction][playerObject.column] then
        playerObject.moving := FALSE;
        playerObject.line_direction := 0;
      end if;
    end if;
  end func;


const proc: get_command (inout playerObj: playerObject) is func
  local
    var char: cmd is ' ';
  begin
    cmd := busy_getc(KEYBOARD);
    if playerObject.living then
      case cmd of
        when {KEY_LEFT, 'J', 'j'}:
          playerObject.command := KEY_LEFT;
        when {KEY_RIGHT, 'K', 'k'}:
          playerObject.command := KEY_RIGHT;
        when {KEY_UP, 'I', 'i'}:
          playerObject.command := KEY_UP;
        when {KEY_DOWN, 'M', 'm'}:
          playerObject.command := KEY_DOWN;
        when {'A', 'a'}:
          playerObject.command := 'A';
        when {'S', 's'}:
          playerObject.command := 'S';
        when {' '}:
          playerObject.command := ' ';
      end case;
    elsif cmd in {'S', 's'} then
      game.round_finished := TRUE;
    end if;
    game_command(cmd);
  end func;


const proc: game_round is func
  local
    var integer: number is 0;
    var integer: progress is 0;
    var integer: new_bonus is 0;
    var integer: bonus is 0;
  begin
    clear(curr_win, black);
    DRAW_FLUSH;
    init_round(game.round_number);
    bonus := game.round_bonus;
    game.turn_time := time(NOW);
    while not game.round_finished and not game.quit do
      for number range 1 to length(monster) do
        check_direction(monster[number]);
        move(monster[number]);
      end for;
      DRAW_FLUSH;
      get_command(player);
      if not game.round_finished and not game.quit then
        process(player);
        move(player);
        do_dig(player);
        rect(1             * FIELD_ELEM_STEP,
           182             * FIELD_ELEM_STEP,
           progress div 62 * FIELD_ELEM_STEP,
           3               * FIELD_ELEM_STEP,
           black);
        new_bonus := (game.round_bonus + 19 - progress div 7) div 20 * 20;
        if bonus <> new_bonus then
          bonus := new_bonus;
          if bonus > 0 then
            draw_number(24, 24, bonus lpad 4);
          elsif bonus = 0 then
            draw_number(24, 24, "    ");
          end if;
        end if;
        if progress div 62 = 266 then
          game.round_finished := TRUE;
        end if;
        incr(progress);
        game.turn_time +:= 30000 . MYCRO_SECONDS;
        DRAW_FLUSH;
        await(game.turn_time);
      end if;
    end while;
    if player.living and game.num_monsters = 0 then
      game.score +:= bonus;
      draw_number(24, 10, game.score lpad 6);
      if game.score > game.hiScore then
        game.hiScore := game.score;
        draw_number(24, 35, game.hiScore lpad 6);
      end if;
    end if;
  end func;


const proc: play_game is func
  begin
    game.num_players := 3;
    game.round_number := 1;
    game.score := 0;
    game.restart := FALSE;
    game_command(busy_getc(KEYBOARD));
    while not game.quit and not game.restart and game.num_players <> 0 do
      game_round;
      if not game.quit and not player.living then
        decr(game.num_players);
      elsif game.num_monsters = 0 then
        incr(game.round_number);
        game.num_players +:= round_description[game.round_number][5];
      end if;
    end while;
  end func;


const proc: main is func
  begin
    screen(WIN_WIDTH, WIN_HEIGHT);
    clear(curr_win, black);
    KEYBOARD := GRAPH_KEYBOARD;
    scr := open(curr_win);
    setPos(scr, 2, 44);
    writeln(scr, "P A N I C");
    setPos(scr, 5, 29);
    writeln(scr, "Copyright (C) 2004, 2005  Thomas Mertes");
    setPos(scr, 7, 29);
    writeln(scr, "This program is free software under the");
    setPos(scr, 8, 29);
    writeln(scr, "terms of the GNU General Public License");
    setPos(scr, 10, 24);
    writeln(scr, "Panic is written in the Seed7 programming language");
    setPos(scr, 11, 28);
    writeln(scr, "Homepage:    http://seed7.sourceforge.net");
    setPos(scr, 16, 14);
    writeln(scr, "Dig holes and pound the apples through the holes");
    setPos(scr, 18, 14);
    writeln(scr, "cursor keys: Move your man");
    setPos(scr, 19, 14);
    writeln(scr, "space:       Stop moving");
    setPos(scr, 20, 14);
    writeln(scr, "A:           Dig hole");
    setPos(scr, 21, 14);
    writeln(scr, "S:           Pound apples, shut hole and");
    setPos(scr, 22, 14);
    writeln(scr, "             play aggain when the game is over");
    setPos(scr, 23, 14);
    writeln(scr, "ESC or P:    Pause game");
    setPos(scr, 24, 14);
    writeln(scr, "ctrl-R:      Restart game");
    setPos(scr, 25, 14);
    writeln(scr, "Q:           Quit game");
    setPos(scr, 29, 35);
    writeln(scr, "     Wait for a moment     ");
    draw_level(level_line[1]);
    draw_level(level_line[3]);
    draw_base_level(level_line[6]);
    draw_ladder(level_line[1], level_line[6], 8);
    draw_ladder(level_line[1], level_line[6], 260);
    DRAW_FLUSH;
    init_pictures;
    setPos(scr, 29, 35);
    writeln(scr, "Press any key to start game");
    DRAW_FLUSH;
    if upper(getc(KEYBOARD)) <> 'Q' then
      repeat
        play_game;
      until game.quit;
    end if;
  end func;
