
(********************************************************************)
(*                                                                  *)
(*  comanche.sd7  Simple webserver for static and cgi pages.        *)
(*  Copyright (C) 2009 - 2015  Thomas Mertes                        *)
(*                                                                  *)
(*  This program is free software; you can redistribute it and/or   *)
(*  modify it under the terms of the GNU General Public License as  *)
(*  published by the Free Software Foundation; either version 2 of  *)
(*  the License, or (at your option) any later version.             *)
(*                                                                  *)
(*  This program is distributed in the hope that it will be useful, *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of  *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *)
(*  GNU General Public License for more details.                    *)
(*                                                                  *)
(*  You should have received a copy of the GNU General Public       *)
(*  License along with this program; if not, write to the           *)
(*  Free Software Foundation, Inc., 51 Franklin Street,             *)
(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)
(*                                                                  *)
(********************************************************************)


$ include "seed7_05.s7i";
  include "osfiles.s7i";
  include "duration.s7i";
  include "socket.s7i";
  include "listener.s7i";
  include "shell.s7i";
  include "getf.s7i";
  include "x509cert.s7i";
  include "tls.s7i";

var string: htdocs is "../htdocs";
var string: cgi_bin is "../prg";
var integer: port is 1080;
var duration: keepAliveTime is 15 . SECONDS;

const type: httpServerConnection is new struct
    var file: sock is STD_NULL;
    var time: timeout is time.value;
    var integer: num is 0;
  end struct;

const type: httpConnectionHash is hash [file] httpServerConnection;

var httpConnectionHash: httpSessions is httpConnectionHash.value;
var integer: sessionNum is 0;


const func string: rfc1123Date (in time: aTime) is func
  result
    var string: dateStri is "";
  local
    const array string: wkday is [] ("Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun");
    const array string: month is [] ("Jan", "Feb", "Mar", "Apr", "May", "Jun",
                                     "Jul", "Aug", "Sep", "Oct", "Nov", "Dec");
    var time: timeInUTC is time.value;
  begin
    timeInUTC := toUTC(aTime);
    dateStri := wkday[dayOfWeek(timeInUTC)] <& ", " <&
                timeInUTC.day lpad0 2 <& " " <&
                month[timeInUTC.month] <& " " <&
                timeInUTC.year <& " " <&
                str_hh_mm_ss(timeInUTC, ":") <& " GMT";
  end func;


const proc: sendHttpResponse (inout file: sock, in string: content,
    in var string: contentType, in array string: header) is func
  local
    var string: line is "";
    var string: status is "";
    var string: response is "";
  begin
    # writeln("sendHttpResponse: len=" <& length(content) <& " " <& contentType);
    for line range header do
      if startsWith(line, "Status") then
        status := trim(line[succ(pos(line, ":")) ..]);
      elsif startsWith(line, "Content-Type") then
        contentType := trim(line[succ(pos(line, ":")) ..]);
      end if;
    end for;
    if status = "" then
      response &:= "HTTP/1.1 200 OK\r\n";
    else
      response &:= "HTTP/1.1 " <& status <& "\r\n";
    end if;
    response &:= "Server: Comanche\r\n";
    # response &:= "Transfer-Encoding: identity\r\n";
    response &:= "Cache-Control: max-age=259200\r\n";
    if contentType <> "" then
      response &:= "Content-Type: " <& contentType <& "\r\n";
    elsif startsWith(content, "\137;PNG") then
      response &:= "Content-Type: image/png\r\n";
    elsif pos(content, "<html") = 0 then
      response &:= "Content-Type: text/html\r\n";
    else
      response &:= "Content-Type: text/plain\r\n";
    end if;
    # writeln("Content-Length: " <& length(content));
    response &:= "Content-Length: " <& length(content) <& "\r\n";
    for line range header do
      if not startsWith(line, "Content-Type") and
          not startsWith(line, "Connection") then
        response &:= line <& "\r\n";
      end if;
    end for;
    response &:= "Connection: keep-alive\r\n";
    response &:= "\r\n";
    response &:= content;
    write(sock, response);
  end func;


const proc: sendClientError (inout file: sock, in string: message,
    in string: explanation) is func
  local
    var string: htmlMessage is "";
  begin
    htmlMessage := "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\n\
                   \<html><head>\n\
                   \<title>" <& message <& "</title>\n\
                   \</head><body>\n\
                   \<h1>Not Found</h1>\n\
                   \<p>" <& explanation <& "</p>\n\
                   \<hr>\n\
                   \<address>Comanche</address>\n\
                   \</body></html>\n";
    writeln(sock, "HTTP/1.1 " <& message);
    writeln(sock, "Server: Comanche");
    writeln(sock, "Transfer-Encoding: identity");
    writeln(sock, "Content-Length: " <& length(htmlMessage));
    writeln(sock, "Content-Type: text/html");
    writeln(sock);
    write(sock, htmlMessage);
  end func;


const func string: callCgi (in string: filePath, in string: queryParams,
    in string: postParams, in string: cookies, inout array string: header) is func
  result
    var string: response is "";
  local
    var string: cgiPath is "";
    var string: tempName is "";
    var file: cgiInput is STD_NULL;
    var file: cgiOutput is STD_NULL;
    var string: line is "";
  begin
    # writeln("CGI " <& filePath <& " " <& queryParams);
    # writeln(postParams);
    cgiPath := toStdPath(cgi_bin & filePath[9 ..]);
    setenv("QUERY_STRING", queryParams);
    setenv("HTTP_COOKIE", cookies);
    tempName := "cgiInput_" & str(rand(0, 99999));
    cgiInput := open(tempName, "w");
    writeln(cgiInput, postParams);
    # writeln(cgiInput, "*");
    # writeln(cgiInput, "*");
    close(cgiInput);
    if endsWith(cgiPath, ".sd7") then
      cgiOutput := popen("./s7 -q " <& cgiPath & " < " & tempName, "r");
    else
      cgiOutput := popen(cgiPath & " < " & tempName, "r");
    end if;
    if cgiOutput <> STD_NULL then
      line := getln(cgiOutput);
      while line <> "" do
        # writeln(line);
        header &:= [] (line);
        line := getln(cgiOutput);
      end while;
      # writeln;
      response := gets(cgiOutput, 999999999);
      # writeln(length(response));
      # writeln(literal(response));
      close(cgiOutput);
      removeFile(tempName);
    end if;
    if response = "" then
      header &:= "Status: 404 Not Found";
      header &:= "Content-Type: text/html";
      response := "<html><head>\n\
                  \<title>CGI Error</title>\n\
                  \</head><body>\n\
                  \<h1>CGI Error</h1>\n\
                  \<p>The requested CGI script " <& filePath <&
                  " could not be executed or did not produce any output.</p>\n\
                  \<p>Query params: " <& queryParams <& "</p>\n\
                  \<p>Post params: " <& postParams <& "</p>\n\
                  \<hr>\n\
                  \<address>Comanche</address>\n\
                  \</body></html>\n";
    end if;
  end func;


const proc: processHttpRequest (inout httpServerConnection: http) is func
  local
    var string: line is "";
    var string: requestCommand is "";
    var string: requestPath is "";
    var string: filePath is "";
    var string: hostName is "";
    var integer: questionMarkPos is 0;
    var string: queryParams is "";
    var string: postParams is "";
    var string: cookies is "";
    var array string: cgiHeader is 0 times "";
    var string: buffer is "";
    var string: contentType is "";
    var string: contentLengthStri is "";
    var integer: contentLength is 0;
    var boolean: keepAlive is FALSE;
  begin
    http.timeout := time(NOW) + keepAliveTime;
    line := getln(http.sock);
    # writeln(literal(line));
    while line <> "" do
      # writeln(line);
      if startsWith(line, "GET") then
        requestCommand := "GET";
        requestPath := trim(line[4 ..]);
        requestPath := requestPath[.. pred(pos(requestPath, ' '))];
      elsif startsWith(line, "POST") then
        requestCommand := "POST";
        requestPath := trim(line[5 ..]);
        requestPath := requestPath[.. pred(pos(requestPath, ' '))];
      elsif startsWith(line, "Host") then
        hostName := trim(line[succ(pos(line, ":")) ..]);
      elsif startsWith(line, "Content-Length") then
        contentLengthStri := trim(line[succ(pos(line, ":")) ..]);
        block
          contentLength := integer parse contentLengthStri;
        exception
          catch RANGE_ERROR:
            contentLength := -1;
        end block;
      elsif startsWith(line, "Connection") then
        keepAlive := lower(trim(line[succ(pos(line, ":")) ..])) = "keep-alive";
      elsif startsWith(line, "Cookie") then
        cookies := trim(line[succ(pos(line, ":")) ..]);
      end if;
      line := getln(http.sock);
    end while;
    if requestCommand = "GET" then
      # writeln("GET " <& requestPath);
      questionMarkPos := pos(requestPath, '?');
      if questionMarkPos <> 0 then
        queryParams := requestPath[succ(questionMarkPos) ..];
        requestPath := requestPath[.. pred(questionMarkPos)];
      end if;
      filePath := replace(requestPath, "\\", "/");
      if startsWith(filePath, "/cgi-bin/") then
        buffer := callCgi(filePath, queryParams, "", cookies, cgiHeader);
        if buffer <> "" then
          sendHttpResponse(http.sock, buffer, "", cgiHeader);
        end if;
      else
        filePath := toStdPath(htdocs & "/" & filePath);
        # writeln(literal(filePath));
        if fileType(filePath) = FILE_ABSENT then
          if fileType(filePath & ".html") <> FILE_ABSENT then
            filePath &:= ".html";
          elsif fileType(filePath & ".htm") <> FILE_ABSENT then
            filePath &:= ".htm";
          end if;
        elsif fileType(filePath) = FILE_DIR then
          if fileType(filePath & "/index.html") <> FILE_ABSENT then
            filePath &:= "/index.html";
          elsif fileType(filePath & "/index.htm") <> FILE_ABSENT then
            filePath &:= "/index.htm";
          end if;
        end if;
        if fileType(filePath) = FILE_REGULAR then
          buffer := getf(filePath);
        else
          buffer := "";
        end if;
        if buffer <> "" then
          if endsWith(filePath, ".htm") or endsWith(filePath, ".html") then
            contentType := "text/html";
          end if;
          sendHttpResponse(http.sock, buffer, contentType, 0 times "");
        end if;
      end if;
      if buffer = "" then
        sendClientError(http.sock, "404 Not Found",
            "The requested URL " <& requestPath <&
            " was not found on this server.");
      end if;
    elsif requestCommand = "POST" then
      # writeln("POST " <& requestPath);
      questionMarkPos := pos(requestPath, '?');
      if questionMarkPos <> 0 then
        queryParams := requestPath[succ(questionMarkPos) ..];
        requestPath := requestPath[.. pred(questionMarkPos)];
      end if;
      # writeln(queryParams);
      if contentLengthStri <> "" then
        while contentLength <> 0 do
          buffer := gets(http.sock, contentLength);
          contentLength -:= length(buffer);
          postParams &:= buffer;
        end while;
      elsif inputReady(http.sock, 1 . SECONDS) then
        buffer := gets(http.sock, 10000000);
        while buffer <> "" do
          postParams &:= buffer;
          if inputReady(http.sock, 1 . SECONDS) then
            buffer := gets(http.sock, 10000000);
          else
            buffer := "";
          end if;
        end while;
      end if;
      buffer := "";
      # writeln(postParams);
      filePath := replace(requestPath, "\\", "/");
      if startsWith(filePath, "/cgi-bin/") then
        buffer := callCgi(filePath, queryParams, postParams, cookies, cgiHeader);
      end if;
      if buffer <> "" then
        sendHttpResponse(http.sock, buffer, "", cgiHeader);
      else
        sendClientError(http.sock, "404 Not Found",
            "The requested URL " <& requestPath <&
            " was not found on this server.");
      end if;
    end if;
  end func;


const proc: openHttpSession (inout file: sock, in boolean: useTls) is func
  local
    var file: tlsSock is STD_NULL;
    var httpServerConnection: http is httpServerConnection.value;
  begin
    # writeln("openHttpSession: " <& ord(sock));
    if useTls then
      http.sock := openServerTls(sock, stdCertificate);
      if http.sock = STD_NULL then
        # writeln(" ***** Cannot open TLS connection.");
        close(sock);
        sock := STD_NULL;
      end if;
    else
      http.sock := sock;
    end if;
    if http.sock <> STD_NULL then
      incr(sessionNum);
      # writeln("Open session: " <& sessionNum);
      http.timeout := time(NOW) + keepAliveTime;
      http.num := sessionNum;
      httpSessions @:= [sock] http;
    end if;
  end func;


const proc: closeHttpSession (inout file: sock) is func
  begin
    # writeln("closeHttpSession: " <& ord(sock));
    # writeln("Close session: " <& httpSessions[sock].num);
    close(httpSessions[sock].sock);
    excl(httpSessions, sock);
  end func;


const proc: processHttpRequest (inout file: sock, in boolean: useTls) is func
  begin
    # writeln("processHttpRequest: " <& ord(sock));
    if sock not in httpSessions then
      openHttpSession(sock, useTls);
    end if;
    if sock in httpSessions then
      if eof(sock) then
        closeHttpSession(sock);
      else
        block
          processHttpRequest(httpSessions[sock]);
        exception
          catch FILE_ERROR:
            noop;
        end block;
      end if;
    end if;
  end func;


const proc: cleanSessions is func
  local
    var file: sock is STD_NULL;
  begin
    # writeln(length(httpSessions) <& " sessions");
    for sock range keys(httpSessions) do
      if sock in httpSessions and time(NOW) > httpSessions[sock].timeout then
        closeHttpSession(sock);
      end if;
    end for;
  end func;


const proc: main is func
  local
    var array string: args is 0 times "";
    var integer: index is 0;
    var boolean: writeHelp is FALSE;
    var boolean: useTls is FALSE;
    var boolean: htdocsAssigned is FALSE;
    var boolean: cgiBinAssigned is FALSE;
    var boolean: okay is TRUE;
    var listener: inetListener is listener.value;
    var file: existingConnection is STD_NULL;
    var file: newConnection is STD_NULL;
    var file: sock is STD_NULL;
    var file: tlsSock is STD_NULL;
  begin
    writeln("Comanche Version 1.1 - Simple webserver for static and cgi pages");
    writeln("Copyright (C) 2009 - 2015 Thomas Mertes");
    writeln("This is free software; see the source for copying conditions.  There is NO");
    writeln("warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.");
    writeln("Comanche is written in the Seed7 programming language");
    writeln("Homepage: http://seed7.sourceforge.net");
    args := argv(PROGRAM);
    for key index range argv(PROGRAM) do
      if args[index] in {"-h", "-?"} then
        writeHelp := TRUE;
      elsif args[index] = "-p" and index < length(args) then
        block
          port := integer parse (args[succ(index)]);
        exception
          catch RANGE_ERROR:
            writeln(" ***** Port not numeric. Port " <& port <& " used instead.");
        end block;
        incr(index);
      elsif args[index] = "-tls" then
        useTls := TRUE;
      elsif not htdocsAssigned then
        htdocs := args[index];
        htdocsAssigned := TRUE;
      elsif not cgiBinAssigned then
        cgi_bin := args[index];
        cgiBinAssigned := TRUE;
      else
        writeln(" ***** Unrecognized parameter " <& args[index] <& ".");
      end if;
    end for;
    if writeHelp then
      writeln;
      writeln("usage: comanche [-h | -?] [-p port] [-tls] [html-directory [cgi-directory]]");
      writeln;
      writeln("The html-directory specifies the root directory for HTML files.");
      writeln("The default html-directory is \"../htdocs\".");
      writeln("The cgi-directory specifies the root directory for CGI scripts.");
      writeln("The default cgi-directory is \"../prg\".");
      writeln("The default port is 1080.");
    else
      if fileType(htdocs) <> FILE_DIR then
        writeln(" *** Directory " <& literal(htdocs) <& " not found.");
        writeln("     You need to specify a directory which contains");
        writeln("     at least \"index.htm\" and possibly other HTML files.");
        okay := FALSE;
      end if;
      if fileType(cgi_bin) <> FILE_DIR then
        writeln(" *** Directory " <& literal(cgi_bin) <& " not found.");
        writeln("     You need to specify a directory which contains");
        writeln("     executable CGI scripts.");
        okay := FALSE;
      end if;
      if not okay then
        writeln("Use the option -? (or -h) to get more information.");
      else
        writeln("HTML directory: " <& htdocs);
        writeln("CGI directory: " <& cgi_bin);
        writeln("Port: " <& port);
        inetListener := openInetListener(port);
        listen(inetListener, 10);
        writeln("To test comanche make sure that " <&
                literal(htdocs & "/index.htm") <& " exists and");
        writeln("open http://localhost:" <& port <& "/ in your browser. \
                \To stop comanche press CTRL-C.");
        while TRUE do
          waitForRequest(inetListener, existingConnection, newConnection);
          if existingConnection <> STD_NULL then
            processHttpRequest(existingConnection, useTls);
          end if;
          if newConnection <> STD_NULL then
            openHttpSession(newConnection, useTls);
          end if;
          cleanSessions;
        end while;
      end if;
    end if;
  end func;
