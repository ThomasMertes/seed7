
(********************************************************************)
(*                                                                  *)
(*  chkchr.sd7    Checks character properties                       *)
(*  Copyright (C) 2015, 2019 Thomas Mertes                          *)
(*                2015 Arkadiy Kuleshov                             *)
(*                                                                  *)
(*  This program is free software; you can redistribute it and/or   *)
(*  modify it under the terms of the GNU General Public License as  *)
(*  published by the Free Software Foundation; either version 2 of  *)
(*  the License, or (at your option) any later version.             *)
(*                                                                  *)
(*  This program is distributed in the hope that it will be useful, *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of  *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *)
(*  GNU General Public License for more details.                    *)
(*                                                                  *)
(*  You should have received a copy of the GNU General Public       *)
(*  License along with this program; if not, write to the           *)
(*  Free Software Foundation, Inc., 51 Franklin Street,             *)
(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)
(*                                                                  *)
(********************************************************************)


$ include "seed7_05.s7i";
  include "stdio.s7i";


const func char: charExpr (in char: ch) is
  return chr(ord(ch) + length(str(rand(1, 9))[2 ..]));


const func boolean: boolExpr (in boolean: okay) is
  return boolean(ord(okay) + length(str(rand(1, 9))[2 ..]));


const proc: check_isLetter is func
  local
    var boolean: success is TRUE;
  begin
    if isLetter('\16#00020;') <> FALSE then writeln("isLetter( #   20 ) incorrect"); success := FALSE; end if; # SPACE
    if isLetter('\16#00038;') <> FALSE then writeln("isLetter( #   38 ) incorrect"); success := FALSE; end if; # DIGIT EIGHT
    if isLetter('\16#00050;') <> TRUE  then writeln("isLetter( #   50 ) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER P
    if isLetter('\16#0005f;') <> FALSE then writeln("isLetter( #   5f ) incorrect"); success := FALSE; end if; # LOW LINE
    if isLetter('\16#00068;') <> TRUE  then writeln("isLetter( #   68 ) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER H
    if isLetter('\16#00080;') <> FALSE then writeln("isLetter( #   80 ) incorrect"); success := FALSE; end if; # <control-0080>
    if isLetter('\16#000a0;') <> FALSE then writeln("isLetter( #   a0 ) incorrect"); success := FALSE; end if; # NO-BREAK SPACE
    if isLetter('\16#000c0;') <> TRUE  then writeln("isLetter( #   c0 ) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER A WITH GRAVE
    if isLetter('\16#000e0;') <> TRUE  then writeln("isLetter( #   e0 ) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER A WITH GRAVE
    if isLetter('\16#00100;') <> TRUE  then writeln("isLetter( #  100 ) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER A WITH MACRON
    if isLetter('\16#00120;') <> TRUE  then writeln("isLetter( #  120 ) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER G WITH DOT ABOVE
    if isLetter('\16#00140;') <> TRUE  then writeln("isLetter( #  140 ) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER L WITH MIDDLE DOT
    if isLetter('\16#00160;') <> TRUE  then writeln("isLetter( #  160 ) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER S WITH CARON
    if isLetter('\16#00180;') <> TRUE  then writeln("isLetter( #  180 ) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER B WITH STROKE
    if isLetter('\16#001b4;') <> TRUE  then writeln("isLetter( #  1b4 ) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER Y WITH HOOK
    if isLetter('\16#001e8;') <> TRUE  then writeln("isLetter( #  1e8 ) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER K WITH CARON
    if isLetter('\16#0021c;') <> TRUE  then writeln("isLetter( #  21c ) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER YOGH
    if isLetter('\16#00250;') <> TRUE  then writeln("isLetter( #  250 ) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER TURNED A
    if isLetter('\16#00268;') <> TRUE  then writeln("isLetter( #  268 ) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER I WITH STROKE
    if isLetter('\16#00280;') <> TRUE  then writeln("isLetter( #  280 ) incorrect"); success := FALSE; end if; # LATIN LETTER SMALL CAPITAL R
    if isLetter('\16#00298;') <> TRUE  then writeln("isLetter( #  298 ) incorrect"); success := FALSE; end if; # LATIN LETTER BILABIAL CLICK
    if isLetter('\16#002b0;') <> TRUE  then writeln("isLetter( #  2b0 ) incorrect"); success := FALSE; end if; # MODIFIER LETTER SMALL H
    if isLetter('\16#002c4;') <> FALSE then writeln("isLetter( #  2c4 ) incorrect"); success := FALSE; end if; # MODIFIER LETTER UP ARROWHEAD
    if isLetter('\16#002d8;') <> FALSE then writeln("isLetter( #  2d8 ) incorrect"); success := FALSE; end if; # BREVE
    if isLetter('\16#002ec;') <> TRUE  then writeln("isLetter( #  2ec ) incorrect"); success := FALSE; end if; # MODIFIER LETTER VOICING
    if isLetter('\16#00300;') <> FALSE then writeln("isLetter( #  300 ) incorrect"); success := FALSE; end if; # COMBINING GRAVE ACCENT
    if isLetter('\16#0031c;') <> FALSE then writeln("isLetter( #  31c ) incorrect"); success := FALSE; end if; # COMBINING LEFT HALF RING BELOW
    if isLetter('\16#00338;') <> FALSE then writeln("isLetter( #  338 ) incorrect"); success := FALSE; end if; # COMBINING LONG SOLIDUS OVERLAY
    if isLetter('\16#00354;') <> FALSE then writeln("isLetter( #  354 ) incorrect"); success := FALSE; end if; # COMBINING LEFT ARROWHEAD BELOW
    if isLetter('\16#00370;') <> TRUE  then writeln("isLetter( #  370 ) incorrect"); success := FALSE; end if; # GREEK CAPITAL LETTER HETA
    if isLetter('\16#00394;') <> TRUE  then writeln("isLetter( #  394 ) incorrect"); success := FALSE; end if; # GREEK CAPITAL LETTER DELTA
    if isLetter('\16#003b8;') <> TRUE  then writeln("isLetter( #  3b8 ) incorrect"); success := FALSE; end if; # GREEK SMALL LETTER THETA
    if isLetter('\16#003dc;') <> TRUE  then writeln("isLetter( #  3dc ) incorrect"); success := FALSE; end if; # GREEK LETTER DIGAMMA
    if isLetter('\16#00400;') <> TRUE  then writeln("isLetter( #  400 ) incorrect"); success := FALSE; end if; # CYRILLIC CAPITAL LETTER IE WITH GRAVE
    if isLetter('\16#00440;') <> TRUE  then writeln("isLetter( #  440 ) incorrect"); success := FALSE; end if; # CYRILLIC SMALL LETTER ER
    if isLetter('\16#00480;') <> TRUE  then writeln("isLetter( #  480 ) incorrect"); success := FALSE; end if; # CYRILLIC CAPITAL LETTER KOPPA
    if isLetter('\16#004c0;') <> TRUE  then writeln("isLetter( #  4c0 ) incorrect"); success := FALSE; end if; # CYRILLIC LETTER PALOCHKA
    if isLetter('\16#00500;') <> TRUE  then writeln("isLetter( #  500 ) incorrect"); success := FALSE; end if; # CYRILLIC CAPITAL LETTER KOMI DE
    if isLetter('\16#0050c;') <> TRUE  then writeln("isLetter( #  50c ) incorrect"); success := FALSE; end if; # CYRILLIC CAPITAL LETTER KOMI SJE
    if isLetter('\16#00548;') <> TRUE  then writeln("isLetter( #  548 ) incorrect"); success := FALSE; end if; # ARMENIAN CAPITAL LETTER VO
    if isLetter('\16#00578;') <> TRUE  then writeln("isLetter( #  578 ) incorrect"); success := FALSE; end if; # ARMENIAN SMALL LETTER VO
    if isLetter('\16#005ac;') <> FALSE then writeln("isLetter( #  5ac ) incorrect"); success := FALSE; end if; # HEBREW ACCENT ILUY
    if isLetter('\16#005e4;') <> TRUE  then writeln("isLetter( #  5e4 ) incorrect"); success := FALSE; end if; # HEBREW LETTER PE
    if isLetter('\16#00600;') <> FALSE then writeln("isLetter( #  600 ) incorrect"); success := FALSE; end if; # ARABIC NUMBER SIGN
    if isLetter('\16#00640;') <> TRUE  then writeln("isLetter( #  640 ) incorrect"); success := FALSE; end if; # ARABIC TATWEEL
    if isLetter('\16#00680;') <> TRUE  then writeln("isLetter( #  680 ) incorrect"); success := FALSE; end if; # ARABIC LETTER BEHEH
    if isLetter('\16#006c0;') <> TRUE  then writeln("isLetter( #  6c0 ) incorrect"); success := FALSE; end if; # ARABIC LETTER HEH WITH YEH ABOVE
    if isLetter('\16#00700;') <> FALSE then writeln("isLetter( #  700 ) incorrect"); success := FALSE; end if; # SYRIAC END OF PARAGRAPH
    if isLetter('\16#00714;') <> TRUE  then writeln("isLetter( #  714 ) incorrect"); success := FALSE; end if; # SYRIAC LETTER GAMAL GARSHUNI
    if isLetter('\16#00728;') <> TRUE  then writeln("isLetter( #  728 ) incorrect"); success := FALSE; end if; # SYRIAC LETTER SADHE
    if isLetter('\16#0073c;') <> FALSE then writeln("isLetter( #  73c ) incorrect"); success := FALSE; end if; # SYRIAC HBASA-ESASA DOTTED
    if isLetter('\16#00780;') <> TRUE  then writeln("isLetter( #  780 ) incorrect"); success := FALSE; end if; # THAANA LETTER HAA
    if isLetter('\16#00790;') <> TRUE  then writeln("isLetter( #  790 ) incorrect"); success := FALSE; end if; # THAANA LETTER SEENU
    if isLetter('\16#007a0;') <> TRUE  then writeln("isLetter( #  7a0 ) incorrect"); success := FALSE; end if; # THAANA LETTER TO
    if isLetter('\16#007b0;') <> FALSE then writeln("isLetter( #  7b0 ) incorrect"); success := FALSE; end if; # THAANA SUKUN
    if isLetter('\16#007c0;') <> FALSE then writeln("isLetter( #  7c0 ) incorrect"); success := FALSE; end if; # NKO DIGIT ZERO
    if isLetter('\16#007f0;') <> FALSE then writeln("isLetter( #  7f0 ) incorrect"); success := FALSE; end if; # NKO COMBINING LONG LOW TONE
    if isLetter('\16#00920;') <> TRUE  then writeln("isLetter( #  920 ) incorrect"); success := FALSE; end if; # DEVANAGARI LETTER TTHA
    if isLetter('\16#00940;') <> FALSE then writeln("isLetter( #  940 ) incorrect"); success := FALSE; end if; # DEVANAGARI VOWEL SIGN II
    if isLetter('\16#00960;') <> TRUE  then writeln("isLetter( #  960 ) incorrect"); success := FALSE; end if; # DEVANAGARI LETTER VOCALIC RR
    if isLetter('\16#009a0;') <> TRUE  then writeln("isLetter( #  9a0 ) incorrect"); success := FALSE; end if; # BENGALI LETTER TTHA
    if isLetter('\16#009c0;') <> FALSE then writeln("isLetter( #  9c0 ) incorrect"); success := FALSE; end if; # BENGALI VOWEL SIGN II
    if isLetter('\16#009e0;') <> TRUE  then writeln("isLetter( #  9e0 ) incorrect"); success := FALSE; end if; # BENGALI LETTER VOCALIC RR
    if isLetter('\16#00a20;') <> TRUE  then writeln("isLetter( #  a20 ) incorrect"); success := FALSE; end if; # GURMUKHI LETTER TTHA
    if isLetter('\16#00a40;') <> FALSE then writeln("isLetter( #  a40 ) incorrect"); success := FALSE; end if; # GURMUKHI VOWEL SIGN II
    if isLetter('\16#00aa0;') <> TRUE  then writeln("isLetter( #  aa0 ) incorrect"); success := FALSE; end if; # GUJARATI LETTER TTHA
    if isLetter('\16#00ac0;') <> FALSE then writeln("isLetter( #  ac0 ) incorrect"); success := FALSE; end if; # GUJARATI VOWEL SIGN II
    if isLetter('\16#00ae0;') <> TRUE  then writeln("isLetter( #  ae0 ) incorrect"); success := FALSE; end if; # GUJARATI LETTER VOCALIC RR
    if isLetter('\16#00b20;') <> TRUE  then writeln("isLetter( #  b20 ) incorrect"); success := FALSE; end if; # ORIYA LETTER TTHA
    if isLetter('\16#00b40;') <> FALSE then writeln("isLetter( #  b40 ) incorrect"); success := FALSE; end if; # ORIYA VOWEL SIGN II
    if isLetter('\16#00b60;') <> TRUE  then writeln("isLetter( #  b60 ) incorrect"); success := FALSE; end if; # ORIYA LETTER VOCALIC RR
    if isLetter('\16#00bc0;') <> FALSE then writeln("isLetter( #  bc0 ) incorrect"); success := FALSE; end if; # TAMIL VOWEL SIGN II
    if isLetter('\16#00c20;') <> TRUE  then writeln("isLetter( #  c20 ) incorrect"); success := FALSE; end if; # TELUGU LETTER TTHA
    if isLetter('\16#00c40;') <> FALSE then writeln("isLetter( #  c40 ) incorrect"); success := FALSE; end if; # TELUGU VOWEL SIGN II
    if isLetter('\16#00c60;') <> TRUE  then writeln("isLetter( #  c60 ) incorrect"); success := FALSE; end if; # TELUGU LETTER VOCALIC RR
    if isLetter('\16#00ca0;') <> TRUE  then writeln("isLetter( #  ca0 ) incorrect"); success := FALSE; end if; # KANNADA LETTER TTHA
    if isLetter('\16#00cc0;') <> FALSE then writeln("isLetter( #  cc0 ) incorrect"); success := FALSE; end if; # KANNADA VOWEL SIGN II
    if isLetter('\16#00ce0;') <> TRUE  then writeln("isLetter( #  ce0 ) incorrect"); success := FALSE; end if; # KANNADA LETTER VOCALIC RR
    if isLetter('\16#00d20;') <> TRUE  then writeln("isLetter( #  d20 ) incorrect"); success := FALSE; end if; # MALAYALAM LETTER TTHA
    if isLetter('\16#00d40;') <> FALSE then writeln("isLetter( #  d40 ) incorrect"); success := FALSE; end if; # MALAYALAM VOWEL SIGN II
    if isLetter('\16#00d60;') <> TRUE  then writeln("isLetter( #  d60 ) incorrect"); success := FALSE; end if; # MALAYALAM LETTER VOCALIC RR
    if isLetter('\16#00da0;') <> TRUE  then writeln("isLetter( #  da0 ) incorrect"); success := FALSE; end if; # SINHALA LETTER ALPAPRAANA CAYANNA
    if isLetter('\16#00dc0;') <> TRUE  then writeln("isLetter( #  dc0 ) incorrect"); success := FALSE; end if; # SINHALA LETTER VAYANNA
    if isLetter('\16#00e20;') <> TRUE  then writeln("isLetter( #  e20 ) incorrect"); success := FALSE; end if; # THAI CHARACTER PHO SAMPHAO
    if isLetter('\16#00e40;') <> TRUE  then writeln("isLetter( #  e40 ) incorrect"); success := FALSE; end if; # THAI CHARACTER SARA E
    if isLetter('\16#00ec0;') <> TRUE  then writeln("isLetter( #  ec0 ) incorrect"); success := FALSE; end if; # LAO VOWEL SIGN E
    if isLetter('\16#00f00;') <> TRUE  then writeln("isLetter( #  f00 ) incorrect"); success := FALSE; end if; # TIBETAN SYLLABLE OM
    if isLetter('\16#00f40;') <> TRUE  then writeln("isLetter( #  f40 ) incorrect"); success := FALSE; end if; # TIBETAN LETTER KA
    if isLetter('\16#00f80;') <> FALSE then writeln("isLetter( #  f80 ) incorrect"); success := FALSE; end if; # TIBETAN VOWEL SIGN REVERSED I
    if isLetter('\16#00fc0;') <> FALSE then writeln("isLetter( #  fc0 ) incorrect"); success := FALSE; end if; # TIBETAN CANTILLATION SIGN HEAVY BEAT
    if isLetter('\16#01000;') <> TRUE  then writeln("isLetter( # 1000 ) incorrect"); success := FALSE; end if; # MYANMAR LETTER KA
    if isLetter('\16#01050;') <> TRUE  then writeln("isLetter( # 1050 ) incorrect"); success := FALSE; end if; # MYANMAR LETTER SHA
    if isLetter('\16#010a0;') <> TRUE  then writeln("isLetter( # 10a0 ) incorrect"); success := FALSE; end if; # GEORGIAN CAPITAL LETTER AN
    if isLetter('\16#010b8;') <> TRUE  then writeln("isLetter( # 10b8 ) incorrect"); success := FALSE; end if; # GEORGIAN CAPITAL LETTER SHIN
    if isLetter('\16#010d0;') <> TRUE  then writeln("isLetter( # 10d0 ) incorrect"); success := FALSE; end if; # GEORGIAN LETTER AN
    if isLetter('\16#010e8;') <> TRUE  then writeln("isLetter( # 10e8 ) incorrect"); success := FALSE; end if; # GEORGIAN LETTER SHIN
    if isLetter('\16#01100;') <> TRUE  then writeln("isLetter( # 1100 ) incorrect"); success := FALSE; end if; # HANGUL CHOSEONG KIYEOK
    if isLetter('\16#01140;') <> TRUE  then writeln("isLetter( # 1140 ) incorrect"); success := FALSE; end if; # HANGUL CHOSEONG PANSIOS
    if isLetter('\16#01180;') <> TRUE  then writeln("isLetter( # 1180 ) incorrect"); success := FALSE; end if; # HANGUL JUNGSEONG O-E
    if isLetter('\16#011c0;') <> TRUE  then writeln("isLetter( # 11c0 ) incorrect"); success := FALSE; end if; # HANGUL JONGSEONG THIEUTH
    if isLetter('\16#01200;') <> TRUE  then writeln("isLetter( # 1200 ) incorrect"); success := FALSE; end if; # ETHIOPIC SYLLABLE HA
    if isLetter('\16#01260;') <> TRUE  then writeln("isLetter( # 1260 ) incorrect"); success := FALSE; end if; # ETHIOPIC SYLLABLE BA
    if isLetter('\16#012c0;') <> TRUE  then writeln("isLetter( # 12c0 ) incorrect"); success := FALSE; end if; # ETHIOPIC SYLLABLE KXWA
    if isLetter('\16#01320;') <> TRUE  then writeln("isLetter( # 1320 ) incorrect"); success := FALSE; end if; # ETHIOPIC SYLLABLE THA
    if isLetter('\16#01390;') <> FALSE then writeln("isLetter( # 1390 ) incorrect"); success := FALSE; end if; # ETHIOPIC TONAL MARK YIZET
    if isLetter('\16#01398;') <> FALSE then writeln("isLetter( # 1398 ) incorrect"); success := FALSE; end if; # ETHIOPIC TONAL MARK DERET-HIDET
    if isLetter('\16#013a0;') <> TRUE  then writeln("isLetter( # 13a0 ) incorrect"); success := FALSE; end if; # CHEROKEE LETTER A
    if isLetter('\16#013b8;') <> TRUE  then writeln("isLetter( # 13b8 ) incorrect"); success := FALSE; end if; # CHEROKEE LETTER LV
    if isLetter('\16#013d0;') <> TRUE  then writeln("isLetter( # 13d0 ) incorrect"); success := FALSE; end if; # CHEROKEE LETTER SO
    if isLetter('\16#013e8;') <> TRUE  then writeln("isLetter( # 13e8 ) incorrect"); success := FALSE; end if; # CHEROKEE LETTER TSV
    if isLetter('\16#01400;') <> FALSE then writeln("isLetter( # 1400 ) incorrect"); success := FALSE; end if; # CANADIAN SYLLABICS HYPHEN
    if isLetter('\16#014a0;') <> TRUE  then writeln("isLetter( # 14a0 ) incorrect"); success := FALSE; end if; # CANADIAN SYLLABICS NASKAPI CWAA
    if isLetter('\16#01540;') <> TRUE  then writeln("isLetter( # 1540 ) incorrect"); success := FALSE; end if; # CANADIAN SYLLABICS WEST-CREE Y
    if isLetter('\16#015e0;') <> TRUE  then writeln("isLetter( # 15e0 ) incorrect"); success := FALSE; end if; # CANADIAN SYLLABICS CARRIER THI
    if isLetter('\16#01680;') <> FALSE then writeln("isLetter( # 1680 ) incorrect"); success := FALSE; end if; # OGHAM SPACE MARK
    if isLetter('\16#01688;') <> TRUE  then writeln("isLetter( # 1688 ) incorrect"); success := FALSE; end if; # OGHAM LETTER TINNE
    if isLetter('\16#01690;') <> TRUE  then writeln("isLetter( # 1690 ) incorrect"); success := FALSE; end if; # OGHAM LETTER AILM
    if isLetter('\16#01698;') <> TRUE  then writeln("isLetter( # 1698 ) incorrect"); success := FALSE; end if; # OGHAM LETTER IFIN
    if isLetter('\16#016a0;') <> TRUE  then writeln("isLetter( # 16a0 ) incorrect"); success := FALSE; end if; # RUNIC LETTER FEHU FEOH FE F
    if isLetter('\16#016b8;') <> TRUE  then writeln("isLetter( # 16b8 ) incorrect"); success := FALSE; end if; # RUNIC LETTER GAR
    if isLetter('\16#016d0;') <> TRUE  then writeln("isLetter( # 16d0 ) incorrect"); success := FALSE; end if; # RUNIC LETTER SHORT-TWIG-TYR T
    if isLetter('\16#016e8;') <> TRUE  then writeln("isLetter( # 16e8 ) incorrect"); success := FALSE; end if; # RUNIC LETTER ICELANDIC-YR
    if isLetter('\16#01700;') <> TRUE  then writeln("isLetter( # 1700 ) incorrect"); success := FALSE; end if; # TAGALOG LETTER A
    if isLetter('\16#01708;') <> TRUE  then writeln("isLetter( # 1708 ) incorrect"); success := FALSE; end if; # TAGALOG LETTER NA
    if isLetter('\16#01710;') <> TRUE  then writeln("isLetter( # 1710 ) incorrect"); success := FALSE; end if; # TAGALOG LETTER SA
    if isLetter('\16#01720;') <> TRUE  then writeln("isLetter( # 1720 ) incorrect"); success := FALSE; end if; # HANUNOO LETTER A
    if isLetter('\16#01728;') <> TRUE  then writeln("isLetter( # 1728 ) incorrect"); success := FALSE; end if; # HANUNOO LETTER NA
    if isLetter('\16#01730;') <> TRUE  then writeln("isLetter( # 1730 ) incorrect"); success := FALSE; end if; # HANUNOO LETTER SA
    if isLetter('\16#01740;') <> TRUE  then writeln("isLetter( # 1740 ) incorrect"); success := FALSE; end if; # BUHID LETTER A
    if isLetter('\16#01748;') <> TRUE  then writeln("isLetter( # 1748 ) incorrect"); success := FALSE; end if; # BUHID LETTER NA
    if isLetter('\16#01750;') <> TRUE  then writeln("isLetter( # 1750 ) incorrect"); success := FALSE; end if; # BUHID LETTER SA
    if isLetter('\16#01760;') <> TRUE  then writeln("isLetter( # 1760 ) incorrect"); success := FALSE; end if; # TAGBANWA LETTER A
    if isLetter('\16#01768;') <> TRUE  then writeln("isLetter( # 1768 ) incorrect"); success := FALSE; end if; # TAGBANWA LETTER NA
    if isLetter('\16#01770;') <> TRUE  then writeln("isLetter( # 1770 ) incorrect"); success := FALSE; end if; # TAGBANWA LETTER SA
    if isLetter('\16#01780;') <> TRUE  then writeln("isLetter( # 1780 ) incorrect"); success := FALSE; end if; # KHMER LETTER KA
    if isLetter('\16#017a0;') <> TRUE  then writeln("isLetter( # 17a0 ) incorrect"); success := FALSE; end if; # KHMER LETTER HA
    if isLetter('\16#017c0;') <> FALSE then writeln("isLetter( # 17c0 ) incorrect"); success := FALSE; end if; # KHMER VOWEL SIGN IE
    if isLetter('\16#017e0;') <> FALSE then writeln("isLetter( # 17e0 ) incorrect"); success := FALSE; end if; # KHMER DIGIT ZERO
    if isLetter('\16#01800;') <> FALSE then writeln("isLetter( # 1800 ) incorrect"); success := FALSE; end if; # MONGOLIAN BIRGA
    if isLetter('\16#0182c;') <> TRUE  then writeln("isLetter( # 182c ) incorrect"); success := FALSE; end if; # MONGOLIAN LETTER QA
    if isLetter('\16#01858;') <> TRUE  then writeln("isLetter( # 1858 ) incorrect"); success := FALSE; end if; # MONGOLIAN LETTER TODO GAA
    if isLetter('\16#01884;') <> TRUE  then writeln("isLetter( # 1884 ) incorrect"); success := FALSE; end if; # MONGOLIAN LETTER ALI GALI INVERTED UBADAMA
    if isLetter('\16#01900;') <> TRUE  then writeln("isLetter( # 1900 ) incorrect"); success := FALSE; end if; # LIMBU VOWEL-CARRIER LETTER
    if isLetter('\16#01914;') <> TRUE  then writeln("isLetter( # 1914 ) incorrect"); success := FALSE; end if; # LIMBU LETTER MA
    if isLetter('\16#01928;') <> FALSE then writeln("isLetter( # 1928 ) incorrect"); success := FALSE; end if; # LIMBU VOWEL SIGN O
    if isLetter('\16#01950;') <> TRUE  then writeln("isLetter( # 1950 ) incorrect"); success := FALSE; end if; # TAI LE LETTER KA
    if isLetter('\16#0195c;') <> TRUE  then writeln("isLetter( # 195c ) incorrect"); success := FALSE; end if; # TAI LE LETTER FA
    if isLetter('\16#01968;') <> TRUE  then writeln("isLetter( # 1968 ) incorrect"); success := FALSE; end if; # TAI LE LETTER OO
    if isLetter('\16#01974;') <> TRUE  then writeln("isLetter( # 1974 ) incorrect"); success := FALSE; end if; # TAI LE LETTER TONE-6
    if isLetter('\16#019e0;') <> FALSE then writeln("isLetter( # 19e0 ) incorrect"); success := FALSE; end if; # KHMER SYMBOL PATHAMASAT
    if isLetter('\16#019e8;') <> FALSE then writeln("isLetter( # 19e8 ) incorrect"); success := FALSE; end if; # KHMER SYMBOL PRAM-BEI KOET
    if isLetter('\16#019f0;') <> FALSE then writeln("isLetter( # 19f0 ) incorrect"); success := FALSE; end if; # KHMER SYMBOL TUTEYASAT
    if isLetter('\16#019f8;') <> FALSE then writeln("isLetter( # 19f8 ) incorrect"); success := FALSE; end if; # KHMER SYMBOL PRAM-BEI ROC
    if isLetter('\16#01c3c;') <> FALSE then writeln("isLetter( # 1c3c ) incorrect"); success := FALSE; end if; # LEPCHA PUNCTUATION NYET THYOOM TA-ROL
    if isLetter('\16#01c50;') <> FALSE then writeln("isLetter( # 1c50 ) incorrect"); success := FALSE; end if; # OL CHIKI DIGIT ZERO
    if isLetter('\16#01cd0;') <> FALSE then writeln("isLetter( # 1cd0 ) incorrect"); success := FALSE; end if; # VEDIC TONE KARSHANA
    if isLetter('\16#01cdc;') <> FALSE then writeln("isLetter( # 1cdc ) incorrect"); success := FALSE; end if; # VEDIC TONE KATHAKA ANUDATTA
    if isLetter('\16#01ce8;') <> FALSE then writeln("isLetter( # 1ce8 ) incorrect"); success := FALSE; end if; # VEDIC SIGN VISARGA ANUDATTA WITH TAIL
    if isLetter('\16#01d00;') <> TRUE  then writeln("isLetter( # 1d00 ) incorrect"); success := FALSE; end if; # LATIN LETTER SMALL CAPITAL A
    if isLetter('\16#01d20;') <> TRUE  then writeln("isLetter( # 1d20 ) incorrect"); success := FALSE; end if; # LATIN LETTER SMALL CAPITAL V
    if isLetter('\16#01d40;') <> TRUE  then writeln("isLetter( # 1d40 ) incorrect"); success := FALSE; end if; # MODIFIER LETTER CAPITAL T
    if isLetter('\16#01d60;') <> TRUE  then writeln("isLetter( # 1d60 ) incorrect"); success := FALSE; end if; # MODIFIER LETTER SMALL GREEK PHI
    if isLetter('\16#01dc0;') <> FALSE then writeln("isLetter( # 1dc0 ) incorrect"); success := FALSE; end if; # COMBINING DOTTED GRAVE ACCENT
    if isLetter('\16#01dd0;') <> FALSE then writeln("isLetter( # 1dd0 ) incorrect"); success := FALSE; end if; # COMBINING IS BELOW
    if isLetter('\16#01de0;') <> FALSE then writeln("isLetter( # 1de0 ) incorrect"); success := FALSE; end if; # COMBINING LATIN SMALL LETTER N
    if isLetter('\16#01e00;') <> TRUE  then writeln("isLetter( # 1e00 ) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER A WITH RING BELOW
    if isLetter('\16#01e40;') <> TRUE  then writeln("isLetter( # 1e40 ) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER M WITH DOT ABOVE
    if isLetter('\16#01e80;') <> TRUE  then writeln("isLetter( # 1e80 ) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER W WITH GRAVE
    if isLetter('\16#01ec0;') <> TRUE  then writeln("isLetter( # 1ec0 ) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND GRAVE
    if isLetter('\16#01f00;') <> TRUE  then writeln("isLetter( # 1f00 ) incorrect"); success := FALSE; end if; # GREEK SMALL LETTER ALPHA WITH PSILI
    if isLetter('\16#01f40;') <> TRUE  then writeln("isLetter( # 1f40 ) incorrect"); success := FALSE; end if; # GREEK SMALL LETTER OMICRON WITH PSILI
    if isLetter('\16#01f80;') <> TRUE  then writeln("isLetter( # 1f80 ) incorrect"); success := FALSE; end if; # GREEK SMALL LETTER ALPHA WITH PSILI AND YPOGEGRAMMENI
    if isLetter('\16#01fc0;') <> FALSE then writeln("isLetter( # 1fc0 ) incorrect"); success := FALSE; end if; # GREEK PERISPOMENI
    if isLetter('\16#02000;') <> FALSE then writeln("isLetter( # 2000 ) incorrect"); success := FALSE; end if; # EN QUAD
    if isLetter('\16#0201c;') <> FALSE then writeln("isLetter( # 201c ) incorrect"); success := FALSE; end if; # LEFT DOUBLE QUOTATION MARK
    if isLetter('\16#02038;') <> FALSE then writeln("isLetter( # 2038 ) incorrect"); success := FALSE; end if; # CARET
    if isLetter('\16#02054;') <> FALSE then writeln("isLetter( # 2054 ) incorrect"); success := FALSE; end if; # INVERTED UNDERTIE
    if isLetter('\16#02070;') <> FALSE then writeln("isLetter( # 2070 ) incorrect"); success := FALSE; end if; # SUPERSCRIPT ZERO
    if isLetter('\16#0207c;') <> FALSE then writeln("isLetter( # 207c ) incorrect"); success := FALSE; end if; # SUPERSCRIPT EQUALS SIGN
    if isLetter('\16#02088;') <> FALSE then writeln("isLetter( # 2088 ) incorrect"); success := FALSE; end if; # SUBSCRIPT EIGHT
    if isLetter('\16#020a0;') <> FALSE then writeln("isLetter( # 20a0 ) incorrect"); success := FALSE; end if; # EURO-CURRENCY SIGN
    if isLetter('\16#020ac;') <> FALSE then writeln("isLetter( # 20ac ) incorrect"); success := FALSE; end if; # EURO SIGN
    if isLetter('\16#020b8;') <> FALSE then writeln("isLetter( # 20b8 ) incorrect"); success := FALSE; end if; # TENGE SIGN
    if isLetter('\16#020d0;') <> FALSE then writeln("isLetter( # 20d0 ) incorrect"); success := FALSE; end if; # COMBINING LEFT HARPOON ABOVE
    if isLetter('\16#020dc;') <> FALSE then writeln("isLetter( # 20dc ) incorrect"); success := FALSE; end if; # COMBINING FOUR DOTS ABOVE
    if isLetter('\16#020e8;') <> FALSE then writeln("isLetter( # 20e8 ) incorrect"); success := FALSE; end if; # COMBINING TRIPLE UNDERDOT
    if isLetter('\16#02100;') <> FALSE then writeln("isLetter( # 2100 ) incorrect"); success := FALSE; end if; # ACCOUNT OF
    if isLetter('\16#02114;') <> FALSE then writeln("isLetter( # 2114 ) incorrect"); success := FALSE; end if; # L B BAR SYMBOL
    if isLetter('\16#02128;') <> TRUE  then writeln("isLetter( # 2128 ) incorrect"); success := FALSE; end if; # BLACK-LETTER CAPITAL Z
    if isLetter('\16#02150;') <> FALSE then writeln("isLetter( # 2150 ) incorrect"); success := FALSE; end if; # VULGAR FRACTION ONE SEVENTH
    if isLetter('\16#02160;') <> FALSE then writeln("isLetter( # 2160 ) incorrect"); success := FALSE; end if; # ROMAN NUMERAL ONE
    if isLetter('\16#02170;') <> FALSE then writeln("isLetter( # 2170 ) incorrect"); success := FALSE; end if; # SMALL ROMAN NUMERAL ONE
    if isLetter('\16#02180;') <> FALSE then writeln("isLetter( # 2180 ) incorrect"); success := FALSE; end if; # ROMAN NUMERAL ONE THOUSAND C D
    if isLetter('\16#02190;') <> FALSE then writeln("isLetter( # 2190 ) incorrect"); success := FALSE; end if; # LEFTWARDS ARROW
    if isLetter('\16#021ac;') <> FALSE then writeln("isLetter( # 21ac ) incorrect"); success := FALSE; end if; # RIGHTWARDS ARROW WITH LOOP
    if isLetter('\16#021c8;') <> FALSE then writeln("isLetter( # 21c8 ) incorrect"); success := FALSE; end if; # UPWARDS PAIRED ARROWS
    if isLetter('\16#021e4;') <> FALSE then writeln("isLetter( # 21e4 ) incorrect"); success := FALSE; end if; # LEFTWARDS ARROW TO BAR
    if isLetter('\16#02200;') <> FALSE then writeln("isLetter( # 2200 ) incorrect"); success := FALSE; end if; # FOR ALL
    if isLetter('\16#02240;') <> FALSE then writeln("isLetter( # 2240 ) incorrect"); success := FALSE; end if; # WREATH PRODUCT
    if isLetter('\16#02280;') <> FALSE then writeln("isLetter( # 2280 ) incorrect"); success := FALSE; end if; # DOES NOT PRECEDE
    if isLetter('\16#022c0;') <> FALSE then writeln("isLetter( # 22c0 ) incorrect"); success := FALSE; end if; # N-ARY LOGICAL AND
    if isLetter('\16#02300;') <> FALSE then writeln("isLetter( # 2300 ) incorrect"); success := FALSE; end if; # DIAMETER SIGN
    if isLetter('\16#02340;') <> FALSE then writeln("isLetter( # 2340 ) incorrect"); success := FALSE; end if; # APL FUNCTIONAL SYMBOL BACKSLASH BAR
    if isLetter('\16#02380;') <> FALSE then writeln("isLetter( # 2380 ) incorrect"); success := FALSE; end if; # INSERTION SYMBOL
    if isLetter('\16#023c0;') <> FALSE then writeln("isLetter( # 23c0 ) incorrect"); success := FALSE; end if; # DENTISTRY SYMBOL LIGHT VERTICAL WITH CIRCLE
    if isLetter('\16#02400;') <> FALSE then writeln("isLetter( # 2400 ) incorrect"); success := FALSE; end if; # SYMBOL FOR NULL
    if isLetter('\16#02410;') <> FALSE then writeln("isLetter( # 2410 ) incorrect"); success := FALSE; end if; # SYMBOL FOR DATA LINK ESCAPE
    if isLetter('\16#02420;') <> FALSE then writeln("isLetter( # 2420 ) incorrect"); success := FALSE; end if; # SYMBOL FOR SPACE
    if isLetter('\16#02440;') <> FALSE then writeln("isLetter( # 2440 ) incorrect"); success := FALSE; end if; # OCR HOOK
    if isLetter('\16#02448;') <> FALSE then writeln("isLetter( # 2448 ) incorrect"); success := FALSE; end if; # OCR DASH
    if isLetter('\16#02460;') <> FALSE then writeln("isLetter( # 2460 ) incorrect"); success := FALSE; end if; # CIRCLED DIGIT ONE
    if isLetter('\16#02488;') <> FALSE then writeln("isLetter( # 2488 ) incorrect"); success := FALSE; end if; # DIGIT ONE FULL STOP
    if isLetter('\16#024b0;') <> FALSE then writeln("isLetter( # 24b0 ) incorrect"); success := FALSE; end if; # PARENTHESIZED LATIN SMALL LETTER U
    if isLetter('\16#02500;') <> FALSE then writeln("isLetter( # 2500 ) incorrect"); success := FALSE; end if; # BOX DRAWINGS LIGHT HORIZONTAL
    if isLetter('\16#02520;') <> FALSE then writeln("isLetter( # 2520 ) incorrect"); success := FALSE; end if; # BOX DRAWINGS VERTICAL HEAVY AND RIGHT LIGHT
    if isLetter('\16#02540;') <> FALSE then writeln("isLetter( # 2540 ) incorrect"); success := FALSE; end if; # BOX DRAWINGS UP HEAVY AND DOWN HORIZONTAL LIGHT
    if isLetter('\16#02560;') <> FALSE then writeln("isLetter( # 2560 ) incorrect"); success := FALSE; end if; # BOX DRAWINGS DOUBLE VERTICAL AND RIGHT
    if isLetter('\16#02580;') <> FALSE then writeln("isLetter( # 2580 ) incorrect"); success := FALSE; end if; # UPPER HALF BLOCK
    if isLetter('\16#02588;') <> FALSE then writeln("isLetter( # 2588 ) incorrect"); success := FALSE; end if; # FULL BLOCK
    if isLetter('\16#02590;') <> FALSE then writeln("isLetter( # 2590 ) incorrect"); success := FALSE; end if; # RIGHT HALF BLOCK
    if isLetter('\16#02598;') <> FALSE then writeln("isLetter( # 2598 ) incorrect"); success := FALSE; end if; # QUADRANT UPPER LEFT
    if isLetter('\16#025a0;') <> FALSE then writeln("isLetter( # 25a0 ) incorrect"); success := FALSE; end if; # BLACK SQUARE
    if isLetter('\16#025b8;') <> FALSE then writeln("isLetter( # 25b8 ) incorrect"); success := FALSE; end if; # BLACK RIGHT-POINTING SMALL TRIANGLE
    if isLetter('\16#025d0;') <> FALSE then writeln("isLetter( # 25d0 ) incorrect"); success := FALSE; end if; # CIRCLE WITH LEFT HALF BLACK
    if isLetter('\16#025e8;') <> FALSE then writeln("isLetter( # 25e8 ) incorrect"); success := FALSE; end if; # SQUARE WITH RIGHT HALF BLACK
    if isLetter('\16#02600;') <> FALSE then writeln("isLetter( # 2600 ) incorrect"); success := FALSE; end if; # BLACK SUN WITH RAYS
    if isLetter('\16#02640;') <> FALSE then writeln("isLetter( # 2640 ) incorrect"); success := FALSE; end if; # FEMALE SIGN
    if isLetter('\16#02680;') <> FALSE then writeln("isLetter( # 2680 ) incorrect"); success := FALSE; end if; # DIE FACE-1
    if isLetter('\16#026c0;') <> FALSE then writeln("isLetter( # 26c0 ) incorrect"); success := FALSE; end if; # WHITE DRAUGHTS MAN
    if isLetter('\16#02730;') <> FALSE then writeln("isLetter( # 2730 ) incorrect"); success := FALSE; end if; # SHADOWED WHITE STAR
    if isLetter('\16#02760;') <> FALSE then writeln("isLetter( # 2760 ) incorrect"); success := FALSE; end if; # HEAVY LOW DOUBLE COMMA QUOTATION MARK ORNAMENT
    if isLetter('\16#02790;') <> FALSE then writeln("isLetter( # 2790 ) incorrect"); success := FALSE; end if; # DINGBAT NEGATIVE CIRCLED SANS-SERIF DIGIT SEVEN
    if isLetter('\16#027c0;') <> FALSE then writeln("isLetter( # 27c0 ) incorrect"); success := FALSE; end if; # THREE DIMENSIONAL ANGLE
    if isLetter('\16#027cc;') <> FALSE then writeln("isLetter( # 27cc ) incorrect"); success := FALSE; end if; # LONG DIVISION
    if isLetter('\16#027d8;') <> FALSE then writeln("isLetter( # 27d8 ) incorrect"); success := FALSE; end if; # LARGE UP TACK
    if isLetter('\16#027e4;') <> FALSE then writeln("isLetter( # 27e4 ) incorrect"); success := FALSE; end if; # WHITE SQUARE WITH LEFTWARDS TICK
    if isLetter('\16#027f0;') <> FALSE then writeln("isLetter( # 27f0 ) incorrect"); success := FALSE; end if; # UPWARDS QUADRUPLE ARROW
    if isLetter('\16#027f4;') <> FALSE then writeln("isLetter( # 27f4 ) incorrect"); success := FALSE; end if; # RIGHT ARROW WITH CIRCLED PLUS
    if isLetter('\16#027f8;') <> FALSE then writeln("isLetter( # 27f8 ) incorrect"); success := FALSE; end if; # LONG LEFTWARDS DOUBLE ARROW
    if isLetter('\16#027fc;') <> FALSE then writeln("isLetter( # 27fc ) incorrect"); success := FALSE; end if; # LONG RIGHTWARDS ARROW FROM BAR
    if isLetter('\16#02800;') <> FALSE then writeln("isLetter( # 2800 ) incorrect"); success := FALSE; end if; # BRAILLE PATTERN BLANK
    if isLetter('\16#02840;') <> FALSE then writeln("isLetter( # 2840 ) incorrect"); success := FALSE; end if; # BRAILLE PATTERN DOTS-7
    if isLetter('\16#02880;') <> FALSE then writeln("isLetter( # 2880 ) incorrect"); success := FALSE; end if; # BRAILLE PATTERN DOTS-8
    if isLetter('\16#028c0;') <> FALSE then writeln("isLetter( # 28c0 ) incorrect"); success := FALSE; end if; # BRAILLE PATTERN DOTS-78
    if isLetter('\16#02900;') <> FALSE then writeln("isLetter( # 2900 ) incorrect"); success := FALSE; end if; # RIGHTWARDS TWO-HEADED ARROW WITH VERTICAL STROKE
    if isLetter('\16#02920;') <> FALSE then writeln("isLetter( # 2920 ) incorrect"); success := FALSE; end if; # RIGHTWARDS ARROW FROM BAR TO BLACK DIAMOND
    if isLetter('\16#02940;') <> FALSE then writeln("isLetter( # 2940 ) incorrect"); success := FALSE; end if; # ANTICLOCKWISE CLOSED CIRCLE ARROW
    if isLetter('\16#02960;') <> FALSE then writeln("isLetter( # 2960 ) incorrect"); success := FALSE; end if; # UPWARDS HARPOON WITH BARB LEFT FROM BAR
    if isLetter('\16#02980;') <> FALSE then writeln("isLetter( # 2980 ) incorrect"); success := FALSE; end if; # TRIPLE VERTICAL BAR DELIMITER
    if isLetter('\16#029a0;') <> FALSE then writeln("isLetter( # 29a0 ) incorrect"); success := FALSE; end if; # SPHERICAL ANGLE OPENING LEFT
    if isLetter('\16#029c0;') <> FALSE then writeln("isLetter( # 29c0 ) incorrect"); success := FALSE; end if; # CIRCLED LESS-THAN
    if isLetter('\16#029e0;') <> FALSE then writeln("isLetter( # 29e0 ) incorrect"); success := FALSE; end if; # SQUARE WITH CONTOURED OUTLINE
    if isLetter('\16#02a00;') <> FALSE then writeln("isLetter( # 2a00 ) incorrect"); success := FALSE; end if; # N-ARY CIRCLED DOT OPERATOR
    if isLetter('\16#02a40;') <> FALSE then writeln("isLetter( # 2a40 ) incorrect"); success := FALSE; end if; # INTERSECTION WITH DOT
    if isLetter('\16#02a80;') <> FALSE then writeln("isLetter( # 2a80 ) incorrect"); success := FALSE; end if; # GREATER-THAN OR SLANTED EQUAL TO WITH DOT INSIDE
    if isLetter('\16#02ac0;') <> FALSE then writeln("isLetter( # 2ac0 ) incorrect"); success := FALSE; end if; # SUPERSET WITH PLUS SIGN BELOW
    if isLetter('\16#02b00;') <> FALSE then writeln("isLetter( # 2b00 ) incorrect"); success := FALSE; end if; # NORTH EAST WHITE ARROW
    if isLetter('\16#02b40;') <> FALSE then writeln("isLetter( # 2b40 ) incorrect"); success := FALSE; end if; # EQUALS SIGN ABOVE LEFTWARDS ARROW
    if isLetter('\16#02e00;') <> FALSE then writeln("isLetter( # 2e00 ) incorrect"); success := FALSE; end if; # RIGHT ANGLE SUBSTITUTION MARKER
    if isLetter('\16#02e20;') <> FALSE then writeln("isLetter( # 2e20 ) incorrect"); success := FALSE; end if; # LEFT VERTICAL BAR WITH QUILL
    if isLetter('\16#02e80;') <> FALSE then writeln("isLetter( # 2e80 ) incorrect"); success := FALSE; end if; # CJK RADICAL REPEAT
    if isLetter('\16#02ea0;') <> FALSE then writeln("isLetter( # 2ea0 ) incorrect"); success := FALSE; end if; # CJK RADICAL CIVILIAN
    if isLetter('\16#02ec0;') <> FALSE then writeln("isLetter( # 2ec0 ) incorrect"); success := FALSE; end if; # CJK RADICAL GRASS THREE
    if isLetter('\16#02ee0;') <> FALSE then writeln("isLetter( # 2ee0 ) incorrect"); success := FALSE; end if; # CJK RADICAL C-SIMPLIFIED EAT
    if isLetter('\16#02f00;') <> FALSE then writeln("isLetter( # 2f00 ) incorrect"); success := FALSE; end if; # KANGXI RADICAL ONE
    if isLetter('\16#02f38;') <> FALSE then writeln("isLetter( # 2f38 ) incorrect"); success := FALSE; end if; # KANGXI RADICAL BOW
    if isLetter('\16#02f70;') <> FALSE then writeln("isLetter( # 2f70 ) incorrect"); success := FALSE; end if; # KANGXI RADICAL SPIRIT
    if isLetter('\16#02fa8;') <> FALSE then writeln("isLetter( # 2fa8 ) incorrect"); success := FALSE; end if; # KANGXI RADICAL GATE
    if isLetter('\16#02ff0;') <> FALSE then writeln("isLetter( # 2ff0 ) incorrect"); success := FALSE; end if; # IDEOGRAPHIC DESCRIPTION CHARACTER LEFT TO RIGHT
    if isLetter('\16#02ff4;') <> FALSE then writeln("isLetter( # 2ff4 ) incorrect"); success := FALSE; end if; # IDEOGRAPHIC DESCRIPTION CHARACTER FULL SURROUND
    if isLetter('\16#02ff8;') <> FALSE then writeln("isLetter( # 2ff8 ) incorrect"); success := FALSE; end if; # IDEOGRAPHIC DESCRIPTION CHARACTER SURROUND FROM UPPER LEFT
    if isLetter('\16#03000;') <> FALSE then writeln("isLetter( # 3000 ) incorrect"); success := FALSE; end if; # IDEOGRAPHIC SPACE
    if isLetter('\16#03010;') <> FALSE then writeln("isLetter( # 3010 ) incorrect"); success := FALSE; end if; # LEFT BLACK LENTICULAR BRACKET
    if isLetter('\16#03020;') <> FALSE then writeln("isLetter( # 3020 ) incorrect"); success := FALSE; end if; # POSTAL MARK FACE
    if isLetter('\16#03030;') <> FALSE then writeln("isLetter( # 3030 ) incorrect"); success := FALSE; end if; # WAVY DASH
    if isLetter('\16#03058;') <> TRUE  then writeln("isLetter( # 3058 ) incorrect"); success := FALSE; end if; # HIRAGANA LETTER ZI
    if isLetter('\16#03070;') <> TRUE  then writeln("isLetter( # 3070 ) incorrect"); success := FALSE; end if; # HIRAGANA LETTER BA
    if isLetter('\16#03088;') <> TRUE  then writeln("isLetter( # 3088 ) incorrect"); success := FALSE; end if; # HIRAGANA LETTER YO
    if isLetter('\16#030a0;') <> FALSE then writeln("isLetter( # 30a0 ) incorrect"); success := FALSE; end if; # KATAKANA-HIRAGANA DOUBLE HYPHEN
    if isLetter('\16#030b8;') <> TRUE  then writeln("isLetter( # 30b8 ) incorrect"); success := FALSE; end if; # KATAKANA LETTER ZI
    if isLetter('\16#030d0;') <> TRUE  then writeln("isLetter( # 30d0 ) incorrect"); success := FALSE; end if; # KATAKANA LETTER BA
    if isLetter('\16#030e8;') <> TRUE  then writeln("isLetter( # 30e8 ) incorrect"); success := FALSE; end if; # KATAKANA LETTER YO
    if isLetter('\16#0310c;') <> TRUE  then writeln("isLetter( # 310c ) incorrect"); success := FALSE; end if; # BOPOMOFO LETTER L
    if isLetter('\16#03118;') <> TRUE  then writeln("isLetter( # 3118 ) incorrect"); success := FALSE; end if; # BOPOMOFO LETTER C
    if isLetter('\16#03124;') <> TRUE  then writeln("isLetter( # 3124 ) incorrect"); success := FALSE; end if; # BOPOMOFO LETTER ANG
    if isLetter('\16#03148;') <> TRUE  then writeln("isLetter( # 3148 ) incorrect"); success := FALSE; end if; # HANGUL LETTER CIEUC
    if isLetter('\16#03160;') <> TRUE  then writeln("isLetter( # 3160 ) incorrect"); success := FALSE; end if; # HANGUL LETTER YU
    if isLetter('\16#03178;') <> TRUE  then writeln("isLetter( # 3178 ) incorrect"); success := FALSE; end if; # HANGUL LETTER KAPYEOUNPIEUP
    if isLetter('\16#03190;') <> FALSE then writeln("isLetter( # 3190 ) incorrect"); success := FALSE; end if; # IDEOGRAPHIC ANNOTATION LINKING MARK
    if isLetter('\16#03194;') <> FALSE then writeln("isLetter( # 3194 ) incorrect"); success := FALSE; end if; # IDEOGRAPHIC ANNOTATION THREE MARK
    if isLetter('\16#03198;') <> FALSE then writeln("isLetter( # 3198 ) incorrect"); success := FALSE; end if; # IDEOGRAPHIC ANNOTATION BOTTOM MARK
    if isLetter('\16#0319c;') <> FALSE then writeln("isLetter( # 319c ) incorrect"); success := FALSE; end if; # IDEOGRAPHIC ANNOTATION FOURTH MARK
    if isLetter('\16#031a0;') <> TRUE  then writeln("isLetter( # 31a0 ) incorrect"); success := FALSE; end if; # BOPOMOFO LETTER BU
    if isLetter('\16#031a8;') <> TRUE  then writeln("isLetter( # 31a8 ) incorrect"); success := FALSE; end if; # BOPOMOFO LETTER IR
    if isLetter('\16#031b0;') <> TRUE  then writeln("isLetter( # 31b0 ) incorrect"); success := FALSE; end if; # BOPOMOFO LETTER AM
    if isLetter('\16#031c0;') <> FALSE then writeln("isLetter( # 31c0 ) incorrect"); success := FALSE; end if; # CJK STROKE T
    if isLetter('\16#031cc;') <> FALSE then writeln("isLetter( # 31cc ) incorrect"); success := FALSE; end if; # CJK STROKE HPWG
    if isLetter('\16#031d8;') <> FALSE then writeln("isLetter( # 31d8 ) incorrect"); success := FALSE; end if; # CJK STROKE SWZ
    if isLetter('\16#031f0;') <> TRUE  then writeln("isLetter( # 31f0 ) incorrect"); success := FALSE; end if; # KATAKANA LETTER SMALL KU
    if isLetter('\16#031f4;') <> TRUE  then writeln("isLetter( # 31f4 ) incorrect"); success := FALSE; end if; # KATAKANA LETTER SMALL NU
    if isLetter('\16#031f8;') <> TRUE  then writeln("isLetter( # 31f8 ) incorrect"); success := FALSE; end if; # KATAKANA LETTER SMALL HE
    if isLetter('\16#031fc;') <> TRUE  then writeln("isLetter( # 31fc ) incorrect"); success := FALSE; end if; # KATAKANA LETTER SMALL RI
    if isLetter('\16#03200;') <> FALSE then writeln("isLetter( # 3200 ) incorrect"); success := FALSE; end if; # PARENTHESIZED HANGUL KIYEOK
    if isLetter('\16#03240;') <> FALSE then writeln("isLetter( # 3240 ) incorrect"); success := FALSE; end if; # PARENTHESIZED IDEOGRAPH FESTIVAL
    if isLetter('\16#03280;') <> FALSE then writeln("isLetter( # 3280 ) incorrect"); success := FALSE; end if; # CIRCLED IDEOGRAPH ONE
    if isLetter('\16#032c0;') <> FALSE then writeln("isLetter( # 32c0 ) incorrect"); success := FALSE; end if; # IDEOGRAPHIC TELEGRAPH SYMBOL FOR JANUARY
    if isLetter('\16#03300;') <> FALSE then writeln("isLetter( # 3300 ) incorrect"); success := FALSE; end if; # SQUARE APAATO
    if isLetter('\16#03340;') <> FALSE then writeln("isLetter( # 3340 ) incorrect"); success := FALSE; end if; # SQUARE PONDO
    if isLetter('\16#03380;') <> FALSE then writeln("isLetter( # 3380 ) incorrect"); success := FALSE; end if; # SQUARE PA AMPS
    if isLetter('\16#033c0;') <> FALSE then writeln("isLetter( # 33c0 ) incorrect"); success := FALSE; end if; # SQUARE K OHM
    if isLetter('\16#03400;') <> TRUE  then writeln("isLetter( # 3400 ) incorrect"); success := FALSE; end if; # CJK UNIFIED IDEOGRAPH-3400
    if isLetter('\16#03a70;') <> TRUE  then writeln("isLetter( # 3a70 ) incorrect"); success := FALSE; end if; # CJK UNIFIED IDEOGRAPH-3A70
    if isLetter('\16#040e0;') <> TRUE  then writeln("isLetter( # 40e0 ) incorrect"); success := FALSE; end if; # CJK UNIFIED IDEOGRAPH-40E0
    if isLetter('\16#04750;') <> TRUE  then writeln("isLetter( # 4750 ) incorrect"); success := FALSE; end if; # CJK UNIFIED IDEOGRAPH-4750
    if isLetter('\16#04dc0;') <> FALSE then writeln("isLetter( # 4dc0 ) incorrect"); success := FALSE; end if; # HEXAGRAM FOR THE CREATIVE HEAVEN
    if isLetter('\16#04dd0;') <> FALSE then writeln("isLetter( # 4dd0 ) incorrect"); success := FALSE; end if; # HEXAGRAM FOR FOLLOWING
    if isLetter('\16#04de0;') <> FALSE then writeln("isLetter( # 4de0 ) incorrect"); success := FALSE; end if; # HEXAGRAM FOR RETREAT
    if isLetter('\16#04df0;') <> FALSE then writeln("isLetter( # 4df0 ) incorrect"); success := FALSE; end if; # HEXAGRAM FOR REVOLUTION
    if isLetter('\16#04e00;') <> TRUE  then writeln("isLetter( # 4e00 ) incorrect"); success := FALSE; end if; # CJK UNIFIED IDEOGRAPH-4E00
    if isLetter('\16#04e2d;') <> TRUE  then writeln("isLetter( # 4e2d ) incorrect"); success := FALSE; end if; # CJK UNIFIED IDEOGRAPH-4E2D
    if isLetter('\16#06280;') <> TRUE  then writeln("isLetter( # 6280 ) incorrect"); success := FALSE; end if; # CJK UNIFIED IDEOGRAPH-6280
    if isLetter('\16#07700;') <> TRUE  then writeln("isLetter( # 7700 ) incorrect"); success := FALSE; end if; # CJK UNIFIED IDEOGRAPH-7700
    if isLetter('\16#08b80;') <> TRUE  then writeln("isLetter( # 8b80 ) incorrect"); success := FALSE; end if; # CJK UNIFIED IDEOGRAPH-8B80
    if isLetter('\16#0a000;') <> TRUE  then writeln("isLetter( # a000 ) incorrect"); success := FALSE; end if; # YI SYLLABLE IT
    if isLetter('\16#0a124;') <> TRUE  then writeln("isLetter( # a124 ) incorrect"); success := FALSE; end if; # YI SYLLABLE TAP
    if isLetter('\16#0a248;') <> TRUE  then writeln("isLetter( # a248 ) incorrect"); success := FALSE; end if; # YI SYLLABLE HXI
    if isLetter('\16#0a36c;') <> TRUE  then writeln("isLetter( # a36c ) incorrect"); success := FALSE; end if; # YI SYLLABLE CHOP
    if isLetter('\16#0a490;') <> FALSE then writeln("isLetter( # a490 ) incorrect"); success := FALSE; end if; # YI RADICAL QOT
    if isLetter('\16#0a4a0;') <> FALSE then writeln("isLetter( # a4a0 ) incorrect"); success := FALSE; end if; # YI RADICAL TAT
    if isLetter('\16#0a4b0;') <> FALSE then writeln("isLetter( # a4b0 ) incorrect"); success := FALSE; end if; # YI RADICAL SHY
    if isLetter('\16#0a4c0;') <> FALSE then writeln("isLetter( # a4c0 ) incorrect"); success := FALSE; end if; # YI RADICAL SHAT
    if isLetter('\16#0a670;') <> FALSE then writeln("isLetter( # a670 ) incorrect"); success := FALSE; end if; # COMBINING CYRILLIC TEN MILLIONS SIGN
    if isLetter('\16#0a700;') <> FALSE then writeln("isLetter( # a700 ) incorrect"); success := FALSE; end if; # MODIFIER LETTER CHINESE TONE YIN PING
    if isLetter('\16#0a708;') <> FALSE then writeln("isLetter( # a708 ) incorrect"); success := FALSE; end if; # MODIFIER LETTER EXTRA-HIGH DOTTED TONE BAR
    if isLetter('\16#0a710;') <> FALSE then writeln("isLetter( # a710 ) incorrect"); success := FALSE; end if; # MODIFIER LETTER LOW DOTTED LEFT-STEM TONE BAR
    if isLetter('\16#0a720;') <> FALSE then writeln("isLetter( # a720 ) incorrect"); success := FALSE; end if; # MODIFIER LETTER STRESS AND HIGH TONE
    if isLetter('\16#0a830;') <> FALSE then writeln("isLetter( # a830 ) incorrect"); success := FALSE; end if; # NORTH INDIC FRACTION ONE QUARTER
    if isLetter('\16#0a834;') <> FALSE then writeln("isLetter( # a834 ) incorrect"); success := FALSE; end if; # NORTH INDIC FRACTION ONE EIGHTH
    if isLetter('\16#0a838;') <> FALSE then writeln("isLetter( # a838 ) incorrect"); success := FALSE; end if; # NORTH INDIC RUPEE MARK
    if isLetter('\16#0a8e0;') <> FALSE then writeln("isLetter( # a8e0 ) incorrect"); success := FALSE; end if; # COMBINING DEVANAGARI DIGIT ZERO
    if isLetter('\16#0a8e8;') <> FALSE then writeln("isLetter( # a8e8 ) incorrect"); success := FALSE; end if; # COMBINING DEVANAGARI DIGIT EIGHT
    if isLetter('\16#0a8f0;') <> FALSE then writeln("isLetter( # a8f0 ) incorrect"); success := FALSE; end if; # COMBINING DEVANAGARI LETTER VI
    if isLetter('\16#0a8f8;') <> FALSE then writeln("isLetter( # a8f8 ) incorrect"); success := FALSE; end if; # DEVANAGARI SIGN PUSHPIKA
    if isLetter('\16#0a900;') <> FALSE then writeln("isLetter( # a900 ) incorrect"); success := FALSE; end if; # KAYAH LI DIGIT ZERO
    if isLetter('\16#0abf0;') <> FALSE then writeln("isLetter( # abf0 ) incorrect"); success := FALSE; end if; # MEETEI MAYEK DIGIT ZERO
    if isLetter('\16#0ac00;') <> TRUE  then writeln("isLetter( # ac00 ) incorrect"); success := FALSE; end if; # HANGUL SYLLABLE GA
    if isLetter('\16#0b6ec;') <> TRUE  then writeln("isLetter( # b6ec ) incorrect"); success := FALSE; end if; # HANGUL SYLLABLE DDWEK
    if isLetter('\16#0c1d8;') <> TRUE  then writeln("isLetter( # c1d8 ) incorrect"); success := FALSE; end if; # HANGUL SYLLABLE SWAESS
    if isLetter('\16#0ccc4;') <> TRUE  then writeln("isLetter( # ccc4 ) incorrect"); success := FALSE; end if; # HANGUL SYLLABLE CEM
    if isLetter('\16#0d800;') <> FALSE then writeln("isLetter( # d800 ) incorrect"); success := FALSE; end if; # <lead surrogate-D800>
    if isLetter('\16#0d8e0;') <> FALSE then writeln("isLetter( # d8e0 ) incorrect"); success := FALSE; end if; # <lead surrogate-D8E0>
    if isLetter('\16#0d9c0;') <> FALSE then writeln("isLetter( # d9c0 ) incorrect"); success := FALSE; end if; # <lead surrogate-D9C0>
    if isLetter('\16#0daa0;') <> FALSE then writeln("isLetter( # daa0 ) incorrect"); success := FALSE; end if; # <lead surrogate-DAA0>
    if isLetter('\16#0db80;') <> FALSE then writeln("isLetter( # db80 ) incorrect"); success := FALSE; end if; # <lead surrogate-DB80>
    if isLetter('\16#0dba0;') <> FALSE then writeln("isLetter( # dba0 ) incorrect"); success := FALSE; end if; # <lead surrogate-DBA0>
    if isLetter('\16#0dbc0;') <> FALSE then writeln("isLetter( # dbc0 ) incorrect"); success := FALSE; end if; # <lead surrogate-DBC0>
    if isLetter('\16#0dbe0;') <> FALSE then writeln("isLetter( # dbe0 ) incorrect"); success := FALSE; end if; # <lead surrogate-DBE0>
    if isLetter('\16#0dc00;') <> FALSE then writeln("isLetter( # dc00 ) incorrect"); success := FALSE; end if; # <trail surrogate-DC00>
    if isLetter('\16#0dd00;') <> FALSE then writeln("isLetter( # dd00 ) incorrect"); success := FALSE; end if; # <trail surrogate-DD00>
    if isLetter('\16#0de00;') <> FALSE then writeln("isLetter( # de00 ) incorrect"); success := FALSE; end if; # <trail surrogate-DE00>
    if isLetter('\16#0df00;') <> FALSE then writeln("isLetter( # df00 ) incorrect"); success := FALSE; end if; # <trail surrogate-DF00>
    if isLetter('\16#0e000;') <> FALSE then writeln("isLetter( # e000 ) incorrect"); success := FALSE; end if; # <private use area-E000>
    if isLetter('\16#0e640;') <> FALSE then writeln("isLetter( # e640 ) incorrect"); success := FALSE; end if; # <private use area-E640>
    if isLetter('\16#0ec80;') <> FALSE then writeln("isLetter( # ec80 ) incorrect"); success := FALSE; end if; # <private use area-EC80>
    if isLetter('\16#0f2c0;') <> FALSE then writeln("isLetter( # f2c0 ) incorrect"); success := FALSE; end if; # <private use area-F2C0>
    if isLetter('\16#0f900;') <> TRUE  then writeln("isLetter( # f900 ) incorrect"); success := FALSE; end if; # CJK COMPATIBILITY IDEOGRAPH-F900
    if isLetter('\16#0f980;') <> TRUE  then writeln("isLetter( # f980 ) incorrect"); success := FALSE; end if; # CJK COMPATIBILITY IDEOGRAPH-F980
    if isLetter('\16#0fa00;') <> TRUE  then writeln("isLetter( # fa00 ) incorrect"); success := FALSE; end if; # CJK COMPATIBILITY IDEOGRAPH-FA00
    if isLetter('\16#0fb00;') <> TRUE  then writeln("isLetter( # fb00 ) incorrect"); success := FALSE; end if; # LATIN SMALL LIGATURE FF
    if isLetter('\16#0fb14;') <> TRUE  then writeln("isLetter( # fb14 ) incorrect"); success := FALSE; end if; # ARMENIAN SMALL LIGATURE MEN ECH
    if isLetter('\16#0fb28;') <> TRUE  then writeln("isLetter( # fb28 ) incorrect"); success := FALSE; end if; # HEBREW LETTER WIDE TAV
    if isLetter('\16#0fb3c;') <> TRUE  then writeln("isLetter( # fb3c ) incorrect"); success := FALSE; end if; # HEBREW LETTER LAMED WITH DAGESH
    if isLetter('\16#0fb50;') <> TRUE  then writeln("isLetter( # fb50 ) incorrect"); success := FALSE; end if; # ARABIC LETTER ALEF WASLA ISOLATED FORM
    if isLetter('\16#0fbfc;') <> TRUE  then writeln("isLetter( # fbfc ) incorrect"); success := FALSE; end if; # ARABIC LETTER FARSI YEH ISOLATED FORM
    if isLetter('\16#0fca8;') <> TRUE  then writeln("isLetter( # fca8 ) incorrect"); success := FALSE; end if; # ARABIC LIGATURE JEEM WITH MEEM INITIAL FORM
    if isLetter('\16#0fd54;') <> TRUE  then writeln("isLetter( # fd54 ) incorrect"); success := FALSE; end if; # ARABIC LIGATURE TEH WITH KHAH WITH MEEM INITIAL FORM
    if isLetter('\16#0fe00;') <> FALSE then writeln("isLetter( # fe00 ) incorrect"); success := FALSE; end if; # VARIATION SELECTOR-1
    if isLetter('\16#0fe04;') <> FALSE then writeln("isLetter( # fe04 ) incorrect"); success := FALSE; end if; # VARIATION SELECTOR-5
    if isLetter('\16#0fe08;') <> FALSE then writeln("isLetter( # fe08 ) incorrect"); success := FALSE; end if; # VARIATION SELECTOR-9
    if isLetter('\16#0fe0c;') <> FALSE then writeln("isLetter( # fe0c ) incorrect"); success := FALSE; end if; # VARIATION SELECTOR-13
    if isLetter('\16#0fe10;') <> FALSE then writeln("isLetter( # fe10 ) incorrect"); success := FALSE; end if; # PRESENTATION FORM FOR VERTICAL COMMA
    if isLetter('\16#0fe14;') <> FALSE then writeln("isLetter( # fe14 ) incorrect"); success := FALSE; end if; # PRESENTATION FORM FOR VERTICAL SEMICOLON
    if isLetter('\16#0fe18;') <> FALSE then writeln("isLetter( # fe18 ) incorrect"); success := FALSE; end if; # PRESENTATION FORM FOR VERTICAL RIGHT WHITE LENTICULAR BRAKCET
    if isLetter('\16#0fe20;') <> FALSE then writeln("isLetter( # fe20 ) incorrect"); success := FALSE; end if; # COMBINING LIGATURE LEFT HALF
    if isLetter('\16#0fe24;') <> FALSE then writeln("isLetter( # fe24 ) incorrect"); success := FALSE; end if; # COMBINING MACRON LEFT HALF
    if isLetter('\16#0fe30;') <> FALSE then writeln("isLetter( # fe30 ) incorrect"); success := FALSE; end if; # PRESENTATION FORM FOR VERTICAL TWO DOT LEADER
    if isLetter('\16#0fe38;') <> FALSE then writeln("isLetter( # fe38 ) incorrect"); success := FALSE; end if; # PRESENTATION FORM FOR VERTICAL RIGHT CURLY BRACKET
    if isLetter('\16#0fe40;') <> FALSE then writeln("isLetter( # fe40 ) incorrect"); success := FALSE; end if; # PRESENTATION FORM FOR VERTICAL RIGHT ANGLE BRACKET
    if isLetter('\16#0fe48;') <> FALSE then writeln("isLetter( # fe48 ) incorrect"); success := FALSE; end if; # PRESENTATION FORM FOR VERTICAL RIGHT SQUARE BRACKET
    if isLetter('\16#0fe50;') <> FALSE then writeln("isLetter( # fe50 ) incorrect"); success := FALSE; end if; # SMALL COMMA
    if isLetter('\16#0fe58;') <> FALSE then writeln("isLetter( # fe58 ) incorrect"); success := FALSE; end if; # SMALL EM DASH
    if isLetter('\16#0fe60;') <> FALSE then writeln("isLetter( # fe60 ) incorrect"); success := FALSE; end if; # SMALL AMPERSAND
    if isLetter('\16#0fe68;') <> FALSE then writeln("isLetter( # fe68 ) incorrect"); success := FALSE; end if; # SMALL REVERSE SOLIDUS
    if isLetter('\16#0fe70;') <> TRUE  then writeln("isLetter( # fe70 ) incorrect"); success := FALSE; end if; # ARABIC FATHATAN ISOLATED FORM
    if isLetter('\16#0fe94;') <> TRUE  then writeln("isLetter( # fe94 ) incorrect"); success := FALSE; end if; # ARABIC LETTER TEH MARBUTA FINAL FORM
    if isLetter('\16#0feb8;') <> TRUE  then writeln("isLetter( # feb8 ) incorrect"); success := FALSE; end if; # ARABIC LETTER SHEEN MEDIAL FORM
    if isLetter('\16#0fedc;') <> TRUE  then writeln("isLetter( # fedc ) incorrect"); success := FALSE; end if; # ARABIC LETTER KAF MEDIAL FORM
    if isLetter('\16#0ff3c;') <> FALSE then writeln("isLetter( # ff3c ) incorrect"); success := FALSE; end if; # FULLWIDTH REVERSE SOLIDUS
    if isLetter('\16#0ff78;') <> TRUE  then writeln("isLetter( # ff78 ) incorrect"); success := FALSE; end if; # HALFWIDTH KATAKANA LETTER KU
    if isLetter('\16#0ffb4;') <> TRUE  then writeln("isLetter( # ffb4 ) incorrect"); success := FALSE; end if; # HALFWIDTH HANGUL LETTER PIEUP-SIOS
    if isLetter('\16#0fffc;') <> FALSE then writeln("isLetter( # fffc ) incorrect"); success := FALSE; end if; # OBJECT REPLACEMENT CHARACTER
    if isLetter('\16#10000;') <> TRUE  then writeln("isLetter( #10000 ) incorrect"); success := FALSE; end if; # LINEAR B SYLLABLE B008 A
    if isLetter('\16#10020;') <> TRUE  then writeln("isLetter( #10020 ) incorrect"); success := FALSE; end if; # LINEAR B SYLLABLE B039 PI
    if isLetter('\16#10040;') <> TRUE  then writeln("isLetter( #10040 ) incorrect"); success := FALSE; end if; # LINEAR B SYLLABLE B025 A2
    if isLetter('\16#10080;') <> TRUE  then writeln("isLetter( #10080 ) incorrect"); success := FALSE; end if; # LINEAR B IDEOGRAM B100 MAN
    if isLetter('\16#100a0;') <> TRUE  then writeln("isLetter( #100a0 ) incorrect"); success := FALSE; end if; # LINEAR B IDEOGRAM B151 HORN
    if isLetter('\16#100c0;') <> TRUE  then writeln("isLetter( #100c0 ) incorrect"); success := FALSE; end if; # LINEAR B IDEOGRAM B185
    if isLetter('\16#100e0;') <> TRUE  then writeln("isLetter( #100e0 ) incorrect"); success := FALSE; end if; # LINEAR B IDEOGRAM VESSEL B201
    if isLetter('\16#10100;') <> FALSE then writeln("isLetter( #10100 ) incorrect"); success := FALSE; end if; # AEGEAN WORD SEPARATOR LINE
    if isLetter('\16#10110;') <> FALSE then writeln("isLetter( #10110 ) incorrect"); success := FALSE; end if; # AEGEAN NUMBER TEN
    if isLetter('\16#10120;') <> FALSE then writeln("isLetter( #10120 ) incorrect"); success := FALSE; end if; # AEGEAN NUMBER EIGHT HUNDRED
    if isLetter('\16#10130;') <> FALSE then writeln("isLetter( #10130 ) incorrect"); success := FALSE; end if; # AEGEAN NUMBER SIXTY THOUSAND
    if isLetter('\16#1017c;') <> FALSE then writeln("isLetter( #1017c ) incorrect"); success := FALSE; end if; # GREEK OBOL SIGN
    if isLetter('\16#10190;') <> FALSE then writeln("isLetter( #10190 ) incorrect"); success := FALSE; end if; # ROMAN SEXTANS SIGN
    if isLetter('\16#101d0;') <> FALSE then writeln("isLetter( #101d0 ) incorrect"); success := FALSE; end if; # PHAISTOS DISC SIGN PEDESTRIAN
    if isLetter('\16#101dc;') <> FALSE then writeln("isLetter( #101dc ) incorrect"); success := FALSE; end if; # PHAISTOS DISC SIGN CLUB
    if isLetter('\16#101e8;') <> FALSE then writeln("isLetter( #101e8 ) incorrect"); success := FALSE; end if; # PHAISTOS DISC SIGN SHIP
    if isLetter('\16#101f4;') <> FALSE then writeln("isLetter( #101f4 ) incorrect"); success := FALSE; end if; # PHAISTOS DISC SIGN PAPYRUS
    if isLetter('\16#10300;') <> TRUE  then writeln("isLetter( #10300 ) incorrect"); success := FALSE; end if; # OLD ITALIC LETTER A
    if isLetter('\16#1030c;') <> TRUE  then writeln("isLetter( #1030c ) incorrect"); success := FALSE; end if; # OLD ITALIC LETTER EM
    if isLetter('\16#10318;') <> TRUE  then writeln("isLetter( #10318 ) incorrect"); success := FALSE; end if; # OLD ITALIC LETTER PHE
    if isLetter('\16#10330;') <> TRUE  then writeln("isLetter( #10330 ) incorrect"); success := FALSE; end if; # GOTHIC LETTER AHSA
    if isLetter('\16#10338;') <> TRUE  then writeln("isLetter( #10338 ) incorrect"); success := FALSE; end if; # GOTHIC LETTER THIUTH
    if isLetter('\16#10340;') <> TRUE  then writeln("isLetter( #10340 ) incorrect"); success := FALSE; end if; # GOTHIC LETTER PAIRTHRA
    if isLetter('\16#10348;') <> TRUE  then writeln("isLetter( #10348 ) incorrect"); success := FALSE; end if; # GOTHIC LETTER HWAIR
    if isLetter('\16#10380;') <> TRUE  then writeln("isLetter( #10380 ) incorrect"); success := FALSE; end if; # UGARITIC LETTER ALPA
    if isLetter('\16#10388;') <> TRUE  then writeln("isLetter( #10388 ) incorrect"); success := FALSE; end if; # UGARITIC LETTER HOTA
    if isLetter('\16#10390;') <> TRUE  then writeln("isLetter( #10390 ) incorrect"); success := FALSE; end if; # UGARITIC LETTER NUN
    if isLetter('\16#10398;') <> TRUE  then writeln("isLetter( #10398 ) incorrect"); success := FALSE; end if; # UGARITIC LETTER THANNA
    if isLetter('\16#103d0;') <> FALSE then writeln("isLetter( #103d0 ) incorrect"); success := FALSE; end if; # OLD PERSIAN WORD DIVIDER
    if isLetter('\16#10400;') <> TRUE  then writeln("isLetter( #10400 ) incorrect"); success := FALSE; end if; # DESERET CAPITAL LETTER LONG I
    if isLetter('\16#10414;') <> TRUE  then writeln("isLetter( #10414 ) incorrect"); success := FALSE; end if; # DESERET CAPITAL LETTER DEE
    if isLetter('\16#10428;') <> TRUE  then writeln("isLetter( #10428 ) incorrect"); success := FALSE; end if; # DESERET SMALL LETTER LONG I
    if isLetter('\16#1043c;') <> TRUE  then writeln("isLetter( #1043c ) incorrect"); success := FALSE; end if; # DESERET SMALL LETTER DEE
    if isLetter('\16#10450;') <> TRUE  then writeln("isLetter( #10450 ) incorrect"); success := FALSE; end if; # SHAVIAN LETTER PEEP
    if isLetter('\16#1045c;') <> TRUE  then writeln("isLetter( #1045c ) incorrect"); success := FALSE; end if; # SHAVIAN LETTER GAG
    if isLetter('\16#10468;') <> TRUE  then writeln("isLetter( #10468 ) incorrect"); success := FALSE; end if; # SHAVIAN LETTER ASH
    if isLetter('\16#10474;') <> TRUE  then writeln("isLetter( #10474 ) incorrect"); success := FALSE; end if; # SHAVIAN LETTER OAK
    if isLetter('\16#10480;') <> TRUE  then writeln("isLetter( #10480 ) incorrect"); success := FALSE; end if; # OSMANYA LETTER ALEF
    if isLetter('\16#1048c;') <> TRUE  then writeln("isLetter( #1048c ) incorrect"); success := FALSE; end if; # OSMANYA LETTER GA
    if isLetter('\16#10498;') <> TRUE  then writeln("isLetter( #10498 ) incorrect"); success := FALSE; end if; # OSMANYA LETTER I
    if isLetter('\16#104a4;') <> FALSE then writeln("isLetter( #104a4 ) incorrect"); success := FALSE; end if; # OSMANYA DIGIT FOUR
    if isLetter('\16#10800;') <> TRUE  then writeln("isLetter( #10800 ) incorrect"); success := FALSE; end if; # CYPRIOT SYLLABLE A
    if isLetter('\16#10810;') <> TRUE  then writeln("isLetter( #10810 ) incorrect"); success := FALSE; end if; # CYPRIOT SYLLABLE LE
    if isLetter('\16#10820;') <> TRUE  then writeln("isLetter( #10820 ) incorrect"); success := FALSE; end if; # CYPRIOT SYLLABLE PI
    if isLetter('\16#10830;') <> TRUE  then writeln("isLetter( #10830 ) incorrect"); success := FALSE; end if; # CYPRIOT SYLLABLE TO
    if isLetter('\16#10858;') <> FALSE then writeln("isLetter( #10858 ) incorrect"); success := FALSE; end if; # IMPERIAL ARAMAIC NUMBER ONE
    if isLetter('\16#10918;') <> FALSE then writeln("isLetter( #10918 ) incorrect"); success := FALSE; end if; # PHOENICIAN NUMBER TWENTY
    if isLetter('\16#10b78;') <> FALSE then writeln("isLetter( #10b78 ) incorrect"); success := FALSE; end if; # INSCRIPTIONAL PAHLAVI NUMBER ONE
    if isLetter('\16#10e60;') <> FALSE then writeln("isLetter( #10e60 ) incorrect"); success := FALSE; end if; # RUMI DIGIT ONE
    if isLetter('\16#10e68;') <> FALSE then writeln("isLetter( #10e68 ) incorrect"); success := FALSE; end if; # RUMI DIGIT NINE
    if isLetter('\16#10e70;') <> FALSE then writeln("isLetter( #10e70 ) incorrect"); success := FALSE; end if; # RUMI NUMBER EIGHTY
    if isLetter('\16#10e78;') <> FALSE then writeln("isLetter( #10e78 ) incorrect"); success := FALSE; end if; # RUMI NUMBER SEVEN HUNDRED
    if isLetter('\16#11060;') <> FALSE then writeln("isLetter( #11060 ) incorrect"); success := FALSE; end if; # BRAHMI NUMBER SIXTY
    if isLetter('\16#11080;') <> FALSE then writeln("isLetter( #11080 ) incorrect"); success := FALSE; end if; # KAITHI SIGN CANDRABINDU
    if isLetter('\16#110bc;') <> FALSE then writeln("isLetter( #110bc ) incorrect"); success := FALSE; end if; # KAITHI ENUMERATION SIGN
    if isLetter('\16#1d000;') <> FALSE then writeln("isLetter( #1d000 ) incorrect"); success := FALSE; end if; # BYZANTINE MUSICAL SYMBOL PSILI
    if isLetter('\16#1d040;') <> FALSE then writeln("isLetter( #1d040 ) incorrect"); success := FALSE; end if; # BYZANTINE MUSICAL SYMBOL NANA
    if isLetter('\16#1d080;') <> FALSE then writeln("isLetter( #1d080 ) incorrect"); success := FALSE; end if; # BYZANTINE MUSICAL SYMBOL DIPLI ARCHAION
    if isLetter('\16#1d0c0;') <> FALSE then writeln("isLetter( #1d0c0 ) incorrect"); success := FALSE; end if; # BYZANTINE MUSICAL SYMBOL FTHORA DIATONIKI ZO
    if isLetter('\16#1d100;') <> FALSE then writeln("isLetter( #1d100 ) incorrect"); success := FALSE; end if; # MUSICAL SYMBOL SINGLE BARLINE
    if isLetter('\16#1d140;') <> FALSE then writeln("isLetter( #1d140 ) incorrect"); success := FALSE; end if; # MUSICAL SYMBOL THIRTY-SECOND REST
    if isLetter('\16#1d180;') <> FALSE then writeln("isLetter( #1d180 ) incorrect"); success := FALSE; end if; # MUSICAL SYMBOL COMBINING MARCATO-STACCATO
    if isLetter('\16#1d1c0;') <> FALSE then writeln("isLetter( #1d1c0 ) incorrect"); success := FALSE; end if; # MUSICAL SYMBOL FUSA BLACK
    if isLetter('\16#1d200;') <> FALSE then writeln("isLetter( #1d200 ) incorrect"); success := FALSE; end if; # GREEK VOCAL NOTATION SYMBOL-1
    if isLetter('\16#1d214;') <> FALSE then writeln("isLetter( #1d214 ) incorrect"); success := FALSE; end if; # GREEK VOCAL NOTATION SYMBOL-21
    if isLetter('\16#1d228;') <> FALSE then writeln("isLetter( #1d228 ) incorrect"); success := FALSE; end if; # GREEK INSTRUMENTAL NOTATION SYMBOL-18
    if isLetter('\16#1d23c;') <> FALSE then writeln("isLetter( #1d23c ) incorrect"); success := FALSE; end if; # GREEK INSTRUMENTAL NOTATION SYMBOL-49
    if isLetter('\16#1d300;') <> FALSE then writeln("isLetter( #1d300 ) incorrect"); success := FALSE; end if; # MONOGRAM FOR EARTH
    if isLetter('\16#1d318;') <> FALSE then writeln("isLetter( #1d318 ) incorrect"); success := FALSE; end if; # TETRAGRAM FOR FOLLOWING
    if isLetter('\16#1d330;') <> FALSE then writeln("isLetter( #1d330 ) incorrect"); success := FALSE; end if; # TETRAGRAM FOR ENCOUNTERS
    if isLetter('\16#1d348;') <> FALSE then writeln("isLetter( #1d348 ) incorrect"); success := FALSE; end if; # TETRAGRAM FOR DARKENING
    if isLetter('\16#1d360;') <> FALSE then writeln("isLetter( #1d360 ) incorrect"); success := FALSE; end if; # COUNTING ROD UNIT DIGIT ONE
    if isLetter('\16#1d368;') <> FALSE then writeln("isLetter( #1d368 ) incorrect"); success := FALSE; end if; # COUNTING ROD UNIT DIGIT NINE
    if isLetter('\16#1d370;') <> FALSE then writeln("isLetter( #1d370 ) incorrect"); success := FALSE; end if; # COUNTING ROD TENS DIGIT EIGHT
    if isLetter('\16#1d400;') <> TRUE  then writeln("isLetter( #1d400 ) incorrect"); success := FALSE; end if; # MATHEMATICAL BOLD CAPITAL A
    if isLetter('\16#1d500;') <> TRUE  then writeln("isLetter( #1d500 ) incorrect"); success := FALSE; end if; # MATHEMATICAL BOLD SCRIPT SMALL W
    if isLetter('\16#1d600;') <> TRUE  then writeln("isLetter( #1d600 ) incorrect"); success := FALSE; end if; # MATHEMATICAL SANS-SERIF BOLD SMALL S
    if isLetter('\16#1d700;') <> TRUE  then writeln("isLetter( #1d700 ) incorrect"); success := FALSE; end if; # MATHEMATICAL ITALIC SMALL EPSILON
    if isLetter('\16#1f000;') <> FALSE then writeln("isLetter( #1f000 ) incorrect"); success := FALSE; end if; # MAHJONG TILE EAST WIND
    if isLetter('\16#1f00c;') <> FALSE then writeln("isLetter( #1f00c ) incorrect"); success := FALSE; end if; # MAHJONG TILE SIX OF CHARACTERS
    if isLetter('\16#1f018;') <> FALSE then writeln("isLetter( #1f018 ) incorrect"); success := FALSE; end if; # MAHJONG TILE NINE OF BAMBOOS
    if isLetter('\16#1f024;') <> FALSE then writeln("isLetter( #1f024 ) incorrect"); success := FALSE; end if; # MAHJONG TILE BAMBOO
    if isLetter('\16#1f030;') <> FALSE then writeln("isLetter( #1f030 ) incorrect"); success := FALSE; end if; # DOMINO TILE HORIZONTAL BACK
    if isLetter('\16#1f04c;') <> FALSE then writeln("isLetter( #1f04c ) incorrect"); success := FALSE; end if; # DOMINO TILE HORIZONTAL-03-06
    if isLetter('\16#1f068;') <> FALSE then writeln("isLetter( #1f068 ) incorrect"); success := FALSE; end if; # DOMINO TILE VERTICAL-00-05
    if isLetter('\16#1f084;') <> FALSE then writeln("isLetter( #1f084 ) incorrect"); success := FALSE; end if; # DOMINO TILE VERTICAL-04-05
    if isLetter('\16#1f0a0;') <> FALSE then writeln("isLetter( #1f0a0 ) incorrect"); success := FALSE; end if; # PLAYING CARD BACK
    if isLetter('\16#1f0b8;') <> FALSE then writeln("isLetter( #1f0b8 ) incorrect"); success := FALSE; end if; # PLAYING CARD EIGHT OF HEARTS
    if isLetter('\16#1f100;') <> FALSE then writeln("isLetter( #1f100 ) incorrect"); success := FALSE; end if; # DIGIT ZERO FULL STOP
    if isLetter('\16#1f140;') <> FALSE then writeln("isLetter( #1f140 ) incorrect"); success := FALSE; end if; # SQUARED LATIN CAPITAL LETTER Q
    if isLetter('\16#1f180;') <> FALSE then writeln("isLetter( #1f180 ) incorrect"); success := FALSE; end if; # NEGATIVE SQUARED LATIN CAPITAL LETTER Q
    if isLetter('\16#1f200;') <> FALSE then writeln("isLetter( #1f200 ) incorrect"); success := FALSE; end if; # SQUARE HIRAGANA HOKA
    if isLetter('\16#1f240;') <> FALSE then writeln("isLetter( #1f240 ) incorrect"); success := FALSE; end if; # TORTOISE SHELL BRACKETED CJK UNIFIED IDEOGRAPH-672C
    if isLetter('\16#1f300;') <> FALSE then writeln("isLetter( #1f300 ) incorrect"); success := FALSE; end if; # CYCLONE
    if isLetter('\16#1f3c0;') <> FALSE then writeln("isLetter( #1f3c0 ) incorrect"); success := FALSE; end if; # BASKETBALL AND HOOP
    if isLetter('\16#1f480;') <> FALSE then writeln("isLetter( #1f480 ) incorrect"); success := FALSE; end if; # SKULL
    if isLetter('\16#1f614;') <> FALSE then writeln("isLetter( #1f614 ) incorrect"); success := FALSE; end if; # PENSIVE FACE
    if isLetter('\16#1f628;') <> FALSE then writeln("isLetter( #1f628 ) incorrect"); success := FALSE; end if; # FEARFUL FACE
    if isLetter('\16#1f63c;') <> FALSE then writeln("isLetter( #1f63c ) incorrect"); success := FALSE; end if; # CAT FACE WITH WRY SMILE
    if isLetter('\16#1f680;') <> FALSE then writeln("isLetter( #1f680 ) incorrect"); success := FALSE; end if; # ROCKET
    if isLetter('\16#1f6a0;') <> FALSE then writeln("isLetter( #1f6a0 ) incorrect"); success := FALSE; end if; # MOUNTAIN CABLEWAY
    if isLetter('\16#1f6c0;') <> FALSE then writeln("isLetter( #1f6c0 ) incorrect"); success := FALSE; end if; # BATH
    if isLetter('\16#1f700;') <> FALSE then writeln("isLetter( #1f700 ) incorrect"); success := FALSE; end if; # ALCHEMICAL SYMBOL FOR QUINTESSENCE
    if isLetter('\16#1f720;') <> FALSE then writeln("isLetter( #1f720 ) incorrect"); success := FALSE; end if; # ALCHEMICAL SYMBOL FOR COPPER ORE
    if isLetter('\16#1f740;') <> FALSE then writeln("isLetter( #1f740 ) incorrect"); success := FALSE; end if; # ALCHEMICAL SYMBOL FOR TARTAR-2
    if isLetter('\16#1f760;') <> FALSE then writeln("isLetter( #1f760 ) incorrect"); success := FALSE; end if; # ALCHEMICAL SYMBOL FOR DISTILL
    if isLetter('\16#20000;') <> TRUE  then writeln("isLetter( #20000 ) incorrect"); success := FALSE; end if; # CJK UNIFIED IDEOGRAPH-20000
    if isLetter('\16#229b8;') <> TRUE  then writeln("isLetter( #229b8 ) incorrect"); success := FALSE; end if; # CJK UNIFIED IDEOGRAPH-229B8
    if isLetter('\16#25370;') <> TRUE  then writeln("isLetter( #25370 ) incorrect"); success := FALSE; end if; # CJK UNIFIED IDEOGRAPH-25370
    if isLetter('\16#27d28;') <> TRUE  then writeln("isLetter( #27d28 ) incorrect"); success := FALSE; end if; # CJK UNIFIED IDEOGRAPH-27D28
    if isLetter('\16#2f800;') <> TRUE  then writeln("isLetter( #2f800 ) incorrect"); success := FALSE; end if; # CJK COMPATIBILITY IDEOGRAPH-2F800
    if isLetter('\16#2f888;') <> TRUE  then writeln("isLetter( #2f888 ) incorrect"); success := FALSE; end if; # CJK COMPATIBILITY IDEOGRAPH-2F888
    if isLetter('\16#2f910;') <> TRUE  then writeln("isLetter( #2f910 ) incorrect"); success := FALSE; end if; # CJK COMPATIBILITY IDEOGRAPH-2F910
    if isLetter('\16#2f998;') <> TRUE  then writeln("isLetter( #2f998 ) incorrect"); success := FALSE; end if; # CJK COMPATIBILITY IDEOGRAPH-2F998
    if isLetter('\16#e0020;') <> FALSE then writeln("isLetter( #e0020 ) incorrect"); success := FALSE; end if; # TAG SPACE
    if isLetter('\16#e0040;') <> FALSE then writeln("isLetter( #e0040 ) incorrect"); success := FALSE; end if; # TAG COMMERCIAL AT
    if isLetter('\16#e0060;') <> FALSE then writeln("isLetter( #e0060 ) incorrect"); success := FALSE; end if; # TAG GRAVE ACCENT
    if isLetter('\16#e0100;') <> FALSE then writeln("isLetter( #e0100 ) incorrect"); success := FALSE; end if; # VARIATION SELECTOR-17
    if isLetter('\16#e013c;') <> FALSE then writeln("isLetter( #e013c ) incorrect"); success := FALSE; end if; # VARIATION SELECTOR-77
    if success then
      writeln("isLetter function works correctly.");
    end if;
  end func;


const proc: check_width is func
  local
    var boolean: success is TRUE;
  begin
    if width('\16#00021;') <> 1 then writeln("width(#   21) incorrect"); success := FALSE; end if; # EXCLAMATION MARK
    if width('\16#00050;') <> 1 then writeln("width(#   50) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER P
    if width('\16#0007f;') <> 0 then writeln("width(#   7f) incorrect"); success := FALSE; end if; # DELETE
    if width('\16#00090;') <> 0 then writeln("width(#   90) incorrect"); success := FALSE; end if; # DEVICE CONTROL STRING
    if width('\16#000a1;') <> 1 then writeln("width(#   a1) incorrect"); success := FALSE; end if; # INVERTED EXCLAMATION MARK
    if width('\16#000a2;') <> 1 then writeln("width(#   a2) incorrect"); success := FALSE; end if; # CENT SIGN
    if width('\16#000a3;') <> 1 then writeln("width(#   a3) incorrect"); success := FALSE; end if; # POUND SIGN
    if width('\16#000a4;') <> 1 then writeln("width(#   a4) incorrect"); success := FALSE; end if; # CURRENCY SIGN
    if width('\16#000a5;') <> 1 then writeln("width(#   a5) incorrect"); success := FALSE; end if; # YEN SIGN
    if width('\16#000a6;') <> 1 then writeln("width(#   a6) incorrect"); success := FALSE; end if; # BROKEN BAR
    if width('\16#000a7;') <> 1 then writeln("width(#   a7) incorrect"); success := FALSE; end if; # SECTION SIGN
    if width('\16#000a9;') <> 1 then writeln("width(#   a9) incorrect"); success := FALSE; end if; # COPYRIGHT SIGN
    if width('\16#000aa;') <> 1 then writeln("width(#   aa) incorrect"); success := FALSE; end if; # FEMININE ORDINAL INDICATOR
    if width('\16#000ab;') <> 1 then writeln("width(#   ab) incorrect"); success := FALSE; end if; # LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
    if width('\16#000ac;') <> 1 then writeln("width(#   ac) incorrect"); success := FALSE; end if; # NOT SIGN
    if width('\16#000ae;') <> 1 then writeln("width(#   ae) incorrect"); success := FALSE; end if; # REGISTERED SIGN
    if width('\16#000b0;') <> 1 then writeln("width(#   b0) incorrect"); success := FALSE; end if; # DEGREE SIGN
    if width('\16#000b2;') <> 1 then writeln("width(#   b2) incorrect"); success := FALSE; end if; # SUPERSCRIPT TWO
    if width('\16#000b5;') <> 1 then writeln("width(#   b5) incorrect"); success := FALSE; end if; # MICRO SIGN
    if width('\16#000b6;') <> 1 then writeln("width(#   b6) incorrect"); success := FALSE; end if; # PILCROW SIGN
    if width('\16#000bb;') <> 1 then writeln("width(#   bb) incorrect"); success := FALSE; end if; # RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
    if width('\16#000bc;') <> 1 then writeln("width(#   bc) incorrect"); success := FALSE; end if; # VULGAR FRACTION ONE QUARTER
    if width('\16#000be;') <> 1 then writeln("width(#   be) incorrect"); success := FALSE; end if; # VULGAR FRACTION THREE QUARTERS
    if width('\16#000c0;') <> 1 then writeln("width(#   c0) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER A WITH GRAVE
    if width('\16#000c3;') <> 1 then writeln("width(#   c3) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER A WITH TILDE
    if width('\16#000c6;') <> 1 then writeln("width(#   c6) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER AE
    if width('\16#000c7;') <> 1 then writeln("width(#   c7) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER C WITH CEDILLA
    if width('\16#000cb;') <> 1 then writeln("width(#   cb) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER E WITH DIAERESIS
    if width('\16#000d0;') <> 1 then writeln("width(#   d0) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER ETH
    if width('\16#000d1;') <> 1 then writeln("width(#   d1) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER N WITH TILDE
    if width('\16#000d4;') <> 1 then writeln("width(#   d4) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER O WITH CIRCUMFLEX
    if width('\16#000d7;') <> 1 then writeln("width(#   d7) incorrect"); success := FALSE; end if; # MULTIPLICATION SIGN
    if width('\16#000d8;') <> 1 then writeln("width(#   d8) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER O WITH STROKE
    if width('\16#000d9;') <> 1 then writeln("width(#   d9) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER U WITH GRAVE
    if width('\16#000db;') <> 1 then writeln("width(#   db) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER U WITH CIRCUMFLEX
    if width('\16#000de;') <> 1 then writeln("width(#   de) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER THORN
    if width('\16#000e0;') <> 1 then writeln("width(#   e0) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER A WITH GRAVE
    if width('\16#000e2;') <> 1 then writeln("width(#   e2) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER A WITH CIRCUMFLEX
    if width('\16#000e4;') <> 1 then writeln("width(#   e4) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER A WITH DIAERESIS
    if width('\16#000e6;') <> 1 then writeln("width(#   e6) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER AE
    if width('\16#000e7;') <> 1 then writeln("width(#   e7) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER C WITH CEDILLA
    if width('\16#000e8;') <> 1 then writeln("width(#   e8) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER E WITH GRAVE
    if width('\16#000e9;') <> 1 then writeln("width(#   e9) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER E WITH ACUTE
    if width('\16#000eb;') <> 1 then writeln("width(#   eb) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER E WITH DIAERESIS
    if width('\16#000ec;') <> 1 then writeln("width(#   ec) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER I WITH GRAVE
    if width('\16#000ed;') <> 1 then writeln("width(#   ed) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER I WITH ACUTE
    if width('\16#000ee;') <> 1 then writeln("width(#   ee) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER I WITH CIRCUMFLEX
    if width('\16#000ef;') <> 1 then writeln("width(#   ef) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER I WITH DIAERESIS
    if width('\16#000f0;') <> 1 then writeln("width(#   f0) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER ETH
    if width('\16#000f1;') <> 1 then writeln("width(#   f1) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER N WITH TILDE
    if width('\16#000f2;') <> 1 then writeln("width(#   f2) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER O WITH GRAVE
    if width('\16#000f3;') <> 1 then writeln("width(#   f3) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER O WITH ACUTE
    if width('\16#000f4;') <> 1 then writeln("width(#   f4) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER O WITH CIRCUMFLEX
    if width('\16#000f5;') <> 1 then writeln("width(#   f5) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER O WITH TILDE
    if width('\16#000f7;') <> 1 then writeln("width(#   f7) incorrect"); success := FALSE; end if; # DIVISION SIGN
    if width('\16#000f9;') <> 1 then writeln("width(#   f9) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER U WITH GRAVE
    if width('\16#000fb;') <> 1 then writeln("width(#   fb) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER U WITH CIRCUMFLEX
    if width('\16#000fc;') <> 1 then writeln("width(#   fc) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER U WITH DIAERESIS
    if width('\16#000fd;') <> 1 then writeln("width(#   fd) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER Y WITH ACUTE
    if width('\16#000fe;') <> 1 then writeln("width(#   fe) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER THORN
    if width('\16#000ff;') <> 1 then writeln("width(#   ff) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER Y WITH DIAERESIS
    if width('\16#00100;') <> 1 then writeln("width(#  100) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER A WITH MACRON
    if width('\16#00101;') <> 1 then writeln("width(#  101) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER A WITH MACRON
    if width('\16#00102;') <> 1 then writeln("width(#  102) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER A WITH BREVE
    if width('\16#00109;') <> 1 then writeln("width(#  109) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER C WITH CIRCUMFLEX
    if width('\16#00111;') <> 1 then writeln("width(#  111) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER D WITH STROKE
    if width('\16#00112;') <> 1 then writeln("width(#  112) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER E WITH MACRON
    if width('\16#00113;') <> 1 then writeln("width(#  113) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER E WITH MACRON
    if width('\16#00114;') <> 1 then writeln("width(#  114) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER E WITH BREVE
    if width('\16#00117;') <> 1 then writeln("width(#  117) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER E WITH DOT ABOVE
    if width('\16#0011b;') <> 1 then writeln("width(#  11b) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER E WITH CARON
    if width('\16#0011c;') <> 1 then writeln("width(#  11c) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER G WITH CIRCUMFLEX
    if width('\16#00121;') <> 1 then writeln("width(#  121) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER G WITH DOT ABOVE
    if width('\16#00126;') <> 1 then writeln("width(#  126) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER H WITH STROKE
    if width('\16#00127;') <> 1 then writeln("width(#  127) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER H WITH STROKE
    if width('\16#00128;') <> 1 then writeln("width(#  128) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER I WITH TILDE
    if width('\16#00129;') <> 1 then writeln("width(#  129) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER I WITH TILDE
    if width('\16#0012b;') <> 1 then writeln("width(#  12b) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER I WITH MACRON
    if width('\16#0012c;') <> 1 then writeln("width(#  12c) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER I WITH BREVE
    if width('\16#0012e;') <> 1 then writeln("width(#  12e) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER I WITH OGONEK
    if width('\16#00131;') <> 1 then writeln("width(#  131) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER DOTLESS I
    if width('\16#00132;') <> 1 then writeln("width(#  132) incorrect"); success := FALSE; end if; # LATIN CAPITAL LIGATURE IJ
    if width('\16#00134;') <> 1 then writeln("width(#  134) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER J WITH CIRCUMFLEX
    if width('\16#00136;') <> 1 then writeln("width(#  136) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER K WITH CEDILLA
    if width('\16#00138;') <> 1 then writeln("width(#  138) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER KRA
    if width('\16#00139;') <> 1 then writeln("width(#  139) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER L WITH ACUTE
    if width('\16#0013c;') <> 1 then writeln("width(#  13c) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER L WITH CEDILLA
    if width('\16#0013f;') <> 1 then writeln("width(#  13f) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER L WITH MIDDLE DOT
    if width('\16#00141;') <> 1 then writeln("width(#  141) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER L WITH STROKE
    if width('\16#00143;') <> 1 then writeln("width(#  143) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER N WITH ACUTE
    if width('\16#00144;') <> 1 then writeln("width(#  144) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER N WITH ACUTE
    if width('\16#00145;') <> 1 then writeln("width(#  145) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER N WITH CEDILLA
    if width('\16#00146;') <> 1 then writeln("width(#  146) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER N WITH CEDILLA
    if width('\16#00148;') <> 1 then writeln("width(#  148) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER N WITH CARON
    if width('\16#0014a;') <> 1 then writeln("width(#  14a) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER ENG
    if width('\16#0014c;') <> 1 then writeln("width(#  14c) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER O WITH MACRON
    if width('\16#0014d;') <> 1 then writeln("width(#  14d) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER O WITH MACRON
    if width('\16#0014e;') <> 1 then writeln("width(#  14e) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER O WITH BREVE
    if width('\16#00150;') <> 1 then writeln("width(#  150) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER O WITH DOUBLE ACUTE
    if width('\16#00152;') <> 1 then writeln("width(#  152) incorrect"); success := FALSE; end if; # LATIN CAPITAL LIGATURE OE
    if width('\16#00153;') <> 1 then writeln("width(#  153) incorrect"); success := FALSE; end if; # LATIN SMALL LIGATURE OE
    if width('\16#00154;') <> 1 then writeln("width(#  154) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER R WITH ACUTE
    if width('\16#0015d;') <> 1 then writeln("width(#  15d) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER S WITH CIRCUMFLEX
    if width('\16#00166;') <> 1 then writeln("width(#  166) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER T WITH STROKE
    if width('\16#00167;') <> 1 then writeln("width(#  167) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER T WITH STROKE
    if width('\16#00168;') <> 1 then writeln("width(#  168) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER U WITH TILDE
    if width('\16#00169;') <> 1 then writeln("width(#  169) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER U WITH TILDE
    if width('\16#0016b;') <> 1 then writeln("width(#  16b) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER U WITH MACRON
    if width('\16#0016c;') <> 1 then writeln("width(#  16c) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER U WITH BREVE
    if width('\16#0019d;') <> 1 then writeln("width(#  19d) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER N WITH LEFT HOOK
    if width('\16#001ce;') <> 1 then writeln("width(#  1ce) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER A WITH CARON
    if width('\16#001cf;') <> 1 then writeln("width(#  1cf) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER I WITH CARON
    if width('\16#001d0;') <> 1 then writeln("width(#  1d0) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER I WITH CARON
    if width('\16#001d1;') <> 1 then writeln("width(#  1d1) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER O WITH CARON
    if width('\16#001d2;') <> 1 then writeln("width(#  1d2) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER O WITH CARON
    if width('\16#001d3;') <> 1 then writeln("width(#  1d3) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER U WITH CARON
    if width('\16#001d4;') <> 1 then writeln("width(#  1d4) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER U WITH CARON
    if width('\16#001d5;') <> 1 then writeln("width(#  1d5) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER U WITH DIAERESIS AND MACRON
    if width('\16#001d6;') <> 1 then writeln("width(#  1d6) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER U WITH DIAERESIS AND MACRON
    if width('\16#001d7;') <> 1 then writeln("width(#  1d7) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER U WITH DIAERESIS AND ACUTE
    if width('\16#001d8;') <> 1 then writeln("width(#  1d8) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER U WITH DIAERESIS AND ACUTE
    if width('\16#001d9;') <> 1 then writeln("width(#  1d9) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER U WITH DIAERESIS AND CARON
    if width('\16#001da;') <> 1 then writeln("width(#  1da) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER U WITH DIAERESIS AND CARON
    if width('\16#001db;') <> 1 then writeln("width(#  1db) incorrect"); success := FALSE; end if; # LATIN CAPITAL LETTER U WITH DIAERESIS AND GRAVE
    if width('\16#001dc;') <> 1 then writeln("width(#  1dc) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER U WITH DIAERESIS AND GRAVE
    if width('\16#001dd;') <> 1 then writeln("width(#  1dd) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER TURNED E
    if width('\16#00217;') <> 1 then writeln("width(#  217) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER U WITH INVERTED BREVE
    if width('\16#00251;') <> 1 then writeln("width(#  251) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER ALPHA
    if width('\16#00252;') <> 1 then writeln("width(#  252) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER TURNED ALPHA
    if width('\16#00259;') <> 1 then writeln("width(#  259) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER SCHWA
    if width('\16#00261;') <> 1 then writeln("width(#  261) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER SCRIPT G
    if width('\16#00262;') <> 1 then writeln("width(#  262) incorrect"); success := FALSE; end if; # LATIN LETTER SMALL CAPITAL G
    if width('\16#00293;') <> 1 then writeln("width(#  293) incorrect"); success := FALSE; end if; # LATIN SMALL LETTER EZH WITH CURL
    if width('\16#00300;') <> 0 then writeln("width(#  300) incorrect"); success := FALSE; end if; # COMBINING GRAVE ACCENT
    if width('\16#00338;') <> 0 then writeln("width(#  338) incorrect"); success := FALSE; end if; # COMBINING LONG SOLIDUS OVERLAY
    if width('\16#00370;') <> 1 then writeln("width(#  370) incorrect"); success := FALSE; end if; # GREEK CAPITAL LETTER HETA
    if width('\16#00380;') <> 1 then writeln("width(#  380) incorrect"); success := FALSE; end if; # <unassigned-0380>
    if width('\16#00391;') <> 1 then writeln("width(#  391) incorrect"); success := FALSE; end if; # GREEK CAPITAL LETTER ALPHA
    if width('\16#00399;') <> 1 then writeln("width(#  399) incorrect"); success := FALSE; end if; # GREEK CAPITAL LETTER IOTA
    if width('\16#003a2;') <> 1 then writeln("width(#  3a2) incorrect"); success := FALSE; end if; # <unassigned-03A2>
    if width('\16#003a3;') <> 1 then writeln("width(#  3a3) incorrect"); success := FALSE; end if; # GREEK CAPITAL LETTER SIGMA
    if width('\16#003a6;') <> 1 then writeln("width(#  3a6) incorrect"); success := FALSE; end if; # GREEK CAPITAL LETTER PHI
    if width('\16#003aa;') <> 1 then writeln("width(#  3aa) incorrect"); success := FALSE; end if; # GREEK CAPITAL LETTER IOTA WITH DIALYTIKA
    if width('\16#003ad;') <> 1 then writeln("width(#  3ad) incorrect"); success := FALSE; end if; # GREEK SMALL LETTER EPSILON WITH TONOS
    if width('\16#003b1;') <> 1 then writeln("width(#  3b1) incorrect"); success := FALSE; end if; # GREEK SMALL LETTER ALPHA
    if width('\16#003b9;') <> 1 then writeln("width(#  3b9) incorrect"); success := FALSE; end if; # GREEK SMALL LETTER IOTA
    if width('\16#003c2;') <> 1 then writeln("width(#  3c2) incorrect"); success := FALSE; end if; # GREEK SMALL LETTER FINAL SIGMA
    if width('\16#003c3;') <> 1 then writeln("width(#  3c3) incorrect"); success := FALSE; end if; # GREEK SMALL LETTER SIGMA
    if width('\16#003c6;') <> 1 then writeln("width(#  3c6) incorrect"); success := FALSE; end if; # GREEK SMALL LETTER PHI
    if width('\16#003ca;') <> 1 then writeln("width(#  3ca) incorrect"); success := FALSE; end if; # GREEK SMALL LETTER IOTA WITH DIALYTIKA
    if width('\16#003e5;') <> 1 then writeln("width(#  3e5) incorrect"); success := FALSE; end if; # COPTIC SMALL LETTER FEI
    if width('\16#00401;') <> 1 then writeln("width(#  401) incorrect"); success := FALSE; end if; # CYRILLIC CAPITAL LETTER IO
    if width('\16#00402;') <> 1 then writeln("width(#  402) incorrect"); success := FALSE; end if; # CYRILLIC CAPITAL LETTER DJE
    if width('\16#00409;') <> 1 then writeln("width(#  409) incorrect"); success := FALSE; end if; # CYRILLIC CAPITAL LETTER LJE
    if width('\16#00410;') <> 1 then writeln("width(#  410) incorrect"); success := FALSE; end if; # CYRILLIC CAPITAL LETTER A
    if width('\16#00430;') <> 1 then writeln("width(#  430) incorrect"); success := FALSE; end if; # CYRILLIC SMALL LETTER A
    if width('\16#00450;') <> 1 then writeln("width(#  450) incorrect"); success := FALSE; end if; # CYRILLIC SMALL LETTER IE WITH GRAVE
    if width('\16#00451;') <> 1 then writeln("width(#  451) incorrect"); success := FALSE; end if; # CYRILLIC SMALL LETTER IO
    if width('\16#00452;') <> 1 then writeln("width(#  452) incorrect"); success := FALSE; end if; # CYRILLIC SMALL LETTER DJE
    if width('\16#00aa9;') <> 1 then writeln("width(#  aa9) incorrect"); success := FALSE; end if; # <unassigned-0AA9>
    if width('\16#01100;') <> 1 then writeln("width(# 1100) incorrect"); success := FALSE; end if; # HANGUL CHOSEONG KIYEOK
    if width('\16#01130;') <> 2 then writeln("width(# 1130) incorrect"); success := FALSE; end if; # HANGUL CHOSEONG SIOS-RIEUL
    if width('\16#01160;') <> 2 then writeln("width(# 1160) incorrect"); success := FALSE; end if; # HANGUL JUNGSEONG FILLER
    if width('\16#01181;') <> 1 then writeln("width(# 1181) incorrect"); success := FALSE; end if; # HANGUL JUNGSEONG O-YE
    if width('\16#011a3;') <> 1 then writeln("width(# 11a3) incorrect"); success := FALSE; end if; # HANGUL JUNGSEONG A-EU
    if width('\16#011a5;') <> 1 then writeln("width(# 11a5) incorrect"); success := FALSE; end if; # HANGUL JUNGSEONG YEO-YA
    if width('\16#011a8;') <> 1 then writeln("width(# 11a8) incorrect"); success := FALSE; end if; # HANGUL JONGSEONG KIYEOK
    if width('\16#011d1;') <> 1 then writeln("width(# 11d1) incorrect"); success := FALSE; end if; # HANGUL JONGSEONG RIEUL-MIEUM-KIYEOK
    if width('\16#011fa;') <> 1 then writeln("width(# 11fa) incorrect"); success := FALSE; end if; # HANGUL JONGSEONG KIYEOK-NIEUN
    if width('\16#011fd;') <> 1 then writeln("width(# 11fd) incorrect"); success := FALSE; end if; # HANGUL JONGSEONG KIYEOK-KHIEUKH
    if width('\16#01200;') <> 1 then writeln("width(# 1200) incorrect"); success := FALSE; end if; # ETHIOPIC SYLLABLE HA
    if width('\16#01908;') <> 1 then writeln("width(# 1908) incorrect"); success := FALSE; end if; # LIMBU LETTER JA
    if width('\16#02010;') <> 1 then writeln("width(# 2010) incorrect"); success := FALSE; end if; # HYPHEN
    if width('\16#02011;') <> 1 then writeln("width(# 2011) incorrect"); success := FALSE; end if; # NON-BREAKING HYPHEN
    if width('\16#02012;') <> 1 then writeln("width(# 2012) incorrect"); success := FALSE; end if; # FIGURE DASH
    if width('\16#02013;') <> 1 then writeln("width(# 2013) incorrect"); success := FALSE; end if; # EN DASH
    if width('\16#02015;') <> 1 then writeln("width(# 2015) incorrect"); success := FALSE; end if; # HORIZONTAL BAR
    if width('\16#02017;') <> 1 then writeln("width(# 2017) incorrect"); success := FALSE; end if; # DOUBLE LOW LINE
    if width('\16#02018;') <> 1 then writeln("width(# 2018) incorrect"); success := FALSE; end if; # LEFT SINGLE QUOTATION MARK
    if width('\16#02019;') <> 1 then writeln("width(# 2019) incorrect"); success := FALSE; end if; # RIGHT SINGLE QUOTATION MARK
    if width('\16#0201a;') <> 1 then writeln("width(# 201a) incorrect"); success := FALSE; end if; # SINGLE LOW-9 QUOTATION MARK
    if width('\16#0201b;') <> 1 then writeln("width(# 201b) incorrect"); success := FALSE; end if; # SINGLE HIGH-REVERSED-9 QUOTATION MARK
    if width('\16#0201c;') <> 1 then writeln("width(# 201c) incorrect"); success := FALSE; end if; # LEFT DOUBLE QUOTATION MARK
    if width('\16#0201d;') <> 1 then writeln("width(# 201d) incorrect"); success := FALSE; end if; # RIGHT DOUBLE QUOTATION MARK
    if width('\16#0201e;') <> 1 then writeln("width(# 201e) incorrect"); success := FALSE; end if; # DOUBLE LOW-9 QUOTATION MARK
    if width('\16#0201f;') <> 1 then writeln("width(# 201f) incorrect"); success := FALSE; end if; # DOUBLE HIGH-REVERSED-9 QUOTATION MARK
    if width('\16#02020;') <> 1 then writeln("width(# 2020) incorrect"); success := FALSE; end if; # DAGGER
    if width('\16#02021;') <> 1 then writeln("width(# 2021) incorrect"); success := FALSE; end if; # DOUBLE DAGGER
    if width('\16#02023;') <> 1 then writeln("width(# 2023) incorrect"); success := FALSE; end if; # TRIANGULAR BULLET
    if width('\16#02024;') <> 1 then writeln("width(# 2024) incorrect"); success := FALSE; end if; # ONE DOT LEADER
    if width('\16#02026;') <> 1 then writeln("width(# 2026) incorrect"); success := FALSE; end if; # HORIZONTAL ELLIPSIS
    if width('\16#02028;') <> 1 then writeln("width(# 2028) incorrect"); success := FALSE; end if; # LINE SEPARATOR
    if width('\16#0202c;') <> 1 then writeln("width(# 202c) incorrect"); success := FALSE; end if; # POP DIRECTIONAL FORMATTING
    if width('\16#02030;') <> 1 then writeln("width(# 2030) incorrect"); success := FALSE; end if; # PER MILLE SIGN
    if width('\16#02031;') <> 1 then writeln("width(# 2031) incorrect"); success := FALSE; end if; # PER TEN THOUSAND SIGN
    if width('\16#02032;') <> 1 then writeln("width(# 2032) incorrect"); success := FALSE; end if; # PRIME
    if width('\16#02033;') <> 1 then writeln("width(# 2033) incorrect"); success := FALSE; end if; # DOUBLE PRIME
    if width('\16#02034;') <> 1 then writeln("width(# 2034) incorrect"); success := FALSE; end if; # TRIPLE PRIME
    if width('\16#02035;') <> 1 then writeln("width(# 2035) incorrect"); success := FALSE; end if; # REVERSED PRIME
    if width('\16#02036;') <> 1 then writeln("width(# 2036) incorrect"); success := FALSE; end if; # REVERSED DOUBLE PRIME
    if width('\16#02038;') <> 1 then writeln("width(# 2038) incorrect"); success := FALSE; end if; # CARET
    if width('\16#0203b;') <> 1 then writeln("width(# 203b) incorrect"); success := FALSE; end if; # REFERENCE MARK
    if width('\16#0203c;') <> 1 then writeln("width(# 203c) incorrect"); success := FALSE; end if; # DOUBLE EXCLAMATION MARK
    if width('\16#0203d;') <> 1 then writeln("width(# 203d) incorrect"); success := FALSE; end if; # INTERROBANG
    if width('\16#0203e;') <> 1 then writeln("width(# 203e) incorrect"); success := FALSE; end if; # OVERLINE
    if width('\16#0203f;') <> 1 then writeln("width(# 203f) incorrect"); success := FALSE; end if; # UNDERTIE
    if width('\16#02059;') <> 1 then writeln("width(# 2059) incorrect"); success := FALSE; end if; # FIVE DOT PUNCTUATION
    if width('\16#02074;') <> 1 then writeln("width(# 2074) incorrect"); success := FALSE; end if; # SUPERSCRIPT FOUR
    if width('\16#02075;') <> 1 then writeln("width(# 2075) incorrect"); success := FALSE; end if; # SUPERSCRIPT FIVE
    if width('\16#0207a;') <> 1 then writeln("width(# 207a) incorrect"); success := FALSE; end if; # SUPERSCRIPT PLUS SIGN
    if width('\16#0207f;') <> 1 then writeln("width(# 207f) incorrect"); success := FALSE; end if; # SUPERSCRIPT LATIN SMALL LETTER N
    if width('\16#02080;') <> 1 then writeln("width(# 2080) incorrect"); success := FALSE; end if; # SUBSCRIPT ZERO
    if width('\16#02081;') <> 1 then writeln("width(# 2081) incorrect"); success := FALSE; end if; # SUBSCRIPT ONE
    if width('\16#02083;') <> 1 then writeln("width(# 2083) incorrect"); success := FALSE; end if; # SUBSCRIPT THREE
    if width('\16#02085;') <> 1 then writeln("width(# 2085) incorrect"); success := FALSE; end if; # SUBSCRIPT FIVE
    if width('\16#02097;') <> 1 then writeln("width(# 2097) incorrect"); success := FALSE; end if; # LATIN SUBSCRIPT SMALL LETTER L
    if width('\16#020a9;') <> 1 then writeln("width(# 20a9) incorrect"); success := FALSE; end if; # WON SIGN
    if width('\16#020aa;') <> 1 then writeln("width(# 20aa) incorrect"); success := FALSE; end if; # NEW SHEQEL SIGN
    if width('\16#020ab;') <> 1 then writeln("width(# 20ab) incorrect"); success := FALSE; end if; # DONG SIGN
    if width('\16#020ac;') <> 1 then writeln("width(# 20ac) incorrect"); success := FALSE; end if; # EURO SIGN
    if width('\16#020ad;') <> 1 then writeln("width(# 20ad) incorrect"); success := FALSE; end if; # KIP SIGN
    if width('\16#020d8;') <> 0 then writeln("width(# 20d8) incorrect"); success := FALSE; end if; # COMBINING RING OVERLAY
    if width('\16#02103;') <> 1 then writeln("width(# 2103) incorrect"); success := FALSE; end if; # DEGREE CELSIUS
    if width('\16#02104;') <> 1 then writeln("width(# 2104) incorrect"); success := FALSE; end if; # CENTRE LINE SYMBOL
    if width('\16#02105;') <> 1 then writeln("width(# 2105) incorrect"); success := FALSE; end if; # CARE OF
    if width('\16#02106;') <> 1 then writeln("width(# 2106) incorrect"); success := FALSE; end if; # CADA UNA
    if width('\16#02107;') <> 1 then writeln("width(# 2107) incorrect"); success := FALSE; end if; # EULER CONSTANT
    if width('\16#02109;') <> 1 then writeln("width(# 2109) incorrect"); success := FALSE; end if; # DEGREE FAHRENHEIT
    if width('\16#0210a;') <> 1 then writeln("width(# 210a) incorrect"); success := FALSE; end if; # SCRIPT SMALL G
    if width('\16#0210e;') <> 1 then writeln("width(# 210e) incorrect"); success := FALSE; end if; # PLANCK CONSTANT
    if width('\16#02113;') <> 1 then writeln("width(# 2113) incorrect"); success := FALSE; end if; # SCRIPT SMALL L
    if width('\16#02114;') <> 1 then writeln("width(# 2114) incorrect"); success := FALSE; end if; # L B BAR SYMBOL
    if width('\16#02115;') <> 1 then writeln("width(# 2115) incorrect"); success := FALSE; end if; # DOUBLE-STRUCK CAPITAL N
    if width('\16#02116;') <> 1 then writeln("width(# 2116) incorrect"); success := FALSE; end if; # NUMERO SIGN
    if width('\16#02117;') <> 1 then writeln("width(# 2117) incorrect"); success := FALSE; end if; # SOUND RECORDING COPYRIGHT
    if width('\16#0211c;') <> 1 then writeln("width(# 211c) incorrect"); success := FALSE; end if; # BLACK-LETTER CAPITAL R
    if width('\16#02121;') <> 1 then writeln("width(# 2121) incorrect"); success := FALSE; end if; # TELEPHONE SIGN
    if width('\16#02122;') <> 1 then writeln("width(# 2122) incorrect"); success := FALSE; end if; # TRADE MARK SIGN
    if width('\16#02123;') <> 1 then writeln("width(# 2123) incorrect"); success := FALSE; end if; # VERSICLE
    if width('\16#02124;') <> 1 then writeln("width(# 2124) incorrect"); success := FALSE; end if; # DOUBLE-STRUCK CAPITAL Z
    if width('\16#02126;') <> 1 then writeln("width(# 2126) incorrect"); success := FALSE; end if; # OHM SIGN
    if width('\16#02127;') <> 1 then writeln("width(# 2127) incorrect"); success := FALSE; end if; # INVERTED OHM SIGN
    if width('\16#02129;') <> 1 then writeln("width(# 2129) incorrect"); success := FALSE; end if; # TURNED GREEK SMALL LETTER IOTA
    if width('\16#0212b;') <> 1 then writeln("width(# 212b) incorrect"); success := FALSE; end if; # ANGSTROM SIGN
    if width('\16#0212c;') <> 1 then writeln("width(# 212c) incorrect"); success := FALSE; end if; # SCRIPT CAPITAL B
    if width('\16#0213f;') <> 1 then writeln("width(# 213f) incorrect"); success := FALSE; end if; # DOUBLE-STRUCK CAPITAL PI
    if width('\16#02153;') <> 1 then writeln("width(# 2153) incorrect"); success := FALSE; end if; # VULGAR FRACTION ONE THIRD
    if width('\16#02154;') <> 1 then writeln("width(# 2154) incorrect"); success := FALSE; end if; # VULGAR FRACTION TWO THIRDS
    if width('\16#02155;') <> 1 then writeln("width(# 2155) incorrect"); success := FALSE; end if; # VULGAR FRACTION ONE FIFTH
    if width('\16#02158;') <> 1 then writeln("width(# 2158) incorrect"); success := FALSE; end if; # VULGAR FRACTION FOUR FIFTHS
    if width('\16#0215b;') <> 1 then writeln("width(# 215b) incorrect"); success := FALSE; end if; # VULGAR FRACTION ONE EIGHTH
    if width('\16#0215d;') <> 1 then writeln("width(# 215d) incorrect"); success := FALSE; end if; # VULGAR FRACTION FIVE EIGHTHS
    if width('\16#0215f;') <> 1 then writeln("width(# 215f) incorrect"); success := FALSE; end if; # FRACTION NUMERATOR ONE
    if width('\16#02160;') <> 1 then writeln("width(# 2160) incorrect"); success := FALSE; end if; # ROMAN NUMERAL ONE
    if width('\16#02166;') <> 1 then writeln("width(# 2166) incorrect"); success := FALSE; end if; # ROMAN NUMERAL SEVEN
    if width('\16#0216c;') <> 1 then writeln("width(# 216c) incorrect"); success := FALSE; end if; # ROMAN NUMERAL FIFTY
    if width('\16#0216e;') <> 1 then writeln("width(# 216e) incorrect"); success := FALSE; end if; # ROMAN NUMERAL FIVE HUNDRED
    if width('\16#02170;') <> 1 then writeln("width(# 2170) incorrect"); success := FALSE; end if; # SMALL ROMAN NUMERAL ONE
    if width('\16#02175;') <> 1 then writeln("width(# 2175) incorrect"); success := FALSE; end if; # SMALL ROMAN NUMERAL SIX
    if width('\16#0217a;') <> 1 then writeln("width(# 217a) incorrect"); success := FALSE; end if; # SMALL ROMAN NUMERAL ELEVEN
    if width('\16#02181;') <> 1 then writeln("width(# 2181) incorrect"); success := FALSE; end if; # ROMAN NUMERAL FIVE THOUSAND
    if width('\16#02189;') <> 1 then writeln("width(# 2189) incorrect"); success := FALSE; end if; # VULGAR FRACTION ZERO THIRDS
    if width('\16#0218a;') <> 1 then writeln("width(# 218a) incorrect"); success := FALSE; end if; # <unassigned-218A>
    if width('\16#0218d;') <> 1 then writeln("width(# 218d) incorrect"); success := FALSE; end if; # <unassigned-218D>
    if width('\16#02190;') <> 1 then writeln("width(# 2190) incorrect"); success := FALSE; end if; # LEFTWARDS ARROW
    if width('\16#02195;') <> 1 then writeln("width(# 2195) incorrect"); success := FALSE; end if; # UP DOWN ARROW
    if width('\16#0219a;') <> 1 then writeln("width(# 219a) incorrect"); success := FALSE; end if; # LEFTWARDS ARROW WITH STROKE
    if width('\16#021a9;') <> 1 then writeln("width(# 21a9) incorrect"); success := FALSE; end if; # LEFTWARDS ARROW WITH HOOK
    if width('\16#021b8;') <> 1 then writeln("width(# 21b8) incorrect"); success := FALSE; end if; # NORTH WEST ARROW TO LONG BAR
    if width('\16#021b9;') <> 1 then writeln("width(# 21b9) incorrect"); success := FALSE; end if; # LEFTWARDS ARROW TO BAR OVER RIGHTWARDS ARROW TO BAR
    if width('\16#021ba;') <> 1 then writeln("width(# 21ba) incorrect"); success := FALSE; end if; # ANTICLOCKWISE OPEN CIRCLE ARROW
    if width('\16#021c6;') <> 1 then writeln("width(# 21c6) incorrect"); success := FALSE; end if; # LEFTWARDS ARROW OVER RIGHTWARDS ARROW
    if width('\16#021d2;') <> 1 then writeln("width(# 21d2) incorrect"); success := FALSE; end if; # RIGHTWARDS DOUBLE ARROW
    if width('\16#021d3;') <> 1 then writeln("width(# 21d3) incorrect"); success := FALSE; end if; # DOWNWARDS DOUBLE ARROW
    if width('\16#021d4;') <> 1 then writeln("width(# 21d4) incorrect"); success := FALSE; end if; # LEFT RIGHT DOUBLE ARROW
    if width('\16#021d5;') <> 1 then writeln("width(# 21d5) incorrect"); success := FALSE; end if; # UP DOWN DOUBLE ARROW
    if width('\16#021de;') <> 1 then writeln("width(# 21de) incorrect"); success := FALSE; end if; # UPWARDS ARROW WITH DOUBLE STROKE
    if width('\16#021e7;') <> 1 then writeln("width(# 21e7) incorrect"); success := FALSE; end if; # UPWARDS WHITE ARROW
    if width('\16#021e8;') <> 1 then writeln("width(# 21e8) incorrect"); success := FALSE; end if; # RIGHTWARDS WHITE ARROW
    if width('\16#021f4;') <> 1 then writeln("width(# 21f4) incorrect"); success := FALSE; end if; # RIGHT ARROW WITH SMALL CIRCLE
    if width('\16#02200;') <> 1 then writeln("width(# 2200) incorrect"); success := FALSE; end if; # FOR ALL
    if width('\16#02201;') <> 1 then writeln("width(# 2201) incorrect"); success := FALSE; end if; # COMPLEMENT
    if width('\16#02202;') <> 1 then writeln("width(# 2202) incorrect"); success := FALSE; end if; # PARTIAL DIFFERENTIAL
    if width('\16#02203;') <> 1 then writeln("width(# 2203) incorrect"); success := FALSE; end if; # THERE EXISTS
    if width('\16#02204;') <> 1 then writeln("width(# 2204) incorrect"); success := FALSE; end if; # THERE DOES NOT EXIST
    if width('\16#02205;') <> 1 then writeln("width(# 2205) incorrect"); success := FALSE; end if; # EMPTY SET
    if width('\16#02207;') <> 1 then writeln("width(# 2207) incorrect"); success := FALSE; end if; # NABLA
    if width('\16#02208;') <> 1 then writeln("width(# 2208) incorrect"); success := FALSE; end if; # ELEMENT OF
    if width('\16#02209;') <> 1 then writeln("width(# 2209) incorrect"); success := FALSE; end if; # NOT AN ELEMENT OF
    if width('\16#0220a;') <> 1 then writeln("width(# 220a) incorrect"); success := FALSE; end if; # SMALL ELEMENT OF
    if width('\16#0220b;') <> 1 then writeln("width(# 220b) incorrect"); success := FALSE; end if; # CONTAINS AS MEMBER
    if width('\16#0220c;') <> 1 then writeln("width(# 220c) incorrect"); success := FALSE; end if; # DOES NOT CONTAIN AS MEMBER
    if width('\16#0220d;') <> 1 then writeln("width(# 220d) incorrect"); success := FALSE; end if; # SMALL CONTAINS AS MEMBER
    if width('\16#0220f;') <> 1 then writeln("width(# 220f) incorrect"); success := FALSE; end if; # N-ARY PRODUCT
    if width('\16#02210;') <> 1 then writeln("width(# 2210) incorrect"); success := FALSE; end if; # N-ARY COPRODUCT
    if width('\16#02211;') <> 1 then writeln("width(# 2211) incorrect"); success := FALSE; end if; # N-ARY SUMMATION
    if width('\16#02212;') <> 1 then writeln("width(# 2212) incorrect"); success := FALSE; end if; # MINUS SIGN
    if width('\16#02213;') <> 1 then writeln("width(# 2213) incorrect"); success := FALSE; end if; # MINUS-OR-PLUS SIGN
    if width('\16#02215;') <> 1 then writeln("width(# 2215) incorrect"); success := FALSE; end if; # DIVISION SLASH
    if width('\16#02216;') <> 1 then writeln("width(# 2216) incorrect"); success := FALSE; end if; # SET MINUS
    if width('\16#02218;') <> 1 then writeln("width(# 2218) incorrect"); success := FALSE; end if; # RING OPERATOR
    if width('\16#0221a;') <> 1 then writeln("width(# 221a) incorrect"); success := FALSE; end if; # SQUARE ROOT
    if width('\16#0221b;') <> 1 then writeln("width(# 221b) incorrect"); success := FALSE; end if; # CUBE ROOT
    if width('\16#0221c;') <> 1 then writeln("width(# 221c) incorrect"); success := FALSE; end if; # FOURTH ROOT
    if width('\16#0221d;') <> 1 then writeln("width(# 221d) incorrect"); success := FALSE; end if; # PROPORTIONAL TO
    if width('\16#0221f;') <> 1 then writeln("width(# 221f) incorrect"); success := FALSE; end if; # RIGHT ANGLE
    if width('\16#02221;') <> 1 then writeln("width(# 2221) incorrect"); success := FALSE; end if; # MEASURED ANGLE
    if width('\16#02222;') <> 1 then writeln("width(# 2222) incorrect"); success := FALSE; end if; # SPHERICAL ANGLE
    if width('\16#02223;') <> 1 then writeln("width(# 2223) incorrect"); success := FALSE; end if; # DIVIDES
    if width('\16#02224;') <> 1 then writeln("width(# 2224) incorrect"); success := FALSE; end if; # DOES NOT DIVIDE
    if width('\16#02225;') <> 1 then writeln("width(# 2225) incorrect"); success := FALSE; end if; # PARALLEL TO
    if width('\16#02226;') <> 1 then writeln("width(# 2226) incorrect"); success := FALSE; end if; # NOT PARALLEL TO
    if width('\16#02227;') <> 1 then writeln("width(# 2227) incorrect"); success := FALSE; end if; # LOGICAL AND
    if width('\16#0222a;') <> 1 then writeln("width(# 222a) incorrect"); success := FALSE; end if; # UNION
    if width('\16#0222d;') <> 1 then writeln("width(# 222d) incorrect"); success := FALSE; end if; # TRIPLE INTEGRAL
    if width('\16#0222e;') <> 1 then writeln("width(# 222e) incorrect"); success := FALSE; end if; # CONTOUR INTEGRAL
    if width('\16#0222f;') <> 1 then writeln("width(# 222f) incorrect"); success := FALSE; end if; # SURFACE INTEGRAL
    if width('\16#02231;') <> 1 then writeln("width(# 2231) incorrect"); success := FALSE; end if; # CLOCKWISE INTEGRAL
    if width('\16#02234;') <> 1 then writeln("width(# 2234) incorrect"); success := FALSE; end if; # THEREFORE
    if width('\16#02236;') <> 1 then writeln("width(# 2236) incorrect"); success := FALSE; end if; # RATIO
    if width('\16#02238;') <> 1 then writeln("width(# 2238) incorrect"); success := FALSE; end if; # DOT MINUS
    if width('\16#0223a;') <> 1 then writeln("width(# 223a) incorrect"); success := FALSE; end if; # GEOMETRIC PROPORTION
    if width('\16#0223c;') <> 1 then writeln("width(# 223c) incorrect"); success := FALSE; end if; # TILDE OPERATOR
    if width('\16#0223d;') <> 1 then writeln("width(# 223d) incorrect"); success := FALSE; end if; # REVERSED TILDE
    if width('\16#0223e;') <> 1 then writeln("width(# 223e) incorrect"); success := FALSE; end if; # INVERTED LAZY S
    if width('\16#02243;') <> 1 then writeln("width(# 2243) incorrect"); success := FALSE; end if; # ASYMPTOTICALLY EQUAL TO
    if width('\16#02248;') <> 1 then writeln("width(# 2248) incorrect"); success := FALSE; end if; # ALMOST EQUAL TO
    if width('\16#02249;') <> 1 then writeln("width(# 2249) incorrect"); success := FALSE; end if; # NOT ALMOST EQUAL TO
    if width('\16#0224a;') <> 1 then writeln("width(# 224a) incorrect"); success := FALSE; end if; # ALMOST EQUAL OR EQUAL TO
    if width('\16#0224c;') <> 1 then writeln("width(# 224c) incorrect"); success := FALSE; end if; # ALL EQUAL TO
    if width('\16#0224d;') <> 1 then writeln("width(# 224d) incorrect"); success := FALSE; end if; # EQUIVALENT TO
    if width('\16#0224f;') <> 1 then writeln("width(# 224f) incorrect"); success := FALSE; end if; # DIFFERENCE BETWEEN
    if width('\16#02252;') <> 1 then writeln("width(# 2252) incorrect"); success := FALSE; end if; # APPROXIMATELY EQUAL TO OR THE IMAGE OF
    if width('\16#02253;') <> 1 then writeln("width(# 2253) incorrect"); success := FALSE; end if; # IMAGE OF OR APPROXIMATELY EQUAL TO
    if width('\16#02259;') <> 1 then writeln("width(# 2259) incorrect"); success := FALSE; end if; # ESTIMATES
    if width('\16#02260;') <> 1 then writeln("width(# 2260) incorrect"); success := FALSE; end if; # NOT EQUAL TO
    if width('\16#02261;') <> 1 then writeln("width(# 2261) incorrect"); success := FALSE; end if; # IDENTICAL TO
    if width('\16#02262;') <> 1 then writeln("width(# 2262) incorrect"); success := FALSE; end if; # NOT IDENTICAL TO
    if width('\16#02263;') <> 1 then writeln("width(# 2263) incorrect"); success := FALSE; end if; # STRICTLY EQUIVALENT TO
    if width('\16#02264;') <> 1 then writeln("width(# 2264) incorrect"); success := FALSE; end if; # LESS-THAN OR EQUAL TO
    if width('\16#02266;') <> 1 then writeln("width(# 2266) incorrect"); success := FALSE; end if; # LESS-THAN OVER EQUAL TO
    if width('\16#02268;') <> 1 then writeln("width(# 2268) incorrect"); success := FALSE; end if; # LESS-THAN BUT NOT EQUAL TO
    if width('\16#02269;') <> 1 then writeln("width(# 2269) incorrect"); success := FALSE; end if; # GREATER-THAN BUT NOT EQUAL TO
    if width('\16#0226a;') <> 1 then writeln("width(# 226a) incorrect"); success := FALSE; end if; # MUCH LESS-THAN
    if width('\16#0226b;') <> 1 then writeln("width(# 226b) incorrect"); success := FALSE; end if; # MUCH GREATER-THAN
    if width('\16#0226c;') <> 1 then writeln("width(# 226c) incorrect"); success := FALSE; end if; # BETWEEN
    if width('\16#0226d;') <> 1 then writeln("width(# 226d) incorrect"); success := FALSE; end if; # NOT EQUIVALENT TO
    if width('\16#0226e;') <> 1 then writeln("width(# 226e) incorrect"); success := FALSE; end if; # NOT LESS-THAN
    if width('\16#0226f;') <> 1 then writeln("width(# 226f) incorrect"); success := FALSE; end if; # NOT GREATER-THAN
    if width('\16#02270;') <> 1 then writeln("width(# 2270) incorrect"); success := FALSE; end if; # NEITHER LESS-THAN NOR EQUAL TO
    if width('\16#02279;') <> 1 then writeln("width(# 2279) incorrect"); success := FALSE; end if; # NEITHER GREATER-THAN NOR LESS-THAN
    if width('\16#02282;') <> 1 then writeln("width(# 2282) incorrect"); success := FALSE; end if; # SUBSET OF
    if width('\16#02283;') <> 1 then writeln("width(# 2283) incorrect"); success := FALSE; end if; # SUPERSET OF
    if width('\16#02284;') <> 1 then writeln("width(# 2284) incorrect"); success := FALSE; end if; # NOT A SUBSET OF
    if width('\16#02285;') <> 1 then writeln("width(# 2285) incorrect"); success := FALSE; end if; # NOT A SUPERSET OF
    if width('\16#02286;') <> 1 then writeln("width(# 2286) incorrect"); success := FALSE; end if; # SUBSET OF OR EQUAL TO
    if width('\16#02287;') <> 1 then writeln("width(# 2287) incorrect"); success := FALSE; end if; # SUPERSET OF OR EQUAL TO
    if width('\16#02288;') <> 1 then writeln("width(# 2288) incorrect"); success := FALSE; end if; # NEITHER A SUBSET OF NOR EQUAL TO
    if width('\16#0228e;') <> 1 then writeln("width(# 228e) incorrect"); success := FALSE; end if; # MULTISET UNION
    if width('\16#02295;') <> 1 then writeln("width(# 2295) incorrect"); success := FALSE; end if; # CIRCLED PLUS
    if width('\16#02296;') <> 1 then writeln("width(# 2296) incorrect"); success := FALSE; end if; # CIRCLED MINUS
    if width('\16#02297;') <> 1 then writeln("width(# 2297) incorrect"); success := FALSE; end if; # CIRCLED TIMES
    if width('\16#02299;') <> 1 then writeln("width(# 2299) incorrect"); success := FALSE; end if; # CIRCLED DOT OPERATOR
    if width('\16#0229a;') <> 1 then writeln("width(# 229a) incorrect"); success := FALSE; end if; # CIRCLED RING OPERATOR
    if width('\16#0229f;') <> 1 then writeln("width(# 229f) incorrect"); success := FALSE; end if; # SQUARED MINUS
    if width('\16#022a5;') <> 1 then writeln("width(# 22a5) incorrect"); success := FALSE; end if; # UP TACK
    if width('\16#022a6;') <> 1 then writeln("width(# 22a6) incorrect"); success := FALSE; end if; # ASSERTION
    if width('\16#022b2;') <> 1 then writeln("width(# 22b2) incorrect"); success := FALSE; end if; # NORMAL SUBGROUP OF
    if width('\16#022bf;') <> 1 then writeln("width(# 22bf) incorrect"); success := FALSE; end if; # RIGHT TRIANGLE
    if width('\16#022c0;') <> 1 then writeln("width(# 22c0) incorrect"); success := FALSE; end if; # N-ARY LOGICAL AND
    if width('\16#022e9;') <> 1 then writeln("width(# 22e9) incorrect"); success := FALSE; end if; # SUCCEEDS BUT NOT EQUIVALENT TO
    if width('\16#02312;') <> 1 then writeln("width(# 2312) incorrect"); success := FALSE; end if; # ARC
    if width('\16#02313;') <> 1 then writeln("width(# 2313) incorrect"); success := FALSE; end if; # SEGMENT
    if width('\16#0231e;') <> 1 then writeln("width(# 231e) incorrect"); success := FALSE; end if; # BOTTOM LEFT CORNER
    if width('\16#02329;') <> 1 then writeln("width(# 2329) incorrect"); success := FALSE; end if; # LEFT-POINTING ANGLE BRACKET
    if width('\16#0232a;') <> 2 then writeln("width(# 232a) incorrect"); success := FALSE; end if; # RIGHT-POINTING ANGLE BRACKET
    if width('\16#0232b;') <> 2 then writeln("width(# 232b) incorrect"); success := FALSE; end if; # ERASE TO THE LEFT
    if width('\16#023c5;') <> 1 then writeln("width(# 23c5) incorrect"); success := FALSE; end if; # DENTISTRY SYMBOL LIGHT UP AND HORIZONTAL WITH TRIANGLE
    if width('\16#02460;') <> 1 then writeln("width(# 2460) incorrect"); success := FALSE; end if; # CIRCLED DIGIT ONE
    if width('\16#024a5;') <> 1 then writeln("width(# 24a5) incorrect"); success := FALSE; end if; # PARENTHESIZED LATIN SMALL LETTER J
    if width('\16#024ea;') <> 1 then writeln("width(# 24ea) incorrect"); success := FALSE; end if; # CIRCLED DIGIT ZERO
    if width('\16#024eb;') <> 1 then writeln("width(# 24eb) incorrect"); success := FALSE; end if; # NEGATIVE CIRCLED NUMBER ELEVEN
    if width('\16#0251b;') <> 1 then writeln("width(# 251b) incorrect"); success := FALSE; end if; # BOX DRAWINGS HEAVY UP AND LEFT
    if width('\16#0254c;') <> 1 then writeln("width(# 254c) incorrect"); success := FALSE; end if; # BOX DRAWINGS LIGHT DOUBLE DASH HORIZONTAL
    if width('\16#0254e;') <> 1 then writeln("width(# 254e) incorrect"); success := FALSE; end if; # BOX DRAWINGS LIGHT DOUBLE DASH VERTICAL
    if width('\16#02550;') <> 1 then writeln("width(# 2550) incorrect"); success := FALSE; end if; # BOX DRAWINGS DOUBLE HORIZONTAL
    if width('\16#02562;') <> 1 then writeln("width(# 2562) incorrect"); success := FALSE; end if; # BOX DRAWINGS VERTICAL DOUBLE AND LEFT SINGLE
    if width('\16#02574;') <> 1 then writeln("width(# 2574) incorrect"); success := FALSE; end if; # BOX DRAWINGS LIGHT LEFT
    if width('\16#0257a;') <> 1 then writeln("width(# 257a) incorrect"); success := FALSE; end if; # BOX DRAWINGS HEAVY RIGHT
    if width('\16#02580;') <> 1 then writeln("width(# 2580) incorrect"); success := FALSE; end if; # UPPER HALF BLOCK
    if width('\16#02588;') <> 1 then writeln("width(# 2588) incorrect"); success := FALSE; end if; # FULL BLOCK
    if width('\16#02590;') <> 1 then writeln("width(# 2590) incorrect"); success := FALSE; end if; # RIGHT HALF BLOCK
    if width('\16#02591;') <> 1 then writeln("width(# 2591) incorrect"); success := FALSE; end if; # LIGHT SHADE
    if width('\16#02592;') <> 1 then writeln("width(# 2592) incorrect"); success := FALSE; end if; # MEDIUM SHADE
    if width('\16#02594;') <> 1 then writeln("width(# 2594) incorrect"); success := FALSE; end if; # UPPER ONE EIGHTH BLOCK
    if width('\16#02596;') <> 1 then writeln("width(# 2596) incorrect"); success := FALSE; end if; # QUADRANT LOWER LEFT
    if width('\16#0259b;') <> 1 then writeln("width(# 259b) incorrect"); success := FALSE; end if; # QUADRANT UPPER LEFT AND UPPER RIGHT AND LOWER LEFT
    if width('\16#025a0;') <> 1 then writeln("width(# 25a0) incorrect"); success := FALSE; end if; # BLACK SQUARE
    if width('\16#025a1;') <> 1 then writeln("width(# 25a1) incorrect"); success := FALSE; end if; # WHITE SQUARE
    if width('\16#025a2;') <> 1 then writeln("width(# 25a2) incorrect"); success := FALSE; end if; # WHITE SQUARE WITH ROUNDED CORNERS
    if width('\16#025a3;') <> 1 then writeln("width(# 25a3) incorrect"); success := FALSE; end if; # WHITE SQUARE CONTAINING BLACK SMALL SQUARE
    if width('\16#025a6;') <> 1 then writeln("width(# 25a6) incorrect"); success := FALSE; end if; # SQUARE WITH ORTHOGONAL CROSSHATCH FILL
    if width('\16#025aa;') <> 1 then writeln("width(# 25aa) incorrect"); success := FALSE; end if; # BLACK SMALL SQUARE
    if width('\16#025ae;') <> 1 then writeln("width(# 25ae) incorrect"); success := FALSE; end if; # BLACK VERTICAL RECTANGLE
    if width('\16#025b2;') <> 1 then writeln("width(# 25b2) incorrect"); success := FALSE; end if; # BLACK UP-POINTING TRIANGLE
    if width('\16#025b3;') <> 1 then writeln("width(# 25b3) incorrect"); success := FALSE; end if; # WHITE UP-POINTING TRIANGLE
    if width('\16#025b4;') <> 1 then writeln("width(# 25b4) incorrect"); success := FALSE; end if; # BLACK UP-POINTING SMALL TRIANGLE
    if width('\16#025b5;') <> 1 then writeln("width(# 25b5) incorrect"); success := FALSE; end if; # WHITE UP-POINTING SMALL TRIANGLE
    if width('\16#025b6;') <> 1 then writeln("width(# 25b6) incorrect"); success := FALSE; end if; # BLACK RIGHT-POINTING TRIANGLE
    if width('\16#025b7;') <> 1 then writeln("width(# 25b7) incorrect"); success := FALSE; end if; # WHITE RIGHT-POINTING TRIANGLE
    if width('\16#025b8;') <> 1 then writeln("width(# 25b8) incorrect"); success := FALSE; end if; # BLACK RIGHT-POINTING SMALL TRIANGLE
    if width('\16#025ba;') <> 1 then writeln("width(# 25ba) incorrect"); success := FALSE; end if; # BLACK RIGHT-POINTING POINTER
    if width('\16#025bc;') <> 1 then writeln("width(# 25bc) incorrect"); success := FALSE; end if; # BLACK DOWN-POINTING TRIANGLE
    if width('\16#025bd;') <> 1 then writeln("width(# 25bd) incorrect"); success := FALSE; end if; # WHITE DOWN-POINTING TRIANGLE
    if width('\16#025be;') <> 1 then writeln("width(# 25be) incorrect"); success := FALSE; end if; # BLACK DOWN-POINTING SMALL TRIANGLE
    if width('\16#025bf;') <> 1 then writeln("width(# 25bf) incorrect"); success := FALSE; end if; # WHITE DOWN-POINTING SMALL TRIANGLE
    if width('\16#025c0;') <> 1 then writeln("width(# 25c0) incorrect"); success := FALSE; end if; # BLACK LEFT-POINTING TRIANGLE
    if width('\16#025c1;') <> 1 then writeln("width(# 25c1) incorrect"); success := FALSE; end if; # WHITE LEFT-POINTING TRIANGLE
    if width('\16#025c2;') <> 1 then writeln("width(# 25c2) incorrect"); success := FALSE; end if; # BLACK LEFT-POINTING SMALL TRIANGLE
    if width('\16#025c4;') <> 1 then writeln("width(# 25c4) incorrect"); success := FALSE; end if; # BLACK LEFT-POINTING POINTER
    if width('\16#025c6;') <> 1 then writeln("width(# 25c6) incorrect"); success := FALSE; end if; # BLACK DIAMOND
    if width('\16#025c7;') <> 1 then writeln("width(# 25c7) incorrect"); success := FALSE; end if; # WHITE DIAMOND
    if width('\16#025c9;') <> 1 then writeln("width(# 25c9) incorrect"); success := FALSE; end if; # FISHEYE
    if width('\16#025ca;') <> 1 then writeln("width(# 25ca) incorrect"); success := FALSE; end if; # LOZENGE
    if width('\16#025cb;') <> 1 then writeln("width(# 25cb) incorrect"); success := FALSE; end if; # WHITE CIRCLE
    if width('\16#025cc;') <> 1 then writeln("width(# 25cc) incorrect"); success := FALSE; end if; # DOTTED CIRCLE
    if width('\16#025cd;') <> 1 then writeln("width(# 25cd) incorrect"); success := FALSE; end if; # CIRCLE WITH VERTICAL FILL
    if width('\16#025ce;') <> 1 then writeln("width(# 25ce) incorrect"); success := FALSE; end if; # BULLSEYE
    if width('\16#025d0;') <> 1 then writeln("width(# 25d0) incorrect"); success := FALSE; end if; # CIRCLE WITH LEFT HALF BLACK
    if width('\16#025d2;') <> 1 then writeln("width(# 25d2) incorrect"); success := FALSE; end if; # CIRCLE WITH LOWER HALF BLACK
    if width('\16#025da;') <> 1 then writeln("width(# 25da) incorrect"); success := FALSE; end if; # UPPER HALF INVERSE WHITE CIRCLE
    if width('\16#025e2;') <> 1 then writeln("width(# 25e2) incorrect"); success := FALSE; end if; # BLACK LOWER RIGHT TRIANGLE
    if width('\16#025e4;') <> 1 then writeln("width(# 25e4) incorrect"); success := FALSE; end if; # BLACK UPPER LEFT TRIANGLE
    if width('\16#025e6;') <> 1 then writeln("width(# 25e6) incorrect"); success := FALSE; end if; # WHITE BULLET
    if width('\16#025ea;') <> 1 then writeln("width(# 25ea) incorrect"); success := FALSE; end if; # SQUARE WITH LOWER RIGHT DIAGONAL HALF BLACK
    if width('\16#025ef;') <> 1 then writeln("width(# 25ef) incorrect"); success := FALSE; end if; # LARGE CIRCLE
    if width('\16#025f0;') <> 1 then writeln("width(# 25f0) incorrect"); success := FALSE; end if; # WHITE SQUARE WITH UPPER LEFT QUADRANT
    if width('\16#025fa;') <> 1 then writeln("width(# 25fa) incorrect"); success := FALSE; end if; # LOWER LEFT TRIANGLE
    if width('\16#02605;') <> 1 then writeln("width(# 2605) incorrect"); success := FALSE; end if; # BLACK STAR
    if width('\16#02606;') <> 1 then writeln("width(# 2606) incorrect"); success := FALSE; end if; # WHITE STAR
    if width('\16#02607;') <> 1 then writeln("width(# 2607) incorrect"); success := FALSE; end if; # LIGHTNING
    if width('\16#02608;') <> 1 then writeln("width(# 2608) incorrect"); success := FALSE; end if; # THUNDERSTORM
    if width('\16#02609;') <> 1 then writeln("width(# 2609) incorrect"); success := FALSE; end if; # SUN
    if width('\16#0260a;') <> 1 then writeln("width(# 260a) incorrect"); success := FALSE; end if; # ASCENDING NODE
    if width('\16#0260c;') <> 1 then writeln("width(# 260c) incorrect"); success := FALSE; end if; # CONJUNCTION
    if width('\16#0260e;') <> 1 then writeln("width(# 260e) incorrect"); success := FALSE; end if; # BLACK TELEPHONE
    if width('\16#0260f;') <> 1 then writeln("width(# 260f) incorrect"); success := FALSE; end if; # WHITE TELEPHONE
    if width('\16#02610;') <> 1 then writeln("width(# 2610) incorrect"); success := FALSE; end if; # BALLOT BOX
    if width('\16#02612;') <> 1 then writeln("width(# 2612) incorrect"); success := FALSE; end if; # BALLOT BOX WITH X
    if width('\16#02614;') <> 1 then writeln("width(# 2614) incorrect"); success := FALSE; end if; # UMBRELLA WITH RAIN DROPS
    if width('\16#02615;') <> 1 then writeln("width(# 2615) incorrect"); success := FALSE; end if; # HOT BEVERAGE
    if width('\16#02616;') <> 1 then writeln("width(# 2616) incorrect"); success := FALSE; end if; # WHITE SHOGI PIECE
    if width('\16#02619;') <> 1 then writeln("width(# 2619) incorrect"); success := FALSE; end if; # REVERSED ROTATED FLORAL HEART BULLET
    if width('\16#0261c;') <> 1 then writeln("width(# 261c) incorrect"); success := FALSE; end if; # WHITE LEFT POINTING INDEX
    if width('\16#0261d;') <> 1 then writeln("width(# 261d) incorrect"); success := FALSE; end if; # WHITE UP POINTING INDEX
    if width('\16#0261e;') <> 1 then writeln("width(# 261e) incorrect"); success := FALSE; end if; # WHITE RIGHT POINTING INDEX
    if width('\16#0261f;') <> 1 then writeln("width(# 261f) incorrect"); success := FALSE; end if; # WHITE DOWN POINTING INDEX
    if width('\16#0262f;') <> 1 then writeln("width(# 262f) incorrect"); success := FALSE; end if; # YIN YANG
    if width('\16#02640;') <> 1 then writeln("width(# 2640) incorrect"); success := FALSE; end if; # FEMALE SIGN
    if width('\16#02641;') <> 1 then writeln("width(# 2641) incorrect"); success := FALSE; end if; # EARTH
    if width('\16#02642;') <> 1 then writeln("width(# 2642) incorrect"); success := FALSE; end if; # MALE SIGN
    if width('\16#02643;') <> 1 then writeln("width(# 2643) incorrect"); success := FALSE; end if; # JUPITER
    if width('\16#02651;') <> 1 then writeln("width(# 2651) incorrect"); success := FALSE; end if; # CAPRICORN
    if width('\16#02660;') <> 1 then writeln("width(# 2660) incorrect"); success := FALSE; end if; # BLACK SPADE SUIT
    if width('\16#02661;') <> 1 then writeln("width(# 2661) incorrect"); success := FALSE; end if; # WHITE HEART SUIT
    if width('\16#02662;') <> 1 then writeln("width(# 2662) incorrect"); success := FALSE; end if; # WHITE DIAMOND SUIT
    if width('\16#02663;') <> 1 then writeln("width(# 2663) incorrect"); success := FALSE; end if; # BLACK CLUB SUIT
    if width('\16#02664;') <> 1 then writeln("width(# 2664) incorrect"); success := FALSE; end if; # WHITE SPADE SUIT
    if width('\16#02666;') <> 1 then writeln("width(# 2666) incorrect"); success := FALSE; end if; # BLACK DIAMOND SUIT
    if width('\16#02667;') <> 1 then writeln("width(# 2667) incorrect"); success := FALSE; end if; # WHITE CLUB SUIT
    if width('\16#02669;') <> 1 then writeln("width(# 2669) incorrect"); success := FALSE; end if; # QUARTER NOTE
    if width('\16#0266b;') <> 1 then writeln("width(# 266b) incorrect"); success := FALSE; end if; # BEAMED EIGHTH NOTES
    if width('\16#0266c;') <> 1 then writeln("width(# 266c) incorrect"); success := FALSE; end if; # BEAMED SIXTEENTH NOTES
    if width('\16#0266d;') <> 1 then writeln("width(# 266d) incorrect"); success := FALSE; end if; # MUSIC FLAT SIGN
    if width('\16#0266e;') <> 1 then writeln("width(# 266e) incorrect"); success := FALSE; end if; # MUSIC NATURAL SIGN
    if width('\16#0266f;') <> 1 then writeln("width(# 266f) incorrect"); success := FALSE; end if; # MUSIC SHARP SIGN
    if width('\16#02670;') <> 1 then writeln("width(# 2670) incorrect"); success := FALSE; end if; # WEST SYRIAC CROSS
    if width('\16#02687;') <> 1 then writeln("width(# 2687) incorrect"); success := FALSE; end if; # WHITE CIRCLE WITH TWO DOTS
    if width('\16#0269e;') <> 1 then writeln("width(# 269e) incorrect"); success := FALSE; end if; # THREE LINES CONVERGING RIGHT
    if width('\16#0269f;') <> 1 then writeln("width(# 269f) incorrect"); success := FALSE; end if; # THREE LINES CONVERGING LEFT
    if width('\16#026a0;') <> 1 then writeln("width(# 26a0) incorrect"); success := FALSE; end if; # WARNING SIGN
    if width('\16#026af;') <> 1 then writeln("width(# 26af) incorrect"); success := FALSE; end if; # UNMARRIED PARTNERSHIP SYMBOL
    if width('\16#026be;') <> 1 then writeln("width(# 26be) incorrect"); success := FALSE; end if; # BASEBALL
    if width('\16#026bf;') <> 1 then writeln("width(# 26bf) incorrect"); success := FALSE; end if; # SQUARED KEY
    if width('\16#026c0;') <> 1 then writeln("width(# 26c0) incorrect"); success := FALSE; end if; # WHITE DRAUGHTS MAN
    if width('\16#026c2;') <> 1 then writeln("width(# 26c2) incorrect"); success := FALSE; end if; # BLACK DRAUGHTS MAN
    if width('\16#026c4;') <> 1 then writeln("width(# 26c4) incorrect"); success := FALSE; end if; # SNOWMAN WITHOUT SNOW
    if width('\16#026c9;') <> 1 then writeln("width(# 26c9) incorrect"); success := FALSE; end if; # TURNED WHITE SHOGI PIECE
    if width('\16#026ce;') <> 1 then writeln("width(# 26ce) incorrect"); success := FALSE; end if; # OPHIUCHUS
    if width('\16#026cf;') <> 1 then writeln("width(# 26cf) incorrect"); success := FALSE; end if; # PICK
    if width('\16#026d8;') <> 1 then writeln("width(# 26d8) incorrect"); success := FALSE; end if; # BLACK LEFT LANE MERGE
    if width('\16#026e2;') <> 1 then writeln("width(# 26e2) incorrect"); success := FALSE; end if; # ASTRONOMICAL SYMBOL FOR URANUS
    if width('\16#026e3;') <> 1 then writeln("width(# 26e3) incorrect"); success := FALSE; end if; # HEAVY CIRCLE WITH STROKE AND TWO DOTS ABOVE
    if width('\16#026e4;') <> 1 then writeln("width(# 26e4) incorrect"); success := FALSE; end if; # PENTAGRAM
    if width('\16#026e6;') <> 1 then writeln("width(# 26e6) incorrect"); success := FALSE; end if; # LEFT-HANDED INTERLACED PENTAGRAM
    if width('\16#026e8;') <> 1 then writeln("width(# 26e8) incorrect"); success := FALSE; end if; # BLACK CROSS ON SHIELD
    if width('\16#026f4;') <> 1 then writeln("width(# 26f4) incorrect"); success := FALSE; end if; # FERRY
    if width('\16#02700;') <> 1 then writeln("width(# 2700) incorrect"); success := FALSE; end if; # <unassigned-2700>
    if width('\16#0271e;') <> 1 then writeln("width(# 271e) incorrect"); success := FALSE; end if; # SHADOWED WHITE LATIN CROSS
    if width('\16#0273d;') <> 1 then writeln("width(# 273d) incorrect"); success := FALSE; end if; # HEAVY TEARDROP-SPOKED ASTERISK
    if width('\16#0273e;') <> 1 then writeln("width(# 273e) incorrect"); success := FALSE; end if; # SIX PETALLED BLACK AND WHITE FLORETTE
    if width('\16#0274a;') <> 1 then writeln("width(# 274a) incorrect"); success := FALSE; end if; # EIGHT TEARDROP-SPOKED PROPELLER ASTERISK
    if width('\16#02757;') <> 1 then writeln("width(# 2757) incorrect"); success := FALSE; end if; # HEAVY EXCLAMATION MARK SYMBOL
    if width('\16#02758;') <> 1 then writeln("width(# 2758) incorrect"); success := FALSE; end if; # LIGHT VERTICAL BAR
    if width('\16#02767;') <> 1 then writeln("width(# 2767) incorrect"); success := FALSE; end if; # ROTATED FLORAL HEART BULLET
    if width('\16#02776;') <> 1 then writeln("width(# 2776) incorrect"); success := FALSE; end if; # DINGBAT NEGATIVE CIRCLED DIGIT ONE
    if width('\16#0277b;') <> 1 then writeln("width(# 277b) incorrect"); success := FALSE; end if; # DINGBAT NEGATIVE CIRCLED DIGIT SIX
    if width('\16#02780;') <> 1 then writeln("width(# 2780) incorrect"); success := FALSE; end if; # DINGBAT CIRCLED SANS-SERIF DIGIT ONE
    if width('\16#027b3;') <> 1 then writeln("width(# 27b3) incorrect"); success := FALSE; end if; # WHITE-FEATHERED RIGHTWARDS ARROW
    if width('\16#027e6;') <> 1 then writeln("width(# 27e6) incorrect"); success := FALSE; end if; # MATHEMATICAL LEFT WHITE SQUARE BRACKET
    if width('\16#027ea;') <> 1 then writeln("width(# 27ea) incorrect"); success := FALSE; end if; # MATHEMATICAL LEFT DOUBLE ANGLE BRACKET
    if width('\16#027ee;') <> 1 then writeln("width(# 27ee) incorrect"); success := FALSE; end if; # MATHEMATICAL LEFT FLATTENED PARENTHESIS
    if width('\16#028b9;') <> 1 then writeln("width(# 28b9) incorrect"); success := FALSE; end if; # BRAILLE PATTERN DOTS-14568
    if width('\16#02985;') <> 1 then writeln("width(# 2985) incorrect"); success := FALSE; end if; # LEFT WHITE PARENTHESIS
    if width('\16#02986;') <> 1 then writeln("width(# 2986) incorrect"); success := FALSE; end if; # RIGHT WHITE PARENTHESIS
    if width('\16#02987;') <> 1 then writeln("width(# 2987) incorrect"); success := FALSE; end if; # Z NOTATION LEFT IMAGE BRACKET
    if width('\16#02a6e;') <> 1 then writeln("width(# 2a6e) incorrect"); success := FALSE; end if; # EQUALS WITH ASTERISK
    if width('\16#02b55;') <> 1 then writeln("width(# 2b55) incorrect"); success := FALSE; end if; # HEAVY LARGE CIRCLE
    if width('\16#02b57;') <> 1 then writeln("width(# 2b57) incorrect"); success := FALSE; end if; # HEAVY CIRCLE WITH CIRCLE INSIDE
    if width('\16#02b5a;') <> 1 then writeln("width(# 2b5a) incorrect"); success := FALSE; end if; # <unassigned-2B5A>
    if width('\16#02ced;') <> 1 then writeln("width(# 2ced) incorrect"); success := FALSE; end if; # COPTIC CAPITAL LETTER CRYPTOGRAMMIC GANGIA
    if width('\16#02e80;') <> 1 then writeln("width(# 2e80) incorrect"); success := FALSE; end if; # CJK RADICAL REPEAT
    if width('\16#02e8d;') <> 2 then writeln("width(# 2e8d) incorrect"); success := FALSE; end if; # CJK RADICAL SMALL TWO
    if width('\16#02e9b;') <> 1 then writeln("width(# 2e9b) incorrect"); success := FALSE; end if; # CJK RADICAL CHOKE
    if width('\16#02ec7;') <> 2 then writeln("width(# 2ec7) incorrect"); success := FALSE; end if; # CJK RADICAL HORN
    if width('\16#02efa;') <> 1 then writeln("width(# 2efa) incorrect"); success := FALSE; end if; # <unassigned-2EFA>
    if width('\16#02f00;') <> 1 then writeln("width(# 2f00) incorrect"); success := FALSE; end if; # KANGXI RADICAL ONE
    if width('\16#02f6b;') <> 2 then writeln("width(# 2f6b) incorrect"); success := FALSE; end if; # KANGXI RADICAL DISH
    if width('\16#02ff0;') <> 1 then writeln("width(# 2ff0) incorrect"); success := FALSE; end if; # IDEOGRAPHIC DESCRIPTION CHARACTER LEFT TO RIGHT
    if width('\16#02ff6;') <> 2 then writeln("width(# 2ff6) incorrect"); success := FALSE; end if; # IDEOGRAPHIC DESCRIPTION CHARACTER SURROUND FROM BELOW
    if width('\16#03000;') <> 1 then writeln("width(# 3000) incorrect"); success := FALSE; end if; # IDEOGRAPHIC SPACE
    if width('\16#03001;') <> 2 then writeln("width(# 3001) incorrect"); success := FALSE; end if; # IDEOGRAPHIC COMMA
    if width('\16#03020;') <> 2 then writeln("width(# 3020) incorrect"); success := FALSE; end if; # POSTAL MARK FACE
    if width('\16#0303f;') <> 2 then writeln("width(# 303f) incorrect"); success := FALSE; end if; # IDEOGRAPHIC HALF FILL SPACE
    if width('\16#03040;') <> 1 then writeln("width(# 3040) incorrect"); success := FALSE; end if; # <unassigned-3040>
    if width('\16#03041;') <> 1 then writeln("width(# 3041) incorrect"); success := FALSE; end if; # HIRAGANA LETTER SMALL A
    if width('\16#0306c;') <> 2 then writeln("width(# 306c) incorrect"); success := FALSE; end if; # HIRAGANA LETTER NU
    if width('\16#03099;') <> 0 then writeln("width(# 3099) incorrect"); success := FALSE; end if; # COMBINING KATAKANA-HIRAGANA VOICED SOUND MARK
    if width('\16#030cc;') <> 2 then writeln("width(# 30cc) incorrect"); success := FALSE; end if; # KATAKANA LETTER NU
    if width('\16#03105;') <> 1 then writeln("width(# 3105) incorrect"); success := FALSE; end if; # BOPOMOFO LETTER B
    if width('\16#03119;') <> 2 then writeln("width(# 3119) incorrect"); success := FALSE; end if; # BOPOMOFO LETTER S
    if width('\16#0312e;') <> 1 then writeln("width(# 312e) incorrect"); success := FALSE; end if; # <unassigned-312E>
    if width('\16#0312f;') <> 1 then writeln("width(# 312f) incorrect"); success := FALSE; end if; # <unassigned-312F>
    if width('\16#03131;') <> 1 then writeln("width(# 3131) incorrect"); success := FALSE; end if; # HANGUL LETTER KIYEOK
    if width('\16#03160;') <> 2 then writeln("width(# 3160) incorrect"); success := FALSE; end if; # HANGUL LETTER YU
    if width('\16#03190;') <> 1 then writeln("width(# 3190) incorrect"); success := FALSE; end if; # IDEOGRAPHIC ANNOTATION LINKING MARK
    if width('\16#031a5;') <> 2 then writeln("width(# 31a5) incorrect"); success := FALSE; end if; # BOPOMOFO LETTER ENN
    if width('\16#031bb;') <> 1 then writeln("width(# 31bb) incorrect"); success := FALSE; end if; # <unassigned-31BB>
    if width('\16#031bd;') <> 1 then writeln("width(# 31bd) incorrect"); success := FALSE; end if; # <unassigned-31BD>
    if width('\16#031c0;') <> 1 then writeln("width(# 31c0) incorrect"); success := FALSE; end if; # CJK STROKE T
    if width('\16#031d2;') <> 1 then writeln("width(# 31d2) incorrect"); success := FALSE; end if; # CJK STROKE P
    if width('\16#031e4;') <> 1 then writeln("width(# 31e4) incorrect"); success := FALSE; end if; # <unassigned-31E4>
    if width('\16#031ea;') <> 1 then writeln("width(# 31ea) incorrect"); success := FALSE; end if; # <unassigned-31EA>
    if width('\16#031f0;') <> 1 then writeln("width(# 31f0) incorrect"); success := FALSE; end if; # KATAKANA LETTER SMALL KU
    if width('\16#03207;') <> 2 then writeln("width(# 3207) incorrect"); success := FALSE; end if; # PARENTHESIZED HANGUL IEUNG
    if width('\16#03220;') <> 1 then writeln("width(# 3220) incorrect"); success := FALSE; end if; # PARENTHESIZED IDEOGRAPH ONE
    if width('\16#03234;') <> 2 then writeln("width(# 3234) incorrect"); success := FALSE; end if; # PARENTHESIZED IDEOGRAPH NAME
    if width('\16#03248;') <> 1 then writeln("width(# 3248) incorrect"); success := FALSE; end if; # CIRCLED NUMBER TEN ON BLACK SQUARE
    if width('\16#0324c;') <> 1 then writeln("width(# 324c) incorrect"); success := FALSE; end if; # CIRCLED NUMBER FIFTY ON BLACK SQUARE
    if width('\16#03250;') <> 1 then writeln("width(# 3250) incorrect"); success := FALSE; end if; # PARTNERSHIP SIGN
    if width('\16#032a7;') <> 2 then writeln("width(# 32a7) incorrect"); success := FALSE; end if; # CIRCLED IDEOGRAPH LEFT
    if width('\16#03300;') <> 1 then writeln("width(# 3300) incorrect"); success := FALSE; end if; # SQUARE APAATO
    if width('\16#04060;') <> 2 then writeln("width(# 4060) incorrect"); success := FALSE; end if; # CJK UNIFIED IDEOGRAPH-4060
    if width('\16#04dc0;') <> 1 then writeln("width(# 4dc0) incorrect"); success := FALSE; end if; # HEXAGRAM FOR THE CREATIVE HEAVEN
    if width('\16#04de0;') <> 1 then writeln("width(# 4de0) incorrect"); success := FALSE; end if; # HEXAGRAM FOR RETREAT
    if width('\16#04e00;') <> 1 then writeln("width(# 4e00) incorrect"); success := FALSE; end if; # CJK UNIFIED IDEOGRAPH-4E00
    if width('\16#07946;') <> 2 then writeln("width(# 7946) incorrect"); success := FALSE; end if; # CJK UNIFIED IDEOGRAPH-7946
    if width('\16#0a490;') <> 1 then writeln("width(# a490) incorrect"); success := FALSE; end if; # YI RADICAL QOT
    if width('\16#0a4ab;') <> 2 then writeln("width(# a4ab) incorrect"); success := FALSE; end if; # YI RADICAL ZOT
    if width('\16#0a713;') <> 1 then writeln("width(# a713) incorrect"); success := FALSE; end if; # MODIFIER LETTER HIGH LEFT-STEM TONE BAR
    if width('\16#0a960;') <> 1 then writeln("width(# a960) incorrect"); success := FALSE; end if; # HANGUL CHOSEONG TIKEUT-MIEUM
    if width('\16#0a96e;') <> 1 then writeln("width(# a96e) incorrect"); success := FALSE; end if; # HANGUL CHOSEONG RIEUL-KHIEUKH
    if width('\16#0aabe;') <> 1 then writeln("width(# aabe) incorrect"); success := FALSE; end if; # TAI VIET VOWEL AM
    if width('\16#0ac00;') <> 1 then writeln("width(# ac00) incorrect"); success := FALSE; end if; # HANGUL SYLLABLE GA
    if width('\16#0c1d2;') <> 2 then writeln("width(# c1d2) incorrect"); success := FALSE; end if; # HANGUL SYLLABLE SWAELP
    if width('\16#0d7b0;') <> 1 then writeln("width(# d7b0) incorrect"); success := FALSE; end if; # HANGUL JUNGSEONG O-YEO
    if width('\16#0d7bb;') <> 1 then writeln("width(# d7bb) incorrect"); success := FALSE; end if; # HANGUL JUNGSEONG EU-E
    if width('\16#0d7cb;') <> 1 then writeln("width(# d7cb) incorrect"); success := FALSE; end if; # HANGUL JONGSEONG NIEUN-RIEUL
    if width('\16#0d7e3;') <> 1 then writeln("width(# d7e3) incorrect"); success := FALSE; end if; # HANGUL JONGSEONG PIEUP-TIKEUT
    if width('\16#0d7fc;') <> 1 then writeln("width(# d7fc) incorrect"); success := FALSE; end if; # <unassigned-D7FC>
    if width('\16#0dbfe;') <> 1 then writeln("width(# dbfe) incorrect"); success := FALSE; end if; # <lead surrogate-DBFE>
    if width('\16#0e000;') <> 1 then writeln("width(# e000) incorrect"); success := FALSE; end if; # <private use area-E000>
    if width('\16#0ec80;') <> 1 then writeln("width(# ec80) incorrect"); success := FALSE; end if; # <private use area-EC80>
    if width('\16#0f900;') <> 1 then writeln("width(# f900) incorrect"); success := FALSE; end if; # CJK COMPATIBILITY IDEOGRAPH-F900
    if width('\16#0fa00;') <> 2 then writeln("width(# fa00) incorrect"); success := FALSE; end if; # CJK COMPATIBILITY IDEOGRAPH-FA00
    if width('\16#0fb00;') <> 1 then writeln("width(# fb00) incorrect"); success := FALSE; end if; # LATIN SMALL LIGATURE FF
    if width('\16#0fc80;') <> 1 then writeln("width(# fc80) incorrect"); success := FALSE; end if; # ARABIC LIGATURE KAF WITH ALEF FINAL FORM
    if width('\16#0fe10;') <> 1 then writeln("width(# fe10) incorrect"); success := FALSE; end if; # PRESENTATION FORM FOR VERTICAL COMMA
    if width('\16#0fe15;') <> 1 then writeln("width(# fe15) incorrect"); success := FALSE; end if; # PRESENTATION FORM FOR VERTICAL EXCLAMATION MARK
    if width('\16#0fe25;') <> 1 then writeln("width(# fe25) incorrect"); success := FALSE; end if; # COMBINING MACRON RIGHT HALF
    if width('\16#0fe30;') <> 1 then writeln("width(# fe30) incorrect"); success := FALSE; end if; # PRESENTATION FORM FOR VERTICAL TWO DOT LEADER
    if width('\16#0fe41;') <> 2 then writeln("width(# fe41) incorrect"); success := FALSE; end if; # PRESENTATION FORM FOR VERTICAL LEFT CORNER BRACKET
    if width('\16#0fe54;') <> 1 then writeln("width(# fe54) incorrect"); success := FALSE; end if; # SMALL SEMICOLON
    if width('\16#0fe5d;') <> 2 then writeln("width(# fe5d) incorrect"); success := FALSE; end if; # SMALL LEFT TORTOISE SHELL BRACKET
    if width('\16#0fe68;') <> 1 then writeln("width(# fe68) incorrect"); success := FALSE; end if; # SMALL REVERSE SOLIDUS
    if width('\16#0fe6a;') <> 2 then writeln("width(# fe6a) incorrect"); success := FALSE; end if; # SMALL PERCENT SIGN
    if width('\16#0feb6;') <> 1 then writeln("width(# feb6) incorrect"); success := FALSE; end if; # ARABIC LETTER SHEEN FINAL FORM
    if width('\16#0ff01;') <> 1 then writeln("width(# ff01) incorrect"); success := FALSE; end if; # FULLWIDTH EXCLAMATION MARK
    if width('\16#0ff31;') <> 2 then writeln("width(# ff31) incorrect"); success := FALSE; end if; # FULLWIDTH LATIN CAPITAL LETTER Q
    if width('\16#0ff61;') <> 2 then writeln("width(# ff61) incorrect"); success := FALSE; end if; # HALFWIDTH IDEOGRAPHIC FULL STOP
    if width('\16#0ff90;') <> 1 then writeln("width(# ff90) incorrect"); success := FALSE; end if; # HALFWIDTH KATAKANA LETTER MI
    if width('\16#0ffc2;') <> 1 then writeln("width(# ffc2) incorrect"); success := FALSE; end if; # HALFWIDTH HANGUL LETTER A
    if width('\16#0ffc5;') <> 1 then writeln("width(# ffc5) incorrect"); success := FALSE; end if; # HALFWIDTH HANGUL LETTER YAE
    if width('\16#0ffca;') <> 1 then writeln("width(# ffca) incorrect"); success := FALSE; end if; # HALFWIDTH HANGUL LETTER YEO
    if width('\16#0ffcd;') <> 1 then writeln("width(# ffcd) incorrect"); success := FALSE; end if; # HALFWIDTH HANGUL LETTER WA
    if width('\16#0ffd2;') <> 1 then writeln("width(# ffd2) incorrect"); success := FALSE; end if; # HALFWIDTH HANGUL LETTER YO
    if width('\16#0ffd5;') <> 1 then writeln("width(# ffd5) incorrect"); success := FALSE; end if; # HALFWIDTH HANGUL LETTER WE
    if width('\16#0ffda;') <> 1 then writeln("width(# ffda) incorrect"); success := FALSE; end if; # HALFWIDTH HANGUL LETTER EU
    if width('\16#0ffdb;') <> 1 then writeln("width(# ffdb) incorrect"); success := FALSE; end if; # HALFWIDTH HANGUL LETTER YI
    if width('\16#0ffe0;') <> 1 then writeln("width(# ffe0) incorrect"); success := FALSE; end if; # FULLWIDTH CENT SIGN
    if width('\16#0ffe3;') <> 2 then writeln("width(# ffe3) incorrect"); success := FALSE; end if; # FULLWIDTH MACRON
    if width('\16#0ffeb;') <> 1 then writeln("width(# ffeb) incorrect"); success := FALSE; end if; # HALFWIDTH RIGHTWARDS ARROW
    if width('\16#0fffd;') <> 1 then writeln("width(# fffd) incorrect"); success := FALSE; end if; # REPLACEMENT CHARACTER
    if width('\16#1b000;') <> 1 then writeln("width(#1b000) incorrect"); success := FALSE; end if; # KATAKANA LETTER ARCHAIC E
    if width('\16#1b001;') <> 1 then writeln("width(#1b001) incorrect"); success := FALSE; end if; # HIRAGANA LETTER ARCHAIC YE
    if width('\16#1b002;') <> 1 then writeln("width(#1b002) incorrect"); success := FALSE; end if; # <unassigned-1B002>
    if width('\16#1d081;') <> 1 then writeln("width(#1d081) incorrect"); success := FALSE; end if; # BYZANTINE MUSICAL SYMBOL KRATIMA ARCHAION
    if width('\16#1f100;') <> 1 then writeln("width(#1f100) incorrect"); success := FALSE; end if; # DIGIT ZERO FULL STOP
    if width('\16#1f105;') <> 1 then writeln("width(#1f105) incorrect"); success := FALSE; end if; # DIGIT FOUR COMMA
    if width('\16#1f10b;') <> 1 then writeln("width(#1f10b) incorrect"); success := FALSE; end if; # <unassigned-1F10B>
    if width('\16#1f10d;') <> 1 then writeln("width(#1f10d) incorrect"); success := FALSE; end if; # <unassigned-1F10D>
    if width('\16#1f110;') <> 1 then writeln("width(#1f110) incorrect"); success := FALSE; end if; # PARENTHESIZED LATIN CAPITAL LETTER A
    if width('\16#1f11f;') <> 1 then writeln("width(#1f11f) incorrect"); success := FALSE; end if; # PARENTHESIZED LATIN CAPITAL LETTER P
    if width('\16#1f12e;') <> 1 then writeln("width(#1f12e) incorrect"); success := FALSE; end if; # CIRCLED WZ
    if width('\16#1f12f;') <> 1 then writeln("width(#1f12f) incorrect"); success := FALSE; end if; # <unassigned-1F12F>
    if width('\16#1f130;') <> 1 then writeln("width(#1f130) incorrect"); success := FALSE; end if; # SQUARED LATIN CAPITAL LETTER A
    if width('\16#1f14d;') <> 1 then writeln("width(#1f14d) incorrect"); success := FALSE; end if; # SQUARED SS
    if width('\16#1f16a;') <> 1 then writeln("width(#1f16a) incorrect"); success := FALSE; end if; # <unassigned-1F16A>
    if width('\16#1f16d;') <> 1 then writeln("width(#1f16d) incorrect"); success := FALSE; end if; # <unassigned-1F16D>
    if width('\16#1f170;') <> 1 then writeln("width(#1f170) incorrect"); success := FALSE; end if; # NEGATIVE SQUARED LATIN CAPITAL LETTER A
    if width('\16#1f185;') <> 1 then writeln("width(#1f185) incorrect"); success := FALSE; end if; # NEGATIVE SQUARED LATIN CAPITAL LETTER V
    if width('\16#1f200;') <> 1 then writeln("width(#1f200) incorrect"); success := FALSE; end if; # SQUARE HIRAGANA HOKA
    if width('\16#1f201;') <> 1 then writeln("width(#1f201) incorrect"); success := FALSE; end if; # SQUARED KATAKANA KOKO
    if width('\16#1f210;') <> 1 then writeln("width(#1f210) incorrect"); success := FALSE; end if; # SQUARED CJK UNIFIED IDEOGRAPH-624B
    if width('\16#1f225;') <> 1 then writeln("width(#1f225) incorrect"); success := FALSE; end if; # SQUARED CJK UNIFIED IDEOGRAPH-54390
    if width('\16#1f240;') <> 1 then writeln("width(#1f240) incorrect"); success := FALSE; end if; # TORTOISE SHELL BRACKETED CJK UNIFIED IDEOGRAPH-672C
    if width('\16#1f244;') <> 1 then writeln("width(#1f244) incorrect"); success := FALSE; end if; # TORTOISE SHELL BRACKETED CJK UNIFIED IDEOGRAPH-70B9
    if width('\16#1f250;') <> 1 then writeln("width(#1f250) incorrect"); success := FALSE; end if; # CIRCLED IDEOGRAPH ADVANTAGE
    if width('\16#1f251;') <> 1 then writeln("width(#1f251) incorrect"); success := FALSE; end if; # CIRCLED IDEOGRAPH ACCEPT
    if width('\16#20000;') <> 1 then writeln("width(#20000) incorrect"); success := FALSE; end if; # CJK UNIFIED IDEOGRAPH-20000
    if width('\16#27fff;') <> 2 then writeln("width(#27fff) incorrect"); success := FALSE; end if; # CJK UNIFIED IDEOGRAPH-27FFF
    if success then
      writeln("width function works correctly.");
    end if;
  end func;


const func string: literalFunction (in char: ch) is
  return literal(ch);


const func string: cLiteralFunction (in char: ch) is
  return c_literal(ch);


const func boolean: check_literal_func is func
  result
    var boolean: okay is TRUE;
  local
    var boolean: ok is TRUE;
    var string: stri is "";
  begin
    if  literalFunction('\0;')   <> "'\\0;'" or
        literalFunction('\1;')   <> "'\\1;'" or
        literalFunction('\2;')   <> "'\\2;'" or
        literalFunction('\3;')   <> "'\\3;'" or
        literalFunction('\4;')   <> "'\\4;'" or
        literalFunction('\5;')   <> "'\\5;'" or
        literalFunction('\6;')   <> "'\\6;'" or
        literalFunction('\a')    <> "'\\a'" or
        literalFunction('\b')    <> "'\\b'" or
        literalFunction('\t')    <> "'\\t'" or
        literalFunction('\n')    <> "'\\n'" or
        literalFunction('\v')    <> "'\\v'" or
        literalFunction('\f')    <> "'\\f'" or
        literalFunction('\r')    <> "'\\r'" or
        literalFunction('\14;')  <> "'\\14;'" or
        literalFunction('\15;')  <> "'\\15;'" or
        literalFunction('\16;')  <> "'\\16;'" or
        literalFunction('\17;')  <> "'\\17;'" or
        literalFunction('\18;')  <> "'\\18;'" or
        literalFunction('\19;')  <> "'\\19;'" or
        literalFunction('\20;')  <> "'\\20;'" or
        literalFunction('\21;')  <> "'\\21;'" or
        literalFunction('\22;')  <> "'\\22;'" or
        literalFunction('\23;')  <> "'\\23;'" or
        literalFunction('\24;')  <> "'\\24;'" or
        literalFunction('\25;')  <> "'\\25;'" or
        literalFunction('\26;')  <> "'\\26;'" or
        literalFunction('\e')    <> "'\\e'" or
        literalFunction('\28;')  <> "'\\28;'" or
        literalFunction('\29;')  <> "'\\29;'" or
        literalFunction('\30;')  <> "'\\30;'" or
        literalFunction('\31;')  <> "'\\31;'" or
        literalFunction(' ')     <> "' '" or
        literalFunction('"')     <> "'\\\"'" or
        literalFunction('\\')    <> "'\\\\'" or
        literalFunction('\'')    <> "'\\''" or
        literalFunction('~')     <> "'~'" or
        literalFunction('\128;') <> "'\\128;'" or
        literalFunction('\128;') <> "'\\128;'" or
        literalFunction('\129;') <> "'\\129;'" or
        literalFunction('\130;') <> "'\\130;'" or
        literalFunction('\131;') <> "'\\131;'" or
        literalFunction('\132;') <> "'\\132;'" or
        literalFunction('\133;') <> "'\\133;'" or
        literalFunction('\134;') <> "'\\134;'" or
        literalFunction('\135;') <> "'\\135;'" or
        literalFunction('\136;') <> "'\\136;'" or
        literalFunction('\137;') <> "'\\137;'" or
        literalFunction('\138;') <> "'\\138;'" or
        literalFunction('\139;') <> "'\\139;'" or
        literalFunction('\140;') <> "'\\140;'" or
        literalFunction('\141;') <> "'\\141;'" or
        literalFunction('\142;') <> "'\\142;'" or
        literalFunction('\143;') <> "'\\143;'" or
        literalFunction('\144;') <> "'\\144;'" or
        literalFunction('\145;') <> "'\\145;'" or
        literalFunction('\146;') <> "'\\146;'" or
        literalFunction('\147;') <> "'\\147;'" or
        literalFunction('\148;') <> "'\\148;'" or
        literalFunction('\149;') <> "'\\149;'" or
        literalFunction('\150;') <> "'\\150;'" or
        literalFunction('\151;') <> "'\\151;'" or
        literalFunction('\152;') <> "'\\152;'" or
        literalFunction('\153;') <> "'\\153;'" or
        literalFunction('\154;') <> "'\\154;'" or
        literalFunction('\155;') <> "'\\155;'" or
        literalFunction('\156;') <> "'\\156;'" or
        literalFunction('\157;') <> "'\\157;'" or
        literalFunction('\158;') <> "'\\158;'" or
        literalFunction('\159;') <> "'\\159;'" or
        literalFunction('\160;') <> "'\\160;'" or
        literalFunction('')     <> "''" or
        literalFunction('')     <> "''" or
        literalFunction('')     <> "''" or
        literalFunction('')     <> "''" or
        literalFunction('')     <> "''" or
        literalFunction('')     <> "''" or
        literalFunction('')     <> "''" or
        literalFunction('')     <> "''" or
        literalFunction('')     <> "''" or
        literalFunction('')     <> "''" or
        literalFunction('')     <> "''" or
        literalFunction('')     <> "''" or
        literalFunction('')     <> "''" or
        literalFunction('')     <> "'\\338;'" or
        literalFunction('')     <> "'\\352;'" or
        literalFunction('')     <> "'\\402;'" or
        literalFunction('')     <> "'\\8224;'" or
        literalFunction('')     <> "'\\8226;'" or
        literalFunction('')     <> "'\\8240;'" or
        literalFunction('')     <> "'\\8364;'" or
        literalFunction('')     <> "'\\8482;'" then
      writeln(" ***** Function literal(ch) via a function does not work correctly. (1)");
      okay := FALSE;
    end if;

    if  literalFunction(charExpr('\0;'))   <> "'\\0;'" or
        literalFunction(charExpr('\1;'))   <> "'\\1;'" or
        literalFunction(charExpr('\2;'))   <> "'\\2;'" or
        literalFunction(charExpr('\3;'))   <> "'\\3;'" or
        literalFunction(charExpr('\4;'))   <> "'\\4;'" or
        literalFunction(charExpr('\5;'))   <> "'\\5;'" or
        literalFunction(charExpr('\6;'))   <> "'\\6;'" or
        literalFunction(charExpr('\a'))    <> "'\\a'" or
        literalFunction(charExpr('\b'))    <> "'\\b'" or
        literalFunction(charExpr('\t'))    <> "'\\t'" or
        literalFunction(charExpr('\n'))    <> "'\\n'" or
        literalFunction(charExpr('\v'))    <> "'\\v'" or
        literalFunction(charExpr('\f'))    <> "'\\f'" or
        literalFunction(charExpr('\r'))    <> "'\\r'" or
        literalFunction(charExpr('\14;'))  <> "'\\14;'" or
        literalFunction(charExpr('\15;'))  <> "'\\15;'" or
        literalFunction(charExpr('\16;'))  <> "'\\16;'" or
        literalFunction(charExpr('\17;'))  <> "'\\17;'" or
        literalFunction(charExpr('\18;'))  <> "'\\18;'" or
        literalFunction(charExpr('\19;'))  <> "'\\19;'" or
        literalFunction(charExpr('\20;'))  <> "'\\20;'" or
        literalFunction(charExpr('\21;'))  <> "'\\21;'" or
        literalFunction(charExpr('\22;'))  <> "'\\22;'" or
        literalFunction(charExpr('\23;'))  <> "'\\23;'" or
        literalFunction(charExpr('\24;'))  <> "'\\24;'" or
        literalFunction(charExpr('\25;'))  <> "'\\25;'" or
        literalFunction(charExpr('\26;'))  <> "'\\26;'" or
        literalFunction(charExpr('\e'))    <> "'\\e'" or
        literalFunction(charExpr('\28;'))  <> "'\\28;'" or
        literalFunction(charExpr('\29;'))  <> "'\\29;'" or
        literalFunction(charExpr('\30;'))  <> "'\\30;'" or
        literalFunction(charExpr('\31;'))  <> "'\\31;'" or
        literalFunction(charExpr(' '))     <> "' '" or
        literalFunction(charExpr('"'))     <> "'\\\"'" or
        literalFunction(charExpr('\\'))    <> "'\\\\'" or
        literalFunction(charExpr('\''))    <> "'\\''" or
        literalFunction(charExpr('~'))     <> "'~'" or
        literalFunction(charExpr('\128;')) <> "'\\128;'" or
        literalFunction(charExpr('\128;')) <> "'\\128;'" or
        literalFunction(charExpr('\129;')) <> "'\\129;'" or
        literalFunction(charExpr('\130;')) <> "'\\130;'" or
        literalFunction(charExpr('\131;')) <> "'\\131;'" or
        literalFunction(charExpr('\132;')) <> "'\\132;'" or
        literalFunction(charExpr('\133;')) <> "'\\133;'" or
        literalFunction(charExpr('\134;')) <> "'\\134;'" or
        literalFunction(charExpr('\135;')) <> "'\\135;'" or
        literalFunction(charExpr('\136;')) <> "'\\136;'" or
        literalFunction(charExpr('\137;')) <> "'\\137;'" or
        literalFunction(charExpr('\138;')) <> "'\\138;'" or
        literalFunction(charExpr('\139;')) <> "'\\139;'" or
        literalFunction(charExpr('\140;')) <> "'\\140;'" or
        literalFunction(charExpr('\141;')) <> "'\\141;'" or
        literalFunction(charExpr('\142;')) <> "'\\142;'" or
        literalFunction(charExpr('\143;')) <> "'\\143;'" or
        literalFunction(charExpr('\144;')) <> "'\\144;'" or
        literalFunction(charExpr('\145;')) <> "'\\145;'" or
        literalFunction(charExpr('\146;')) <> "'\\146;'" or
        literalFunction(charExpr('\147;')) <> "'\\147;'" or
        literalFunction(charExpr('\148;')) <> "'\\148;'" or
        literalFunction(charExpr('\149;')) <> "'\\149;'" or
        literalFunction(charExpr('\150;')) <> "'\\150;'" or
        literalFunction(charExpr('\151;')) <> "'\\151;'" or
        literalFunction(charExpr('\152;')) <> "'\\152;'" or
        literalFunction(charExpr('\153;')) <> "'\\153;'" or
        literalFunction(charExpr('\154;')) <> "'\\154;'" or
        literalFunction(charExpr('\155;')) <> "'\\155;'" or
        literalFunction(charExpr('\156;')) <> "'\\156;'" or
        literalFunction(charExpr('\157;')) <> "'\\157;'" or
        literalFunction(charExpr('\158;')) <> "'\\158;'" or
        literalFunction(charExpr('\159;')) <> "'\\159;'" or
        literalFunction(charExpr('\160;')) <> "'\\160;'" or
        literalFunction(charExpr(''))     <> "''" or
        literalFunction(charExpr(''))     <> "''" or
        literalFunction(charExpr(''))     <> "''" or
        literalFunction(charExpr(''))     <> "''" or
        literalFunction(charExpr(''))     <> "''" or
        literalFunction(charExpr(''))     <> "''" or
        literalFunction(charExpr(''))     <> "''" or
        literalFunction(charExpr(''))     <> "''" or
        literalFunction(charExpr(''))     <> "''" or
        literalFunction(charExpr(''))     <> "''" or
        literalFunction(charExpr(''))     <> "''" or
        literalFunction(charExpr(''))     <> "''" or
        literalFunction(charExpr(''))     <> "''" or
        literalFunction(charExpr(''))     <> "'\\338;'" or
        literalFunction(charExpr(''))     <> "'\\352;'" or
        literalFunction(charExpr(''))     <> "'\\402;'" or
        literalFunction(charExpr(''))     <> "'\\8224;'" or
        literalFunction(charExpr(''))     <> "'\\8226;'" or
        literalFunction(charExpr(''))     <> "'\\8240;'" or
        literalFunction(charExpr(''))     <> "'\\8364;'" or
        literalFunction(charExpr(''))     <> "'\\8482;'" then
      writeln(" ***** Function literal(ch) via a function does not work correctly. (2)");
      okay := FALSE;
    end if;

    if  c_literal('\0;')   <> "'\\000'" or
        c_literal('\1;')   <> "'\\001'" or
        c_literal('\2;')   <> "'\\002'" or
        c_literal('\3;')   <> "'\\003'" or
        c_literal('\4;')   <> "'\\004'" or
        c_literal('\5;')   <> "'\\005'" or
        c_literal('\6;')   <> "'\\006'" or
        c_literal('\7;')   <> "'\\007'" or
        c_literal('\b')    <> "'\\b'" or
        c_literal('\t')    <> "'\\t'" or
        c_literal('\n')    <> "'\\n'" or
        c_literal('\11;')  <> "'\\013'" or
        c_literal('\f')    <> "'\\f'" or
        c_literal('\r')    <> "'\\r'" or
        c_literal('\14;')  <> "'\\016'" or
        c_literal('\15;')  <> "'\\017'" or
        c_literal('\16;')  <> "'\\020'" or
        c_literal('\17;')  <> "'\\021'" or
        c_literal('\18;')  <> "'\\022'" or
        c_literal('\19;')  <> "'\\023'" or
        c_literal('\20;')  <> "'\\024'" or
        c_literal('\21;')  <> "'\\025'" or
        c_literal('\22;')  <> "'\\026'" or
        c_literal('\23;')  <> "'\\027'" or
        c_literal('\24;')  <> "'\\030'" or
        c_literal('\25;')  <> "'\\031'" or
        c_literal('\26;')  <> "'\\032'" or
        c_literal('\27;')  <> "'\\033'" or
        c_literal('\28;')  <> "'\\034'" or
        c_literal('\29;')  <> "'\\035'" or
        c_literal('\30;')  <> "'\\036'" or
        c_literal('\31;')  <> "'\\037'" or
        c_literal(' ')     <> "' '" or
        c_literal('!')     <> "'!'" or
        c_literal('"')     <> "'\"'" or
        c_literal('\\')    <> "'\\\\'" or
        c_literal('\'')    <> "'\\''" or
        c_literal('~')     <> "'~'" or
        c_literal('\128;') <> "128" or
        c_literal('\129;') <> "129" or
        c_literal('\130;') <> "130" or
        c_literal('\131;') <> "131" or
        c_literal('\132;') <> "132" or
        c_literal('\133;') <> "133" or
        c_literal('\134;') <> "134" or
        c_literal('\135;') <> "135" or
        c_literal('\136;') <> "136" or
        c_literal('\137;') <> "137" or
        c_literal('\138;') <> "138" or
        c_literal('\139;') <> "139" or
        c_literal('\140;') <> "140" or
        c_literal('\141;') <> "141" or
        c_literal('\142;') <> "142" or
        c_literal('\143;') <> "143" or
        c_literal('\144;') <> "144" or
        c_literal('\145;') <> "145" or
        c_literal('\146;') <> "146" or
        c_literal('\147;') <> "147" or
        c_literal('\148;') <> "148" or
        c_literal('\149;') <> "149" or
        c_literal('\150;') <> "150" or
        c_literal('\151;') <> "151" or
        c_literal('\152;') <> "152" or
        c_literal('\153;') <> "153" or
        c_literal('\154;') <> "154" or
        c_literal('\155;') <> "155" or
        c_literal('\156;') <> "156" or
        c_literal('\157;') <> "157" or
        c_literal('\158;') <> "158" or
        c_literal('\159;') <> "159" or
        c_literal('\160;') <> "160" or
        c_literal('')     <> "161" or
        c_literal('')     <> "164" or
        c_literal('')     <> "167" or
        c_literal('')     <> "172" or
        c_literal('')     <> "173" or
        c_literal('')     <> "181" or
        c_literal('')     <> "191" or
        c_literal('')     <> "196" or
        c_literal('')     <> "215" or
        c_literal('')     <> "223" or
        c_literal('')     <> "228" or
        c_literal('')     <> "247" or
        c_literal('')     <> "255" or
        c_literal('')     <> "338" or
        c_literal('')     <> "352" or
        c_literal('')     <> "402" or
        c_literal('')     <> "8224" or
        c_literal('')     <> "8226" or
        c_literal('')     <> "8240" or
        c_literal('')     <> "8364" or
        c_literal('')     <> "8482" then
      writeln(" ***** Function c_literal(ch) does not work correctly. (1)");
      okay := FALSE;
    end if;

    if  c_literal(charExpr('\0;'))   <> "'\\000'" or
        c_literal(charExpr('\1;'))   <> "'\\001'" or
        c_literal(charExpr('\2;'))   <> "'\\002'" or
        c_literal(charExpr('\3;'))   <> "'\\003'" or
        c_literal(charExpr('\4;'))   <> "'\\004'" or
        c_literal(charExpr('\5;'))   <> "'\\005'" or
        c_literal(charExpr('\6;'))   <> "'\\006'" or
        c_literal(charExpr('\7;'))   <> "'\\007'" or
        c_literal(charExpr('\b'))    <> "'\\b'" or
        c_literal(charExpr('\t'))    <> "'\\t'" or
        c_literal(charExpr('\n'))    <> "'\\n'" or
        c_literal(charExpr('\11;'))  <> "'\\013'" or
        c_literal(charExpr('\f'))    <> "'\\f'" or
        c_literal(charExpr('\r'))    <> "'\\r'" or
        c_literal(charExpr('\14;'))  <> "'\\016'" or
        c_literal(charExpr('\15;'))  <> "'\\017'" or
        c_literal(charExpr('\16;'))  <> "'\\020'" or
        c_literal(charExpr('\17;'))  <> "'\\021'" or
        c_literal(charExpr('\18;'))  <> "'\\022'" or
        c_literal(charExpr('\19;'))  <> "'\\023'" or
        c_literal(charExpr('\20;'))  <> "'\\024'" or
        c_literal(charExpr('\21;'))  <> "'\\025'" or
        c_literal(charExpr('\22;'))  <> "'\\026'" or
        c_literal(charExpr('\23;'))  <> "'\\027'" or
        c_literal(charExpr('\24;'))  <> "'\\030'" or
        c_literal(charExpr('\25;'))  <> "'\\031'" or
        c_literal(charExpr('\26;'))  <> "'\\032'" or
        c_literal(charExpr('\27;'))  <> "'\\033'" or
        c_literal(charExpr('\28;'))  <> "'\\034'" or
        c_literal(charExpr('\29;'))  <> "'\\035'" or
        c_literal(charExpr('\30;'))  <> "'\\036'" or
        c_literal(charExpr('\31;'))  <> "'\\037'" or
        c_literal(charExpr(' '))     <> "' '" or
        c_literal(charExpr('!'))     <> "'!'" or
        c_literal(charExpr('"'))     <> "'\"'" or
        c_literal(charExpr('\\'))    <> "'\\\\'" or
        c_literal(charExpr('\''))    <> "'\\''" or
        c_literal(charExpr('~'))     <> "'~'" or
        c_literal(charExpr('\128;')) <> "128" or
        c_literal(charExpr('\129;')) <> "129" or
        c_literal(charExpr('\130;')) <> "130" or
        c_literal(charExpr('\131;')) <> "131" or
        c_literal(charExpr('\132;')) <> "132" or
        c_literal(charExpr('\133;')) <> "133" or
        c_literal(charExpr('\134;')) <> "134" or
        c_literal(charExpr('\135;')) <> "135" or
        c_literal(charExpr('\136;')) <> "136" or
        c_literal(charExpr('\137;')) <> "137" or
        c_literal(charExpr('\138;')) <> "138" or
        c_literal(charExpr('\139;')) <> "139" or
        c_literal(charExpr('\140;')) <> "140" or
        c_literal(charExpr('\141;')) <> "141" or
        c_literal(charExpr('\142;')) <> "142" or
        c_literal(charExpr('\143;')) <> "143" or
        c_literal(charExpr('\144;')) <> "144" or
        c_literal(charExpr('\145;')) <> "145" or
        c_literal(charExpr('\146;')) <> "146" or
        c_literal(charExpr('\147;')) <> "147" or
        c_literal(charExpr('\148;')) <> "148" or
        c_literal(charExpr('\149;')) <> "149" or
        c_literal(charExpr('\150;')) <> "150" or
        c_literal(charExpr('\151;')) <> "151" or
        c_literal(charExpr('\152;')) <> "152" or
        c_literal(charExpr('\153;')) <> "153" or
        c_literal(charExpr('\154;')) <> "154" or
        c_literal(charExpr('\155;')) <> "155" or
        c_literal(charExpr('\156;')) <> "156" or
        c_literal(charExpr('\157;')) <> "157" or
        c_literal(charExpr('\158;')) <> "158" or
        c_literal(charExpr('\159;')) <> "159" or
        c_literal(charExpr('\160;')) <> "160" or
        c_literal(charExpr(''))     <> "161" or
        c_literal(charExpr(''))     <> "164" or
        c_literal(charExpr(''))     <> "167" or
        c_literal(charExpr(''))     <> "172" or
        c_literal(charExpr(''))     <> "173" or
        c_literal(charExpr(''))     <> "181" or
        c_literal(charExpr(''))     <> "191" or
        c_literal(charExpr(''))     <> "196" or
        c_literal(charExpr(''))     <> "215" or
        c_literal(charExpr(''))     <> "223" or
        c_literal(charExpr(''))     <> "228" or
        c_literal(charExpr(''))     <> "247" or
        c_literal(charExpr(''))     <> "255" or
        c_literal(charExpr(''))     <> "338" or
        c_literal(charExpr(''))     <> "352" or
        c_literal(charExpr(''))     <> "402" or
        c_literal(charExpr(''))     <> "8224" or
        c_literal(charExpr(''))     <> "8226" or
        c_literal(charExpr(''))     <> "8240" or
        c_literal(charExpr(''))     <> "8364" or
        c_literal(charExpr(''))     <> "8482" then
      writeln(" ***** Function c_literal(ch) does not work correctly. (2)");
      okay := FALSE;
    end if;

    ok := TRUE;
    stri := c_literal('\0;');   ok := ok and stri = "'\\000'";
    stri := c_literal('\1;');   ok := ok and stri = "'\\001'";
    stri := c_literal('\2;');   ok := ok and stri = "'\\002'";
    stri := c_literal('\3;');   ok := ok and stri = "'\\003'";
    stri := c_literal('\4;');   ok := ok and stri = "'\\004'";
    stri := c_literal('\5;');   ok := ok and stri = "'\\005'";
    stri := c_literal('\6;');   ok := ok and stri = "'\\006'";
    stri := c_literal('\7;');   ok := ok and stri = "'\\007'";
    stri := c_literal('\b');    ok := ok and stri = "'\\b'";
    stri := c_literal('\t');    ok := ok and stri = "'\\t'";
    stri := c_literal('\n');    ok := ok and stri = "'\\n'";
    stri := c_literal('\11;');  ok := ok and stri = "'\\013'";
    stri := c_literal('\f');    ok := ok and stri = "'\\f'";
    stri := c_literal('\r');    ok := ok and stri = "'\\r'";
    stri := c_literal('\14;');  ok := ok and stri = "'\\016'";
    stri := c_literal('\15;');  ok := ok and stri = "'\\017'";
    stri := c_literal('\16;');  ok := ok and stri = "'\\020'";
    stri := c_literal('\17;');  ok := ok and stri = "'\\021'";
    stri := c_literal('\18;');  ok := ok and stri = "'\\022'";
    stri := c_literal('\19;');  ok := ok and stri = "'\\023'";
    stri := c_literal('\20;');  ok := ok and stri = "'\\024'";
    stri := c_literal('\21;');  ok := ok and stri = "'\\025'";
    stri := c_literal('\22;');  ok := ok and stri = "'\\026'";
    stri := c_literal('\23;');  ok := ok and stri = "'\\027'";
    stri := c_literal('\24;');  ok := ok and stri = "'\\030'";
    stri := c_literal('\25;');  ok := ok and stri = "'\\031'";
    stri := c_literal('\26;');  ok := ok and stri = "'\\032'";
    stri := c_literal('\27;');  ok := ok and stri = "'\\033'";
    stri := c_literal('\28;');  ok := ok and stri = "'\\034'";
    stri := c_literal('\29;');  ok := ok and stri = "'\\035'";
    stri := c_literal('\30;');  ok := ok and stri = "'\\036'";
    stri := c_literal('\31;');  ok := ok and stri = "'\\037'";
    stri := c_literal(' ');     ok := ok and stri = "' '";
    stri := c_literal('!');     ok := ok and stri = "'!'";
    stri := c_literal('"');     ok := ok and stri = "'\"'";
    stri := c_literal('\\');    ok := ok and stri = "'\\\\'";
    stri := c_literal('\'');    ok := ok and stri = "'\\''";
    stri := c_literal('~');     ok := ok and stri = "'~'";
    stri := c_literal('\128;'); ok := ok and stri = "128";
    stri := c_literal('\129;'); ok := ok and stri = "129";
    stri := c_literal('\130;'); ok := ok and stri = "130";
    stri := c_literal('\131;'); ok := ok and stri = "131";
    stri := c_literal('\132;'); ok := ok and stri = "132";
    stri := c_literal('\133;'); ok := ok and stri = "133";
    stri := c_literal('\134;'); ok := ok and stri = "134";
    stri := c_literal('\135;'); ok := ok and stri = "135";
    stri := c_literal('\136;'); ok := ok and stri = "136";
    stri := c_literal('\137;'); ok := ok and stri = "137";
    stri := c_literal('\138;'); ok := ok and stri = "138";
    stri := c_literal('\139;'); ok := ok and stri = "139";
    stri := c_literal('\140;'); ok := ok and stri = "140";
    stri := c_literal('\141;'); ok := ok and stri = "141";
    stri := c_literal('\142;'); ok := ok and stri = "142";
    stri := c_literal('\143;'); ok := ok and stri = "143";
    stri := c_literal('\144;'); ok := ok and stri = "144";
    stri := c_literal('\145;'); ok := ok and stri = "145";
    stri := c_literal('\146;'); ok := ok and stri = "146";
    stri := c_literal('\147;'); ok := ok and stri = "147";
    stri := c_literal('\148;'); ok := ok and stri = "148";
    stri := c_literal('\149;'); ok := ok and stri = "149";
    stri := c_literal('\150;'); ok := ok and stri = "150";
    stri := c_literal('\151;'); ok := ok and stri = "151";
    stri := c_literal('\152;'); ok := ok and stri = "152";
    stri := c_literal('\153;'); ok := ok and stri = "153";
    stri := c_literal('\154;'); ok := ok and stri = "154";
    stri := c_literal('\155;'); ok := ok and stri = "155";
    stri := c_literal('\156;'); ok := ok and stri = "156";
    stri := c_literal('\157;'); ok := ok and stri = "157";
    stri := c_literal('\158;'); ok := ok and stri = "158";
    stri := c_literal('\159;'); ok := ok and stri = "159";
    stri := c_literal('\160;'); ok := ok and stri = "160";
    stri := c_literal('');     ok := ok and stri = "161";
    stri := c_literal('');     ok := ok and stri = "164";
    stri := c_literal('');     ok := ok and stri = "167";
    stri := c_literal('');     ok := ok and stri = "172";
    stri := c_literal('');     ok := ok and stri = "173";
    stri := c_literal('');     ok := ok and stri = "181";
    stri := c_literal('');     ok := ok and stri = "191";
    stri := c_literal('');     ok := ok and stri = "196";
    stri := c_literal('');     ok := ok and stri = "215";
    stri := c_literal('');     ok := ok and stri = "223";
    stri := c_literal('');     ok := ok and stri = "228";
    stri := c_literal('');     ok := ok and stri = "247";
    stri := c_literal('');     ok := ok and stri = "255";
    stri := c_literal('');     ok := ok and stri = "338";
    stri := c_literal('');     ok := ok and stri = "352";
    stri := c_literal('');     ok := ok and stri = "402";
    stri := c_literal('');     ok := ok and stri = "8224";
    stri := c_literal('');     ok := ok and stri = "8226";
    stri := c_literal('');     ok := ok and stri = "8240";
    stri := c_literal('');     ok := ok and stri = "8364";
    stri := c_literal('');     ok := ok and stri = "8482";
    if not ok then
      writeln(" ***** Function c_literal(ch) does not work correctly. (3)");
      okay := FALSE;
    end if;

    ok := TRUE;
    stri := c_literal(charExpr('\0;'));   ok := ok and stri = "'\\000'";
    stri := c_literal(charExpr('\1;'));   ok := ok and stri = "'\\001'";
    stri := c_literal(charExpr('\2;'));   ok := ok and stri = "'\\002'";
    stri := c_literal(charExpr('\3;'));   ok := ok and stri = "'\\003'";
    stri := c_literal(charExpr('\4;'));   ok := ok and stri = "'\\004'";
    stri := c_literal(charExpr('\5;'));   ok := ok and stri = "'\\005'";
    stri := c_literal(charExpr('\6;'));   ok := ok and stri = "'\\006'";
    stri := c_literal(charExpr('\7;'));   ok := ok and stri = "'\\007'";
    stri := c_literal(charExpr('\b'));    ok := ok and stri = "'\\b'";
    stri := c_literal(charExpr('\t'));    ok := ok and stri = "'\\t'";
    stri := c_literal(charExpr('\n'));    ok := ok and stri = "'\\n'";
    stri := c_literal(charExpr('\11;'));  ok := ok and stri = "'\\013'";
    stri := c_literal(charExpr('\f'));    ok := ok and stri = "'\\f'";
    stri := c_literal(charExpr('\r'));    ok := ok and stri = "'\\r'";
    stri := c_literal(charExpr('\14;'));  ok := ok and stri = "'\\016'";
    stri := c_literal(charExpr('\15;'));  ok := ok and stri = "'\\017'";
    stri := c_literal(charExpr('\16;'));  ok := ok and stri = "'\\020'";
    stri := c_literal(charExpr('\17;'));  ok := ok and stri = "'\\021'";
    stri := c_literal(charExpr('\18;'));  ok := ok and stri = "'\\022'";
    stri := c_literal(charExpr('\19;'));  ok := ok and stri = "'\\023'";
    stri := c_literal(charExpr('\20;'));  ok := ok and stri = "'\\024'";
    stri := c_literal(charExpr('\21;'));  ok := ok and stri = "'\\025'";
    stri := c_literal(charExpr('\22;'));  ok := ok and stri = "'\\026'";
    stri := c_literal(charExpr('\23;'));  ok := ok and stri = "'\\027'";
    stri := c_literal(charExpr('\24;'));  ok := ok and stri = "'\\030'";
    stri := c_literal(charExpr('\25;'));  ok := ok and stri = "'\\031'";
    stri := c_literal(charExpr('\26;'));  ok := ok and stri = "'\\032'";
    stri := c_literal(charExpr('\27;'));  ok := ok and stri = "'\\033'";
    stri := c_literal(charExpr('\28;'));  ok := ok and stri = "'\\034'";
    stri := c_literal(charExpr('\29;'));  ok := ok and stri = "'\\035'";
    stri := c_literal(charExpr('\30;'));  ok := ok and stri = "'\\036'";
    stri := c_literal(charExpr('\31;'));  ok := ok and stri = "'\\037'";
    stri := c_literal(charExpr(' '));     ok := ok and stri = "' '";
    stri := c_literal(charExpr('!'));     ok := ok and stri = "'!'";
    stri := c_literal(charExpr('"'));     ok := ok and stri = "'\"'";
    stri := c_literal(charExpr('\\'));    ok := ok and stri = "'\\\\'";
    stri := c_literal(charExpr('\''));    ok := ok and stri = "'\\''";
    stri := c_literal(charExpr('~'));     ok := ok and stri = "'~'";
    stri := c_literal(charExpr('\128;')); ok := ok and stri = "128";
    stri := c_literal(charExpr('\129;')); ok := ok and stri = "129";
    stri := c_literal(charExpr('\130;')); ok := ok and stri = "130";
    stri := c_literal(charExpr('\131;')); ok := ok and stri = "131";
    stri := c_literal(charExpr('\132;')); ok := ok and stri = "132";
    stri := c_literal(charExpr('\133;')); ok := ok and stri = "133";
    stri := c_literal(charExpr('\134;')); ok := ok and stri = "134";
    stri := c_literal(charExpr('\135;')); ok := ok and stri = "135";
    stri := c_literal(charExpr('\136;')); ok := ok and stri = "136";
    stri := c_literal(charExpr('\137;')); ok := ok and stri = "137";
    stri := c_literal(charExpr('\138;')); ok := ok and stri = "138";
    stri := c_literal(charExpr('\139;')); ok := ok and stri = "139";
    stri := c_literal(charExpr('\140;')); ok := ok and stri = "140";
    stri := c_literal(charExpr('\141;')); ok := ok and stri = "141";
    stri := c_literal(charExpr('\142;')); ok := ok and stri = "142";
    stri := c_literal(charExpr('\143;')); ok := ok and stri = "143";
    stri := c_literal(charExpr('\144;')); ok := ok and stri = "144";
    stri := c_literal(charExpr('\145;')); ok := ok and stri = "145";
    stri := c_literal(charExpr('\146;')); ok := ok and stri = "146";
    stri := c_literal(charExpr('\147;')); ok := ok and stri = "147";
    stri := c_literal(charExpr('\148;')); ok := ok and stri = "148";
    stri := c_literal(charExpr('\149;')); ok := ok and stri = "149";
    stri := c_literal(charExpr('\150;')); ok := ok and stri = "150";
    stri := c_literal(charExpr('\151;')); ok := ok and stri = "151";
    stri := c_literal(charExpr('\152;')); ok := ok and stri = "152";
    stri := c_literal(charExpr('\153;')); ok := ok and stri = "153";
    stri := c_literal(charExpr('\154;')); ok := ok and stri = "154";
    stri := c_literal(charExpr('\155;')); ok := ok and stri = "155";
    stri := c_literal(charExpr('\156;')); ok := ok and stri = "156";
    stri := c_literal(charExpr('\157;')); ok := ok and stri = "157";
    stri := c_literal(charExpr('\158;')); ok := ok and stri = "158";
    stri := c_literal(charExpr('\159;')); ok := ok and stri = "159";
    stri := c_literal(charExpr('\160;')); ok := ok and stri = "160";
    stri := c_literal(charExpr(''));     ok := ok and stri = "161";
    stri := c_literal(charExpr(''));     ok := ok and stri = "164";
    stri := c_literal(charExpr(''));     ok := ok and stri = "167";
    stri := c_literal(charExpr(''));     ok := ok and stri = "172";
    stri := c_literal(charExpr(''));     ok := ok and stri = "173";
    stri := c_literal(charExpr(''));     ok := ok and stri = "181";
    stri := c_literal(charExpr(''));     ok := ok and stri = "191";
    stri := c_literal(charExpr(''));     ok := ok and stri = "196";
    stri := c_literal(charExpr(''));     ok := ok and stri = "215";
    stri := c_literal(charExpr(''));     ok := ok and stri = "223";
    stri := c_literal(charExpr(''));     ok := ok and stri = "228";
    stri := c_literal(charExpr(''));     ok := ok and stri = "247";
    stri := c_literal(charExpr(''));     ok := ok and stri = "255";
    stri := c_literal(charExpr(''));     ok := ok and stri = "338";
    stri := c_literal(charExpr(''));     ok := ok and stri = "352";
    stri := c_literal(charExpr(''));     ok := ok and stri = "402";
    stri := c_literal(charExpr(''));     ok := ok and stri = "8224";
    stri := c_literal(charExpr(''));     ok := ok and stri = "8226";
    stri := c_literal(charExpr(''));     ok := ok and stri = "8240";
    stri := c_literal(charExpr(''));     ok := ok and stri = "8364";
    stri := c_literal(charExpr(''));     ok := ok and stri = "8482";
    if not ok then
      writeln(" ***** Function c_literal(ch) does not work correctly. (4)");
      okay := FALSE;
    end if;

    if  cLiteralFunction('\0;')   <> "'\\000'" or
        cLiteralFunction('\1;')   <> "'\\001'" or
        cLiteralFunction('\2;')   <> "'\\002'" or
        cLiteralFunction('\3;')   <> "'\\003'" or
        cLiteralFunction('\4;')   <> "'\\004'" or
        cLiteralFunction('\5;')   <> "'\\005'" or
        cLiteralFunction('\6;')   <> "'\\006'" or
        cLiteralFunction('\7;')   <> "'\\007'" or
        cLiteralFunction('\b')    <> "'\\b'" or
        cLiteralFunction('\t')    <> "'\\t'" or
        cLiteralFunction('\n')    <> "'\\n'" or
        cLiteralFunction('\11;')  <> "'\\013'" or
        cLiteralFunction('\f')    <> "'\\f'" or
        cLiteralFunction('\r')    <> "'\\r'" or
        cLiteralFunction('\14;')  <> "'\\016'" or
        cLiteralFunction('\15;')  <> "'\\017'" or
        cLiteralFunction('\16;')  <> "'\\020'" or
        cLiteralFunction('\17;')  <> "'\\021'" or
        cLiteralFunction('\18;')  <> "'\\022'" or
        cLiteralFunction('\19;')  <> "'\\023'" or
        cLiteralFunction('\20;')  <> "'\\024'" or
        cLiteralFunction('\21;')  <> "'\\025'" or
        cLiteralFunction('\22;')  <> "'\\026'" or
        cLiteralFunction('\23;')  <> "'\\027'" or
        cLiteralFunction('\24;')  <> "'\\030'" or
        cLiteralFunction('\25;')  <> "'\\031'" or
        cLiteralFunction('\26;')  <> "'\\032'" or
        cLiteralFunction('\27;')  <> "'\\033'" or
        cLiteralFunction('\28;')  <> "'\\034'" or
        cLiteralFunction('\29;')  <> "'\\035'" or
        cLiteralFunction('\30;')  <> "'\\036'" or
        cLiteralFunction('\31;')  <> "'\\037'" or
        cLiteralFunction(' ')     <> "' '" or
        cLiteralFunction('!')     <> "'!'" or
        cLiteralFunction('"')     <> "'\"'" or
        cLiteralFunction('\\')    <> "'\\\\'" or
        cLiteralFunction('\'')    <> "'\\''" or
        cLiteralFunction('~')     <> "'~'" or
        cLiteralFunction('\128;') <> "128" or
        cLiteralFunction('\129;') <> "129" or
        cLiteralFunction('\130;') <> "130" or
        cLiteralFunction('\131;') <> "131" or
        cLiteralFunction('\132;') <> "132" or
        cLiteralFunction('\133;') <> "133" or
        cLiteralFunction('\134;') <> "134" or
        cLiteralFunction('\135;') <> "135" or
        cLiteralFunction('\136;') <> "136" or
        cLiteralFunction('\137;') <> "137" or
        cLiteralFunction('\138;') <> "138" or
        cLiteralFunction('\139;') <> "139" or
        cLiteralFunction('\140;') <> "140" or
        cLiteralFunction('\141;') <> "141" or
        cLiteralFunction('\142;') <> "142" or
        cLiteralFunction('\143;') <> "143" or
        cLiteralFunction('\144;') <> "144" or
        cLiteralFunction('\145;') <> "145" or
        cLiteralFunction('\146;') <> "146" or
        cLiteralFunction('\147;') <> "147" or
        cLiteralFunction('\148;') <> "148" or
        cLiteralFunction('\149;') <> "149" or
        cLiteralFunction('\150;') <> "150" or
        cLiteralFunction('\151;') <> "151" or
        cLiteralFunction('\152;') <> "152" or
        cLiteralFunction('\153;') <> "153" or
        cLiteralFunction('\154;') <> "154" or
        cLiteralFunction('\155;') <> "155" or
        cLiteralFunction('\156;') <> "156" or
        cLiteralFunction('\157;') <> "157" or
        cLiteralFunction('\158;') <> "158" or
        cLiteralFunction('\159;') <> "159" or
        cLiteralFunction('\160;') <> "160" or
        cLiteralFunction('')     <> "161" or
        cLiteralFunction('')     <> "164" or
        cLiteralFunction('')     <> "167" or
        cLiteralFunction('')     <> "172" or
        cLiteralFunction('')     <> "173" or
        cLiteralFunction('')     <> "181" or
        cLiteralFunction('')     <> "191" or
        cLiteralFunction('')     <> "196" or
        cLiteralFunction('')     <> "215" or
        cLiteralFunction('')     <> "223" or
        cLiteralFunction('')     <> "228" or
        cLiteralFunction('')     <> "247" or
        cLiteralFunction('')     <> "255" or
        cLiteralFunction('')     <> "338" or
        cLiteralFunction('')     <> "352" or
        cLiteralFunction('')     <> "402" or
        cLiteralFunction('')     <> "8224" or
        cLiteralFunction('')     <> "8226" or
        cLiteralFunction('')     <> "8240" or
        cLiteralFunction('')     <> "8364" or
        cLiteralFunction('')     <> "8482" then
      writeln(" ***** Function c_literal(ch) via a function does not work correctly. (1)");
      okay := FALSE;
    end if;

    if  cLiteralFunction(charExpr('\0;'))   <> "'\\000'" or
        cLiteralFunction(charExpr('\1;'))   <> "'\\001'" or
        cLiteralFunction(charExpr('\2;'))   <> "'\\002'" or
        cLiteralFunction(charExpr('\3;'))   <> "'\\003'" or
        cLiteralFunction(charExpr('\4;'))   <> "'\\004'" or
        cLiteralFunction(charExpr('\5;'))   <> "'\\005'" or
        cLiteralFunction(charExpr('\6;'))   <> "'\\006'" or
        cLiteralFunction(charExpr('\7;'))   <> "'\\007'" or
        cLiteralFunction(charExpr('\b'))    <> "'\\b'" or
        cLiteralFunction(charExpr('\t'))    <> "'\\t'" or
        cLiteralFunction(charExpr('\n'))    <> "'\\n'" or
        cLiteralFunction(charExpr('\11;'))  <> "'\\013'" or
        cLiteralFunction(charExpr('\f'))    <> "'\\f'" or
        cLiteralFunction(charExpr('\r'))    <> "'\\r'" or
        cLiteralFunction(charExpr('\14;'))  <> "'\\016'" or
        cLiteralFunction(charExpr('\15;'))  <> "'\\017'" or
        cLiteralFunction(charExpr('\16;'))  <> "'\\020'" or
        cLiteralFunction(charExpr('\17;'))  <> "'\\021'" or
        cLiteralFunction(charExpr('\18;'))  <> "'\\022'" or
        cLiteralFunction(charExpr('\19;'))  <> "'\\023'" or
        cLiteralFunction(charExpr('\20;'))  <> "'\\024'" or
        cLiteralFunction(charExpr('\21;'))  <> "'\\025'" or
        cLiteralFunction(charExpr('\22;'))  <> "'\\026'" or
        cLiteralFunction(charExpr('\23;'))  <> "'\\027'" or
        cLiteralFunction(charExpr('\24;'))  <> "'\\030'" or
        cLiteralFunction(charExpr('\25;'))  <> "'\\031'" or
        cLiteralFunction(charExpr('\26;'))  <> "'\\032'" or
        cLiteralFunction(charExpr('\27;'))  <> "'\\033'" or
        cLiteralFunction(charExpr('\28;'))  <> "'\\034'" or
        cLiteralFunction(charExpr('\29;'))  <> "'\\035'" or
        cLiteralFunction(charExpr('\30;'))  <> "'\\036'" or
        cLiteralFunction(charExpr('\31;'))  <> "'\\037'" or
        cLiteralFunction(charExpr(' '))     <> "' '" or
        cLiteralFunction(charExpr('!'))     <> "'!'" or
        cLiteralFunction(charExpr('"'))     <> "'\"'" or
        cLiteralFunction(charExpr('\\'))    <> "'\\\\'" or
        cLiteralFunction(charExpr('\''))    <> "'\\''" or
        cLiteralFunction(charExpr('~'))     <> "'~'" or
        cLiteralFunction(charExpr('\128;')) <> "128" or
        cLiteralFunction(charExpr('\129;')) <> "129" or
        cLiteralFunction(charExpr('\130;')) <> "130" or
        cLiteralFunction(charExpr('\131;')) <> "131" or
        cLiteralFunction(charExpr('\132;')) <> "132" or
        cLiteralFunction(charExpr('\133;')) <> "133" or
        cLiteralFunction(charExpr('\134;')) <> "134" or
        cLiteralFunction(charExpr('\135;')) <> "135" or
        cLiteralFunction(charExpr('\136;')) <> "136" or
        cLiteralFunction(charExpr('\137;')) <> "137" or
        cLiteralFunction(charExpr('\138;')) <> "138" or
        cLiteralFunction(charExpr('\139;')) <> "139" or
        cLiteralFunction(charExpr('\140;')) <> "140" or
        cLiteralFunction(charExpr('\141;')) <> "141" or
        cLiteralFunction(charExpr('\142;')) <> "142" or
        cLiteralFunction(charExpr('\143;')) <> "143" or
        cLiteralFunction(charExpr('\144;')) <> "144" or
        cLiteralFunction(charExpr('\145;')) <> "145" or
        cLiteralFunction(charExpr('\146;')) <> "146" or
        cLiteralFunction(charExpr('\147;')) <> "147" or
        cLiteralFunction(charExpr('\148;')) <> "148" or
        cLiteralFunction(charExpr('\149;')) <> "149" or
        cLiteralFunction(charExpr('\150;')) <> "150" or
        cLiteralFunction(charExpr('\151;')) <> "151" or
        cLiteralFunction(charExpr('\152;')) <> "152" or
        cLiteralFunction(charExpr('\153;')) <> "153" or
        cLiteralFunction(charExpr('\154;')) <> "154" or
        cLiteralFunction(charExpr('\155;')) <> "155" or
        cLiteralFunction(charExpr('\156;')) <> "156" or
        cLiteralFunction(charExpr('\157;')) <> "157" or
        cLiteralFunction(charExpr('\158;')) <> "158" or
        cLiteralFunction(charExpr('\159;')) <> "159" or
        cLiteralFunction(charExpr('\160;')) <> "160" or
        cLiteralFunction(charExpr(''))     <> "161" or
        cLiteralFunction(charExpr(''))     <> "164" or
        cLiteralFunction(charExpr(''))     <> "167" or
        cLiteralFunction(charExpr(''))     <> "172" or
        cLiteralFunction(charExpr(''))     <> "173" or
        cLiteralFunction(charExpr(''))     <> "181" or
        cLiteralFunction(charExpr(''))     <> "191" or
        cLiteralFunction(charExpr(''))     <> "196" or
        cLiteralFunction(charExpr(''))     <> "215" or
        cLiteralFunction(charExpr(''))     <> "223" or
        cLiteralFunction(charExpr(''))     <> "228" or
        cLiteralFunction(charExpr(''))     <> "247" or
        cLiteralFunction(charExpr(''))     <> "255" or
        cLiteralFunction(charExpr(''))     <> "338" or
        cLiteralFunction(charExpr(''))     <> "352" or
        cLiteralFunction(charExpr(''))     <> "402" or
        cLiteralFunction(charExpr(''))     <> "8224" or
        cLiteralFunction(charExpr(''))     <> "8226" or
        cLiteralFunction(charExpr(''))     <> "8240" or
        cLiteralFunction(charExpr(''))     <> "8364" or
        cLiteralFunction(charExpr(''))     <> "8482" then
      writeln(" ***** Function c_literal(ch) via a function does not work correctly. (2)");
      okay := FALSE;
    end if;
  end func;


const proc: check_literal is func
  local
    var boolean: okay is TRUE;
    var boolean: ok is TRUE;
    var string: stri is "";
  begin
    if  literal('\0;')   <> "'\\0;'" or
        literal('\1;')   <> "'\\1;'" or
        literal('\2;')   <> "'\\2;'" or
        literal('\3;')   <> "'\\3;'" or
        literal('\4;')   <> "'\\4;'" or
        literal('\5;')   <> "'\\5;'" or
        literal('\6;')   <> "'\\6;'" or
        literal('\a')    <> "'\\a'" or
        literal('\b')    <> "'\\b'" or
        literal('\t')    <> "'\\t'" or
        literal('\n')    <> "'\\n'" or
        literal('\v')    <> "'\\v'" or
        literal('\f')    <> "'\\f'" or
        literal('\r')    <> "'\\r'" or
        literal('\14;')  <> "'\\14;'" or
        literal('\15;')  <> "'\\15;'" or
        literal('\16;')  <> "'\\16;'" or
        literal('\17;')  <> "'\\17;'" or
        literal('\18;')  <> "'\\18;'" or
        literal('\19;')  <> "'\\19;'" or
        literal('\20;')  <> "'\\20;'" or
        literal('\21;')  <> "'\\21;'" or
        literal('\22;')  <> "'\\22;'" or
        literal('\23;')  <> "'\\23;'" or
        literal('\24;')  <> "'\\24;'" or
        literal('\25;')  <> "'\\25;'" or
        literal('\26;')  <> "'\\26;'" or
        literal('\e')    <> "'\\e'" or
        literal('\28;')  <> "'\\28;'" or
        literal('\29;')  <> "'\\29;'" or
        literal('\30;')  <> "'\\30;'" or
        literal('\31;')  <> "'\\31;'" or
        literal(' ')     <> "' '" or
        literal('"')     <> "'\\\"'" or
        literal('\\')    <> "'\\\\'" or
        literal('\'')    <> "'\\''" or
        literal('~')     <> "'~'" or
        literal('\128;') <> "'\\128;'" or
        literal('\128;') <> "'\\128;'" or
        literal('\129;') <> "'\\129;'" or
        literal('\130;') <> "'\\130;'" or
        literal('\131;') <> "'\\131;'" or
        literal('\132;') <> "'\\132;'" or
        literal('\133;') <> "'\\133;'" or
        literal('\134;') <> "'\\134;'" or
        literal('\135;') <> "'\\135;'" or
        literal('\136;') <> "'\\136;'" or
        literal('\137;') <> "'\\137;'" or
        literal('\138;') <> "'\\138;'" or
        literal('\139;') <> "'\\139;'" or
        literal('\140;') <> "'\\140;'" or
        literal('\141;') <> "'\\141;'" or
        literal('\142;') <> "'\\142;'" or
        literal('\143;') <> "'\\143;'" or
        literal('\144;') <> "'\\144;'" or
        literal('\145;') <> "'\\145;'" or
        literal('\146;') <> "'\\146;'" or
        literal('\147;') <> "'\\147;'" or
        literal('\148;') <> "'\\148;'" or
        literal('\149;') <> "'\\149;'" or
        literal('\150;') <> "'\\150;'" or
        literal('\151;') <> "'\\151;'" or
        literal('\152;') <> "'\\152;'" or
        literal('\153;') <> "'\\153;'" or
        literal('\154;') <> "'\\154;'" or
        literal('\155;') <> "'\\155;'" or
        literal('\156;') <> "'\\156;'" or
        literal('\157;') <> "'\\157;'" or
        literal('\158;') <> "'\\158;'" or
        literal('\159;') <> "'\\159;'" or
        literal('\160;') <> "'\\160;'" or
        literal('')     <> "''" or
        literal('')     <> "''" or
        literal('')     <> "''" or
        literal('')     <> "''" or
        literal('')     <> "''" or
        literal('')     <> "''" or
        literal('')     <> "''" or
        literal('')     <> "''" or
        literal('')     <> "''" or
        literal('')     <> "''" or
        literal('')     <> "''" or
        literal('')     <> "''" or
        literal('')     <> "''" or
        literal('')     <> "'\\338;'" or
        literal('')     <> "'\\352;'" or
        literal('')     <> "'\\402;'" or
        literal('')     <> "'\\8224;'" or
        literal('')     <> "'\\8226;'" or
        literal('')     <> "'\\8240;'" or
        literal('')     <> "'\\8364;'" or
        literal('')     <> "'\\8482;'" then
      writeln(" ***** Function literal(ch) does not work correctly. (1)");
      okay := FALSE;
    end if;

    if  literal(charExpr('\0;'))   <> "'\\0;'" or
        literal(charExpr('\1;'))   <> "'\\1;'" or
        literal(charExpr('\2;'))   <> "'\\2;'" or
        literal(charExpr('\3;'))   <> "'\\3;'" or
        literal(charExpr('\4;'))   <> "'\\4;'" or
        literal(charExpr('\5;'))   <> "'\\5;'" or
        literal(charExpr('\6;'))   <> "'\\6;'" or
        literal(charExpr('\a'))    <> "'\\a'" or
        literal(charExpr('\b'))    <> "'\\b'" or
        literal(charExpr('\t'))    <> "'\\t'" or
        literal(charExpr('\n'))    <> "'\\n'" or
        literal(charExpr('\v'))    <> "'\\v'" or
        literal(charExpr('\f'))    <> "'\\f'" or
        literal(charExpr('\r'))    <> "'\\r'" or
        literal(charExpr('\14;'))  <> "'\\14;'" or
        literal(charExpr('\15;'))  <> "'\\15;'" or
        literal(charExpr('\16;'))  <> "'\\16;'" or
        literal(charExpr('\17;'))  <> "'\\17;'" or
        literal(charExpr('\18;'))  <> "'\\18;'" or
        literal(charExpr('\19;'))  <> "'\\19;'" or
        literal(charExpr('\20;'))  <> "'\\20;'" or
        literal(charExpr('\21;'))  <> "'\\21;'" or
        literal(charExpr('\22;'))  <> "'\\22;'" or
        literal(charExpr('\23;'))  <> "'\\23;'" or
        literal(charExpr('\24;'))  <> "'\\24;'" or
        literal(charExpr('\25;'))  <> "'\\25;'" or
        literal(charExpr('\26;'))  <> "'\\26;'" or
        literal(charExpr('\e'))    <> "'\\e'" or
        literal(charExpr('\28;'))  <> "'\\28;'" or
        literal(charExpr('\29;'))  <> "'\\29;'" or
        literal(charExpr('\30;'))  <> "'\\30;'" or
        literal(charExpr('\31;'))  <> "'\\31;'" or
        literal(charExpr(' '))     <> "' '" or
        literal(charExpr('"'))     <> "'\\\"'" or
        literal(charExpr('\\'))    <> "'\\\\'" or
        literal(charExpr('\''))    <> "'\\''" or
        literal(charExpr('~'))     <> "'~'" or
        literal(charExpr('\128;')) <> "'\\128;'" or
        literal(charExpr('\128;')) <> "'\\128;'" or
        literal(charExpr('\129;')) <> "'\\129;'" or
        literal(charExpr('\130;')) <> "'\\130;'" or
        literal(charExpr('\131;')) <> "'\\131;'" or
        literal(charExpr('\132;')) <> "'\\132;'" or
        literal(charExpr('\133;')) <> "'\\133;'" or
        literal(charExpr('\134;')) <> "'\\134;'" or
        literal(charExpr('\135;')) <> "'\\135;'" or
        literal(charExpr('\136;')) <> "'\\136;'" or
        literal(charExpr('\137;')) <> "'\\137;'" or
        literal(charExpr('\138;')) <> "'\\138;'" or
        literal(charExpr('\139;')) <> "'\\139;'" or
        literal(charExpr('\140;')) <> "'\\140;'" or
        literal(charExpr('\141;')) <> "'\\141;'" or
        literal(charExpr('\142;')) <> "'\\142;'" or
        literal(charExpr('\143;')) <> "'\\143;'" or
        literal(charExpr('\144;')) <> "'\\144;'" or
        literal(charExpr('\145;')) <> "'\\145;'" or
        literal(charExpr('\146;')) <> "'\\146;'" or
        literal(charExpr('\147;')) <> "'\\147;'" or
        literal(charExpr('\148;')) <> "'\\148;'" or
        literal(charExpr('\149;')) <> "'\\149;'" or
        literal(charExpr('\150;')) <> "'\\150;'" or
        literal(charExpr('\151;')) <> "'\\151;'" or
        literal(charExpr('\152;')) <> "'\\152;'" or
        literal(charExpr('\153;')) <> "'\\153;'" or
        literal(charExpr('\154;')) <> "'\\154;'" or
        literal(charExpr('\155;')) <> "'\\155;'" or
        literal(charExpr('\156;')) <> "'\\156;'" or
        literal(charExpr('\157;')) <> "'\\157;'" or
        literal(charExpr('\158;')) <> "'\\158;'" or
        literal(charExpr('\159;')) <> "'\\159;'" or
        literal(charExpr('\160;')) <> "'\\160;'" or
        literal(charExpr(''))     <> "''" or
        literal(charExpr(''))     <> "''" or
        literal(charExpr(''))     <> "''" or
        literal(charExpr(''))     <> "''" or
        literal(charExpr(''))     <> "''" or
        literal(charExpr(''))     <> "''" or
        literal(charExpr(''))     <> "''" or
        literal(charExpr(''))     <> "''" or
        literal(charExpr(''))     <> "''" or
        literal(charExpr(''))     <> "''" or
        literal(charExpr(''))     <> "''" or
        literal(charExpr(''))     <> "''" or
        literal(charExpr(''))     <> "''" or
        literal(charExpr(''))     <> "'\\338;'" or
        literal(charExpr(''))     <> "'\\352;'" or
        literal(charExpr(''))     <> "'\\402;'" or
        literal(charExpr(''))     <> "'\\8224;'" or
        literal(charExpr(''))     <> "'\\8226;'" or
        literal(charExpr(''))     <> "'\\8240;'" or
        literal(charExpr(''))     <> "'\\8364;'" or
        literal(charExpr(''))     <> "'\\8482;'" then
      writeln(" ***** Function literal(ch) does not work correctly. (2)");
      okay := FALSE;
    end if;

    stri := literal('\0;');   ok := ok and stri = "'\\0;'";
    stri := literal('\1;');   ok := ok and stri = "'\\1;'";
    stri := literal('\2;');   ok := ok and stri = "'\\2;'";
    stri := literal('\3;');   ok := ok and stri = "'\\3;'";
    stri := literal('\4;');   ok := ok and stri = "'\\4;'";
    stri := literal('\5;');   ok := ok and stri = "'\\5;'";
    stri := literal('\6;');   ok := ok and stri = "'\\6;'";
    stri := literal('\a');    ok := ok and stri = "'\\a'";
    stri := literal('\b');    ok := ok and stri = "'\\b'";
    stri := literal('\t');    ok := ok and stri = "'\\t'";
    stri := literal('\n');    ok := ok and stri = "'\\n'";
    stri := literal('\v');    ok := ok and stri = "'\\v'";
    stri := literal('\f');    ok := ok and stri = "'\\f'";
    stri := literal('\r');    ok := ok and stri = "'\\r'";
    stri := literal('\14;');  ok := ok and stri = "'\\14;'";
    stri := literal('\15;');  ok := ok and stri = "'\\15;'";
    stri := literal('\16;');  ok := ok and stri = "'\\16;'";
    stri := literal('\17;');  ok := ok and stri = "'\\17;'";
    stri := literal('\18;');  ok := ok and stri = "'\\18;'";
    stri := literal('\19;');  ok := ok and stri = "'\\19;'";
    stri := literal('\20;');  ok := ok and stri = "'\\20;'";
    stri := literal('\21;');  ok := ok and stri = "'\\21;'";
    stri := literal('\22;');  ok := ok and stri = "'\\22;'";
    stri := literal('\23;');  ok := ok and stri = "'\\23;'";
    stri := literal('\24;');  ok := ok and stri = "'\\24;'";
    stri := literal('\25;');  ok := ok and stri = "'\\25;'";
    stri := literal('\26;');  ok := ok and stri = "'\\26;'";
    stri := literal('\e');    ok := ok and stri = "'\\e'";
    stri := literal('\28;');  ok := ok and stri = "'\\28;'";
    stri := literal('\29;');  ok := ok and stri = "'\\29;'";
    stri := literal('\30;');  ok := ok and stri = "'\\30;'";
    stri := literal('\31;');  ok := ok and stri = "'\\31;'";
    stri := literal(' ');     ok := ok and stri = "' '";
    stri := literal('"');     ok := ok and stri = "'\\\"'";
    stri := literal('\\');    ok := ok and stri = "'\\\\'";
    stri := literal('\'');    ok := ok and stri = "'\\''";
    stri := literal('~');     ok := ok and stri = "'~'";
    stri := literal('\128;'); ok := ok and stri = "'\\128;'";
    stri := literal('\128;'); ok := ok and stri = "'\\128;'";
    stri := literal('\129;'); ok := ok and stri = "'\\129;'";
    stri := literal('\130;'); ok := ok and stri = "'\\130;'";
    stri := literal('\131;'); ok := ok and stri = "'\\131;'";
    stri := literal('\132;'); ok := ok and stri = "'\\132;'";
    stri := literal('\133;'); ok := ok and stri = "'\\133;'";
    stri := literal('\134;'); ok := ok and stri = "'\\134;'";
    stri := literal('\135;'); ok := ok and stri = "'\\135;'";
    stri := literal('\136;'); ok := ok and stri = "'\\136;'";
    stri := literal('\137;'); ok := ok and stri = "'\\137;'";
    stri := literal('\138;'); ok := ok and stri = "'\\138;'";
    stri := literal('\139;'); ok := ok and stri = "'\\139;'";
    stri := literal('\140;'); ok := ok and stri = "'\\140;'";
    stri := literal('\141;'); ok := ok and stri = "'\\141;'";
    stri := literal('\142;'); ok := ok and stri = "'\\142;'";
    stri := literal('\143;'); ok := ok and stri = "'\\143;'";
    stri := literal('\144;'); ok := ok and stri = "'\\144;'";
    stri := literal('\145;'); ok := ok and stri = "'\\145;'";
    stri := literal('\146;'); ok := ok and stri = "'\\146;'";
    stri := literal('\147;'); ok := ok and stri = "'\\147;'";
    stri := literal('\148;'); ok := ok and stri = "'\\148;'";
    stri := literal('\149;'); ok := ok and stri = "'\\149;'";
    stri := literal('\150;'); ok := ok and stri = "'\\150;'";
    stri := literal('\151;'); ok := ok and stri = "'\\151;'";
    stri := literal('\152;'); ok := ok and stri = "'\\152;'";
    stri := literal('\153;'); ok := ok and stri = "'\\153;'";
    stri := literal('\154;'); ok := ok and stri = "'\\154;'";
    stri := literal('\155;'); ok := ok and stri = "'\\155;'";
    stri := literal('\156;'); ok := ok and stri = "'\\156;'";
    stri := literal('\157;'); ok := ok and stri = "'\\157;'";
    stri := literal('\158;'); ok := ok and stri = "'\\158;'";
    stri := literal('\159;'); ok := ok and stri = "'\\159;'";
    stri := literal('\160;'); ok := ok and stri = "'\\160;'";
    stri := literal('');     ok := ok and stri = "''";
    stri := literal('');     ok := ok and stri = "''";
    stri := literal('');     ok := ok and stri = "''";
    stri := literal('');     ok := ok and stri = "''";
    stri := literal('');     ok := ok and stri = "''";
    stri := literal('');     ok := ok and stri = "''";
    stri := literal('');     ok := ok and stri = "''";
    stri := literal('');     ok := ok and stri = "''";
    stri := literal('');     ok := ok and stri = "''";
    stri := literal('');     ok := ok and stri = "''";
    stri := literal('');     ok := ok and stri = "''";
    stri := literal('');     ok := ok and stri = "''";
    stri := literal('');     ok := ok and stri = "''";
    stri := literal('');     ok := ok and stri = "'\\338;'";
    stri := literal('');     ok := ok and stri = "'\\352;'";
    stri := literal('');     ok := ok and stri = "'\\402;'";
    stri := literal('');     ok := ok and stri = "'\\8224;'";
    stri := literal('');     ok := ok and stri = "'\\8226;'";
    stri := literal('');     ok := ok and stri = "'\\8240;'";
    stri := literal('');     ok := ok and stri = "'\\8364;'";
    stri := literal('');     ok := ok and stri = "'\\8482;'";
    if not ok then
      writeln(" ***** Function literal(ch) does not work correctly. (3)");
      okay := FALSE;
    end if;

    ok := TRUE;
    stri := literal(charExpr('\0;'));   ok := ok and stri = "'\\0;'";
    stri := literal(charExpr('\1;'));   ok := ok and stri = "'\\1;'";
    stri := literal(charExpr('\2;'));   ok := ok and stri = "'\\2;'";
    stri := literal(charExpr('\3;'));   ok := ok and stri = "'\\3;'";
    stri := literal(charExpr('\4;'));   ok := ok and stri = "'\\4;'";
    stri := literal(charExpr('\5;'));   ok := ok and stri = "'\\5;'";
    stri := literal(charExpr('\6;'));   ok := ok and stri = "'\\6;'";
    stri := literal(charExpr('\a'));    ok := ok and stri = "'\\a'";
    stri := literal(charExpr('\b'));    ok := ok and stri = "'\\b'";
    stri := literal(charExpr('\t'));    ok := ok and stri = "'\\t'";
    stri := literal(charExpr('\n'));    ok := ok and stri = "'\\n'";
    stri := literal(charExpr('\v'));    ok := ok and stri = "'\\v'";
    stri := literal(charExpr('\f'));    ok := ok and stri = "'\\f'";
    stri := literal(charExpr('\r'));    ok := ok and stri = "'\\r'";
    stri := literal(charExpr('\14;'));  ok := ok and stri = "'\\14;'";
    stri := literal(charExpr('\15;'));  ok := ok and stri = "'\\15;'";
    stri := literal(charExpr('\16;'));  ok := ok and stri = "'\\16;'";
    stri := literal(charExpr('\17;'));  ok := ok and stri = "'\\17;'";
    stri := literal(charExpr('\18;'));  ok := ok and stri = "'\\18;'";
    stri := literal(charExpr('\19;'));  ok := ok and stri = "'\\19;'";
    stri := literal(charExpr('\20;'));  ok := ok and stri = "'\\20;'";
    stri := literal(charExpr('\21;'));  ok := ok and stri = "'\\21;'";
    stri := literal(charExpr('\22;'));  ok := ok and stri = "'\\22;'";
    stri := literal(charExpr('\23;'));  ok := ok and stri = "'\\23;'";
    stri := literal(charExpr('\24;'));  ok := ok and stri = "'\\24;'";
    stri := literal(charExpr('\25;'));  ok := ok and stri = "'\\25;'";
    stri := literal(charExpr('\26;'));  ok := ok and stri = "'\\26;'";
    stri := literal(charExpr('\e'));    ok := ok and stri = "'\\e'";
    stri := literal(charExpr('\28;'));  ok := ok and stri = "'\\28;'";
    stri := literal(charExpr('\29;'));  ok := ok and stri = "'\\29;'";
    stri := literal(charExpr('\30;'));  ok := ok and stri = "'\\30;'";
    stri := literal(charExpr('\31;'));  ok := ok and stri = "'\\31;'";
    stri := literal(charExpr(' '));     ok := ok and stri = "' '";
    stri := literal(charExpr('"'));     ok := ok and stri = "'\\\"'";
    stri := literal(charExpr('\\'));    ok := ok and stri = "'\\\\'";
    stri := literal(charExpr('\''));    ok := ok and stri = "'\\''";
    stri := literal(charExpr('~'));     ok := ok and stri = "'~'";
    stri := literal(charExpr('\128;')); ok := ok and stri = "'\\128;'";
    stri := literal(charExpr('\128;')); ok := ok and stri = "'\\128;'";
    stri := literal(charExpr('\129;')); ok := ok and stri = "'\\129;'";
    stri := literal(charExpr('\130;')); ok := ok and stri = "'\\130;'";
    stri := literal(charExpr('\131;')); ok := ok and stri = "'\\131;'";
    stri := literal(charExpr('\132;')); ok := ok and stri = "'\\132;'";
    stri := literal(charExpr('\133;')); ok := ok and stri = "'\\133;'";
    stri := literal(charExpr('\134;')); ok := ok and stri = "'\\134;'";
    stri := literal(charExpr('\135;')); ok := ok and stri = "'\\135;'";
    stri := literal(charExpr('\136;')); ok := ok and stri = "'\\136;'";
    stri := literal(charExpr('\137;')); ok := ok and stri = "'\\137;'";
    stri := literal(charExpr('\138;')); ok := ok and stri = "'\\138;'";
    stri := literal(charExpr('\139;')); ok := ok and stri = "'\\139;'";
    stri := literal(charExpr('\140;')); ok := ok and stri = "'\\140;'";
    stri := literal(charExpr('\141;')); ok := ok and stri = "'\\141;'";
    stri := literal(charExpr('\142;')); ok := ok and stri = "'\\142;'";
    stri := literal(charExpr('\143;')); ok := ok and stri = "'\\143;'";
    stri := literal(charExpr('\144;')); ok := ok and stri = "'\\144;'";
    stri := literal(charExpr('\145;')); ok := ok and stri = "'\\145;'";
    stri := literal(charExpr('\146;')); ok := ok and stri = "'\\146;'";
    stri := literal(charExpr('\147;')); ok := ok and stri = "'\\147;'";
    stri := literal(charExpr('\148;')); ok := ok and stri = "'\\148;'";
    stri := literal(charExpr('\149;')); ok := ok and stri = "'\\149;'";
    stri := literal(charExpr('\150;')); ok := ok and stri = "'\\150;'";
    stri := literal(charExpr('\151;')); ok := ok and stri = "'\\151;'";
    stri := literal(charExpr('\152;')); ok := ok and stri = "'\\152;'";
    stri := literal(charExpr('\153;')); ok := ok and stri = "'\\153;'";
    stri := literal(charExpr('\154;')); ok := ok and stri = "'\\154;'";
    stri := literal(charExpr('\155;')); ok := ok and stri = "'\\155;'";
    stri := literal(charExpr('\156;')); ok := ok and stri = "'\\156;'";
    stri := literal(charExpr('\157;')); ok := ok and stri = "'\\157;'";
    stri := literal(charExpr('\158;')); ok := ok and stri = "'\\158;'";
    stri := literal(charExpr('\159;')); ok := ok and stri = "'\\159;'";
    stri := literal(charExpr('\160;')); ok := ok and stri = "'\\160;'";
    stri := literal(charExpr(''));     ok := ok and stri = "''";
    stri := literal(charExpr(''));     ok := ok and stri = "''";
    stri := literal(charExpr(''));     ok := ok and stri = "''";
    stri := literal(charExpr(''));     ok := ok and stri = "''";
    stri := literal(charExpr(''));     ok := ok and stri = "''";
    stri := literal(charExpr(''));     ok := ok and stri = "''";
    stri := literal(charExpr(''));     ok := ok and stri = "''";
    stri := literal(charExpr(''));     ok := ok and stri = "''";
    stri := literal(charExpr(''));     ok := ok and stri = "''";
    stri := literal(charExpr(''));     ok := ok and stri = "''";
    stri := literal(charExpr(''));     ok := ok and stri = "''";
    stri := literal(charExpr(''));     ok := ok and stri = "''";
    stri := literal(charExpr(''));     ok := ok and stri = "''";
    stri := literal(charExpr(''));     ok := ok and stri = "'\\338;'";
    stri := literal(charExpr(''));     ok := ok and stri = "'\\352;'";
    stri := literal(charExpr(''));     ok := ok and stri = "'\\402;'";
    stri := literal(charExpr(''));     ok := ok and stri = "'\\8224;'";
    stri := literal(charExpr(''));     ok := ok and stri = "'\\8226;'";
    stri := literal(charExpr(''));     ok := ok and stri = "'\\8240;'";
    stri := literal(charExpr(''));     ok := ok and stri = "'\\8364;'";
    stri := literal(charExpr(''));     ok := ok and stri = "'\\8482;'";
    if not ok then
      writeln(" ***** Function literal(ch) does not work correctly. (4)");
      okay := FALSE;
    end if;

    if not check_literal_func then
      okay := FALSE;
    end if;

    if okay then
      writeln("Char literal functions work correctly.");
    end if;
  end func;


const proc: check_ternary is func
  local
    var boolean: okay is TRUE;
    var boolean: ok is TRUE;
    var char: ch is ' ';
  begin
    if  ( TRUE ?  'a' : 'b') <> 'a' or
        (FALSE ?  'a' : 'b') <> 'b' or
        ( TRUE ?  'a' : charExpr('b')) <> 'a' or
        (FALSE ?  'a' : charExpr('b')) <> 'b' or
        ( TRUE ?  charExpr('a') : 'b') <> 'a' or
        (FALSE ?  charExpr('a') : 'b') <> 'b' or
        ( TRUE ?  charExpr('a') : charExpr('b')) <> 'a' or
        (FALSE ?  charExpr('a') : charExpr('b')) <> 'b' or
        (boolExpr( TRUE) ?  'a' : 'b') <> 'a' or
        (boolExpr(FALSE) ?  'a' : 'b') <> 'b' or
        (boolExpr( TRUE) ?  'a' : charExpr('b')) <> 'a' or
        (boolExpr(FALSE) ?  'a' : charExpr('b')) <> 'b' or
        (boolExpr( TRUE) ?  charExpr('a') : 'b') <> 'a' or
        (boolExpr(FALSE) ?  charExpr('a') : 'b') <> 'b' or
        (boolExpr( TRUE) ?  charExpr('a') : charExpr('b')) <> 'a' or
        (boolExpr(FALSE) ?  charExpr('a') : charExpr('b')) <> 'b' then
      writeln(" ***** The ternary operator ? : does not work correctly. (1)");
      okay := FALSE;
    end if;

    ch :=  TRUE ?  'a' : 'b'; ok := ok and ch = 'a';
    ch := FALSE ?  'a' : 'b'; ok := ok and ch = 'b';
    ch :=  TRUE ?  'a' : charExpr('b'); ok := ok and ch = 'a';
    ch := FALSE ?  'a' : charExpr('b'); ok := ok and ch = 'b';
    ch :=  TRUE ?  charExpr('a') : 'b'; ok := ok and ch = 'a';
    ch := FALSE ?  charExpr('a') : 'b'; ok := ok and ch = 'b';
    ch :=  TRUE ?  charExpr('a') : charExpr('b'); ok := ok and ch = 'a';
    ch := FALSE ?  charExpr('a') : charExpr('b'); ok := ok and ch = 'b';
    ch := boolExpr( TRUE) ?  'a' : 'b'; ok := ok and ch = 'a';
    ch := boolExpr(FALSE) ?  'a' : 'b'; ok := ok and ch = 'b';
    ch := boolExpr( TRUE) ?  'a' : charExpr('b'); ok := ok and ch = 'a';
    ch := boolExpr(FALSE) ?  'a' : charExpr('b'); ok := ok and ch = 'b';
    ch := boolExpr( TRUE) ?  charExpr('a') : 'b'; ok := ok and ch = 'a';
    ch := boolExpr(FALSE) ?  charExpr('a') : 'b'; ok := ok and ch = 'b';
    ch := boolExpr( TRUE) ?  charExpr('a') : charExpr('b'); ok := ok and ch = 'a';
    ch := boolExpr(FALSE) ?  charExpr('a') : charExpr('b'); ok := ok and ch = 'b';
    if not ok then
      writeln(" ***** The ternary operator ? : does not work correctly. (2)");
      okay := FALSE;
    end if;

    if okay then
      writeln("The ternary operator ? : works correctly for char.");
    else
      writeln(" ***** The ternary operator ? : does not work correctly.");
    end if;
  end func;


const proc: main is func

  begin
    writeln;
    check_isLetter();
    check_width();
    check_literal();
    check_ternary();
  end func;
