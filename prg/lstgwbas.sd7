
(********************************************************************)
(*                                                                  *)
(*  lstgwbas.sd7  List tokenized GW-BASIC program.                  *)
(*  Copyright (C) 2008 - 2025  Thomas Mertes                        *)
(*                                                                  *)
(*  This program is free software; you can redistribute it and/or   *)
(*  modify it under the terms of the GNU General Public License as  *)
(*  published by the Free Software Foundation; either version 2 of  *)
(*  the License, or (at your option) any later version.             *)
(*                                                                  *)
(*  This program is distributed in the hope that it will be useful, *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of  *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *)
(*  GNU General Public License for more details.                    *)
(*                                                                  *)
(*  You should have received a copy of the GNU General Public       *)
(*  License along with this program; if not, write to the           *)
(*  Free Software Foundation, Inc., 51 Franklin Street,             *)
(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)
(*                                                                  *)
(********************************************************************)


$ include "seed7_05.s7i";
  include "chartype.s7i";
  include "bytedata.s7i";
  include "float.s7i";
  include "bin32.s7i";
  include "bin64.s7i";


const array string: tokenTable1 is [129] (
    (* 129 *) "END",
    (* 130 *) "FOR",
    (* 131 *) "NEXT",
    (* 132 *) "DATA",
    (* 133 *) "INPUT",
    (* 134 *) "DIM",
    (* 135 *) "READ",
    (* 136 *) "LET",
    (* 137 *) "GOTO",
    (* 138 *) "RUN",
    (* 139 *) "IF",
    (* 140 *) "RESTORE",
    (* 141 *) "GOSUB",
    (* 142 *) "RETURN",
    (* 143 *) "REM",
    (* 144 *) "STOP",
    (* 145 *) "PRINT",
    (* 146 *) "CLEAR",
    (* 147 *) "LIST",
    (* 148 *) "NEW",
    (* 149 *) "ON",
    (* 150 *) "WAIT",
    (* 151 *) "DEF",
    (* 152 *) "POKE",
    (* 153 *) "CONT",
    (* 154 *) "**undef**",
    (* 155 *) "**undef**",
    (* 156 *) "OUT",
    (* 157 *) "LPRINT",
    (* 158 *) "LLIST",
    (* 159 *) "**undef**",
    (* 160 *) "WIDTH",
    (* 161 *) "ELSE",
    (* 162 *) "TRON",
    (* 163 *) "TROFF",
    (* 164 *) "SWAP",
    (* 165 *) "ERASE",
    (* 166 *) "EDIT",
    (* 167 *) "ERROR",
    (* 168 *) "RESUME",
    (* 169 *) "DELETE",
    (* 170 *) "AUTO",
    (* 171 *) "RENUM",
    (* 172 *) "DEFSTR",
    (* 173 *) "DEFINT",
    (* 174 *) "DEFSNG",
    (* 175 *) "DEFDBL",
    (* 176 *) "LINE",
    (* 177 *) "WHILE",
    (* 178 *) "WEND",
    (* 179 *) "CALL",
    (* 180 *) "**undef**",
    (* 181 *) "**undef**",
    (* 182 *) "**undef**",
    (* 183 *) "WRITE",
    (* 184 *) "OPTION",
    (* 185 *) "RANDOMIZE",
    (* 186 *) "OPEN",
    (* 187 *) "CLOSE",
    (* 188 *) "LOAD",
    (* 189 *) "MERGE",
    (* 190 *) "SAVE",
    (* 191 *) "COLOR",
    (* 192 *) "CLS",
    (* 193 *) "MOTOR",
    (* 194 *) "BSAVE",
    (* 195 *) "BLOAD",
    (* 196 *) "SOUND",
    (* 197 *) "BEEP",
    (* 198 *) "PSET",
    (* 199 *) "PRESET",
    (* 200 *) "SCREEN",
    (* 201 *) "KEY",
    (* 202 *) "LOCATE",
    (* 203 *) "**undef**",
    (* 204 *) "TO",
    (* 205 *) "THEN",
    (* 206 *) "TAB(",
    (* 207 *) "STEP",
    (* 208 *) "USR",
    (* 209 *) "FN",
    (* 210 *) "SPC(",
    (* 211 *) "NOT",
    (* 212 *) "ERL",
    (* 213 *) "ERR",
    (* 214 *) "STRING$",
    (* 215 *) "USING",
    (* 216 *) "INSTR",
    (* 217 *) "'",
    (* 218 *) "VARPTR",
    (* 219 *) "CSRLIN",
    (* 220 *) "POINT",
    (* 221 *) "OFF",
    (* 222 *) "INKEY$",
    (* 223 *) "**undef**",
    (* 224 *) "**undef**",
    (* 225 *) "**undef**",
    (* 226 *) "**undef**",
    (* 227 *) "**undef**",
    (* 228 *) "**undef**",
    (* 229 *) "**undef**",
    (* 230 *) ">",
    (* 231 *) "=",
    (* 232 *) "<",
    (* 233 *) "+",
    (* 234 *) "-",
    (* 235 *) "*",
    (* 236 *) "/",
    (* 237 *) "^",
    (* 238 *) "AND",
    (* 239 *) "OR",
    (* 240 *) "XOR",
    (* 241 *) "EQV",
    (* 242 *) "IMP",
    (* 243 *) "MOD",
    (* 244 *) "\\");

const array string: tokenTable2 is [129] (
    (* 129 *) "CVI",
    (* 130 *) "CVS",
    (* 131 *) "CVD",
    (* 132 *) "MKI$",
    (* 133 *) "MKS$",
    (* 134 *) "MKD$",
    (* 135 *) "**undef**",
    (* 136 *) "**undef**",
    (* 137 *) "**undef**",
    (* 138 *) "**undef**",
    (* 139 *) "EXTERR");

const array string: tokenTable3 is [129] (
    (* 129 *) "FILES",
    (* 130 *) "FIELD",
    (* 131 *) "SYSTEM",
    (* 132 *) "NAME",
    (* 133 *) "LSET",
    (* 134 *) "RSET",
    (* 135 *) "KILL",
    (* 136 *) "PUT",
    (* 137 *) "GET",
    (* 138 *) "RESET",
    (* 139 *) "COMMON",
    (* 140 *) "CHAIN",
    (* 141 *) "DATE$",
    (* 142 *) "TIME$",
    (* 143 *) "PAINT",
    (* 144 *) "COM",
    (* 145 *) "CIRCLE",
    (* 146 *) "DRAW",
    (* 147 *) "PLAY",
    (* 148 *) "TIMER",
    (* 149 *) "ERDEV",
    (* 150 *) "IOCTL",
    (* 151 *) "CHDIR",
    (* 152 *) "MKDIR",
    (* 153 *) "RMDIR",
    (* 154 *) "SHELL",
    (* 155 *) "ENVIRON",
    (* 156 *) "VIEW",
    (* 157 *) "WINDOW",
    (* 158 *) "PMAP",
    (* 159 *) "PALETTE",
    (* 160 *) "LCOPY",
    (* 161 *) "CALLS",
    (* 162 *) "**undef**",
    (* 163 *) "**undef**",
    (* 164 *) "NOISE",
    (* 165 *) "PCOPY",
    (* 166 *) "TERM",
    (* 167 *) "LOCK",
    (* 168 *) "UNLOCK");

const array string: tokenTable4 is [129] (
    (* 129 *) "LEFT$",
    (* 130 *) "RIGHT$",
    (* 131 *) "MID$",
    (* 132 *) "SGN",
    (* 133 *) "INT",
    (* 134 *) "ABS",
    (* 135 *) "SQR",
    (* 136 *) "RND",
    (* 137 *) "SIN",
    (* 138 *) "LOG",
    (* 139 *) "EXP",
    (* 140 *) "COS",
    (* 141 *) "TAN",
    (* 142 *) "ATN",
    (* 143 *) "FRE",
    (* 144 *) "INP",
    (* 145 *) "POS",
    (* 146 *) "LEN",
    (* 147 *) "STR$",
    (* 148 *) "VAL",
    (* 149 *) "ASC",
    (* 150 *) "CHR$",
    (* 151 *) "PEEK",
    (* 152 *) "SPACE$",
    (* 153 *) "OCT$",
    (* 154 *) "HEX$",
    (* 155 *) "LPOS",
    (* 156 *) "CINT",
    (* 157 *) "CSNG",
    (* 158 *) "CDBL",
    (* 159 *) "FIX",
    (* 160 *) "PEN",
    (* 161 *) "STICK",
    (* 162 *) "STRIG",
    (* 163 *) "EOF",
    (* 164 *) "LOC",
    (* 165 *) "LOF");


const proc: appendToken(inout string: sourceLine, in string: token) is func
  begin
    if sourceLine <> "" and sourceLine[length(sourceLine)] in alphanum_char and
        token[1] in letter_char then
      sourceLine &:= " ";
    end if;
    sourceLine &:= token;
  end func;


const func string: floatLiteral (in float: number, in boolean: isDouble) is func
  result
    var string: stri is "";
  local
    var string: decimalFloat is "";
    var string: scientificFloat is "";
  begin
    if isDouble then
      decimalFloat := str(number);
    else
      decimalFloat := number sci 6;
      decimalFloat := str(float parse decimalFloat);
    end if;
    if endsWith(decimalFloat, ".0") then
      decimalFloat := decimalFloat[.. length(decimalFloat) - 2];
    elsif startsWith(decimalFloat, "0.") then
      decimalFloat := decimalFloat[2 ..];
    elsif startsWith(decimalFloat, "-0.") then
      decimalFloat := "-" & decimalFloat[3 ..];
    end if;
    if isDouble then
      decimalFloat &:= "#";
    end if;
    scientificFloat := str(number, SCIENTIFIC);
    scientificFloat := replace(scientificFloat, "e+", "e");
    scientificFloat := replace(scientificFloat, ".0e", "e");
    if isDouble then
      scientificFloat := replace(scientificFloat, "e", "D");
    else
      scientificFloat := replace(scientificFloat, "e", "E");
    end if;
    if length(scientificFloat) < length(decimalFloat) then
      stri := scientificFloat;
    else
      stri := decimalFloat;
    end if;
  end func;


(**
 *  Decodes a line from the bytes buffer at position pos.
 *  @param bytes Buffer containing the tokenized program.
 *  @param pos Current position in the bytes buffer (pos is changed).
 *  @return the basic source line or "" at the end of the program.
 *  @exception RANGE_ERROR If an illegal encoding was found.
 *)
const func string: decodeTokenizedLine (in string: bytes, inout integer: pos) is func
  result
    var string: sourceLine is "";
  local
    var integer: code is 0;
    var string: token is "";
    var boolean: tokenEndsWithLetter is FALSE;
    var boolean: insertSpaceBeforeIdentifier is FALSE;
  begin
    # The first two bytes are the address of the next line.
    # This address is not needed here.
    # At the end of the program both bytes are zero.
    if bytes[pos] = '\0;' and bytes[pos + 1] = '\0;' then
      pos := succ(length(bytes));
    else
      # next two bytes are the line number
      sourceLine &:= str(bytes2Int(bytes[pos + 2 fixLen 2], UNSIGNED, LE));
      # writeln("line: " <& sourceLine);
      sourceLine &:= " ";
      pos +:= 4;
      while pos <= length(bytes) and bytes[pos] <> '\0;' do
        code := ord(bytes[pos]);
        # writeln("code: " <& code);
        case code of
          when {11}:         # 2 bytes as octal constant (unsigned)
            sourceLine &:= "&O" <& bytes2Int(bytes[pos + 1 fixLen 2], UNSIGNED, LE) radix 8;
            pos +:= 3;
          when {12}:         # 2 bytes as hex constant (unsigned)
            sourceLine &:= "&H" <& bytes2Int(bytes[pos + 1 fixLen 2], UNSIGNED, LE) RADIX 16;
            pos +:= 3;
          when {13}:         # 2 bytes as line pointer (unsigned)
            writeln(" ***** Line pointer (16#0d) shouldn't occur in saved program.");
            raise RANGE_ERROR;
          when {14}:         # 2 bytes as line number (unsigned)
            sourceLine &:= str(bytes2Int(bytes[pos + 1 fixLen 2], UNSIGNED, LE));
            pos +:= 3;
          when {15}:         # 1 byte integer constant: 10 to 255
            sourceLine &:= str(ord(bytes[pos + 1]));
            pos +:= 2;
          when {16}:         # Flags constant (unused)
            writeln(" ***** Unexpected token 16 (16#10)");
            raise RANGE_ERROR;
          when {17 .. 26}:   # Decimal digit - integer: 0 .. 9
            sourceLine &:= str(code - 17);
            pos +:= 1;
          when {27}:         # unused
            writeln(" ***** Unexpected token 27 (16#1b)");
            raise RANGE_ERROR;
          when {28}:         # 2 bytes as signed integer constant
            sourceLine &:= str(bytes2Int(bytes[pos + 1 fixLen 2], SIGNED, LE));
            pos +:= 3;
          when {29}:         # 4 byte single precision floating point constant
            sourceLine &:= floatLiteral(mbfBits2Float(bin32(bytes[pos + 1 fixLen 4], LE)), FALSE);
            pos +:= 5;
          when {30}:         # unused
            writeln(" ***** Unexpected token 30 (16#1e)");
            raise RANGE_ERROR;
          when {31}:         # 8 byte double precision floating point constant
            sourceLine &:= floatLiteral(mbfBits2Float(bin64(bytes[pos + 1 fixLen 8], LE)), TRUE);
            pos +:= 9;
          when {32, 33}:     # ' ', '!'
            sourceLine &:= str(char(code));
            pos +:= 1;
          when {34}:         # String literal
            sourceLine &:= '"';
            incr(pos);
            # Get the bytes of a string without decoding the tokens.
            while pos <= length(bytes) and bytes[pos] <> '"' and bytes[pos] <> '\0;' do
              sourceLine &:= bytes[pos];
              incr(pos);
            end while;
            # A string might not be terminated by "
            if pos <= length(bytes) and bytes[pos] = '"' then
              sourceLine &:= '"';
              incr(pos);
            end if;
          when {35 .. 57}:   # '#' .. '9'
            sourceLine &:= str(char(code));
            incr(pos);
          when {58}:         # ':'
            if pos + 2 <= length(bytes) and ord(bytes[succ(pos)]) = 143 and
                 ord(bytes[pos + 2]) = 217 then
              # ' is stored as ":REM'" with the bytes 58, 143, 217 (16#3a8fd9).
              # The ":REM" is suppressed when the program is listed.
              sourceLine &:= "'";
              pos +:= 3;
              # Get the bytes of ' without decoding the tokens.
              while pos <= length(bytes) and bytes[pos] <> '\0;' do
                sourceLine &:= bytes[pos];
                if bytes[pos] = '\n' then
                  sourceLine &:= "' ";
                end if;
                incr(pos);
              end while;
            elsif pos < length(bytes) and ord(bytes[succ(pos)]) = 161 then
              # ELSE is stored as ":ELSE" with the bytes 58, 161 (16#3aa1).
              # The ":" is suppressed when the program is listed.
              appendToken(sourceLine, "ELSE");
              tokenEndsWithLetter := TRUE;
              pos +:= 2;
            else
              sourceLine &:= ":";
              incr(pos);
            end if;
          when {59 .. 126}:  # ';' .. '~'
            if insertSpaceBeforeIdentifier and char(code) in letter_char then
              sourceLine &:= " ";
            end if;
            sourceLine &:= str(char(code));
            pos +:= 1;
          when {129 .. 244}: # One byte token
            appendToken(sourceLine, tokenTable1[code]);
            if code = 177 and pos < length(bytes) and ord(bytes[succ(pos)]) = 233 then
              # WHILE is stored as "WHILE+" with the bytes 177, 233 (16#b1e9).
              # The "+" is suppressed when the program is listed.
              incr(pos);
            elsif code = 143 then
              # Get the bytes of REM without decoding the tokens.
              incr(pos);
              while pos <= length(bytes) and bytes[pos] <> '\0;' do
                sourceLine &:= bytes[pos];
                if bytes[pos] = '\n' then
                  sourceLine &:= "REM ";
                end if;
                incr(pos);
              end while;
              decr(pos);
            elsif code <> 209 then
              # After "FN" the function name should follow without space.
              tokenEndsWithLetter := sourceLine[length(sourceLine)] in letter_char;
            end if;
            incr(pos);
          when {253}:        # Two byte token from table 2
            incr(pos);
            code := ord(bytes[pos]);
            if code >= 129 and code <= 139 then
              appendToken(sourceLine, tokenTable2[code]);
              tokenEndsWithLetter := sourceLine[length(sourceLine)] in letter_char;
            else
              writeln(" ***** Unexpected token: 253, " <& code <&
                      " (16#fd" <& code radix 16 lpad0 2 <& ")");
              raise RANGE_ERROR;
            end if;
            incr(pos);
          when {254}:        # Two byte token from table 3
            incr(pos);
            code := ord(bytes[pos]);
            if code >= 129 and code <= 168 then
              appendToken(sourceLine, tokenTable3[code]);
              tokenEndsWithLetter := sourceLine[length(sourceLine)] in letter_char;
            else
              writeln(" ***** Unexpected token: 254, " <& code <&
                      " (16#fe" <& code radix 16 lpad0 2 <& ")");
              raise RANGE_ERROR;
            end if;
            incr(pos);
          when {255}:        # Two byte token from table 4
            incr(pos);
            code := ord(bytes[pos]);
            if code >= 129 and code <= 165 then
              appendToken(sourceLine, tokenTable4[code]);
              tokenEndsWithLetter := sourceLine[length(sourceLine)] in letter_char;
            else
              writeln(" ***** Unexpected token: 255, " <& code <&
                      " (16#ff" <& code radix 16 lpad0 2 <& ")");
              raise RANGE_ERROR;
            end if;
            incr(pos);
          otherwise:
            writeln(" ***** Unexpected token: " <& code <&
                      " (" <& code radix 16 lpad0 2 <& ")");
            raise RANGE_ERROR;
        end case;
        if tokenEndsWithLetter then
          insertSpaceBeforeIdentifier := TRUE;
          tokenEndsWithLetter := FALSE;
        else
          insertSpaceBeforeIdentifier := FALSE;
        end if;
      end while;
      if pos > length(bytes) then
        writeln(" ***** Unexpected end of line.");
        raise RANGE_ERROR;
      else
        pos +:= 1;  # Consume the null byte at end of line
      end if;
    end if;
  end func;


const proc: unprotect (inout string: bytes) is func
  local
    const array bin32: patterns1 is [] (
        bin32(16#9a), bin32(16#f7), bin32(16#19), bin32(16#83), bin32(16#24),
        bin32(16#63), bin32(16#43), bin32(16#83), bin32(16#75), bin32(16#cd),
        bin32(16#8d), bin32(16#84), bin32(16#a9));
    const array bin32: patterns2 is [] (
        bin32(16#7c), bin32(16#88), bin32(16#59), bin32(16#74), bin32(16#e0),
        bin32(16#97), bin32(16#26), bin32(16#77), bin32(16#c4), bin32(16#1d),
        bin32(16#1e));
    var integer: pattern1Idx is length(patterns1);
    var integer: pattern2Idx is length(patterns2);
    var integer: pos is 0;
    var integer: code is 0;
  begin
    for pos range 2 to pred(length(bytes)) do
      code := ord(bytes[pos]);
      code := (code - pattern2Idx) mod 256;
      code := ord(bin32(code) >< patterns1[pattern1Idx] >< patterns2[pattern2Idx]);
      code := (code + pattern1Idx) mod 256;
      bytes @:= [pos] char(code);
      decr(pattern1Idx);
      if pattern1Idx = 0 then
        pattern1Idx := length(patterns1);
      end if;
      decr(pattern2Idx);
      if pattern2Idx = 0 then
        pattern2Idx := length(patterns2);
      end if;
    end for;
    bytes @:= [1] '\16#ff;';
  end func;


const proc: writeLines (in var string: bytes) is func
  local
    var integer: pos is 2;
    var string: line is "";
  begin
    if startsWith(bytes, "\16#fe;") then
      unprotect(bytes);
    end if;
    if startsWith(bytes, "\16#ff;") then
      line := decodeTokenizedLine(bytes, pos);
      while pos <= length(bytes) do
        if line = "" then
          writeln(" ***** Couldn't parse program at position " <& pos);
        elsif pos <= length(bytes) then
          writeln(line);
        end if;
        line := decodeTokenizedLine(bytes, pos);
      end while;
    else
      writeln(" ***** Magic number (255) for gwbasic missing.");
    end if;
  end func;


const proc: main is func
  local
    var string: fileName is "";
    var file: tokenFile is STD_NULL;
    var string: bytes is "";
  begin
    if length(argv(PROGRAM)) = 1 then
      fileName := argv(PROGRAM)[1];
      tokenFile := open(fileName, "r");
      if tokenFile <> STD_NULL then
        bytes := gets(tokenFile, length(tokenFile));
        close(tokenFile);
        writeLines(bytes);
      else
        writeln(" ***** Could not open " <& fileName);
      end if;
    else
      writeln("Lstgwbas Version 1.0 - List tokenized GW-BASIC program.");
      writeln("Copyright (C) 2008 - 2025 Thomas Mertes");
      writeln("This is free software; see the source for copying conditions.  There is NO");
      writeln("warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.");
      writeln("Lstgwbas is written in the Seed7 programming language");
      writeln("Homepage: http://seed7.net");
      writeln;
      writeln("usage: lstgwbas file");
    end if;
  end func;
