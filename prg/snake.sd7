
(********************************************************************)
(*                                                                  *)
(*  snake.sd7     Snake eats apple game                             *)
(*  Copyright (C) 1993, 1994, 2004  Thomas Mertes                   *)
(*                                                                  *)
(*  This program is free software; you can redistribute it and/or   *)
(*  modify it under the terms of the GNU General Public License as  *)
(*  published by the Free Software Foundation; either version 2 of  *)
(*  the License, or (at your option) any later version.             *)
(*                                                                  *)
(*  This program is distributed in the hope that it will be useful, *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of  *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *)
(*  GNU General Public License for more details.                    *)
(*                                                                  *)
(*  You should have received a copy of the GNU General Public       *)
(*  License along with this program; if not, write to the Free      *)
(*  Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,  *)
(*  MA 02111-1307 USA                                               *)
(*                                                                  *)
(********************************************************************)


$ include "seed7_05.s7i";
include "time.s7i";
include "screen.s7i";
include "window.s7i";
include "keybd.s7i";

const char: BLANK   is ' ';
const char: BODY is '*';

const type: direction_type is new enum
    STAY, UP, DOWN, LEFT, RIGHT
  end enum;

var integer: MAX_LINE is 0;
var integer: MAX_COLUMN is 0;

const type: char_line is array char;
const type: pos_type is array integer;

var array char_line: FIELD is 0 times 0 times ' ';

const type: screen_object is new struct
    var integer: line is 0;
    var integer: column is 0;
    var char: picture is ' ';
  end struct;

const type: apple_object is sub screen_object struct
  end struct;

var apple_object: APPLE is apple_object.value;
APPLE.picture := 'o';

const type: snake_object is sub screen_object struct
    var direction_type: direction is STAY;
    var boolean: backward_movement is FALSE;
    var boolean: fence_movement is FALSE;
    var char: last_meal is ' ';
    var integer: head_index is 1;
    var integer: end_index is 1;
    var array pos_type: position is 2000 times (2 times 0);
    var integer: length is 0;
    var integer: grow is 2;
  end struct;

var snake_object: SNAKE is snake_object.value;
SNAKE.picture := 'S';

const proc: move (SNAKE, in direction_type param) is DYNAMIC;


var TEXT: SCR is STD_NULL;
var TEXT: WIN is STD_NULL;
var TEXT: STATUS is STD_NULL;


const proc: beep is func

  begin
(*  write("\G"); *)
    noop;
  end func;


const proc: set_position (inout screen_object: scr_object) is func

  local
    var integer: lin is 0;
    var integer: col is 0;
    var char: ch is ' ';
  begin
    repeat
      lin := rand(1, MAX_LINE - 2);
      col := rand(1, MAX_COLUMN - 2);
      ch := FIELD[lin][col];
    until ch = BLANK;
    setPos(WIN, lin, col);
    WIN << scr_object.picture;
    FIELD[lin][col] := scr_object.picture;
    scr_object.line := lin;
    scr_object.column := col;
  end func;


const proc: show_status is func

  begin
    setPos(STATUS, 1, MAX_COLUMN div 2 - 3);
    STATUS << " ";
    STATUS << SNAKE.length;
    STATUS << " ";
  end func;


const proc: turn (SNAKE, UP) is func

  begin
    if SNAKE.direction = DOWN then
      SNAKE.backward_movement := TRUE;
    else
      SNAKE.direction := UP;
      SNAKE.picture := 'v';
    end if;
  end func;


const proc: turn (SNAKE, DOWN) is func

  begin
    if SNAKE.direction = UP then
      SNAKE.backward_movement := TRUE;
    else
      SNAKE.direction := DOWN;
      SNAKE.picture := '^';
    end if;
  end func;


const proc: turn (SNAKE, LEFT) is func

  begin
    if SNAKE.direction = RIGHT then
      SNAKE.backward_movement := TRUE;
    else
      SNAKE.direction := LEFT;
      SNAKE.picture := '>';
    end if;
  end func;


const proc: turn (SNAKE, RIGHT) is func

  begin
    if SNAKE.direction = LEFT then
      SNAKE.backward_movement := TRUE;
    else
      SNAKE.direction := RIGHT;
      SNAKE.picture := '<';
    end if;
  end func;


const proc: move (SNAKE, UP) is func

  begin
    if SNAKE.line > 1 then
      decr(SNAKE.line);
    else
      SNAKE.fence_movement := TRUE;
    end if;
  end func;


const proc: move (SNAKE, DOWN) is func

  begin
    if SNAKE.line < MAX_LINE then
      incr(SNAKE.line);
    else
      SNAKE.fence_movement := TRUE;
    end if;
  end func;


const proc: move (SNAKE, LEFT) is func

  begin
    if SNAKE.column > 1 then
      decr(SNAKE.column);
    else
      SNAKE.fence_movement := TRUE;
    end if;
  end func;


const proc: move (SNAKE, RIGHT) is func

  begin
    if SNAKE.column < MAX_COLUMN then
      incr(SNAKE.column);
    else
      SNAKE.fence_movement := TRUE;
    end if;
  end func;


const proc: move (SNAKE, STAY) is func

  begin
    noop;
  end func;


const proc: move (SNAKE) is func

  begin
    move(SNAKE, SNAKE.direction);
    if not SNAKE.fence_movement then
      SNAKE.last_meal := FIELD[SNAKE.line][SNAKE.column];
    end if;
  end func;


const proc: enlarge (SNAKE) is func

  local
    var integer: number is 0;
  begin
    number := SNAKE.length div 2;
    if number <= 5 then
      SNAKE.grow +:= 5;
    elsif number >= 30 then
      SNAKE.grow +:= 30;
    else
      SNAKE.grow +:= number;
    end if;
  end func;


const proc: show (SNAKE) is func

  begin
    if SNAKE.grow <> 0 then
      if SNAKE.length = 0 then
        setPos(WIN, SNAKE.position[SNAKE.end_index][1],
            SNAKE.position[SNAKE.end_index][2]);
        WIN << BODY;
        FIELD[SNAKE.position[SNAKE.end_index][1]]
            [SNAKE.position[SNAKE.end_index][2]] := BODY;
      end if;
      decr(SNAKE.grow);
      incr(SNAKE.length);
      show_status();
    else
      setPos(WIN, SNAKE.position[SNAKE.end_index][1],
          SNAKE.position[SNAKE.end_index][2]);
      WIN << BLANK;
      FIELD[SNAKE.position[SNAKE.end_index][1]]
          [SNAKE.position[SNAKE.end_index][2]] := BLANK;
      incr(SNAKE.end_index);
    end if;

    incr(SNAKE.head_index);
    SNAKE.position[SNAKE.head_index][1] := SNAKE.line;
    SNAKE.position[SNAKE.head_index][2] := SNAKE.column;

    setPos(WIN, SNAKE.line, SNAKE.column);
    WIN << SNAKE.picture;
    FIELD[SNAKE.line][SNAKE.column] := SNAKE.picture;
    setPos(WIN, SNAKE.position[pred(SNAKE.head_index)][1],
        SNAKE.position[pred(SNAKE.head_index)][2]);
    WIN << BODY;
    FIELD[SNAKE.position[pred(SNAKE.head_index)][1]]
        [SNAKE.position[pred(SNAKE.head_index)][2]] := BODY;
  end func;


const func boolean: play(ROUND) is func

  result
    var boolean: result is FALSE;
  local
    var char: inp is ' ';
    var time: start_time is NULL_TIME;
    var integer: apple_counter is 0;
  begin
    show_status();
    inp := busy_getc(KEYBOARD);
    while inp <> 'q' do
      start_time := time(NOW);
      if inp <> KEY_NONE then
        case inp of
          when {KEY_UP}:
            turn(SNAKE, UP);
          when {KEY_DOWN}:
            turn(SNAKE, DOWN);
          when {KEY_LEFT}:
            turn(SNAKE, LEFT);
          when {KEY_RIGHT}:
            turn(SNAKE, RIGHT);
        end case;
      end if;

      move(SNAKE);

      if SNAKE.fence_movement then
        beep();
        setPos(SCR, 1, 1);
        SCR << "FENCE";
        inp := 'q';
      else

        if SNAKE.direction <> STAY then
          show(SNAKE);
        end if;

        if SNAKE.last_meal = BODY then
          beep();
          setPos(SCR, 1, 1);
          SCR << "BODY";
          inp := 'q';
        elsif SNAKE.last_meal = '#' then
          beep();
          setPos(SCR, 1, 1);
          SCR << "#";
          inp := 'q';
        elsif apple_counter >= 10 then
          inp := 'q';
        else

          if SNAKE.last_meal = APPLE.picture then
            incr(apple_counter);
            if apple_counter < 10 then
              enlarge(SNAKE);
              beep();
              set_position(APPLE);
            end if;
          end if;


          await(start_time + 100000 . MYCRO_SECONDS);

          inp := busy_getc(KEYBOARD);

        end if;
      end if;
    end while;
    result := apple_counter >= 10;
  end func;


const proc: init_level (in integer: level) is func

  local
    var integer: number is 0;
    var integer: column is 0;
  begin
    case level of
      when {1}:
        noop;
(*      SNAKE(1).row = 25: SNAKE(2).row = 25
        SNAKE(1).col = 50: SNAKE(2).col = 30
        SNAKE(1).direction = 4: SNAKE(2).direction = 3 *)


      when {2}:
        for number range 19 to 59 do
          FIELD[11][number] := '#';
          setPos(WIN, 11, number);
          WIN << "#";
        end for;
(*      SNAKE(1).row = 7: SNAKE(2).row = 43
        SNAKE(1).col = 60: SNAKE(2).col = 20
        SNAKE(1).direction = 3: SNAKE(2).direction = 4 *)

      when {3}:
        for number range 6 to 16 do
          FIELD[number][19] := '#';
          FIELD[number][59] := '#';
          setPos(WIN, number, 19);
          WIN << "#";
          setPos(WIN, number, 59);
          WIN << "#";
        end for;
(*      SNAKE(1).row = 25: SNAKE(2).row = 25
        SNAKE(1).col = 50: SNAKE(2).col = 30
        SNAKE(1).direction = 1: SNAKE(2).direction = 2 *)

      when {4}:
        for number range 1 to 12 do
          FIELD[number][19] := '#';
          FIELD[22 - number][59] := '#';
          setPos(WIN, number, 19);
          WIN << "#";
          setPos(WIN, 22 - number, 59);
          WIN << "#";
        end for;
        for number range 1 to 45 do
          FIELD[16][number] := '#';
          FIELD[6][79 - number] := '#';
          setPos(WIN, 16, number);
          WIN << "#";
          setPos(WIN, 6, 79 - number);
          WIN << "#";
        end for;
(*      SNAKE(1).row = 7: SNAKE(2).row = 43
        SNAKE(1).col = 60: SNAKE(2).col = 20
        SNAKE(1).direction = 3: SNAKE(2).direction = 4 *)

      when {5}:
        for number range 6 to 16 do
          FIELD[number][19] := '#';
          FIELD[number][59] := '#';
          setPos(WIN, number, 19);
          WIN << "#";
          setPos(WIN, number, 59);
          WIN << "#";
        end for;
        for number range 21 to 57 do
          FIELD[4][number] := '#';
          FIELD[18][number] := '#';
          setPos(WIN, 4, number);
          WIN << "#";
          setPos(WIN, 18, number);
          WIN << "#";
        end for;
(*      SNAKE(1).row = 25: SNAKE(2).row = 25
        SNAKE(1).col = 50: SNAKE(2).col = 30
        SNAKE(1).direction = 1: SNAKE(2).direction = 2 *)

      when {6}:
        for number range 1 to 21 do
          if number <= 9 or number >= 13 then
            FIELD[number][10] := '#';
            FIELD[number][20] := '#';
            FIELD[number][30] := '#';
            FIELD[number][40] := '#';
            FIELD[number][50] := '#';
            FIELD[number][60] := '#';
            FIELD[number][70] := '#';
            setPos(WIN, number, 10);
            WIN << "#";
            setPos(WIN, number, 20);
            WIN << "#";
            setPos(WIN, number, 30);
            WIN << "#";
            setPos(WIN, number, 40);
            WIN << "#";
            setPos(WIN, number, 50);
            WIN << "#";
            setPos(WIN, number, 60);
            WIN << "#";
            setPos(WIN, number, 70);
            WIN << "#";
          end if;
        end for;
(*      SNAKE(1).row = 7: SNAKE(2).row = 43
        SNAKE(1).col = 65: SNAKE(2).col = 15
        SNAKE(1).direction = 2: SNAKE(2).direction = 1 *)

      when {7}:
(*      for number range 4 to 49 STEP 2 do
          FIELD[number][40] := '#';
          setPos(WIN, number, 40);
          WIN << "#";
        end for; *)
        number := 1;
        while number <= 21 do
          FIELD[number][39] := '#';
          setPos(WIN, number, 39);
          WIN << "#";
          number +:= 2;
        end while;
(*      SNAKE(1).row = 7: SNAKE(2).row = 43
        SNAKE(1).col = 65: SNAKE(2).col = 15
        SNAKE(1).direction = 2: SNAKE(2).direction = 1 *)

      when {8}:
        for number range 1 to 18 do
          FIELD[number][10] := '#';
          FIELD[22 - number][20] := '#';
          FIELD[number][30] := '#';
          FIELD[22 - number][40] := '#';
          FIELD[number][50] := '#';
          FIELD[22 - number][60] := '#';
          FIELD[number][70] := '#';
          setPos(WIN, number, 10);
          WIN << "#";
          setPos(WIN, 22 - number, 20);
          WIN << "#";
          setPos(WIN, number, 30);
          WIN << "#";
          setPos(WIN, 22 - number, 40);
          WIN << "#";
          setPos(WIN, number, 50);
          WIN << "#";
          setPos(WIN, 22 - number, 60);
          WIN << "#";
          setPos(WIN, number, 70);
          WIN << "#";
        end for;
(*      SNAKE(1).row = 7: SNAKE(2).row = 43
        SNAKE(1).col = 65: SNAKE(2).col = 15
        SNAKE(1).direction = 2: SNAKE(2).direction = 1 *)

      when {9}:
        for number range 3 to 19 do
          FIELD[number][2 * number] := '#';
          FIELD[number][2 * number + 1] := '#';
          FIELD[number][2 * number + 34] := '#';
          FIELD[number][2 * number + 35] := '#';
          setPos(WIN, number, 2 * number);
          WIN << "#";
          setPos(WIN, number, 2 * number + 1);
          WIN << "#";
          setPos(WIN, number, 2 * number + 28);
          WIN << "#";
          setPos(WIN, number, 2 * number + 29);
          WIN << "#";
        end for;
(*      SNAKE(1).row = 40: SNAKE(2).row = 15
        SNAKE(1).col = 75: SNAKE(2).col = 5
        SNAKE(1).direction = 1: SNAKE(2).direction = 2 *)

      otherwise:
(*      for number range 4 to 49 STEP 2 do
          FIELD[number][10] := '#';
          FIELD[number + 1][20] := '#';
          FIELD[number][30] := '#';
          FIELD[number + 1][40] := '#';
          FIELD[number][50] := '#';
          FIELD[number + 1][60] := '#';
          FIELD[number][70] := '#';
        end for; *)
        number := 1;
        while number <= 20 do
          FIELD[number][10] := '#';
          FIELD[21 - number][20] := '#';
          FIELD[number][30] := '#';
          FIELD[21 - number][40] := '#';
          FIELD[number][50] := '#';
          FIELD[21 - number][60] := '#';
          FIELD[number][70] := '#';
          setPos(WIN, number, 10);
          WIN << "#";
          setPos(WIN, 21 - number, 20);
          WIN << "#";
          setPos(WIN, number, 30);
          WIN << "#";
          setPos(WIN, 21 - number, 40);
          WIN << "#";
          setPos(WIN, number, 50);
          WIN << "#";
          setPos(WIN, 21 - number, 60);
          WIN << "#";
          setPos(WIN, number, 70);
          WIN << "#";
          number +:= 2;
        end while;
(*      SNAKE(1).row = 7: SNAKE(2).row = 43
        SNAKE(1).col = 65: SNAKE(2).col = 15
        SNAKE(1).direction = 2: SNAKE(2).direction = 1 *)

    end case;
(*  for number range 1 to 21 do
      for column range 1 to 78 do
        setPos(WIN, number, column);
        WIN << FIELD[number][column];
      end for;
    end for; *)
  end func;


const proc: main is func

  local
    var integer: level is 1;
    var integer: number1 is 0;
    var integer: number2 is 0;
  begin
    SCR := open(SCREEN);
    WIN := open_window(SCR, 2, 2, 21, 78);
    STATUS := open_window(SCR, 23, 2, 1, 78);

    MAX_LINE := 21; (* WIN.HEIGHT; *)
    MAX_COLUMN := 78; (* WIN.WIDTH; *)

    repeat
      box(WIN);
      clear(WIN);
(*    number1 := heapsize(PROGRAM);
      setPos(STATUS, 1, 1);
      STATUS << number1;
      STATUS << " "; *)
      FIELD := 21 times (78 times BLANK);
(*    number2 := heapsize(PROGRAM);
      STATUS << number2;
      STATUS << " ";
      STATUS << number2 - number1;
      STATUS << " "; *)
      init_level(level);
      SNAKE.picture := 'S';
      set_position(APPLE);
      set_position(SNAKE);
      SNAKE.direction := STAY;
      SNAKE.backward_movement := FALSE;
      SNAKE.fence_movement := FALSE;
      SNAKE.last_meal := ' ';
      SNAKE.head_index := 1;
      SNAKE.end_index := 1;
      SNAKE.position[SNAKE.end_index][1] := SNAKE.line;
      SNAKE.position[SNAKE.end_index][2] := SNAKE.column;
      SNAKE.length := 0;
      SNAKE.grow := 2;

      if play(ROUND) then
        incr(level);
      end if;

    until getc(KEYBOARD) = 'q';
  end func;

$ system "main" is main;
