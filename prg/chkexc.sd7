
(********************************************************************)
(*                                                                  *)
(*  chkexc.sd7    Checks exceptions                                 *)
(*  Copyright (C) 1994, 2005  Thomas Mertes                         *)
(*                                                                  *)
(*  This program is free software; you can redistribute it and/or   *)
(*  modify it under the terms of the GNU General Public License as  *)
(*  published by the Free Software Foundation; either version 2 of  *)
(*  the License, or (at your option) any later version.             *)
(*                                                                  *)
(*  This program is distributed in the hope that it will be useful, *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of  *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *)
(*  GNU General Public License for more details.                    *)
(*                                                                  *)
(*  You should have received a copy of the GNU General Public       *)
(*  License along with this program; if not, write to the           *)
(*  Free Software Foundation, Inc., 51 Franklin Street,             *)
(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)
(*                                                                  *)
(********************************************************************)


$ include "seed7_05.s7i";
  include "float.s7i";
  include "math.s7i";


const proc: f1 (in integer: number) is func
  begin
    ignore(1 div 0);
  end func;


const proc: f2 (in integer: number) is func
  begin
    f1(number);
  end func;


const proc: f3 is func
  begin
    f2(5);
  end func;


const proc: f4 (in integer: number) is func
  begin
    f3;
  end func;


const func integer: test_func (in integer: number) is func
  result
    var integer: result is 0;
  begin
    result := number;
  end func;


const proc: check_integer is func
  local
    var boolean: okay is TRUE;
    var integer: number is 0;
    var integer: i_num is 0;
  begin
    block
      i_num := 1 div 0;
      writeln(" ***** 1 div 0 did not raise NUMERIC_ERROR");
      okay := FALSE;
    exception
      catch NUMERIC_ERROR:
        incr(number);
    end block;

    block
      i_num := 1 rem 0;
      writeln(" ***** 1 rem 0 did not raise NUMERIC_ERROR");
      okay := FALSE;
    exception
      catch NUMERIC_ERROR:
        incr(number);
    end block;

    block
      i_num := 1 mdiv 0;
      writeln(" ***** 1 mdiv 0 did not raise NUMERIC_ERROR");
      okay := FALSE;
    exception
      catch NUMERIC_ERROR:
        incr(number);
    end block;

    block
      i_num := 1 mod 0;
      writeln(" ***** 1 mod 0 did not raise NUMERIC_ERROR");
      okay := FALSE;
    exception
      catch NUMERIC_ERROR:
        incr(number);
    end block;

    block
      i_num := ! (-1);
      writeln(" ***** ! (-1) did not raise NUMERIC_ERROR");
      okay := FALSE;
    exception
      catch NUMERIC_ERROR:
        incr(number);
    end block;

    block
      i_num := log2(-1);
      writeln(" ***** log2(-1) did not raise NUMERIC_ERROR");
      okay := FALSE;
    exception
      catch NUMERIC_ERROR:
        incr(number);
    end block;

    block
      i_num := 0 ** 0;
      if i_num = 1 then
        incr(number);
      else
        writeln(" ***** 0 ** 0 did not deliver 1");
        okay := FALSE;
      end if;
    exception
      catch NUMERIC_ERROR:
        writeln(" ***** 0 ** 0 did raise NUMERIC_ERROR");
        okay := FALSE;
    end block;

    block
      i_num := 0 ** (-2);
      writeln(" ***** 0 ** (-2) did not raise NUMERIC_ERROR");
      okay := FALSE;
    exception
      catch NUMERIC_ERROR:
        incr(number);
    end block;

    block
      i_num := 1 ** (-2);
      writeln(" ***** 1 ** (-2) did not raise NUMERIC_ERROR");
      okay := FALSE;
    exception
      catch NUMERIC_ERROR:
        incr(number);
    end block;

    block
      i_num  := integer parse "asdf";
      writeln(" ***** integer parse \"asdf\" did not raise RANGE_ERROR");
      okay := FALSE;
    exception
      catch RANGE_ERROR:
        incr(number);
    end block;

    block
      i_num := rand(1, 0);
      writeln(" ***** rand(1, 0) did not raise RANGE_ERROR");
      okay := FALSE;
    exception
      catch RANGE_ERROR:
        incr(number);
    end block;

    block
      i_num  := sqrt(-1);
      writeln(" ***** sqrt(-1) did not raise NUMERIC_ERROR");
      okay := FALSE;
    exception
      catch NUMERIC_ERROR:
        incr(number);
    end block;

    block
      block
        i_num := 1 div 0;
        writeln(" ***** 1 div 0 did not raise NUMERIC_ERROR");
        okay := FALSE;
      exception
        catch NUMERIC_ERROR:
          incr(number);
      end block;
    exception
      catch NUMERIC_ERROR:
        writeln(" ***** NUMERIC_ERROR catched at wrong level");
    end block;

    block
      block
        i_num := 1 div 0;
        writeln(" ***** 1 div 0 did not raise NUMERIC_ERROR");
        okay := FALSE;
      exception
        catch RANGE_ERROR:
          writeln(" ***** NUMERIC_ERROR catched at wrong level");
      end block;
    exception
      catch NUMERIC_ERROR:
        incr(number);
    end block;

    if okay and number = 14 then
      writeln("Integer exceptions work correct.");
    else
      writeln(" ***** Integer exceptions do not work correct");
      writeln;
    end if;
  end func;


const proc: check_float is func
  local
    var boolean: okay is TRUE;
    var integer: number is 0;
    var float: f_num is 0.0;
  begin
    block
      f_num  := rand(1.0, 0.0);
      writeln(" ***** rand(1.0, 0.0) did not raise RANGE_ERROR");
      okay := FALSE;
    exception
      catch RANGE_ERROR:
        incr(number);
    end block;

    block
      f_num  := sqrt(-1.0);
      if isnan(f_num) then
        incr(number);
      else
        writeln(" ***** sqrt(-1.0) did not deliver NaN");
        okay := FALSE;
      end if;
    exception
      catch NUMERIC_ERROR:
        writeln(" ***** sqrt(-1.0) raises NUMERIC_ERROR");
        okay := FALSE;
    end block;

    block
      f_num  := 1.0 / 0.0;
      if f_num = Infinity then
        incr(number);
      else
        writeln(" ***** 1.0 / 0.0 did not deliver Infinity");
        okay := FALSE;
      end if;
    exception
      catch NUMERIC_ERROR:
        writeln(" ***** 1.0 / 0.0 raises NUMERIC_ERROR");
        okay := FALSE;
    end block;

    block
      f_num  := -1.0 / 0.0;
      if f_num = -Infinity then
        incr(number);
      else
        writeln(" ***** -1.0 / 0.0 did not deliver -Infinity");
        okay := FALSE;
      end if;
    exception
      catch NUMERIC_ERROR:
        writeln(" ***** -1.0 / 0.0 raises NUMERIC_ERROR");
        okay := FALSE;
    end block;

    block
      f_num  := 0.0 / 0.0;
      if isnan(f_num) then
        incr(number);
      else
        writeln(" ***** 0.0 / 0.0 did not deliver NaN");
        okay := FALSE;
      end if;
    exception
      catch NUMERIC_ERROR:
        writeln(" ***** 0.0 / 0.0 raises NUMERIC_ERROR");
        okay := FALSE;
    end block;

    block
      f_num := 0.0 ** (-2);
      if f_num = Infinity then
        incr(number);
      else
        writeln(" ***** 0.0 ** (-2) did not deliver Infinity");
        writeln(f_num);
        okay := FALSE;
      end if;
    exception
      catch NUMERIC_ERROR:
        writeln(" ***** 0.0 ** (-2) did raise NUMERIC_ERROR");
        okay := FALSE;
    end block;

    block
      f_num := 0.0 ** 0.0;
      if f_num = 1.0 then
        incr(number);
      else
        writeln(" ***** 0.0 ** 0.0 did not deliver 1.0");
        writeln(f_num);
        okay := FALSE;
      end if;
    exception
      catch NUMERIC_ERROR:
        writeln(" ***** 0.0 ** 0.0 did raise NUMERIC_ERROR");
        okay := FALSE;
    end block;

    block
      f_num := 0.0 ** (-1.0);
      if f_num = Infinity then
        incr(number);
      else
        writeln(" ***** 0.0 ** (-1.0) did not deliver Infinity");
        okay := FALSE;
      end if;
    exception
      catch NUMERIC_ERROR:
        writeln(" ***** 0.0 ** (-1.0) did raise NUMERIC_ERROR");
        okay := FALSE;
    end block;

    block
      f_num := (-2.0) ** 0.5;
      incr(number);
    exception
      catch NUMERIC_ERROR:
        writeln(" ***** (-2.0) ** 0.5 did raise NUMERIC_ERROR");
        okay := FALSE;
    end block;

    if okay and number = 9 then
      writeln("Floating point exceptions work correct.");
    else
      writeln(" ***** Floating point exceptions do not work correct");
      writeln;
    end if;
  end func;


const proc: check_string is func
  local
    var boolean: okay is TRUE;
    var integer: number is 0;
    var integer: i_num is 0;
    var string: stri is "";
    var char: ch is ' ';
  begin
    block
      ch := "asdf"[-1];
      writeln(" ***** \"asdf\"[-1] did not raise RANGE_ERROR");
      okay := FALSE;
    exception
      catch RANGE_ERROR:
        incr(number);
    end block;

    block
      ch := "asdf"[0];
      writeln(" ***** \"asdf\"[0] did not raise RANGE_ERROR");
      okay := FALSE;
    exception
      catch RANGE_ERROR:
        incr(number);
    end block;

    block
      ch := "asdf"[1];
      incr(number);
    exception
      catch RANGE_ERROR:
        writeln(" ***** \"asdf\"[1] did raise RANGE_ERROR");
        okay := FALSE;
    end block;

    block
      ch := "asdf"[4];
      incr(number);
    exception
      catch RANGE_ERROR:
        writeln(" ***** \"asdf\"[4] did raise RANGE_ERROR");
        okay := FALSE;
    end block;

    block
      ch := "asdf"[5];
      writeln(" ***** \"asdf\"[5] did not raise RANGE_ERROR");
      okay := FALSE;
    exception
      catch RANGE_ERROR:
        incr(number);
    end block;

    block
      ch := "asdf"[6];
      writeln(" ***** \"asdf\"[6] did not raise RANGE_ERROR");
      okay := FALSE;
    exception
      catch RANGE_ERROR:
        incr(number);
    end block;

    block
      stri := "asdf";
      stri @:= [-1] 'x';
      writeln(" ***** stri @:= [-1] 'x'; did not raise RANGE_ERROR");
      okay := FALSE;
    exception
      catch RANGE_ERROR:
        incr(number);
    end block;

    block
      stri := "asdf";
      stri @:= [0] 'x';
      writeln(" ***** stri @:= [0] 'x'; did not raise RANGE_ERROR");
      okay := FALSE;
    exception
      catch RANGE_ERROR:
        incr(number);
    end block;

    block
      stri := "asdf";
      stri @:= [1] 'x';
      incr(number);
    exception
      catch RANGE_ERROR:
        writeln(" ***** stri @:= [1] 'x'; did raise RANGE_ERROR");
        okay := FALSE;
    end block;

    block
      stri := "asdf";
      stri @:= [4] 'x';
      incr(number);
    exception
      catch RANGE_ERROR:
        writeln(" ***** stri @:= [4] 'x'; did raise RANGE_ERROR");
        okay := FALSE;
    end block;

    block
      stri := "asdf";
      stri @:= [5] 'x';
      writeln(" ***** stri @:= [5] 'x'; did not raise RANGE_ERROR");
      okay := FALSE;
    exception
      catch RANGE_ERROR:
        incr(number);
    end block;

    block
      stri := "asdf";
      stri @:= [6] 'x';
      writeln(" ***** stri @:= [6] 'x'; did not raise RANGE_ERROR");
      okay := FALSE;
    exception
      catch RANGE_ERROR:
        incr(number);
    end block;

    block
      stri := "asdf" mult -1;
      writeln(" ***** \"asdf\" mult -1 did not raise RANGE_ERROR");
      okay := FALSE;
    exception
      catch RANGE_ERROR:
        incr(number);
    end block;

    block
      i_num := pos("asdf", "df", -1);
      writeln(" ***** pos(\"asdf\", \"df\", -1) did not raise RANGE_ERROR");
      okay := FALSE;
    exception
      catch RANGE_ERROR:
        incr(number);
    end block;

    block
      stri := str('\99999\');
      incr(number);
    exception
      catch RANGE_ERROR: writeln(" ***** str('\\99999\\') raises RANGE_ERROR");
      okay := FALSE;
    end block;

    if okay and number = 15 then
      writeln("String exceptions work correct.");
    else
      writeln(" ***** String exceptions do not work correct");
      writeln;
    end if;
  end func;


const proc: check_array is func
  local
    var boolean: okay is TRUE;
    var integer: number is 0;
    var integer: i_num is 0;
    var array integer: arr is 0 times 1;
    var char: ch is ' ';
  begin
    block
      i_num := (4 times 1)[-1];
      writeln(" ***** (4 times 1)[-1] did not raise RANGE_ERROR");
      okay := FALSE;
    exception
      catch RANGE_ERROR:
        incr(number);
    end block;

    block
      i_num := (4 times 1)[0];
      writeln(" ***** (4 times 1)[0] did not raise RANGE_ERROR");
      okay := FALSE;
    exception
      catch RANGE_ERROR:
        incr(number);
    end block;

    block
      i_num := (4 times 1)[1];
      incr(number);
    exception
      catch RANGE_ERROR:
        writeln(" ***** (4 times 1)[1] did raise RANGE_ERROR");
        okay := FALSE;
    end block;

    block
      i_num := (4 times 1)[4];
      incr(number);
    exception
      catch RANGE_ERROR:
        writeln(" ***** (4 times 1)[4] did raise RANGE_ERROR");
        okay := FALSE;
    end block;

    block
      i_num := (4 times 1)[5];
      writeln(" ***** (4 times 1)[5] did not raise RANGE_ERROR");
      okay := FALSE;
    exception
      catch RANGE_ERROR:
        incr(number);
    end block;

    block
      i_num := (4 times 1)[6];
      writeln(" ***** (4 times 1)[6] did not raise RANGE_ERROR");
      okay := FALSE;
    exception
      catch RANGE_ERROR:
        incr(number);
    end block;

    block
      arr := 4 times 1;
      arr[-1] := 2;
      writeln(" ***** arr[-1] := 2; did not raise RANGE_ERROR");
      okay := FALSE;
    exception
      catch RANGE_ERROR:
        incr(number);
    end block;

    block
      arr := 4 times 1;
      arr[0] := 2;
      writeln(" ***** arr[0] := 2; did not raise RANGE_ERROR");
      okay := FALSE;
    exception
      catch RANGE_ERROR:
        incr(number);
    end block;

    block
      arr := 4 times 1;
      arr[1] := 2;
      incr(number);
    exception
      catch RANGE_ERROR:
        writeln(" ***** arr[1] := 2; did raise RANGE_ERROR");
        okay := FALSE;
    end block;

    block
      arr := 4 times 1;
      arr[4] := 2;
      incr(number);
    exception
      catch RANGE_ERROR:
        writeln(" ***** arr[4] := 2; did raise RANGE_ERROR");
        okay := FALSE;
    end block;

    block
      arr := 4 times 1;
      arr[5] := 2;
      writeln(" ***** arr[5] := 2; did not raise RANGE_ERROR");
      okay := FALSE;
    exception
      catch RANGE_ERROR:
        incr(number);
    end block;

    block
      arr := 4 times 1;
      arr[6] := 2;
      writeln(" ***** arr[6] := 2; did not raise RANGE_ERROR");
      okay := FALSE;
    exception
      catch RANGE_ERROR:
        incr(number);
    end block;

    block
      arr := 4 times 1;
      i_num := remove(arr, -1);
      writeln(" ***** remove(arr, -1); did not raise RANGE_ERROR");
      okay := FALSE;
    exception
      catch RANGE_ERROR:
        incr(number);
    end block;

    block
      arr := 4 times 1;
      i_num := remove(arr, 0);
      writeln(" ***** remove(arr, 0); did not raise RANGE_ERROR");
      okay := FALSE;
    exception
      catch RANGE_ERROR:
        incr(number);
    end block;

    block
      arr := 4 times 1;
      i_num := remove(arr, 1);
      incr(number);
    exception
      catch RANGE_ERROR:
        writeln(" ***** remove(arr, 1); did raise RANGE_ERROR");
        okay := FALSE;
    end block;

    block
      arr := 4 times 1;
      i_num := remove(arr, 4);
      incr(number);
    exception
      catch RANGE_ERROR:
        writeln(" ***** remove(arr, 4); did raise RANGE_ERROR");
        okay := FALSE;
    end block;

    block
      arr := 4 times 1;
      i_num := remove(arr, 5);
      writeln(" ***** remove(arr, 5); did not raise RANGE_ERROR");
      okay := FALSE;
    exception
      catch RANGE_ERROR:
        incr(number);
    end block;

    block
      arr := 4 times 1;
      i_num := remove(arr, 6);
      writeln(" ***** remove(arr, 6); did not raise RANGE_ERROR");
      okay := FALSE;
    exception
      catch RANGE_ERROR:
        incr(number);
    end block;

    block
      arr := -1 times 1;
      writeln(" ***** -1 times 1 did not raise RANGE_ERROR");
      okay := FALSE;
    exception
      catch RANGE_ERROR:
        incr(number);
    end block;

    if okay and number = 19 then
      writeln("Array exceptions work correct.");
    else
      writeln(" ***** Array exceptions do not work correct");
      writeln;
    end if;
  end func;


const proc: main is func
  local
    var string: stri is "";
    var boolean: bool is FALSE;
    var integer: number is 0;
    var reference: obj is NIL;
  begin
    # f4(6);
    writeln;
    check_integer;
    check_float;
    check_string;
    check_array;

    block
      obj := ref_list.EMPTY[0];
      writeln(" ***** ref_list.EMPTY[0] did not raise RANGE_ERROR");
    exception
      catch RANGE_ERROR: writeln("ref_list.EMPTY[0] raises RANGE_ERROR");
    end block;

    block
      obj := ref_list.EMPTY[1];
      writeln(" ***** ref_list.EMPTY[1] did not raise RANGE_ERROR");
    exception
      catch RANGE_ERROR: writeln("ref_list.EMPTY[1] raises RANGE_ERROR");
    end block;

    block
      ignore(action "asdf");
      writeln(" ***** action \"asdf\" did not raise RANGE_ERROR");
    exception
      catch RANGE_ERROR: writeln("action \"asdf\" raises RANGE_ERROR");
    end block;

    block
      seek(STD_IN, 0);
      writeln(" ***** seek(STD_IN, 0) did not raise RANGE_ERROR");
    exception
      catch RANGE_ERROR: writeln("seek(STD_IN, 0) raises RANGE_ERROR");
    end block;

    block
      stri := gets(STD_IN, -1);
      writeln(" ***** gets(STD_IN, -1) did not raise RANGE_ERROR");
    exception
      catch RANGE_ERROR: writeln("gets(STD_IN, -1) raises RANGE_ERROR");
    end block;

    block
      number := test_func(1 div 0);
      writeln(" ***** test_func(1 div 0) did not raise NUMERIC_ERROR");
    exception
      catch NUMERIC_ERROR: writeln("test_func(1 div 0) raises NUMERIC_ERROR");
      catch RANGE_ERROR:   writeln("test_func(1 div 0) raises RANGE_ERROR");
    end block;

    block
      bool := 1 div 0 = 0 and TRUE;
      writeln(" ***** 1 div 0 = 0 and TRUE did not raise NUMERIC_ERROR");
    exception
      catch NUMERIC_ERROR: writeln("1 div 0 = 0 and TRUE raises NUMERIC_ERROR");
      catch RANGE_ERROR:   writeln("1 div 0 = 0 and TRUE raises RANGE_ERROR");
    end block;

    block
      bool := 1 div 0 = 0 and FALSE;
      writeln(" ***** 1 div 0 = 0 and FALSE did not raise NUMERIC_ERROR");
    exception
      catch NUMERIC_ERROR: writeln("1 div 0 = 0 and FALSE raises NUMERIC_ERROR");
      catch RANGE_ERROR:   writeln("1 div 0 = 0 and FALSE raises RANGE_ERROR");
    end block;

    block
      bool := TRUE and 1 div 0 = 0;
      writeln(" ***** TRUE and 1 div 0 = 0 did not raise NUMERIC_ERROR");
    exception
      catch NUMERIC_ERROR: writeln("TRUE and 1 div 0 = 0 raises NUMERIC_ERROR");
      catch RANGE_ERROR:   writeln("TRUE and 1 div 0 = 0 raises RANGE_ERROR");
    end block;

    block
      bool := 1 div 0 = 0 or TRUE;
      writeln(" ***** 1 div 0 = 0 or TRUE did not raise NUMERIC_ERROR");
    exception
      catch NUMERIC_ERROR: writeln("1 div 0 = 0 or TRUE raises NUMERIC_ERROR");
      catch RANGE_ERROR:   writeln("1 div 0 = 0 or TRUE raises RANGE_ERROR");
    end block;

    block
      bool := 1 div 0 = 0 or FALSE;
      writeln(" ***** 1 div 0 = 0 or FALSE did not raise NUMERIC_ERROR");
    exception
      catch NUMERIC_ERROR: writeln("1 div 0 = 0 or FALSE raises NUMERIC_ERROR");
      catch RANGE_ERROR:   writeln("1 div 0 = 0 or FALSE raises RANGE_ERROR");
    end block;

    block
      bool := FALSE or 1 div 0 = 0;
      writeln(" ***** FALSE or 1 div 0 = 0 did not raise NUMERIC_ERROR");
    exception
      catch NUMERIC_ERROR: writeln("FALSE or 1 div 0 = 0 raises NUMERIC_ERROR");
      catch RANGE_ERROR:   writeln("FALSE or 1 div 0 = 0 raises RANGE_ERROR");
    end block;

    block
      if 1 div 0 = 0 then
        writeln(" ***** if 1 div 0 did not raise NUMERIC_ERROR");
      end if;
      writeln(" ***** if 1 div 0 did not raise NUMERIC_ERROR");
    exception
      catch NUMERIC_ERROR: writeln("if 1 div 0 raises NUMERIC_ERROR");
      catch RANGE_ERROR:   writeln("if 1 div 0 raises RANGE_ERROR");
    end block;

    block
      if TRUE then
        number := 1 div 0;
      end if;
      writeln(" ***** 1 div 0 in if then did not raise NUMERIC_ERROR");
    exception
      catch NUMERIC_ERROR: writeln("1 div 0 in if then raises NUMERIC_ERROR");
      catch RANGE_ERROR:   writeln("1 div 0 in if then raises RANGE_ERROR");
    end block;

    block
      if FALSE then
        noop;
      else
        number := 1 div 0;
      end if;
      writeln(" ***** 1 div 0 in if else did not raise NUMERIC_ERROR");
    exception
      catch NUMERIC_ERROR: writeln("1 div 0 in if else raises NUMERIC_ERROR");
      catch RANGE_ERROR:   writeln("1 div 0 in if else raises RANGE_ERROR");
    end block;

    block
      while 1 div 0 = 0 do
        writeln(" ***** while 1 div 0 did not raise NUMERIC_ERROR");
      end while;
      writeln(" ***** while 1 div 0 did not raise NUMERIC_ERROR");
    exception
      catch NUMERIC_ERROR: writeln("while 1 div 0 raises NUMERIC_ERROR");
      catch RANGE_ERROR:   writeln("while 1 div 0 raises RANGE_ERROR");
    end block;

    block
      while TRUE do
        number := 1 div 0;
      end while;
      writeln(" ***** 1 div 0 in while did not raise NUMERIC_ERROR");
    exception
      catch NUMERIC_ERROR: writeln("1 div 0 in while raises NUMERIC_ERROR");
      catch RANGE_ERROR:   writeln("1 div 0 in while raises RANGE_ERROR");
    end block;

    block
      repeat
        noop;
      until 1 div 0 = 0;
      writeln(" ***** repeat until 1 div 0 did not raise NUMERIC_ERROR");
    exception
      catch NUMERIC_ERROR: writeln("repeat until 1 div 0 raises NUMERIC_ERROR");
      catch RANGE_ERROR:   writeln("repeat until 1 div 0 raises RANGE_ERROR");
    end block;

    block
      repeat
        number := 1 div 0;
      until TRUE;
      writeln(" ***** 1 div 0 in repeat did not raise NUMERIC_ERROR");
    exception
      catch NUMERIC_ERROR: writeln("1 div 0 in repeat raises NUMERIC_ERROR");
      catch RANGE_ERROR:   writeln("1 div 0 in repeat raises RANGE_ERROR");
    end block;
  end func;
