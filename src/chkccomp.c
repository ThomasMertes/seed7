/********************************************************************/
/*                                                                  */
/*  chkccomp.c    Check properties of C compiler and runtime.       */
/*  Copyright (C) 2010 - 2016  Thomas Mertes                        */
/*                                                                  */
/*  This program is free software; you can redistribute it and/or   */
/*  modify it under the terms of the GNU General Public License as  */
/*  published by the Free Software Foundation; either version 2 of  */
/*  the License, or (at your option) any later version.             */
/*                                                                  */
/*  This program is distributed in the hope that it will be useful, */
/*  but WITHOUT ANY WARRANTY; without even the implied warranty of  */
/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   */
/*  GNU General Public License for more details.                    */
/*                                                                  */
/*  You should have received a copy of the GNU General Public       */
/*  License along with this program; if not, write to the           */
/*  Free Software Foundation, Inc., 51 Franklin Street,             */
/*  Fifth Floor, Boston, MA  02110-1301, USA.                       */
/*                                                                  */
/*  Module: Chkccomp                                                */
/*  File: seed7/src/chkccomp.c                                      */
/*  Changes: 2010 - 2015  Thomas Mertes                             */
/*  Content: Program to Check properties of C compiler and runtime. */
/*                                                                  */
/********************************************************************/

#include "version.h"

/**
 *  From version.h the following defines are used (for details see: read_me.txt):
 *
 *  os_off_t
 *      Type used for os_fseek(), os_ftell(), offsetSeek(), offsetTell()
 *      and seekFileLength().
 *  TURN_OFF_FP_EXCEPTIONS
 *      Use the function _control87() to turn off floating point exceptions.
 *  DEFINE_MATHERR_FUNCTION
 *      Define the function _matherr() which handles floating point errors.
 *  PATH_DELIMITER:
 *      Path delimiter character used by the command shell of the operating system.
 *  QUOTE_WHOLE_SHELL_COMMAND:
 *      Defined when shell commands, starting with " need to be quoted again.
 *  OBJECT_FILE_EXTENSION:
 *      The extension used by the C compiler for object files.
 *  EXECUTABLE_FILE_EXTENSION:
 *      The extension which is used by the operating system for executables.
 *  C_COMPILER:
 *      Contains the command to call the stand-alone C compiler and linker.
 *  CC_NO_OPT_OUTPUT_FILE:
 *      Defined, when compiling and linking with one command cannot use -o.
 *  CC_ERROR_FILDES:
 *      File descriptor to which the C compiler writes errors.
 *  LINKER_OPT_OUTPUT_FILE:
 *      Contains the linker option to provide the output filename (e.g.: "-o ").
 *  SYSTEM_LIBS:
 *      Contains system libraries for the stand-alone linker.
 */

#include "stdlib.h"
#include "string.h"
#include "stdio.h"
#include "stddef.h"
#include "time.h"
#include "ctype.h"
#include "float.h"
#include "math.h"
#include "sys/types.h"
#include "sys/stat.h"
#include "errno.h"

#include "config.h"

/**
 *  From config.h the following defines are used (for details see: read_me.txt):
 *
 *  MAP_ABSOLUTE_PATH_TO_DRIVE_LETTERS
 *      Map absolute paths to operating system paths with drive letter.
 */

#include "chkccomp.h"

/**
 *  The file chkccomp.h is NOT part of the Seed7 release.
 *  Instead chkccomp.h is generated by the makefile and
 *  removed after chkccomp was compiled and executed.
 *  In chkccomp.h the following macros might be defined:
 *
 *  rmdir
 *      Name of Posix function rmdir.
 *      E.g.: #define rmdir _rmdir
 *  WRITE_CC_VERSION_INFO
 *      Write the version of the C compiler to the file "cc_vers.txt".
 *      E.g.: #define WRITE_CC_VERSION_INFO system("$(GET_CC_VERSION_INFO) cc_vers.txt");
 *  LIST_DIRECTORY_CONTENTS
 *      Either "ls" or "dir".
 *      E.g.: #define LIST_DIRECTORY_CONTENTS "ls"
 *            #define LIST_DIRECTORY_CONTENTS "dir"
 *  The macros described above are only used in the program chkccomp.
 *  This macros are not used in the Seed7 Interpreter (s7) or in the
 *  Seed7 Runtime Library.
 */


#ifndef EXECUTABLE_FILE_EXTENSION
#define EXECUTABLE_FILE_EXTENSION ""
#endif

#ifndef S_ISREG
#define S_ISREG(mode) (((mode) & S_IFMT) == S_IFREG)
#endif

#ifndef S_ISDIR
#define S_ISDIR(mode) (((mode) & S_IFMT) == S_IFDIR)
#endif

#ifndef REDIRECT_FILDES_1
#define REDIRECT_FILDES_1 ">"
#endif

#ifndef REDIRECT_FILDES_2
#define REDIRECT_FILDES_2 "2>"
#endif

#define xstr(s) str(s)
#define str(s) #s

#define BUFFER_SIZE 4096

static int testNumber = 0;
static char c_compiler[1024];
static FILE *logFile;

static const char *int16TypeStri = NULL;
static const char *uint16TypeStri = NULL;
static const char *int32TypeStri = NULL;
static const char *uint32TypeStri = NULL;
static const char *int32TypeSuffix = "";
static const char *int32TypeFormat = NULL;
static const char *int64TypeStri = NULL;
static const char *uint64TypeStri = NULL;
static const char *int64TypeSuffix = "";
static const char *int64TypeFormat = NULL;
static const char *int128TypeStri = NULL;
static const char *uint128TypeStri = NULL;

static const char *makeDirDefinition = NULL;



#ifdef DEFINE_MATHERR_FUNCTION
int _matherr (struct _exception *a)

  { /* _matherr */
    a->retval = a->retval;
    return 1;
  } /* _matherr */
#endif



static void prepareCompileCommand (void)

  {
    int mapAbsolutePathToDriveLetters = 0;
    int pos;
    int quote_command = 0;
    int len;

  /* prepareCompileCommand */
#ifdef TEST_C_COMPILER
    strcpy(c_compiler, TEST_C_COMPILER);
#else
    strcpy(c_compiler, C_COMPILER);
#endif
#ifdef MAP_ABSOLUTE_PATH_TO_DRIVE_LETTERS
    mapAbsolutePathToDriveLetters = 1;
#else
    {
      char *searchPath;
      searchPath = getenv("PATH");
      if (searchPath != NULL &&
          isalpha(searchPath[0]) && searchPath[1] == ':') {
        mapAbsolutePathToDriveLetters = 1;
      } /* if */
    }
#endif
    if (mapAbsolutePathToDriveLetters) {
      if (c_compiler[0] == '/') {
        c_compiler[0] = c_compiler[1];
        c_compiler[1] = ':';
      } /* if */
    } /* if */
    for (pos = 0; c_compiler[pos] != '\0'; pos++) {
      if (c_compiler[pos] == '/') {
        c_compiler[pos] = PATH_DELIMITER;
      } else if (c_compiler[pos] == ' ') {
        quote_command = 1;
      } /* if */
    } /* for */
    if (quote_command) {
      len = strlen(c_compiler);
      memmove(&c_compiler[1], c_compiler, len);
      c_compiler[0] = '\"';
      c_compiler[len + 1] = '\"';
      c_compiler[len + 2] = '\0';
    } /* if */
  } /* prepareCompileCommand */



static int fileIsRegular (const char *fileName)

  {
    struct stat stat_buf;

  /* fileIsRegular */
    return stat(fileName, &stat_buf) == 0 && S_ISREG(stat_buf.st_mode);
  } /* fileIsRegular */



static int fileIsDir (const char *fileName)

  {
    struct stat stat_buf;

  /* fileIsDir */
    return stat(fileName, &stat_buf) == 0 && S_ISDIR(stat_buf.st_mode);
  } /* fileIsDir */



static void doRemove (const char *fileName)

  {

  /* doRemove */
    fprintf(logFile, "#");
    fflush(logFile);
    if (fileIsRegular(fileName)) {
      if (remove(fileName) != 0) {
#if defined OS_STRI_WCHAR && defined USE_WINSOCK
        /* This workaround is necessary for windows. */
        time_t start_time;
        char command[1024];

        sprintf(command, "DEL %s > nul 2>&1", fileName);
        start_time = time(NULL);
        while (time(NULL) < start_time + 20 &&
               fileIsRegular(fileName)) {
          if (remove(fileName) != 0) {
            system(command);
          } /* if */
        } /* while */
        if (fileIsRegular(fileName)) {
          fprintf(logFile, "\n *** Cannot remove %s\n", fileName);
        } /* if */
#else
        fprintf(logFile, "\n *** Cannot remove %s\n", fileName);
#endif
      } /* if */
    } /* if */
    fprintf(logFile, "\b");
    fflush(logFile);
  } /* doRemove */



static void cleanUpCompilation (int testNumber)

  {
    char fileName[1024];

  /* cleanUpCompilation */
    sprintf(fileName, "ctest%d.c", testNumber);
    doRemove(fileName);
    sprintf(fileName, "ctest%d.cerrs", testNumber);
    doRemove(fileName);
    sprintf(fileName, "ctest%d.lerrs", testNumber);
    doRemove(fileName);
    sprintf(fileName, "ctest%d%s", testNumber, OBJECT_FILE_EXTENSION);
    doRemove(fileName);
    sprintf(fileName, "ctest%d%s", testNumber, EXECUTABLE_FILE_EXTENSION);
    doRemove(fileName);
    sprintf(fileName, "ctest%d.out", testNumber);
    doRemove(fileName);
  } /* cleanUpCompilation */



static int doCompileAndLink (const char *options, const char *linkerOptions, int testNumber)

  {
    char command[1024];
    int len;
    char fileName[1024];
    int returncode;
    int okay = 0;

  /* doCompileAndLink */
    fprintf(logFile, "*");
    fflush(logFile);
#ifdef CC_FLAGS
    sprintf(command, "%s %s %s ctest%d.c %s",
            c_compiler, options, CC_FLAGS, testNumber, linkerOptions);
#else
    sprintf(command, "%s %s ctest%d.c %s",
            c_compiler, options, testNumber, linkerOptions);
#endif
#if !defined LINKER && defined LINKER_OPT_OUTPUT_FILE && !defined CC_NO_OPT_OUTPUT_FILE
    sprintf(&command[strlen(command)], " %sctest%d%s",
            LINKER_OPT_OUTPUT_FILE, testNumber, EXECUTABLE_FILE_EXTENSION);
#endif
#ifdef CC_ERROR_FILDES
    if (CC_ERROR_FILDES == 1) {
      sprintf(&command[strlen(command)], " %sctest%d.cerrs %s%s",
              REDIRECT_FILDES_1, testNumber, REDIRECT_FILDES_2, NULL_DEVICE);
    } else if (CC_ERROR_FILDES == 2) {
      sprintf(&command[strlen(command)], " %sctest%d.cerrs %s%s",
              REDIRECT_FILDES_2, testNumber, REDIRECT_FILDES_1, NULL_DEVICE);
    } /* if */
#endif
#ifdef QUOTE_WHOLE_SHELL_COMMAND
    if (command[0] == '\"') {
      len = strlen(command);
      memmove(&command[1], command, len);
      command[0] = '\"';
      command[len + 1] = '\"';
      command[len + 2] = '\0';
    } /* if */
#endif
    /* fprintf(logFile, "command: %s\n", command); */
    returncode = system(command);
#ifdef LINKER
    if (returncode == 0) {
      /* fprintf(logFile, "returncode: %d\n", returncode); */
      sprintf(command, "%s ctest%d%s %s %sctest%d%s",
              LINKER, testNumber, OBJECT_FILE_EXTENSION, linkerOptions,
              LINKER_OPT_OUTPUT_FILE, testNumber, EXECUTABLE_FILE_EXTENSION);
      returncode = system(command);
    } /* if */
#endif
    sprintf(fileName, "ctest%d%s", testNumber, EXECUTABLE_FILE_EXTENSION);
    if (fileIsRegular(fileName)) {
      if (returncode == 0) {
        okay = 1;
      } else {
        /* fprintf(logFile, "\n *** The compiler %s fails, but creates an executable.\n", c_compiler); */
      } /* if */
    } else {
      /* fprintf(logFile, "\n *** The compiler %s produces no executable: %s\n", c_compiler, fileName); */
    } /* if */
#ifdef DEBUG_CHKCCOMP
    fprintf(logFile, "command: %s\n", command);
    fprintf(logFile, "returncode: %d\n", returncode);
    if (returncode == -1) {
      fprintf(logFile, "errno: %d\nerror: %s\n", errno, strerror(errno));
    } /* if */
    fprintf(logFile, "okay: %d\n", okay);
#endif
    fprintf(logFile, "\b.");
    fflush(logFile);
    return okay;
  } /* doCompileAndLink */



static int compileAndLinkWithOptionsOk (const char *content, const char *options,
    const char *linkerOptions)

  {
    char fileName[1024];
    FILE *testFile;
    int okay = 0;

  /* compileAndLinkWithOptionsOk */
    /* fprintf(logFile, "compileAndLinkWithOptionsOk(%s)\n", content); */
    cleanUpCompilation(testNumber);
    testNumber++;
    cleanUpCompilation(testNumber);
    sprintf(fileName, "ctest%d.c", testNumber);
    testFile = fopen(fileName, "w");
    if (testFile != NULL) {
      fprintf(testFile, "%s", content);
      fclose(testFile);
      okay = doCompileAndLink(options, linkerOptions, testNumber);
    } /* if */
#ifdef DEBUG_CHKCCOMP
    fprintf(logFile, "content: %s\n", content);
#endif
    /* fprintf(logFile, "compileAndLinkWithOptionsOk --> %d\n", okay); */
    return okay;
  } /* compileAndLinkWithOptionsOk */



static void showErrors (void)

  {
    char fileName[1024];
    FILE *errorFile;
    int ch;

  /* showErrors */
    sprintf(fileName, "ctest%d.cerrs", testNumber);
    errorFile = fopen(fileName, "r");
    if (errorFile != NULL) {
      fprintf(logFile, "\nCompiler errors:\n");
      while ((ch = getc(errorFile)) != EOF) {
        fputc(ch, logFile);
      } /* while */
      fclose(errorFile);
      fprintf(logFile, "\n");
    } /* if */
    sprintf(fileName, "ctest%d.lerrs", testNumber);
    errorFile = fopen(fileName, "r");
    if (errorFile != NULL) {
      fprintf(logFile, "\nLinker errors:\n");
      while ((ch = getc(errorFile)) != EOF) {
        fputc(ch, logFile);
      } /* while */
      fclose(errorFile);
      fprintf(logFile, "\n");
    } /* if */
  } /* showErrors */



static int assertCompAndLnkWithOptions (const char *content, const char *options,
    const char *linkerOptions)

  {
    int okay;

  /* assertCompAndLnkWithOptions */
    okay = compileAndLinkWithOptionsOk(content, options, linkerOptions);
    if (!okay) {
      fprintf(logFile, "\n **** Compile and link failed for:\n%s\n", content);
      showErrors();
    } /* if */
    return okay;
  } /* assertCompAndLnkWithOptions */



static int compileAndLinkOk (const char *content)

  { /* compileAndLinkOk */
    return compileAndLinkWithOptionsOk(content, "", "");
  } /* compileAndLinkOk */



static int assertCompAndLnk (const char *content)

  {
    int okay;

  /* assertCompAndLnk */
    okay = compileAndLinkOk(content);
    if (!okay) {
      fprintf(logFile, "\n **** Compile and link failed for:\n%s\n", content);
      showErrors();
    } /* if */
    return okay;
  } /* assertCompAndLnk */



static int doTest (void)

  {
    char command[1024];
    char fileName[1024];
    int returncode;
    FILE *outFile;
    int result = -1;

  /* doTest */
    fprintf(logFile, "+");
    fflush(logFile);
#ifdef INTERPRETER_FOR_EXECUTABLE
    sprintf(command, "%s .%cctest%d%s>ctest%d.out",
            INTERPRETER_FOR_EXECUTABLE, PATH_DELIMITER, testNumber,
            EXECUTABLE_FILE_EXTENSION, testNumber);
#else
    sprintf(command, ".%cctest%d%s>ctest%d.out", PATH_DELIMITER,
            testNumber, EXECUTABLE_FILE_EXTENSION, testNumber);
#endif
    returncode = system(command);
    if (returncode != -1) {
      sprintf(fileName, "ctest%d.out", testNumber);
      outFile = fopen(fileName, "r");
      if (outFile != NULL) {
        fscanf(outFile, "%d", &result);
        fclose(outFile);
      } /* if */
    } /* if */
    fprintf(logFile, "\b");
    fflush(logFile);
    return result;
  } /* doTest */



static int expectTestResult (const char *content, int expected)

  {
    int testResult = -1;
    int okay = 0;

  /* expectTestResult */
    if (compileAndLinkOk(content)) {
      testResult = doTest();
      okay = testResult == expected;
    } else {
      fprintf(logFile, "\n *** Unable to compile test program:\n%s\n", content);
    } /* if */
    return okay;
  } /* expectTestResult */



static void testOutputToVersionFile (FILE *versionFile)

  {
    char command[1024];
    char fileName[1024];
    int returncode;
    FILE *outFile;
    int ch;

  /* testOutputToVersionFile */
    fprintf(logFile, ">");
    fflush(logFile);
#ifdef INTERPRETER_FOR_EXECUTABLE
    sprintf(command, "%s .%cctest%d%s>ctest%d.out",
            INTERPRETER_FOR_EXECUTABLE, PATH_DELIMITER, testNumber,
            EXECUTABLE_FILE_EXTENSION, testNumber);
#else
    sprintf(command, ".%cctest%d%s>ctest%d.out", PATH_DELIMITER,
            testNumber, EXECUTABLE_FILE_EXTENSION, testNumber);
#endif
    returncode = system(command);
    if (returncode != -1) {
      sprintf(fileName, "ctest%d.out", testNumber);
      outFile = fopen(fileName, "r");
      if (outFile != NULL) {
        while ((ch = getc(outFile)) != EOF) {
          putc(ch, versionFile);
        } /* while */
        fclose(outFile);
      } /* if */
    } /* if */
    fprintf(logFile, "\b");
    fflush(logFile);
  } /* testOutputToVersionFile */



static void checkSignal (FILE *versionFile)

  {
    int has_signal = 0;
    int has_sigaction = 0;

  /* checkSignal */
    if (compileAndLinkOk("#include <stdio.h>\n#include <signal.h>\n"
                         "volatile int res=4;\n"
                         "void handleSig1(int sig){res = 1;}\n"
                         "void handleSig2(int sig){res = 2;}\n"
                         "int main (int argc, char *argv[]){\n"
                         "if (signal(SIGINT, handleSig2) == SIG_ERR ||\n"
                         "signal(SIGINT, handleSig1) != handleSig2){\n"
                         "puts(\"3\");"
                         "}else if (raise(SIGINT) != 0){puts(\"5\");\n"
                         "}else{printf(\"%d\\n\",res);}\n"
                         "return 0;}\n") && doTest() == 1) {
      has_signal = 1;
    } /* if */
    fprintf(versionFile, "#define HAS_SIGNAL %d\n", has_signal);
    if (compileAndLinkOk("#include <stdio.h>\n#include <signal.h>\n"
                         "volatile int res=4;\n"
                         "void handleSig(int sig){res=1;}\n"
                         "int main(int argc, char *argv[]){\n"
                         "struct sigaction sig_act;\n"
                         "sig_act.sa_handler = handleSig;\n"
                         "sigemptyset(&sig_act.sa_mask);\n"
                         "sig_act.sa_flags = SA_RESTART;\n"
                         "if (sigaction(SIGINT, &sig_act, NULL) == -1){\n"
                         "puts(\"3\");"
                         "}else if (raise(SIGINT) != 0){puts(\"5\");\n"
                         "}else{printf(\"%d\\n\",res);}\n"
                         "return 0;}\n") && doTest() == 1) {
      has_sigaction = 1;
    } /* if */
    fprintf(versionFile, "#define HAS_SIGACTION %d\n", has_sigaction);
  } /* checkSignal */



static void writeMacroDefs (FILE *versionFile)

  {
    char macroDefs[BUFFER_SIZE];

  /* writeMacroDefs */
    if (compileAndLinkOk("static inline int test(int a){return 2*a;}\n"
                         "int main(int argc,char *argv[]){return test(argc);}\n")) {
      /* The C compiler accepts the definition of inline functions. */
    } else if (compileAndLinkOk("static __inline int test(int a){return 2*a;}\n"
                                "int main(int argc,char *argv[]){return test(argc);}\n")) {
      fputs("#define inline __inline\n", versionFile);
    } else if (compileAndLinkOk("static __inline__ int test(int a){return 2*a;}\n"
                                "int main(int argc,char *argv[]){return test(argc);}\n")) {
      fputs("#define inline __inline__\n", versionFile);
    } else {
      fputs("#define inline\n", versionFile);
    } /* if */
    if (!compileAndLinkOk("int test (int *restrict ptrA, int *restrict ptrB, int *restrict ptrC)\n"
                          "{*ptrA += *ptrC; *ptrB += *ptrC; return *ptrA + *ptrB;}\n"
                          "int main(int argc,char *argv[])\n"
                          "{int a=1, b=2, c=3; return test(&a, &b, &c);}\n")) {
      fputs("#define restrict\n", versionFile);
    } /* if */
    macroDefs[0] = '\0';
    if (compileAndLinkOk("#include <stdio.h>\nint main(int argc,char *argv[])\n"
                         "{if(__builtin_expect(1,1))puts(\"1\");else puts(\"0\");\n"
                         "return 0;}\n") && doTest() == 1) {
      fputs("#define likely(x)   __builtin_expect((x),1)\n", versionFile);
      fputs("#define unlikely(x) __builtin_expect((x),0)\n", versionFile);
      strcat(macroDefs, "#define likely(x)   __builtin_expect((x),1)\\n");
      strcat(macroDefs, "#define unlikely(x) __builtin_expect((x),0)\\n");
    } else {
      strcat(macroDefs, "#define likely(x) (x)\\n");
      strcat(macroDefs, "#define unlikely(x) (x)\\n");
    } /* if */
    if (compileAndLinkOk("#include <stdlib.h>\n"
                         "void fatal (void) __attribute__ ((noreturn));\n"
                         "void fatal (void) {exit(1);}\n"
                         "int main(int argc,char *argv[])\n"
                         "{return 0;}\n")) {
      fputs("#define NORETURN __attribute__ ((noreturn))\n", versionFile);
      strcat(macroDefs, "#define NORETURN __attribute__ ((noreturn))\\n");
    } else {
      strcat(macroDefs, "#define NORETURN\\n");
    } /* if */
    fprintf(versionFile, "#define MACRO_DEFS \"%s\"\n", macroDefs);
  } /* writeMacroDefs */



static void checkPopen (FILE *versionFile)

  {
    char *popen = NULL;
    int binary_mode_supported;
    char *binary_mode = "";
    char buffer[BUFFER_SIZE];
    char fileName[1024];

  /* checkPopen */
    if (compileAndLinkOk("#include <stdio.h>\nint main(int argc, char *argv[])\n"
                         "{FILE *aFile; aFile=popen(\""
                         LIST_DIRECTORY_CONTENTS
                         "\", \"r\");\n"
                         "printf(\"%d\\n\", aFile != NULL); return 0;}\n") && doTest() == 1) {
      popen = "popen";
    } else if (compileAndLinkOk("#include <stdio.h>\nint main(int argc, char *argv[])\n"
                                "{FILE *aFile; aFile=_popen(\""
                                LIST_DIRECTORY_CONTENTS
                                "\", \"r\");\n"
                                "printf(\"%d\\n\", aFile != NULL); return 0;}\n") && doTest() == 1) {
      popen = "_popen";
    } /* if */
    fprintf(versionFile, "#define HAS_POPEN %d\n", popen != NULL);
    if (popen != NULL) {
      sprintf(buffer, "#include <stdio.h>\n"
                      "int main(int argc, char *argv[])\n"
                      "{FILE *aFile; aFile=%s(\""
                      LIST_DIRECTORY_CONTENTS
                      "\", \"rb\");\n"
                      "printf(\"%%d\\n\", aFile != NULL); return 0;}\n", popen);
      if (assertCompAndLnk(buffer)) {
        binary_mode_supported = doTest() == 1;
        fprintf(versionFile, "#define POPEN_SUPPORTS_BINARY_MODE %d\n", binary_mode_supported);
        if (binary_mode_supported) {
          binary_mode = "b";
        } /* if */
      } /* if */
      sprintf(buffer, "#include <stdio.h>\n"
                      "int main(int argc, char *argv[])\n"
                      "{FILE *aFile; aFile=%s(\""
                      LIST_DIRECTORY_CONTENTS
                      "\", \"rt\");\n"
                      "printf(\"%%d\\n\", aFile != NULL); return 0;}\n", popen);
      if (assertCompAndLnk(buffer)) {
        fprintf(versionFile, "#define POPEN_SUPPORTS_TEXT_MODE %d\n", doTest() == 1);
      } /* if */
      sprintf(buffer, "#include <stdio.h>\n#include <windows.h>\n"
                      "int main(int argc, char *argv[])\n"
                      "{FILE *aFile;\n"
                      "SetErrorMode(SEM_NOGPFAULTERRORBOX);\n"
                      "aFile=%s(\""
                      LIST_DIRECTORY_CONTENTS
                      "\", \"re\");\n"
                      "printf(\"%%d\\n\", aFile != NULL); return 0;}\n", popen);
      if (compileAndLinkOk(buffer)) {
        fprintf(versionFile, "#define POPEN_SUPPORTS_CLOEXEC_MODE %d\n", doTest() == 1);
      } else {
        sprintf(buffer, "#include <stdio.h>\n"
                        "int main(int argc, char *argv[])\n"
                        "{FILE *aFile; aFile=%s(\""
                        LIST_DIRECTORY_CONTENTS
                        "\", \"re\");\n"
                        "printf(\"%%d\\n\", aFile != NULL); return 0;}\n", popen);
        if (assertCompAndLnk(buffer)) {
          fprintf(versionFile, "#define POPEN_SUPPORTS_CLOEXEC_MODE %d\n", doTest() == 1);
        } /* if */
      } /* if */
      sprintf(buffer, "#include <stdio.h>\nint main(int argc, char *argv[])\n"
                      "{FILE *aFile; aFile=%s(\""
                      LIST_DIRECTORY_CONTENTS
                      "\", \"r\");\n"
                      "printf(\"%%d\\n\", ftell(aFile) != -1); return 0;}\n", popen);
      if (assertCompAndLnk(buffer)) {
        fprintf(versionFile, "#define FTELL_SUCCEEDS_FOR_PIPE %d\n", doTest() == 1);
      } /* if */
      if (compileAndLinkOk("#include <stdio.h>\n"
                           "int main(int argc, char *argv[])\n"
                           "{printf(\"x\\n\"); return 0;}\n")) {
        sprintf(fileName, "ctest%d%s", testNumber, EXECUTABLE_FILE_EXTENSION);
        if (rename(fileName, "ctest_a" EXECUTABLE_FILE_EXTENSION) == 0) {
          sprintf(buffer, "#include <stdio.h>\n#include <string.h>\n"
                          "int main(int argc, char *argv[])\n"
                          "{char buffer[5]; FILE *aFile; aFile=%s(\""
                          ".%s%cctest_a%s"
                          "\", \"r%s\");\n"
                          "if (aFile != NULL && fgets(buffer, 4, aFile) != NULL)\n"
                          "printf(\"%%d\\n\", memcmp(buffer, \"x\\r\\n\", 3) == 0);\n"
                          "else printf(\"0\\n\"); return 0;}\n",
                          popen, PATH_DELIMITER == '\\' ? "\\" : "", PATH_DELIMITER,
                          EXECUTABLE_FILE_EXTENSION, binary_mode);
          if (assertCompAndLnk(buffer)) {
            fprintf(versionFile, "#define STDOUT_IS_IN_TEXT_MODE %d\n", doTest() == 1);
          } /* if */
          doRemove("ctest_a" EXECUTABLE_FILE_EXTENSION);
        } /* if */
      } /* if */
    } /* if */
  } /* checkPopen */



static void checkMoveDirectory (const char *makeDirDefinition, FILE *versionFile)

  {
    char buffer[BUFFER_SIZE];
    FILE *aFile;
    char line[128];
    int okay = 1;

  /* checkMoveDirectory */
      sprintf(buffer, "#include <stdio.h>\n%s"
                      "int main(int argc, char *argv[])\n"
                      "{FILE *aFile;\n"
                      "makeDir(\"test_dir1\", 0755);\n"
                      "makeDir(\"test_dir1/subdir1\", 0755);\n"
                      "aFile = fopen(\"test_dir1/subdir1/subfile\", \"w\");\n"
                      "if (aFile != NULL) {\n"
                      "  fprintf(aFile, \"File content\\n\");\n"
                      "  fclose(aFile);\n"
                      "}\n"
                      "makeDir(\"test_dir2\", 0755);\n"
                      "return 1;}\n",
                      makeDirDefinition);
    if (assertCompAndLnk(buffer) && doTest() == 1) {
      if (rename("test_dir1/subdir1", "test_dir2/subdir2") != 0) {
        okay = 0;
      } /* if */
      if (fileIsDir("test_dir1/subdir1")) {
        okay = 0;
        if (fileIsRegular("test_dir1/subdir1/subfile")) {
          remove("test_dir1/subdir1/subfile");
        } /* if */
        rmdir("test_dir1/subdir1");
      } /* if */
      if (fileIsDir("test_dir2/subdir2")) {
        if (fileIsRegular("test_dir2/subdir2/subfile")) {
          aFile = fopen("test_dir2/subdir2/subfile", "r");
          if (aFile == NULL) {
            okay = 0;
          } else {
            if (fread(line, 1, 13, aFile) != 13 ||
                memcmp(line, "File content\n", 13) != 0) {
              okay = 0;
            } /* if */
            fclose(aFile);
          } /* if */
          remove("test_dir2/subdir2/subfile");
        } else {
          okay = 0;
        } /* if */
        rmdir("test_dir2/subdir2");
      } else {
        okay = 0;
      } /* if */
      rmdir("test_dir1");
      rmdir("test_dir2");
      if (!okay) {
        fputs("#define MOVE_DIR_WITH_RENAME_FAILS\n", versionFile);
      } /* if */
    } /* if */
  } /* checkMoveDirectory */



static int getSizeof (const char *typeName)

  {
    char buffer[BUFFER_SIZE];
    int computedSize = -1;

  /* getSizeof */
    /* fprintf(logFile, "getSizeof(%s)\n", typeName); */
    sprintf(buffer, "#include <stdio.h>\n"
                    "#include <stddef.h>\n"
                    "#include <time.h>\n"
                    "#include <sys/types.h>\n"
                    "#include \"tst_vers.h\"\n"
                    "int main(int argc, char *argv[])"
                    "{printf(\"%%d\\n\",(int)sizeof(%s));return 0;}\n",
                    typeName);
    if (compileAndLinkOk(buffer)) {
      computedSize = doTest();
      if (computedSize == -1) {
        fprintf(logFile, "\n *** Unable to determine sizeof(%s).\n", typeName);
      } /* if */
    } /* if */
    return computedSize;
  } /* getSizeof */



static int isSignedType (const char *typeName)

  {
    char buffer[BUFFER_SIZE];
    int isSigned = -1;

  /* isSignedType */
    /* fprintf(logFile, "isSignedType(%s)\n", typeName); */
    sprintf(buffer, "#include <stdio.h>\n"
                    "#include <stddef.h>\n"
                    "#include <time.h>\n"
                    "#include \"tst_vers.h\"\n"
                    "int main(int argc, char *argv[])"
                    "{printf(\"%%d\\n\",(%s)-1<0);return 0;}\n",
                    typeName);
    if (compileAndLinkOk(buffer)) {
      isSigned = doTest();
    } /* if */
    if (isSigned == -1) {
      fprintf(logFile, "\n *** Unable to determine if %s is signed.\n", typeName);
    } /* if */
    return isSigned == 1;
  } /* isSignedType */



static void numericSizes (FILE *versionFile)

  {
    int char_bit;
    int sizeof_char;
    int sizeof_short;
    int sizeof_int;
    int sizeof_long;
    int sizeof_long_long;

  /* numericSizes */
    fprintf(logFile, "Numeric sizes: ");
    fflush(stdout);
    if (compileAndLinkOk("#include <stdio.h>\n#include <limits.h>\n"
                         "int main(int argc, char *argv[])"
                         "{printf(\"%d\\n\",CHAR_BIT);return 0;}\n")) {
      char_bit = doTest();
    } else {
      fputs("#define CHAR_BIT 8\n", versionFile);
      char_bit = 8;
    } /* if */
    sizeof_char      = getSizeof("char");
    sizeof_short     = getSizeof("short");
    sizeof_int       = getSizeof("int");
    sizeof_long      = getSizeof("long");
    sizeof_long_long = getSizeof("long long");
    fprintf(versionFile, "#define CHAR_SIZE %d\n",        char_bit * sizeof_char);
    fprintf(versionFile, "#define SHORT_SIZE %d\n",       char_bit * sizeof_short);
    fprintf(versionFile, "#define INT_SIZE %d\n",         char_bit * sizeof_int);
    fprintf(versionFile, "#define LONG_SIZE %d\n",        char_bit * sizeof_long);
    if (sizeof_long_long != -1) {
      fprintf(versionFile, "#define LONG_LONG_SIZE %d\n", char_bit * sizeof_long_long);
    } /* if */
    fprintf(versionFile, "#define POINTER_SIZE %d\n",     char_bit * getSizeof("char *"));
    fprintf(versionFile, "#define FLOAT_SIZE %d\n",       char_bit * getSizeof("float"));
    fprintf(versionFile, "#define DOUBLE_SIZE %d\n",      char_bit * getSizeof("double"));
    fprintf(versionFile, "#define WCHAR_T_SIZE %d\n",     char_bit * getSizeof("wchar_t"));
    fprintf(versionFile, "#define OS_OFF_T_SIZE %d\n",    char_bit * getSizeof("os_off_t"));
    fprintf(versionFile, "#define TIME_T_SIZE %d\n",      char_bit * getSizeof("time_t"));
    fprintf(versionFile, "#define TIME_T_SIGNED %d\n", isSignedType("time_t"));
    fprintf(versionFile, "#define SIZE_T_SIGNED %d\n", isSignedType("size_t"));
    fprintf(versionFile, "#define CHAR_SIGNED %d\n",   isSignedType("char"));
    if (compileAndLinkOk("#include <stdio.h>\nint main(int argc, char *argv[])"
                         "{_Bool flag = 1;return 0;}\n")) {
      fputs("#define BOOLTYPE _Bool\n", versionFile);
      fputs("#define BOOLTYPE_STRI \"_Bool\"\n", versionFile);
    } else if (compileAndLinkOk("#include <stdio.h>\nint main(int argc, char *argv[])"
                         "{bool flag = 1;return 0;}\n")) {
      fputs("#define BOOLTYPE bool\n", versionFile);
      fputs("#define BOOLTYPE_STRI \"bool\"\n", versionFile);
    } else {
      fputs("#define BOOLTYPE int\n", versionFile);
      fputs("#define BOOLTYPE_STRI \"int\"\n", versionFile);
    } /* if */
    if (sizeof_char == 1) {
      fputs("#define INT8TYPE signed char\n", versionFile);
      fputs("#define INT8TYPE_STRI \"signed char\"\n", versionFile);
      fputs("#define UINT8TYPE unsigned char\n", versionFile);
      fputs("#define UINT8TYPE_STRI \"unsigned char\"\n", versionFile);
    } /* if */
    if (sizeof_short == 2) {
      int16TypeStri = "short int";
      uint16TypeStri = "unsigned short int";
    } else if (sizeof_int == 2) {
      int16TypeStri = "int";
      uint16TypeStri = "unsigned int";
    } /* if */
    if (int16TypeStri != NULL) {
      fprintf(versionFile, "#define INT16TYPE %s\n", int16TypeStri);
      fprintf(versionFile, "#define INT16TYPE_STRI \"%s\"\n", int16TypeStri);
      fprintf(versionFile, "#define UINT16TYPE %s\n", uint16TypeStri);
      fprintf(versionFile, "#define UINT16TYPE_STRI \"%s\"\n", uint16TypeStri);
    } /* if */
    if (sizeof_int == 4) {
      int32TypeStri = "int";
      uint32TypeStri = "unsigned int";
      int32TypeSuffix = "";
      int32TypeFormat = "";
    } else if (sizeof_long == 4) {
      int32TypeStri = "long";
      uint32TypeStri = "unsigned long";
      int32TypeSuffix = "L";
      int32TypeFormat = "l";
    } /* if */
    if (int32TypeStri != NULL) {
      fprintf(versionFile, "#define INT32TYPE %s\n", int32TypeStri);
      fprintf(versionFile, "#define INT32TYPE_STRI \"%s\"\n", int32TypeStri);
      fprintf(versionFile, "#define UINT32TYPE %s\n", uint32TypeStri);
      fprintf(versionFile, "#define UINT32TYPE_STRI \"%s\"\n", uint32TypeStri);
      if (int32TypeSuffix[0] == '\0') {
        fprintf(versionFile, "#define INT32_SUFFIX(num) num\n");
      } else {
        fprintf(versionFile, "#define INT32_SUFFIX(num) num ## %s\n", int32TypeSuffix);
      } /* if */
      fprintf(versionFile, "#define UINT32_SUFFIX(num) num ## U%s\n", int32TypeSuffix);
      fprintf(versionFile, "#define INT32TYPE_LITERAL_SUFFIX \"%s\"\n", int32TypeSuffix);
      fprintf(versionFile, "#define INT32TYPE_FORMAT \"%s\"\n", int32TypeFormat);
    } /* if */
    if (sizeof_long == 8) {
      int64TypeStri = "long";
      uint64TypeStri = "unsigned long";
      if (expectTestResult("#include <stdio.h>\nint main(int argc, char *argv[])"
                           "{long n=12345678L;printf(\"%d\\n\",(int)sizeof(1L));return 0;}\n", 8)) {
        int64TypeSuffix = "L";
      } /* if */
      int64TypeFormat = "l";
    } else if (sizeof_long_long == 8) {
      /* The type long long is defined and it is a 64-bit type */
      int64TypeStri = "long long";
      uint64TypeStri = "unsigned long long";
      if (compileAndLinkOk("#include <stdio.h>\nint main(int argc, char *argv[])"
                           "{long long n=12345678LL;printf(\"%d\\n\",sizeof(1LL));\n"
                           "return 0;}\n") && doTest() == 8) {
        int64TypeSuffix = "LL";
      } /* if */
      if (compileAndLinkOk("#include <stdio.h>\n#include <string.h>\n"
                           "int main(int argc, char *argv[])\n"
                           "{char b[99]; sprintf(b, \"A%lldB\", (long long) 1 << 32);\n"
                           "printf(\"%d\\n\", strcmp(b,\"A4294967296B\")==0);\n"
                           "return 0;}\n") && doTest() == 1) {
        int64TypeFormat = "ll";
      } else if (compileAndLinkOk("#include <stdio.h>\n#include <string.h>\n"
                                  "int main(int argc, char *argv[])\n"
                                  "{char b[99]; sprintf(b, \"A%LdB\", (long long) 1 << 32);\n"
                                  "printf(\"%d\\n\", strcmp(b,\"A4294967296B\")==0);\n"
                                  "return 0;}\n") && doTest() == 1) {
        int64TypeFormat = "L";
      } else if (compileAndLinkOk("#include <stdio.h>\n#include <string.h>\n"
                                  "int main(int argc, char *argv[])\n"
                                  "{char b[99]; sprintf(b, \"A%I64dB\", (long long) 1 << 32);\n"
                                  "printf(\"%d\\n\", strcmp(b,\"A4294967296B\")==0);\n"
                                  "return 0;}\n") && doTest() == 1) {
        int64TypeFormat = "I64";
      } /* if */
    } else if (getSizeof("__int64") == 8) {
      /* The type __int64 is defined and it is a 64-bit type */
      int64TypeStri = "__int64";
      uint64TypeStri = "unsigned __int64";
      if (compileAndLinkOk("#include <stdio.h>\nint main(int argc, char *argv[])"
                           "{__int64 n=12345678LL;printf(\"%d\\n\",sizeof(1LL));\n"
                           "return 0;}\n") && doTest() == 8) {
        int64TypeSuffix = "LL";
      } /* if */
      if (compileAndLinkOk("#include <stdio.h>\n#include <string.h>\n"
                           "int main(int argc, char *argv[])\n"
                           "{char b[99]; sprintf(b, \"A%lldB\", (__int64) 1 << 32);\n"
                           "printf(\"%d\\n\", strcmp(b,\"A4294967296B\")==0);\n"
                           "return 0;}\n") && doTest() == 1) {
        int64TypeFormat = "ll";
      } else if (compileAndLinkOk("#include <stdio.h>\n#include <string.h>\n"
                                  "int main(int argc, char *argv[])\n"
                                  "{char b[99]; sprintf(b, \"A%LdB\", (__int64) 1 << 32);\n"
                                  "printf(\"%d\\n\", strcmp(b,\"A4294967296B\")==0);\n"
                                  "return 0;}\n") && doTest() == 1) {
        int64TypeFormat = "L";
      } else if (compileAndLinkOk("#include <stdio.h>\n#include <string.h>\n"
                                  "int main(int argc, char *argv[])\n"
                                  "{char b[99]; sprintf(b, \"A%I64dB\", (__int64) 1 << 32);\n"
                                  "printf(\"%d\\n\", strcmp(b,\"A4294967296B\")==0);\n"
                                  "return 0;}\n") && doTest() == 1) {
        int64TypeFormat = "I64";
      } /* if */
    } /* if */
    if (int64TypeStri != NULL) {
      fprintf(versionFile, "#define INT64TYPE %s\n", int64TypeStri);
      fprintf(versionFile, "#define INT64TYPE_STRI \"%s\"\n", int64TypeStri);
      fprintf(versionFile, "#define UINT64TYPE %s\n", uint64TypeStri);
      fprintf(versionFile, "#define UINT64TYPE_STRI \"%s\"\n", uint64TypeStri);
#ifdef INT64TYPE_NO_SUFFIX_BUT_CAST
      fprintf(versionFile, "#define INT64_SUFFIX(num)  ((int64Type) num)\n");
      fprintf(versionFile, "#define UINT64_SUFFIX(num) ((uint64Type) num ## U)\n");
      fprintf(versionFile, "#define INT64TYPE_LITERAL_SUFFIX \"\"\n");
#else
      if (int64TypeSuffix[0] == '\0') {
        fprintf(versionFile, "#define INT64_SUFFIX(num) ((%s) num)\n", int64TypeStri);
      } else {
        fprintf(versionFile, "#define INT64_SUFFIX(num) num ## %s\n", int64TypeSuffix);
      } /* if */
      fprintf(versionFile, "#define UINT64_SUFFIX(num) num ## U%s\n", int64TypeSuffix);
      fprintf(versionFile, "#define INT64TYPE_LITERAL_SUFFIX \"%s\"\n", int64TypeSuffix);
#endif
      fprintf(versionFile, "#define INT64TYPE_FORMAT \"%s\"\n", int64TypeFormat);
    } /* if */
    if (compileAndLinkOk("#include <stdio.h>\n#include <time.h>\n"
                         "int main(int argc, char *argv[])\n"
                         "{__int128 a = (__int128) time(NULL) * (__int128) clock();\n"
                         "if (sizeof(__int128)==sizeof(unsigned __int128))\n"
                         "printf(\"%d\\n\",sizeof(__int128));\n"
                         "else printf(\"0\\n\");return 0;}\n") && doTest() == 16) {
      /* The type __int128 is defined and it is a 128-bit type */
      int128TypeStri = "__int128";
      uint128TypeStri = "unsigned __int128";
    } else if (compileAndLinkOk("#include <stdio.h>\n#include <time.h>\n"
                                "int main(int argc, char *argv[])\n"
                                "{__int128 a = (__int128) time(NULL) * (__int128) clock();\n"
                                "if (sizeof(__int128_t)==sizeof(__uint128_t))\n"
                                "printf(\"%d\\n\",sizeof(__int128_t));\n"
                                "else printf(\"0\\n\");return 0;}\n") && doTest() == 16) {
      /* The type __int128_t is defined and it is a 128-bit type */
      int128TypeStri = "__int128_t";
      uint128TypeStri = "__uint128_t";
    } /* if */
    if (int128TypeStri != NULL && uint128TypeStri != NULL) {
      fprintf(versionFile, "#define INT128TYPE %s\n", int128TypeStri);
      fprintf(versionFile, "#define INT128TYPE_STRI \"%s\"\n", int128TypeStri);
      fprintf(versionFile, "#define UINT128TYPE %s\n", uint128TypeStri);
      fprintf(versionFile, "#define UINT128TYPE_STRI \"%s\"\n", uint128TypeStri);
    } /* if */
    fprintf(logFile, " determined\n");
  } /* numericSizes */



static void checkIntDivisions (FILE *versionFile)

  {
    int check_int_div_by_zero;
    int check_int_rem_by_zero;
    int check_int_rem_zero_by_zero;

  /* checkIntDivisions */
#ifdef INT_DIV_BY_ZERO_POPUP
    check_int_div_by_zero = 1;
    check_int_rem_by_zero = 1;
    check_int_rem_zero_by_zero = 1;
#else
    check_int_div_by_zero =
        !compileAndLinkOk("#include<stdio.h>\n"
                          "int main(int argc,char *argv[]){"
                          "printf(\"%d\\n\", 1/0);return 0;}\n") ||
        !compileAndLinkOk("#include<stdlib.h>\n#include<stdio.h>\n#include<signal.h>\n"
                          "void handleSigfpe(int sig){puts(\"2\");exit(0);}\n"
                          "void handleSigill(int sig){puts(\"3\");exit(0);}\n"
                          "int main(int argc,char *argv[]){\n"
                          "signal(SIGFPE,handleSigfpe);\n"
                          "signal(SIGILL,handleSigill);\n"
                          "printf(\"%d\\n\",1/0==0);return 0;}\n") || doTest() != 2 ||
        !compileAndLinkOk("#include<stdlib.h>\n#include<stdio.h>\n#include<signal.h>\n"
                          "void handleSigfpe(int sig){puts(\"2\");exit(0);}\n"
                          "void handleSigill(int sig){puts(\"3\");exit(0);}\n"
                           "int main(int argc,char *argv[]){\n"
                          "int zero=0;\n"
                          "signal(SIGFPE,handleSigfpe);\n"
                          "signal(SIGILL,handleSigill);\n"
                          "printf(\"%d\\n\",1/zero==0);return 0;}\n") || doTest() != 2 ||
        !compileAndLinkOk("#include<stdlib.h>\n#include<stdio.h>\n#include<signal.h>\n"
                          "void handleSigfpe(int sig){puts(\"2\");exit(0);}\n"
                          "void handleSigill(int sig){puts(\"3\");exit(0);}\n"
                           "int main(int argc,char *argv[]){\n"
                          "signal(SIGFPE,handleSigfpe);\n"
                          "signal(SIGILL,handleSigill);\n"
                          "printf(\"%d\\n\",0/0==0);return 0;}\n") || doTest() != 2 ||
        !compileAndLinkOk("#include<stdlib.h>\n#include<stdio.h>\n#include<signal.h>\n"
                          "void handleSigfpe(int sig){puts(\"2\");exit(0);}\n"
                          "void handleSigill(int sig){puts(\"3\");exit(0);}\n"
                           "int main(int argc,char *argv[]){\n"
                          "int zero=0;\n"
                          "signal(SIGFPE,handleSigfpe);\n"
                          "signal(SIGILL,handleSigill);\n"
                          "printf(\"%d\\n\",0/zero==0);return 0;}\n") || doTest() != 2;
    if (!check_int_div_by_zero) {
#ifndef DO_SIGFPE_WITH_DIV_BY_ZERO
      fputs("#define DO_SIGFPE_WITH_DIV_BY_ZERO\n", versionFile);
#endif
    } /* if */
    check_int_rem_by_zero = check_int_div_by_zero | (
        !compileAndLinkOk("#include<stdio.h>\n"
                          "int main(int argc,char *argv[]){"
                          "printf(\"%d\\n\", 1%0);return 0;}\n") ||
        !compileAndLinkOk("#include<stdlib.h>\n#include<stdio.h>\n#include<signal.h>\n"
                          "void handleSigfpe(int sig){puts(\"2\");exit(0);}\n"
                          "void handleSigill(int sig){puts(\"3\");exit(0);}\n"
                          "int main(int argc,char *argv[]){\n"
                          "int zero=0;\n"
                          "signal(SIGFPE,handleSigfpe);\n"
                          "signal(SIGILL,handleSigill);\n"
                          "printf(\"%d\\n\",1%zero==0);return 0;}\n") || doTest() != 2 ||
        !compileAndLinkOk("#include<stdlib.h>\n#include<stdio.h>\n#include<signal.h>\n"
                          "void handleSigfpe(int sig){puts(\"2\");exit(0);}\n"
                          "void handleSigill(int sig){puts(\"3\");exit(0);}\n"
                           "int main(int argc,char *argv[]){\n"
                          "int one=0, zero=0;\n"
                          "signal(SIGFPE,handleSigfpe);\n"
                          "signal(SIGILL,handleSigill);\n"
                          "printf(\"%d\\n\",one%zero==0);return 0;}\n") || doTest() != 2 ||
        !compileAndLinkOk("#include<stdlib.h>\n#include<stdio.h>\n#include<signal.h>\n"
                          "void handleSigfpe(int sig){puts(\"2\");exit(0);}\n"
                          "void handleSigill(int sig){puts(\"3\");exit(0);}\n"
                           "int main(int argc,char *argv[]){\n"
                          "int zero1=0, zero2=0;\n"
                          "signal(SIGFPE,handleSigfpe);\n"
                          "signal(SIGILL,handleSigill);\n"
                          "printf(\"%d\\n\",zero1%zero2==0);return 0;}\n") || doTest() != 2);
    check_int_rem_zero_by_zero =
        !compileAndLinkOk("#include<stdlib.h>\n#include<stdio.h>\n#include<signal.h>\n"
                          "void handleSigfpe(int sig){puts(\"2\");exit(0);}\n"
                          "void handleSigill(int sig){puts(\"3\");exit(0);}\n"
                           "int main(int argc,char *argv[]){\n"
                          "signal(SIGFPE,handleSigfpe);\n"
                          "signal(SIGILL,handleSigill);\n"
                          "printf(\"%d\\n\",0%0==0);return 0;}\n") || doTest() != 2 ||
        !compileAndLinkOk("#include<stdlib.h>\n#include<stdio.h>\n#include<signal.h>\n"
                          "void handleSigfpe(int sig){puts(\"2\");exit(0);}\n"
                          "void handleSigill(int sig){puts(\"3\");exit(0);}\n"
                           "int main(int argc,char *argv[]){\n"
                          "int zero=0;\n"
                          "signal(SIGFPE,handleSigfpe);\n"
                          "signal(SIGILL,handleSigill);\n"
                          "printf(\"%d\\n\",0%zero==0);return 0;}\n") || doTest() != 2;
#endif
    fprintf(versionFile, "#define CHECK_INT_DIV_BY_ZERO %d\n", check_int_div_by_zero);
    fprintf(versionFile, "#define CHECK_INT_REM_BY_ZERO %d\n", check_int_rem_by_zero);
    fprintf(versionFile, "#define CHECK_INT_REM_ZERO_BY_ZERO %d\n", check_int_rem_zero_by_zero);
  } /* checkIntDivisions */



static const char *determine_os_isnan_definition (const char *computeValues,
    const char *os_isnan_definition)

  {
    char buffer[BUFFER_SIZE];
    const char *macro_definition = NULL;

  /* determine_os_isnan_definition */
    sprintf(buffer,
            "#include<stdio.h>\n#include<float.h>\n#include<math.h>\n"
            "%s\n"
            "int main(int argc,char *argv[]){\n"
            "%s"
            "printf(\"%%d\\n\",\n"
            "       os_isnan(floatNanValue1) &&\n"
            "       os_isnan(floatNanValue2) &&\n"
            "       os_isnan(doubleNanValue1) &&\n"
            "       os_isnan(doubleNanValue2) &&\n"
            "       !os_isnan(floatPlusInf) &&\n"
            "       !os_isnan(floatMinusInf) &&\n"
            "       !os_isnan(floatNegativeZero) &&\n"
            "       !os_isnan(doublePlusInf) &&\n"
            "       !os_isnan(doubleMinusInf) &&\n"
            "       !os_isnan(doubleNegativeZero) &&\n"
            "       !os_isnan(0.0) &&\n"
            "       !os_isnan(10.0) &&\n"
            "       !os_isnan(100.0) &&\n"
            "       !os_isnan(1000.0) &&\n"
            "       !os_isnan(10000.0) &&\n"
            "       !os_isnan(100000.0) &&\n"
            "       !os_isnan(1000000.0) &&\n"
            "       !os_isnan(10000000.0) &&\n"
            "       !os_isnan(100000000.0) &&\n"
            "       !os_isnan(1000000000.0) &&\n"
            "       !os_isnan(9007199254740992.0) &&\n"
            "       !os_isnan(9007199254740993.0));\n"
            "return 0;}\n",
            os_isnan_definition, computeValues);
    /* printf("%s\n", buffer); */
    if (compileAndLinkOk(buffer) && doTest() == 1) {
      macro_definition = os_isnan_definition;
    } /* if */
    return macro_definition;
  } /* determine_os_isnan_definition */



static void numericProperties (FILE *versionFile)

  {
    int testResult;
    char buffer[8192];
    char computeValues[BUFFER_SIZE];
    const char *os_isnan_definition = NULL;

  /* numericProperties */
    fprintf(logFile, "Numeric properties: ");
    fflush(stdout);
    if (assertCompAndLnk("#include <stdio.h>\nint main(int argc,char *argv[])"
                         "{long num=-1;printf(\"%d\\n\",num>>1==(long)-1);return 0;}\n")) {
      fprintf(versionFile, "#define RSHIFT_DOES_SIGN_EXTEND %d\n", doTest());
    } /* if */
    if (assertCompAndLnk("#include <stdio.h>\nint main(int argc,char *argv[])"
                         "{long num=-1;printf(\"%d\\n\",~num==(long)0);return 0;}\n")) {
      fprintf(versionFile, "#define TWOS_COMPLEMENT_INTTYPE %d\n", doTest());
    } /* if */
    if (assertCompAndLnk("#include <stdio.h>\nint main(int argc,char *argv[])"
                         "{long num=-1;printf(\"%d\\n\",~num==(long)1);return 0;}\n")) {
      fprintf(versionFile, "#define ONES_COMPLEMENT_INTTYPE %d\n", doTest());
    } /* if */
    if (assertCompAndLnk("#include <stdio.h>\nint main(int argc,char *argv[])"
                         "{long num=1;printf(\"%d\\n\",((char*)&num)[0]==1);return 0;}\n")) {
      fprintf(versionFile, "#define LITTLE_ENDIAN_INTTYPE %d\n", doTest());
    } /* if */
    if (assertCompAndLnk("#include <stdio.h>\nint main(int argc,char *argv[])"
                         "{long num=1;printf(\"%d\\n\",((char*)&num)[sizeof(long) - 1]==1);\n"
                         "return 0;}\n")) {
      fprintf(versionFile, "#define BIG_ENDIAN_INTTYPE %d\n", doTest());
    } /* if */
    checkIntDivisions(versionFile);
    sprintf(buffer, "#include<stdlib.h>\n#include<stdio.h>\n#include<limits.h>\n"
                    "#include<signal.h>\n"
                    "void handleSigill(int sig){puts(\"2\");exit(0);}\n"
                    "void handleSigabrt(int sig){puts(\"3\");exit(0);}\n"
                    "int main(int argc,char *argv[]){\n"
                    "%s a=0x7fffffffffffffff,b=1,c=2;\n"
                    "signal(SIGILL,handleSigill);\nsignal(SIGABRT,handleSigabrt);\n"
                    "printf(\"%%d\\n\",a+b==0x8000000000000000 && a*c== -2);return 0;}\n",
                    int64TypeStri);
    if (compileAndLinkOk(buffer)) {
      switch (doTest()) {
        case 2:  fputs("#define OVERFLOW_SIGNAL \"SIGILL\"\n", versionFile);  break;
        case 3:  fputs("#define OVERFLOW_SIGNAL \"SIGABRT\"\n", versionFile); break;
        default: fputs("#define OVERFLOW_SIGNAL \"\"\n", versionFile);        break;
      } /* switch */
    } else {
      fputs("#define INT_MULT64_COMPILE_ERROR\n", versionFile);
      fputs("#define OVERFLOW_SIGNAL \"\"\n", versionFile);
    } /* if */
#ifdef TURN_OFF_FP_EXCEPTIONS
    _control87(MCW_EM, MCW_EM);
#endif
    sprintf(buffer, "%1.0f %1.0f %1.0f %1.1f %1.1f %1.2f %1.2f %1.0f %1.0f %1.0f %1.1f %1.1f %1.2f %1.2f",
            0.5, 1.5, 2.5, 1.25, 1.75, 0.125, 0.375, -0.5, -1.5, -2.5, -1.25, -1.75, -0.125, -0.375);
    if (strcmp(buffer, "0 2 2 1.2 1.8 0.12 0.38 0 -2 -2 -1.2 -1.8 -0.12 -0.38") == 0 ||
        strcmp(buffer, "0 2 2 1.2 1.8 0.12 0.38 -0 -2 -2 -1.2 -1.8 -0.12 -0.38") == 0) {
      fputs("#define ROUND_HALF_TO_EVEN\n", versionFile);
    } else if (strcmp(buffer, "1 2 3 1.3 1.8 0.13 0.38 -1 -2 -3 -1.3 -1.8 -0.13 -0.38") == 0) {
      fputs("#define ROUND_HALF_AWAY_FROM_ZERO\n", versionFile);
    } else if (strcmp(buffer, "1 2 3 1.3 1.8 0.13 0.38 0 -1 -2 -1.2 -1.7 -0.12 -0.37") == 0 ||
               strcmp(buffer, "1 2 3 1.3 1.8 0.13 0.38 -0 -1 -2 -1.2 -1.7 -0.12 -0.37") == 0) {
      fputs("#define ROUND_HALF_UP\n", versionFile);
    } /* if */
    if (assertCompAndLnk("#include<stdio.h>\n#include<string.h>\n#include<float.h>\n"
                         "int main(int argc,char *argv[])\n"
                         "{int precision;double number;char buffer[128];\n"
                         "precision = 3;number = 0.123456789;\n"
                         "sprintf(buffer, \"%1.*f\", precision, number);\n"
                         "printf(\"%d\\n\",strcmp(buffer,\"0.123\")==0);return 0;}\n")) {
      fprintf(versionFile, "#define PRINTF_SUPPORTS_VARIABLE_FORMATS %d\n", doTest());
    } /* if */
    if (assertCompAndLnk("#include<stdio.h>\n#include<string.h>\n#include<float.h>\n"
                         "int main(int argc,char *argv[])\n"
                         "{int minExp10;char buffer[128];\n"
                         "sprintf(buffer, \"%1.10e\", DBL_MIN);\n"
                         "sscanf(strchr(buffer,'e') + 1, \"%d\", &minExp10);\n"
                         "printf(\"%d\\n\",minExp10);return 0;}\n")) {
      fprintf(versionFile, "#define DOUBLE_MIN_EXP10 %d\n", doTest());
    } /* if */
    if (assertCompAndLnk("#include<stdio.h>\n#include<string.h>\n#include<float.h>\n"
                         "int main(int argc,char *argv[])\n"
                         "{int maxExp10;char buffer[128];\n"
                         "sprintf(buffer, \"%1.10e\", DBL_MAX);\n"
                         "sscanf(strchr(buffer,'e') + 1, \"%d\", &maxExp10);\n"
                         "printf(\"%d\\n\",maxExp10);return 0;}\n")) {
      fprintf(versionFile, "#define DOUBLE_MAX_EXP10 %d\n", doTest());
    } /* if */
    if (assertCompAndLnk("#include<stdio.h>\n#include<string.h>\n"
                         "int main(int argc,char *argv[])\n"
                         "{char buffer[128];\n"
                         "sprintf(buffer, \"%1.14e\", 1.12345678901234);\n"
                         "printf(\"%d\\n\",(int)strlen(buffer)-18);return 0;}\n")) {
      fprintf(versionFile, "#define MIN_PRINTED_EXPONENT_DIGITS %u\n", doTest());
    } /* if */
    if (assertCompAndLnk("#include<stdio.h>\n#include<string.h>\n#include<float.h>\n"
                         "int main(int argc,char *argv[])\n"
                         "{int maxExp10;char buffer[128];\n"
                         "sprintf(buffer, \"%1.10e\", DBL_MAX);\n"
                         "sscanf(strchr(buffer,'e') + 1, \"%d\", &maxExp10);\n"
                         "sprintf(buffer, \"%d\", maxExp10);\n"
                         "printf(\"%d\\n\",(int)strlen(buffer));return 0;}\n")) {
      fprintf(versionFile, "#define MAX_PRINTED_EXPONENT_DIGITS %u\n", doTest());
    } /* if */
    if (assertCompAndLnk("#include<stdio.h>\n#include<float.h>\n"
                         "int main(int argc,char *argv[])\n"
                         "{printf(\"%d\\n\",FLT_DIG);return 0;}\n")) {
      testResult = doTest();
      fprintf(versionFile, "#define FMT_E_FLT \"%%1.%de\"\n", testResult - 1);
      fprintf(versionFile, "#define FLOAT_STR_LARGE_NUMBER 1.0e%d\n", testResult);
    } /* if */
    if (assertCompAndLnk("#include<stdio.h>\n#include<float.h>\n"
                         "int main(int argc,char *argv[])\n"
                         "{printf(\"%d\\n\",DBL_DIG);return 0;}\n")) {
      testResult = doTest();
      fprintf(versionFile, "#define FMT_E_DBL \"%%1.%de\"\n", testResult - 1);
      fprintf(versionFile, "#define DOUBLE_STR_LARGE_NUMBER 1.0e%d\n", testResult);
    } /* if */
    if (!compileAndLinkOk("#include<stdio.h>\n"
                          "int main(int argc,char *argv[]){"
                          "printf(\"%f\", 1.0/0.0);return 0;}\n") ||
        !compileAndLinkOk("#include<stdlib.h>\n#include<stdio.h>\n#include<float.h>\n#include<signal.h>\n"
                          "void handleSig(int sig){puts(\"2\");exit(0);}\n"
                          "int main(int argc,char *argv[]){\n"
#ifdef TURN_OFF_FP_EXCEPTIONS
                          "_control87(MCW_EM, MCW_EM);\n"
#endif
                          "signal(SIGFPE,handleSig);\nsignal(SIGILL,handleSig);\n"
                          "signal(SIGINT,handleSig);\n"
                          "printf(\"%d\\n\",1.0/0.0==0.0);return 0;}\n") || doTest() == 2) {
      fputs("#define FLOAT_ZERO_DIV_ERROR\n", versionFile);
    } /* if */
    if (assertCompAndLnk("#include<stdio.h>\n#include<float.h>\n"
                         "int main(int argc,char *argv[]){\n"
                         "printf(\"%d\\n\",\n"
                         "       1.0 == (double) 1 &&\n"
                         "       10.0 == (double) 10 &&\n"
                         "       100.0 == (double) 100 &&\n"
                         "       1000.0 == (double) 1000 &&\n"
                         "       10000.0 == (double) 10000 &&\n"
                         "       100000.0 == (double) 100000 &&\n"
                         "       1000000.0 == (double) 1000000 &&\n"
                         "       10000000.0 == (double) 10000000 &&\n"
                         "       100000000.0 == (double) 100000000 &&\n"
                         "       1000000000.0 == (double) 1000000000);\n"
                         "return 0;}\n")) {
      fprintf(versionFile, "#define CAST_INT_TO_FLOAT_OKAY %d\n", doTest());
    } /* if */
    fprintf(versionFile, "#define HAS_LOG2 %d\n",
        compileAndLinkWithOptionsOk("#include<stdio.h>\n#include<float.h>\n#include<math.h>\n"
                                    "int main(int argc,char *argv[]){\n"
                                    "double number = 2.0;\n"
                                    "printf(\"%d\\n\", log2(number) == 1.0); return 0;}\n",
                                    "", SYSTEM_LIBS) && doTest() == 1);
    fprintf(versionFile, "#define HAS_CBRT %d\n",
        compileAndLinkWithOptionsOk("#include<stdio.h>\n#include<float.h>\n#include<math.h>\n"
                                    "int main(int argc,char *argv[]){\n"
                                    "double zero = 0.0;\n"
                                    "printf(\"%d\\n\",\n"
                                    "       cbrt( zero) == 0.0 &&\n"
                                    "       cbrt(  0.0) == 0.0 &&\n"
                                    "       cbrt(  1.0) == 1.0 &&\n"
                                    "       cbrt(  8.0) == 2.0 &&\n"
                                    "       cbrt( 27.0) == 3.0 &&\n"
                                    "       cbrt( 64.0) == 4.0 &&\n"
                                    "       cbrt(125.0) == 5.0); return 0;}\n",
                                    "", SYSTEM_LIBS) && doTest() == 1);
    strcpy(computeValues,
           "float floatZero = 0.0;\n"
           "float floatNegativeZero;\n"
           "float floatNanValue1;\n"
           "float floatNanValue2;\n"
           "float floatPlusInf;\n"
           "float floatMinusInf;\n"
           "double doubleZero = 0.0;\n"
           "double doubleNegativeZero;\n"
           "double doubleNanValue1;\n"
           "double doubleNanValue2;\n"
           "double doublePlusInf;\n"
           "double doubleMinusInf;\n");
    if (!compileAndLinkOk("#include<stdlib.h>\n#include<stdio.h>\n#include<float.h>\n#include<signal.h>\n"
                          "void handleSig(int sig){puts(\"2\");exit(0);}\n"
                          "int main(int argc,char *argv[]){\n"
                          "float zero=0.0;\n"
#ifdef TURN_OFF_FP_EXCEPTIONS
                          "_control87(MCW_EM, MCW_EM);\n"
#endif
                          "signal(SIGFPE,handleSig);\nsignal(SIGILL,handleSig);\n"
                          "signal(SIGINT,handleSig);\n"
                          "printf(\"%d\\n\",1.0/zero==0.0);return 0;}\n") || doTest() == 2) {
      fputs("#define CHECK_FLOAT_DIV_BY_ZERO 1\n", versionFile);
      fputs("#define USE_NEGATIVE_ZERO_BITPATTERN 1\n", versionFile);
      strcat(computeValues,
             "union {\n"
             "  ");
      switch (getSizeof("float")) {
        case 2: strcat(computeValues, uint16TypeStri); break;
        case 4: strcat(computeValues, uint32TypeStri); break;
        case 8: strcat(computeValues, uint64TypeStri); break;
      } /* switch */
      strcat(computeValues,
             " i;\n"
             "  float f;\n"
             "} fltTransfer;\n");
      strcat(computeValues,
             "union {\n"
             "  ");
      switch (getSizeof("double")) {
        case 2: strcat(computeValues, uint16TypeStri); break;
        case 4: strcat(computeValues, uint32TypeStri); break;
        case 8: strcat(computeValues, uint64TypeStri); break;
      } /* switch */
      strcat(computeValues,
             " i;\n"
             "  double f;\n"
             "} dblTransfer;\n");
#ifdef TURN_OFF_FP_EXCEPTIONS
      strcat(computeValues,
             "_control87(MCW_EM, MCW_EM);\n");
#endif
      strcat(computeValues,
             "fltTransfer.i = 0xffc00000;\n"
             "floatNanValue1 = fltTransfer.f;\n"
             "fltTransfer.i = 0x7f800000;\n"
             "floatPlusInf = fltTransfer.f;\n"
             "fltTransfer.i = 0xff800000;\n"
             "floatMinusInf = fltTransfer.f;\n"
             "fltTransfer.i = 0x80000000;\n"
             "floatNegativeZero = fltTransfer.f;\n"
             "floatNanValue2 = floatNanValue1;\n");
      strcat(computeValues,
             "dblTransfer.i = 0xfff8000000000000;\n"
             "doubleNanValue1 = dblTransfer.f;\n"
             "dblTransfer.i = 0x7ff0000000000000;\n"
             "doublePlusInf = dblTransfer.f;\n"
             "dblTransfer.i = 0xfff0000000000000;\n"
             "doubleMinusInf = dblTransfer.f;\n"
             "dblTransfer.i = 0x8000000000000000;\n"
             "doubleNegativeZero = dblTransfer.f;\n"
             "doubleNanValue2 = doubleNanValue1;\n");
    } else {
      strcat(computeValues,
#ifdef TURN_OFF_FP_EXCEPTIONS
             "_control87(MCW_EM, MCW_EM);\n"
#endif
             "floatNanValue1 = 0.0 / floatZero;\n"
             "floatNanValue2 = 0.0 / floatZero;\n"
             "floatPlusInf = 1.0 / floatZero;\n"
             "floatMinusInf = -floatPlusInf;\n"
             "floatNegativeZero = -1.0 / floatPlusInf;\n"
             "doubleNanValue1 = 0.0 / doubleZero;\n"
             "doubleNanValue2 = 0.0 / doubleZero;\n"
             "doublePlusInf = 1.0 / doubleZero;\n"
             "doubleMinusInf = -doublePlusInf;\n"
             "doubleNegativeZero = -1.0 / doublePlusInf;\n");
      sprintf(buffer,
              "#include<stdio.h>\n#include<float.h>\n"
              "int main(int argc,char *argv[]){\n"
              "float minusZero;\n"
              "%s"
              "printf(\"#define CHECK_FLOAT_DIV_BY_ZERO %%d\\n\",\n"
              "    floatPlusInf == floatMinusInf ||\n"
              "    -1.0 / floatZero != floatMinusInf ||\n"
              "     1.0 / floatNegativeZero != floatMinusInf);\n"
              "minusZero = -floatZero;\n"
              "printf(\"#define USE_NEGATIVE_ZERO_BITPATTERN %%d\\n\",\n"
              "    memcmp(&floatNegativeZero, &minusZero, sizeof(float)) != 0);\n"
              "return 0;}\n", computeValues);
      if (assertCompAndLnk(buffer)) {
        testOutputToVersionFile(versionFile);
      } /* if */
    } /* if */
    os_isnan_definition = determine_os_isnan_definition(computeValues, "#define os_isnan isnan");
    if (os_isnan_definition == NULL) {
      os_isnan_definition = determine_os_isnan_definition(computeValues, "#define os_isnan _isnan");
    } /* if */
    if (os_isnan_definition != NULL) {
      fprintf(versionFile, "%s\n", os_isnan_definition);
      fprintf(versionFile, "#define OS_ISNAN_DEFINITION \"%s\\n\"\n", os_isnan_definition);
    } /* if */
    sprintf(buffer,
            "#include<stdio.h>\n#include<float.h>\n#include<math.h>\n"
            "%s\n"
            "int main(int argc,char *argv[]){\n"
            "%s\n"
            "printf(\"%%d\\n\",\n"
            "       exp(0.0) == 1.0 &&\n"
            "       exp(floatZero) == 1.0 &&\n"
            "       exp(floatNegativeZero) == 1.0 &&\n"
            "       exp(floatMinusInf) == 0.0 &&\n"
            "       exp(doubleMinusInf) == 0.0 &&\n"
            "       exp(floatPlusInf) == floatPlusInf &&\n"
            "       exp(doublePlusInf) == doublePlusInf &&\n"
            "       os_isnan(exp(floatNanValue1)) &&\n"
            "       os_isnan(exp(doubleNanValue1)));\n"
            "return 0;}\n",
            os_isnan_definition, computeValues);
    fprintf(versionFile, "#define HAS_EXP %d\n",
        compileAndLinkWithOptionsOk(buffer, "", SYSTEM_LIBS) && doTest() == 1);
    sprintf(buffer,
            "#include<stdio.h>\n#include<float.h>\n#include<math.h>\n"
            "%s\n"
            "int main(int argc,char *argv[]){\n"
            "%s\n"
            "printf(\"%%d\\n\",\n"
            "       exp2(-5.0) == 0.03125 &&\n"
            "       exp2(-4.0) == 0.0625 &&\n"
            "       exp2(-3.0) == 0.125 &&\n"
            "       exp2(-2.0) == 0.25 &&\n"
            "       exp2(-1.0) == 0.5 &&\n"
            "       exp2( 0.0) == 1.0 &&\n"
            "       exp2( 1.0) == 2.0 &&\n"
            "       exp2( 2.0) == 4.0 &&\n"
            "       exp2( 3.0) == 8.0 &&\n"
            "       exp2( 4.0) == 16.0 &&\n"
            "       exp2( 5.0) == 32.0 &&\n"
            "       exp2(10.0) == 1024.0 &&\n"
            "       exp2(20.0) == 1048576.0 &&\n"
            "       exp2(30.0) == 1073741824.0 &&\n"
            "       exp2(40.0) == 1099511627776.0 &&\n"
            "       exp2(50.0) == 1125899906842624.0 &&\n"
            "       exp2(60.0) == 1152921504606846976.0 &&\n"
            "       exp2(62.0) == 4611686018427387904.0 &&\n"
            "       exp2(floatZero) == 1.0 &&\n"
            "       exp2(floatNegativeZero) == 1.0 &&\n"
            "       exp2(floatMinusInf) == 0.0 &&\n"
            "       exp2(doubleMinusInf) == 0.0 &&\n"
            "       exp2(floatPlusInf) == floatPlusInf &&\n"
            "       exp2(doublePlusInf) == doublePlusInf &&\n"
            "       os_isnan(exp2(floatNanValue1)) &&\n"
            "       os_isnan(exp2(doubleNanValue1)));\n"
            "return 0;}\n",
            os_isnan_definition, computeValues);
    fprintf(versionFile, "#define HAS_EXP2 %d\n",
        compileAndLinkWithOptionsOk(buffer, "", SYSTEM_LIBS) && doTest() == 1);
    sprintf(buffer,
            "#include<stdio.h>\n#include<float.h>\n#include<math.h>\n"
            "%s\n"
            "int main(int argc,char *argv[]){\n"
            "%s\n"
            "printf(\"%%d\\n\",\n"
            "       exp10(0.0) == 1.0 &&\n"
            "       exp10(floatZero) == 1.0 &&\n"
            "       exp10(floatNegativeZero) == 1.0 &&\n"
            "       exp10(floatMinusInf) == 0.0 &&\n"
            "       exp10(doubleMinusInf) == 0.0 &&\n"
            "       exp10(floatPlusInf) == floatPlusInf &&\n"
            "       exp10(doublePlusInf) == doublePlusInf &&\n"
            "       os_isnan(exp10(floatNanValue1)) &&\n"
            "       os_isnan(exp10(doubleNanValue1)));\n"
            "return 0;}\n",
            os_isnan_definition, computeValues);
    fprintf(versionFile, "#define HAS_EXP10 %d\n",
        compileAndLinkWithOptionsOk(buffer, "", SYSTEM_LIBS) && doTest() == 1);
    sprintf(buffer,
            "#include<stdio.h>\n#include<float.h>\n#include<math.h>\n"
            "%s\n"
            "int main(int argc,char *argv[]){\n"
            "int exponent1 = 999999;\n"
            "int exponent2 = 999999;\n"
            "int exponent3 = 999999;\n"
            "int exponent4 = 999999;\n"
            "int exponent5 = 999999;\n"
            "int exponent6 = 999999;\n"
            "int frexp_okay = 1;\n"
            "%s\n"
            "if (frexp(floatMinusInf,  &exponent1) != doubleMinusInf ||\n"
            "    frexp(doubleMinusInf, &exponent2) != doubleMinusInf ||\n"
            "    frexp(floatPlusInf,   &exponent3) != doublePlusInf  ||\n"
            "    frexp(doublePlusInf,  &exponent4) != doublePlusInf  ||\n"
            "    !os_isnan(frexp(floatNanValue1,  &exponent5)) ||\n"
            "    !os_isnan(frexp(doubleNanValue1, &exponent6))) {\n"
            "  frexp_okay = 0;\n"
            "}\n"
            "if (exponent1 != 0 || exponent2 != 0 ||\n"
            "    exponent3 != 0 || exponent4 != 0 ||\n"
            "    exponent5 != 0 || exponent6 != 0) {\n"
            "  frexp_okay = 0;\n"
            "}\n"
            "printf(\"%%d\\n\", frexp_okay);\n"
            "return 0;}\n",
            os_isnan_definition, computeValues);
    if (compileAndLinkWithOptionsOk(buffer, "", SYSTEM_LIBS)) {
      fprintf(versionFile, "#define FREXP_INFINITY_NAN_OKAY %d\n", doTest());
    } /* if */
    sprintf(buffer,
            "#include<stdio.h>\n#include<string.h>\n"
            "#include<float.h>\n#include<math.h>\n"
            "%s\n"
            "int doubleCompare (double num1, double num2){\n"
            "return memcmp(&num1, &num2, sizeof(double));}\n"
            "double getMaxOddFloat(int exponent){\n"
            "double base = (double) FLT_RADIX;\n"
            "double power;\n"
            "for (power=1.0; exponent>0; exponent--) power*=base;\n"
            "if ((FLT_RADIX & 1) == 0) power = floor(power-1.0);\n"
            "return power;}\n"
            "int main(int argc,char *argv[]){\n"
            "float floatOne = 1.0;\n"
            "float floatTwo = 2.0;\n"
            "double doubleOne = 1.0;\n"
            "double doubleTwo = 2.0;\n"
            "%s"
            "printf(\"#define FLOAT_ZERO_TIMES_INFINITE_OKAY %%d\\n\",\n"
            "    0.0 * floatPlusInf != floatNanValue1 ||\n"
            "    0.0 * floatMinusInf != floatNanValue1 ||\n"
            "    floatPlusInf * 0.0 != floatNanValue1 ||\n"
            "    floatMinusInf * 0.0 != floatNanValue1 ||\n"
            "    0.0 * doublePlusInf != doubleNanValue1 ||\n"
            "    0.0 * doubleMinusInf != doubleNanValue1 ||\n"
            "    doublePlusInf * 0.0 != doubleNanValue1 ||\n"
            "    doubleMinusInf * 0.0 != doubleNanValue1);\n"
            "printf(\"#define NAN_COMPARISON_OKAY %%d\\n\",\n"
            "    !(floatNanValue1 == floatNanValue2 ||\n"
            "      floatNanValue1 <  floatNanValue2 ||\n"
            "      floatNanValue1 >  floatNanValue2 ||\n"
            "      floatNanValue1 <= floatNanValue2 ||\n"
            "      floatNanValue1 >= floatNanValue2 ||\n"
            "      doubleNanValue1 == doubleNanValue2 ||\n"
            "      doubleNanValue1 <  doubleNanValue2 ||\n"
            "      doubleNanValue1 >  doubleNanValue2 ||\n"
            "      doubleNanValue1 <= doubleNanValue2 ||\n"
            "      doubleNanValue1 >= doubleNanValue2));\n"
            "printf(\"#define NAN_MULTIPLICATION_OKAY %%d\\n\",\n"
            "    os_isnan(floatNanValue1 * 1.0) &&\n"
            "    os_isnan(floatNanValue1 * floatOne) &&\n"
            "    os_isnan(1.0 * floatNanValue1) &&\n"
            "    os_isnan(floatOne * floatNanValue1) &&\n"
            "    os_isnan(floatNanValue1 * floatNanValue2) &&\n"
            "    os_isnan(doubleNanValue1 * 1.0) &&\n"
            "    os_isnan(doubleNanValue1 * doubleOne) &&\n"
            "    os_isnan(1.0 * doubleNanValue1) &&\n"
            "    os_isnan(doubleOne * doubleNanValue1) &&\n"
            "    os_isnan(doubleNanValue1 * doubleNanValue2));\n"
            "printf(\"#define NAN_DIVISION_OKAY %%d\\n\",\n"
            "    os_isnan(floatNanValue1 / 1.0) &&\n"
            "    os_isnan(floatNanValue1 / floatOne) &&\n"
            "    os_isnan(1.0 / floatNanValue1) &&\n"
            "    os_isnan(floatOne / floatNanValue1) &&\n"
            "    os_isnan(floatNanValue1 / floatNanValue2) &&\n"
            "    os_isnan(doubleNanValue1 / 1.0) &&\n"
            "    os_isnan(doubleNanValue1 / doubleOne) &&\n"
            "    os_isnan(1.0 / doubleNanValue1) &&\n"
            "    os_isnan(doubleOne / doubleNanValue1) &&\n"
            "    os_isnan(doubleNanValue1 / doubleNanValue2));\n"
            "printf(\"#define MAX_ODD_FLOAT %%0.1f\\n\", getMaxOddFloat(FLT_MANT_DIG));\n"
            "printf(\"#define MAX_ODD_DOUBLE %%0.1f\\n\", getMaxOddFloat(DBL_MANT_DIG));\n"
            "printf(\"#define POW_OF_NAN_OKAY %%d\\n\",\n"
            "    pow(floatNanValue1, 0.0) == 1.0 &&\n"
            "    pow(floatNanValue1, floatZero) == 1.0 &&\n"
            "    os_isnan(pow(floatNanValue1, 1.0)) &&\n"
            "    pow(doubleNanValue1, 0.0) == 1.0 &&\n"
            "    pow(doubleNanValue1, doubleZero) == 1.0 &&\n"
            "    os_isnan(pow(doubleNanValue1, 1.0)));\n"
            "printf(\"#define POW_OF_ZERO_OKAY %%d\\n\",\n"
            "    pow(floatZero, -1.0) == floatPlusInf &&\n"
            "    pow(floatZero, -2.0) == floatPlusInf &&\n"
            "    pow(floatNegativeZero, -1.0) == floatMinusInf &&\n"
            "    pow(floatNegativeZero, -2.0) == floatPlusInf &&\n"
            "    pow(floatNegativeZero, -getMaxOddFloat(FLT_MANT_DIG)) == floatMinusInf &&\n"
            "    pow(doubleZero, -1.0) == doublePlusInf &&\n"
            "    pow(doubleZero, -2.0) == doublePlusInf &&\n"
            "    pow(doubleNegativeZero, -1.0) == doubleMinusInf &&\n"
            "    pow(doubleNegativeZero, -2.0) == doublePlusInf &&\n"
            "    pow(doubleNegativeZero, -getMaxOddFloat(DBL_MANT_DIG)) == doubleMinusInf);\n"
            "printf(\"#define POW_OF_ONE_OKAY %%d\\n\",\n"
            "    pow(1.0, floatNanValue1) == 1.0 &&\n"
            "    pow(1.0, doubleNanValue1) == 1.0 &&\n"
            "    pow(floatOne, floatNanValue1) == 1.0 &&\n"
            "    pow(doubleOne, doubleNanValue1) == 1.0);\n"
            "printf(\"#define POW_EXP_NAN_OKAY %%d\\n\",\n"
            "    os_isnan(pow(2.0, doubleNanValue1)) &&\n"
            "    os_isnan(pow(doubleTwo, doubleNanValue1)) &&\n"
            "    os_isnan(pow(10.0, doubleNanValue1)));\n"
            "printf(\"#define POW_EXP_MINUS_INFINITY_OKAY %%d\\n\",\n"
            "    pow(2.0, floatMinusInf) == 0.0 &&\n"
            "    pow(floatTwo, floatMinusInf) == 0.0 &&\n"
            "    pow(0.9, floatMinusInf) == floatPlusInf &&\n"
            "    pow(2.0, doubleMinusInf) == 0.0 &&\n"
            "    pow(doubleTwo, doubleMinusInf) == 0.0 &&\n"
            "    pow(0.9, doubleMinusInf) == doublePlusInf);\n"
            "printf(\"#define POW_UNDERFLOW_WITH_SIGN %%d\\n\",\n"
            "    doubleCompare(pow(-2.0, -2147483649.0), doubleNegativeZero) == 0 &&\n"
            "    doubleCompare(pow(-doubleTwo, -2147483649.0), doubleNegativeZero) == 0);\n"
            "{ char buffer[1024]; sprintf(buffer, \"%%1.1f\", floatNegativeZero);\n"
            "printf(\"#define PRINTS_NEGATIVE_ZERO %%d\\n\", buffer[0] == '-'); }\n"
            "return 0;}\n", os_isnan_definition, computeValues);
    if (assertCompAndLnkWithOptions(buffer, "", SYSTEM_LIBS)) {
      testOutputToVersionFile(versionFile);
    } /* if */
    if (compileAndLinkOk("#include<float.h>\n#include<math.h>\nint main(int argc,char *argv[])"
                          "{float f=0.0; isinf(f); return 0;}\n")) {
      fputs("#define os_isinf isinf\n", versionFile);
    } else {
      if (compileAndLinkOk("#include<float.h>\n#include<math.h>\nint main(int argc,char *argv[])"
                           "{float f=0.0; _isinf(f); return 0;}\n")) {
        fputs("#define os_isinf _isinf\n", versionFile);
      } else {
        sprintf(buffer,
                "#include<stdio.h>\n#include<float.h>\n#include<math.h>\n"
                "int main(int argc,char *argv[]){\n"
                "%s"
                "printf(\"%%d\\n\", fabs(floatPlusInf) > DBL_MAX && fabs(floatMinusInf) > DBL_MAX);\n"
                "return 0;}\n", computeValues);
        if (assertCompAndLnk(buffer)) {
          if (doTest() == 1) {
            fputs("#define os_isinf(x) (fabs(x) > DBL_MAX)\n", versionFile);
          } /* if */
        } /* if */
      } /* if */
    } /* if */
    if (compileAndLinkOk("#include<stdlib.h>\n#include<stdio.h>\n#include<float.h>\n#include<signal.h>\n"
                         "void handleSig(int sig){puts(\"2\");exit(0);}\n"
                         "int main(int argc,char *argv[]){\n"
#ifdef TURN_OFF_FP_EXCEPTIONS
                         "_control87(MCW_EM, MCW_EM);\n"
#endif
                         "signal(SIGFPE,handleSig);\nsignal(SIGILL,handleSig);\n"
                         "signal(SIGINT,handleSig);\n"
                         "printf(\"%d\\n\",(int) 1.0E37);return 0;}\n")) {
      testResult = doTest();
      if ((sizeof(int) == 4 && (long) testResult == 2147483647L) ||
          (sizeof(int) == 2 && testResult == 32767)) {
        fputs("#define FLOAT_TO_INT_OVERFLOW_SATURATES\n", versionFile);
      } else if (testResult == 2) {
        fputs("#define FLOAT_TO_INT_OVERFLOW_SIGNALS\n", versionFile);
      } else if (testResult == 0) {
        fputs("#define FLOAT_TO_INT_OVERFLOW_ZERO\n", versionFile);
      } else {
        fprintf(versionFile, "#define FLOAT_TO_INT_OVERFLOW_GARBAGE %d\n", testResult);
      } /* if */
    } /* if */
    if (assertCompAndLnk("#include<stdio.h>\n#include<float.h>\n"
                         "double dblPower(double base, int exponent){\n"
                         "double power;\n"
                         "for(power=1.0;exponent>0;exponent--)power*=base;\n"
                         "return power;}\n"
                         "int main(int argc,char *argv[]){\n"
                         "int floatRadixFactor;\n"
                         "double power;\n"
#ifdef TURN_OFF_FP_EXCEPTIONS
                         "_control87(MCW_EM, MCW_EM);\n"
#endif
                         "if (FLT_RADIX == 2) floatRadixFactor = 1;\n"
                         "else if (FLT_RADIX == 4) floatRadixFactor = 2;\n"
                         "else if (FLT_RADIX == 8) floatRadixFactor = 3;\n"
                         "else if (FLT_RADIX == 16) floatRadixFactor = 4;\n"
                         "power = dblPower((double) FLT_RADIX, FLT_MANT_DIG);\n"
                         "printf(\"#define INT_RANGE_IN_FLOAT_MAX %0.0f\\n\", power);\n"
                         "printf(\"#define FLOAT_MANTISSA_FACTOR %0.1f\\n\", power);\n"
                         "printf(\"#define FLOAT_MANTISSA_SHIFT %u\\n\", "
                                 "FLT_MANT_DIG * floatRadixFactor);\n"
                         "power = dblPower((double) FLT_RADIX, DBL_MANT_DIG);\n"
                         "printf(\"#define INT_RANGE_IN_DOUBLE_MAX %0.0f\\n\", power);\n"
                         "printf(\"#define DOUBLE_MANTISSA_FACTOR %0.1f\\n\", power);\n"
                         "printf(\"#define DOUBLE_MANTISSA_SHIFT %u\\n\", "
                                 "DBL_MANT_DIG * floatRadixFactor);\n"
                         "return 0;}\n")) {
      testOutputToVersionFile(versionFile);
    } /* if */
    if (assertCompAndLnk("#include<stdio.h>\n#include<string.h>\n"
                         "int main(int argc,char *argv[]){\n"
                         "char buffer[100010];\n"
                         "sprintf(buffer, \"%1.100000e\", 1.0);\n"
                         "printf(\"%lu\\n\", (unsigned long) (strchr(buffer, 'e') - buffer));\n"
                         "return 0;}\n")) {
      testResult = doTest();
      if (testResult >= 2 && testResult < 100002) {
        fprintf(versionFile, "#define PRINTF_FMT_E_MAXIMUM_FLOAT_PRECISION %d\n", testResult - 2);
      } /* if */
    } /* if */
    if (assertCompAndLnk("#include<stdio.h>\n#include<string.h>\n"
                         "int main(int argc,char *argv[]){\n"
                         "char buffer[100010];\n"
                         "sprintf(buffer, \"%1.100000f\", 1.0);\n"
                         "printf(\"%lu\\n\", (unsigned long) strlen(buffer));\n"
                         "return 0;}\n")) {
      testResult = doTest();
      if (testResult >= 2 && testResult < 100002) {
        fprintf(versionFile, "#define PRINTF_FMT_F_MAXIMUM_FLOAT_PRECISION %d\n", testResult - 2);
      } /* if */
    } /* if */
    if (assertCompAndLnk("#include<stdio.h>\n#include<stdlib.h>\n"
                         "int main(int argc,char *argv[]){\n"
                         "printf(\"%d\\n\", strtod(\"0x123\", NULL) != 0.0);\n"
                         "return 0;}\n")) {
      fprintf(versionFile, "#define STRTOD_ACCEPTS_HEX_NUMBERS %d\n", doTest());
    } /* if */
    if (assertCompAndLnk("#include<stdio.h>\n#include<stdlib.h>\n"
                         "int main(int argc,char *argv[]){\n"
                         "printf(\"%d\\n\", atof(\"0x123\") != 0.0);\n"
                         "return 0;}\n")) {
      fprintf(versionFile, "#define ATOF_ACCEPTS_HEX_NUMBERS %d\n", doTest());
    } /* if */
     if (assertCompAndLnk("#include<stdio.h>\n#include<stdlib.h>\n#include <float.h>\n"
                         "int main(int argc,char *argv[]){\n"
                         "double num = DBL_MIN; char buffer[1024];\n"
                         "sprintf(buffer, \"%1.20e\", num / 2.0);\n"
                         "printf(\"%d\\n\", strtod(buffer, NULL) != 0.0);\n"
                         "return 0;}\n")) {
      fprintf(versionFile, "#define STRTOD_ACCEPTS_DENORMAL_NUMBERS %d\n", doTest());
    } /* if */
   if (assertCompAndLnk("#include<stdio.h>\n#include<stdlib.h>\n#include <float.h>\n"
                         "int main(int argc,char *argv[]){\n"
                         "double num = DBL_MIN; char buffer[1024];\n"
                         "sprintf(buffer, \"%1.20e\", num / 2.0);\n"
                         "printf(\"%d\\n\", atof(buffer) != 0.0);\n"
                         "return 0;}\n")) {
      fprintf(versionFile, "#define ATOF_ACCEPTS_DENORMAL_NUMBERS %d\n", doTest());
    } /* if */
    fprintf(logFile, " determined\n");
  } /* numericProperties */



static void determineMallocAlignment (FILE *versionFile)

  {
    int alignment = -1;

  /* determineMallocAlignment */
    if (compileAndLinkOk("#include <stdio.h>\n#include <stdlib.h>\n"
                         "static const int alignmentTable[] = {\n"
                         "    6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,\n"
                         "    4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,\n"
                         "    5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,\n"
                         "    4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,\n"
                         "  };\n"
                         "int main(int argc, char *argv[])"
                         "{\n"
                         "  int count;\n"
                         "  unsigned long malloc_result;\n"
                         "  int alignment;\n"
                         "  int minAlignment = 7;\n"
                         "  for (count = 1; count <= 64; count++) {\n"
                         "    malloc_result = (unsigned long) (size_t) malloc(count);\n"
                         "    alignment = alignmentTable[malloc_result & 0x3f];\n"
                         "    if (alignment < minAlignment) {\n"
                         "      minAlignment = alignment;\n"
                         "    }\n"
                         "  }\n"
                         "  printf(\"%d\\n\", minAlignment);\n"
                         "  return 0;"
                         "}\n")) {
      alignment = doTest();
    } /* if */
    if (alignment == -1) {
      fprintf(logFile, "\n *** Unable to determine malloc alignment.\n");
    } else {
      fprintf(versionFile, "#define MALLOC_ALIGNMENT %d\n", alignment);
    } /* if */
  } /* determineMallocAlignment */



static void checkForLimitedStringLiteralLength (FILE *versionFile)

  {
    const char *programStart = "#include <stdio.h>\n#include <string.h>\n"
                               "int main(int argc, char *argv[]){\n"
                               "char *stri =\n";
    const char *line = "\"12345678901234567890123456789012345678901234567890"
                       "12345678901234567890123456789012345678901234567890\"\n";
    const char *programEnd = "; printf(\"%d\\n\", strlen(stri) != 0); return 0;}\n";
    const int repeatCount = 1000; /* Corresponds to a string literal length of 100000. */
    int lineLength;
    int totalLength;
    int count;
    char *buffer;
    char *bufPos;

  /* checkForLimitedStringLiteralLength */
    lineLength = strlen(line);
    totalLength = strlen(programStart) + lineLength * repeatCount + strlen(programEnd);
    buffer = (char *) malloc((totalLength + 1) * sizeof(char));
    strcpy(buffer, programStart);
    bufPos = &buffer[strlen(buffer)];
    for (count = 1; count <= repeatCount; count++) {
      strcpy(bufPos, line);
      bufPos += lineLength;
    } /* for */
    strcpy(bufPos, programEnd);
    /* printf("%s\n", buffer); */
    /* Some C compilers limit the maximum string literal length. */
    /* There are limits of 2,048 bytes and 16,384 (16K) bytes.   */
    if (!compileAndLinkOk(buffer)) {
      /* A string literal of size repeatCount * lineLength is not accepted. */
      fputs("#define LIMITED_CSTRI_LITERAL_LEN\n", versionFile);
    } /* if */
    free(buffer);
  } /* checkForLimitedStringLiteralLength */



static void determineStackDirection (FILE *versionFile)

  {
    int stackDir;

  /* determineStackDirection */
    if (compileAndLinkOk("#include <stdio.h>\n"
                         "char *stack_base;\n"
                         "void subFunc()\n"
                         "{char localVar;\n"
                         "printf(\"%d\\n\",stack_base<&localVar);return;}\n"
                         "int main(int argc, char *argv[])\n"
                         "{char mainVar;stack_base=&mainVar;\n"
                         "subFunc();return 0;}\n") &&
        (stackDir = doTest()) != -1) {
      if (stackDir) {
        fputs("#define STACK_GROWS_UPWARD\n", versionFile);
      } else {
        fputs("#define STACK_GROWS_DOWNWARD\n", versionFile);
      } /* if */
    } /* if */
  } /* determineStackDirection */



static void localtimeProperties (FILE *versionFile)

  { /* localtimeProperties */
#ifdef USE_ALTERNATE_LOCALTIME_R
    fputs("#define USE_LOCALTIME_R\n", versionFile);
    fprintf(versionFile, "#define LOCALTIME_WORKS_SIGNED %d\n", isSignedType("time_t"));
#else
    if (compileAndLinkOk("#include<time.h>\nint main(int argc,char *argv[])\n"
                         "{time_t ts;struct tm res;struct tm*lt;\n"
                         "lt=localtime_r(&ts,&res);return 0;}\n")) {
      fputs("#define USE_LOCALTIME_R\n", versionFile);
      if (assertCompAndLnk("#include<stdio.h>\n#include<time.h>\n"
                           "int main(int argc,char *argv[])"
                           "{time_t ts=-2147483647-1;struct tm res;struct tm*lt;\n"
                           "lt=localtime_r(&ts,&res);\n"
                           "printf(\"%d\\n\",lt!=NULL&&lt->tm_year==1);return 0;}\n")) {
        fprintf(versionFile, "#define LOCALTIME_WORKS_SIGNED %d\n", doTest() == 1);
      } /* if */
    } else if (compileAndLinkOk("#include<stdio.h>\n#include<time.h>\n"
                                "int main(int argc,char *argv[])\n"
                                "{time_t ts=0;struct tm res;int retval;\n"
                                "retval=localtime_s(&res,&ts);\n"
                                "printf(\"%d\\n\",retval==0);return 0;}\n") && doTest() == 1) {
      fputs("#define USE_LOCALTIME_S\n", versionFile);
      if (assertCompAndLnk("#include<stdio.h>\n#include<time.h>\n"
                           "int main(int argc,char *argv[])"
                           "{time_t ts=-2147483647-1;struct tm res;\n"
                           "printf(\"%d\\n\",localtime_s(&res,&ts)==0&&res.tm_year==1);return 0;}\n")) {
        fprintf(versionFile, "#define LOCALTIME_WORKS_SIGNED %d\n", doTest() == 1);
      } /* if */
    } else if (assertCompAndLnk("#include<stdio.h>\n#include<time.h>\n"
                                "int main(int argc,char *argv[])"
                                "{time_t ts=-2147483647-1;struct tm*lt;\n"
                                "lt = localtime(&ts);\n"
                                "printf(\"%d\\n\",lt!=NULL&&lt->tm_year==1);return 0;}\n")) {
      fprintf(versionFile, "#define LOCALTIME_WORKS_SIGNED %d\n", doTest() == 1);
    } /* if */
#endif
  } /* localtimeProperties */



static const char *defineMakeDir (void)

  {
    const char *makeDirDefinition = NULL;

  /* defineMakeDir */
    if (compileAndLinkOk("#include <stdio.h>\n#include <direct.h>\n"
                         "int main(int argc,char *argv[])\n"
                         "{mkdir(\"tmp_empty_dir1\");return 0;}\n")) {
      makeDirDefinition = "#include <direct.h>\n"
                          "#define makeDir(path,mode) mkdir(path)\n";
    } else if (compileAndLinkOk("#include <stdio.h>\n"
                                "#include <sys/stat.h>\n#include <sys/types.h>\n"
                                "int main(int argc,char *argv[])\n"
                                "{mkdir(\"tmp_empty_dir1\");return 0;}\n")) {
      makeDirDefinition = "#include <sys/stat.h>\n#include <sys/types.h>\n"
                          "#define makeDir(path,mode) mkdir(path)\n";
    } else if (compileAndLinkOk("#include <stdio.h>\n#include <direct.h>\n"
                                "int main(int argc,char *argv[])\n"
                                "{_mkdir(\"tmp_empty_dir1\");return 0;}\n")) {
      makeDirDefinition = "#include <direct.h>\n"
                          "#define makeDir(path,mode) _mkdir(path)\n";
    } else if (compileAndLinkOk("#include <stdio.h>\n"
                                "#include <sys/stat.h>\n#include <sys/types.h>\n"
                                "int main(int argc,char *argv[])\n"
                                "{_mkdir(\"tmp_empty_dir1\");return 0;}\n")) {
      makeDirDefinition = "#include <sys/stat.h>\n#include <sys/types.h>\n"
                          "#define makeDir(path,mode) _mkdir(path)\n";
    } else if (compileAndLinkOk("#include <stdio.h>\n#include <direct.h>\n"
                                "int main(int argc,char *argv[])\n"
                                "{mkdir(\"tmp_empty_dir1\", 0755);return 0;}\n")) {
      makeDirDefinition = "#include <direct.h>\n"
                          "#define makeDir(path,mode) mkdir(path,mode)\n";
    } else if (compileAndLinkOk("#include <stdio.h>\n"
                                "#include <sys/stat.h>\n#include <sys/types.h>\n"
                                "int main(int argc,char *argv[])\n"
                                "{mkdir(\"tmp_empty_dir1\", 0755);return 0;}\n")) {
      makeDirDefinition = "#include <sys/stat.h>\n#include <sys/types.h>\n"
                          "#define makeDir(path,mode) mkdir(path,mode)\n";
    } /* if */
    return makeDirDefinition;
  } /* defineMakeDir */



static void checkRemoveDir (const char *makeDirDefinition, FILE *versionFile)

  {
    char buffer[BUFFER_SIZE];

  /* checkRemoveDir */
    sprintf(buffer, "#include <stdio.h>\n#include <unistd.h>\n%s"
                    "int main(int argc,char *argv[])\n"
                    "{int rmFail=0;makeDir(\"tmp_empty_dir1\",0755);\n"
                    "if(remove(\"tmp_empty_dir1\")!=0){rmFail=1;rmdir(\"tmp_empty_dir1\");}\n"
                    "printf(\"%%d\\n\",rmFail);return 0;}\n",
                    makeDirDefinition);
    if (compileAndLinkOk(buffer)) {
      fprintf(versionFile, "#define REMOVE_FAILS_FOR_EMPTY_DIRS %d\n", doTest() == 1);
    } else {
      sprintf(buffer, "#include <stdio.h>\n#include <direct.h>\n%s"
                      "int main(int argc,char *argv[])\n"
                      "{int rmFail=0;makeDir(\"tmp_empty_dir1\",0755);\n"
                      "if(remove(\"tmp_empty_dir1\")!=0){rmFail=1;rmdir(\"tmp_empty_dir1\");}\n"
                      "printf(\"%%d\\n\",rmFail);return 0;}\n",
                      makeDirDefinition);
      if (compileAndLinkOk(buffer)) {
        fprintf(versionFile, "#define REMOVE_FAILS_FOR_EMPTY_DIRS %d\n", doTest() == 1);
      } /* if */
    } /* if */
  } /* checkRemoveDir */



/**
 *  Determine values for DEFINE_OS_ENVIRON, DECLARE_OS_ENVIRON and
 *  INITIALIZE_OS_ENVIRON.
 */
static void determineEnvironDefines (FILE *versionFile)

  {
    char buffer[BUFFER_SIZE];
    int declare_os_environ = 0;
    int use_get_environment = 0;
    int initialize_os_environ = 0;

  /* determineEnvironDefines */
    buffer[0] = '\0';
    if (compileAndLinkOk("#include <stdio.h>\n#include <stdlib.h>\n#include \"tst_vers.h\"\n"
                         "int main(int argc,char *argv[])\n"
                         "{printf(\"%d\\n\", os_environ != NULL);return 0;}\n")) {
      strcat(buffer, "#include <stdlib.h>\n");
    } else if (compileAndLinkOk("#include <stdio.h>\n#include <unistd.h>\n#include \"tst_vers.h\"\n"
                                "int main(int argc,char *argv[])\n"
                                "{printf(\"%d\\n\", os_environ != NULL);return 0;}\n")) {
      strcat(buffer, "#include <unistd.h>\n");
#ifdef OS_STRI_WCHAR
    } else if (compileAndLinkOk("#include <stdio.h>\n#include \"tst_vers.h\"\n"
                                "int main(int argc,char *argv[])\n"
                                "{extern wchar_t **os_environ;\n"
                                "printf(\"%d\\n\", os_environ != NULL);return 0;}\n")) {
      declare_os_environ = 1;
#else
    } else if (compileAndLinkOk("#include <stdio.h>\n#include \"tst_vers.h\"\n"
                                "int main(int argc,char *argv[])\n"
                                "{extern char **os_environ;\n"
                                "printf(\"%d\\n\", os_environ != NULL);return 0;}\n")) {
      declare_os_environ = 1;
#endif
    } else {
      use_get_environment = 1;
    } /* if */
    fprintf(versionFile, "#define DECLARE_OS_ENVIRON %d\n", declare_os_environ);
    fprintf(versionFile, "#define USE_GET_ENVIRONMENT %d\n", use_get_environment);
    if (!use_get_environment) {
      strcat(buffer, "#include <stdio.h>\n");
      strcat(buffer, "#include \"tst_vers.h\"\n");
#ifdef OS_STRI_WCHAR
      strcat(buffer, "typedef wchar_t *os_striType;\n");
#else
      strcat(buffer, "typedef char *os_striType;\n");
#endif
      if (declare_os_environ) {
        strcat(buffer, "extern os_striType *os_environ;\n");
      } /* if */
#ifdef USE_WMAIN
      strcat(buffer, "int wmain(int argc,wchar_t *argv[])");
#else
      strcat(buffer, "int main(int argc,char *argv[])");
#endif
      strcat(buffer, "{printf(\"%d\\n\",os_environ==(os_striType *)0);return 0;}\n");
      if (!compileAndLinkOk(buffer) || doTest() == 1) {
        initialize_os_environ = 1;
      } /* if */
    } /* if */
    fprintf(versionFile, "#define INITIALIZE_OS_ENVIRON %d\n", initialize_os_environ);
  } /* determineEnvironDefines */



static void determineGetaddrlimit (FILE *versionFile)

  {
    int has_getrlimit;

  /* determineGetaddrlimit */
    /* In FreeBSD it is necessary to include <sys/types.h> before <sys/resource.h> */
    has_getrlimit = compileAndLinkOk("#include <stdio.h>\n"
                                     "#include <sys/types.h>\n#include <sys/resource.h>\n"
                                     "int main(int argc, char *argv[]){\n"
                                     "struct rlimit rlim;\n"
                                     "printf(\"%d\\n\", getrlimit(RLIMIT_STACK, &rlim) == 0);\n"
                                     "return 0;}\n") && doTest() == 1;
    fprintf(versionFile, "#define HAS_GETRLIMIT %d\n", has_getrlimit);
    if (has_getrlimit) {
      if (assertCompAndLnk("#include <stdio.h>\n"
                           "#include <sys/types.h>\n#include <sys/resource.h>\n"
                           "int main(int argc, char *argv[]){\n"
                           "struct rlimit rlim;\n"
                           "getrlimit(RLIMIT_STACK, &rlim);"
                           "if (rlim.rlim_cur == RLIM_INFINITY)\n"
                           "printf(\"0\\n\");\n"
                           "else\n"
                           "printf(\"%d\\n\", rlim.rlim_cur / 1024);\n"
                           "return 0;}\n")) {
        fprintf(versionFile, "#define SOFT_STACK_LIMIT %lu\n", (unsigned long) doTest() * 1024);
      } /* if */
      if (assertCompAndLnk("#include <stdio.h>\n"
                           "#include <sys/types.h>\n#include <sys/resource.h>\n"
                           "int main(int argc, char *argv[]){\n"
                           "struct rlimit rlim;\n"
                           "getrlimit(RLIMIT_STACK, &rlim);"
                           "if (rlim.rlim_max == RLIM_INFINITY)\n"
                           "printf(\"0\\n\");\n"
                           "else\n"
                           "printf(\"%d\\n\", rlim.rlim_max / 1024);\n"
                           "return 0;}\n")) {
        fprintf(versionFile, "#define HARD_STACK_LIMIT %lu\n", (unsigned long) doTest() * 1024);
      } /* if */
    } /* if */
  } /* determineGetaddrlimit */



static void determineOsDirAccess (FILE *versionFile)

  {
    char *dir_include = NULL;
    char *dir_define = NULL;
    char buffer[BUFFER_SIZE];

  /* determineOsDirAccess */
    if (compileAndLinkOk("#include <stdio.h>\n#include <dirent.h>\n"
                         "int main(int argc,char *argv[])\n"
                         "{DIR *directory; struct dirent *dirEntry;\n"
                         "printf(\"%d\\n\", (directory = opendir(\".\")) != NULL &&\n"
                         "(dirEntry = readdir(directory)) != NULL &&\n"
                         "closedir(directory) == 0);\n"
                         "return 0;}\n")) {
      dir_include = "<dirent.h>";
      dir_define = "USE_DIRENT";
    } else {
#ifdef OS_STRI_WCHAR
      dir_include = "\"dir_win.h\"";
      dir_define = "USE_DIRWIN";
#else
      fprintf(logFile, "\n *** Cannot define USE_DIRENT or USE_DIRWIN.\n");
#endif
    } /* if */
#ifdef OS_STRI_WCHAR
    if (dir_include != NULL) {
      fputs("#define USE_DIRWIN\n", versionFile);
      fputs("#define os_DIR WDIR\n", versionFile);
      fputs("#define os_dirent_struct struct wdirent\n", versionFile);
      fputs("#define os_opendir wopendir\n", versionFile);
      fputs("#define os_readdir wreaddir\n", versionFile);
      fputs("#define os_closedir wclosedir\n", versionFile);
    } /* if */
#else
    if (dir_define != NULL) {
      fprintf(versionFile, "#define %s\n", dir_define);
    } /* if */
#endif
  } /* determineOsDirAccess */



static void determineOsUtime (FILE *versionFile)

  {
    char *utime_include = NULL;
    char *os_utimbuf_struct_stri = NULL;
    char *os_utime_stri = NULL;
    char buffer[BUFFER_SIZE];

  /* determineOsUtime */
    if (compileAndLinkOk("#include <stdio.h>\n#include <utime.h>\n"
                         "int main(int argc,char *argv[])\n"
                         "{struct _utimbuf buf; buf.actime = 0, buf.modtime = 0;\n"
                         "printf(\"%d\\n\", &buf != NULL); return 0;}\n")) {
      utime_include = "utime.h";
      os_utimbuf_struct_stri = "struct _utimbuf";
    } else if (compileAndLinkOk("#include <stdio.h>\n#include <utime.h>\n"
                         "int main(int argc,char *argv[])\n"
                         "{struct utimbuf buf; buf.actime = 0, buf.modtime = 0;\n"
                         "printf(\"%d\\n\",  &buf != NULL); return 0;}\n")) {
      utime_include = "utime.h";
      os_utimbuf_struct_stri = "struct utimbuf";
    } else if (compileAndLinkOk("#include <stdio.h>\n#include <sys/utime.h>\n"
                         "int main(int argc,char *argv[])\n"
                         "{struct _utimbuf buf; buf.actime = 0, buf.modtime = 0;\n"
                         "printf(\"%d\\n\",  &buf != NULL); return 0;}\n")) {
      utime_include = "sys/utime.h";
      os_utimbuf_struct_stri = "struct _utimbuf";
      fputs("#define INCLUDE_SYS_UTIME\n", versionFile);
    } else if (compileAndLinkOk("#include <stdio.h>\n#include <sys/utime.h>\n"
                         "int main(int argc,char *argv[])\n"
                         "{struct utimbuf buf; buf.actime = 0, buf.modtime = 0;\n"
                         "printf(\"%d\\n\",  &buf != NULL); return 0;}\n")) {
      utime_include = "sys/utime.h";
      os_utimbuf_struct_stri = "struct utimbuf";
      fputs("#define INCLUDE_SYS_UTIME\n", versionFile);
    } /* if */
    if (utime_include == NULL || os_utimbuf_struct_stri == NULL) {
      fprintf(logFile, "\n *** Cannot find utime.h include and os_utimbuf_struct.\n");
    } else {
      fprintf(versionFile, "#define os_utimbuf_struct %s\n", os_utimbuf_struct_stri);
      sprintf(buffer, "#include <stdio.h>\n#include <%s>\n"
                      "int main(int argc,char *argv[])\n"
                      "{%s buf; buf.actime = 0, buf.modtime = 0;\n"
                      "printf(\"%%d\\n\", _wutime(L\"testfile\", &buf) != -1);return 0;}\n",
                      utime_include, os_utimbuf_struct_stri);
      if (compileAndLinkOk(buffer)) {
        os_utime_stri = "_wutime";
      } else {
        sprintf(buffer, "#include <stdio.h>\n#include <%s>\n"
                        "int main(int argc,char *argv[])\n"
                        "{%s buf; buf.actime = 0, buf.modtime = 0;\n"
                        "printf(\"%%d\\n\", wutime(L\"testfile\", &buf) != -1);return 0;}\n",
                        utime_include, os_utimbuf_struct_stri);
        if (compileAndLinkOk(buffer)) {
          os_utime_stri = "wutime";
        } /* if */
      } /* if */
      if (os_utime_stri != NULL) {
        sprintf(buffer,
                "#include <stdio.h>\n#include <%s>\n#include <errno.h>\n%s"
                "int main(int argc,char *argv[])"
                "{%s utime_buf;makeDir(\"tmp_empty_dir2\",0755);\n"
                "utime_buf.actime=1234567890;utime_buf.modtime=1234567890;\n"
                "printf(\"%%d\\n\",utime(\"tmp_empty_dir2\",&utime_buf)!=0&&errno==EACCES);\n"
                "if(remove(\"tmp_empty_dir2\")!=0)rmdir(\"tmp_empty_dir2\");return 0;}\n",
                utime_include, makeDirDefinition, os_utimbuf_struct_stri);
        if (compileAndLinkOk(buffer) && doTest() == 1) {
          fputs("#define USE_ALTERNATE_UTIME\n", versionFile);
          fprintf(versionFile, "#define os_utime_orig %s\n", os_utime_stri);
          fputs("#define os_utime alternate_utime\n", versionFile);
        } else {
          fprintf(versionFile, "#define os_utime %s\n", os_utime_stri);
        } /* if */
      } else {
        fprintf(logFile, "\n *** Cannot define os_utime.\n");
      } /* if */
    } /* if */
  } /* determineOsUtime */



#ifdef OS_STRI_WCHAR
static void determineOsWCharFunctions (FILE *versionFile)

  { /* determineOsWCharFunctions */
#ifndef os_chdir
    if (compileAndLinkOk("#include <stdio.h>\n#include <direct.h>\n"
                         "int main(int argc,char *argv[])\n"
                         "{printf(\"%d\\n\", _wchdir(L\"..\") != -1);return 0;}\n")) {
      fputs("#define os_chdir _wchdir\n", versionFile);
    } else {
      fprintf(logFile, "\n *** Cannot define os_chdir.\n");
      showErrors();
    } /* if */
#endif
#ifndef os_getcwd
    if (compileAndLinkOk("#include <stdio.h>\n#include <wchar.h>\n#include <direct.h>\n"
                         "int main(int argc,char *argv[])\n"
                         "{wchar_t buffer[1024];\n"
                         "printf(\"%d\\n\", _wgetcwd(buffer, 1024) != NULL);return 0;}\n")) {
      fputs("#define OS_GETCWD_MAX_BUFFER_SIZE INT_MAX\n", versionFile);
      fputs("#define os_getcwd(buf,size) _wgetcwd((buf),(int)(size))\n", versionFile);
    } else {
      fprintf(logFile, "\n *** Cannot define os_getcwd.\n");
      showErrors();
    } /* if */
#endif
#ifndef os_mkdir
    if (compileAndLinkOk("#include <stdio.h>\n#include <direct.h>\n"
                         "int main(int argc,char *argv[])\n"
                         "{printf(\"%d\\n\", _wmkdir(L\"testdir\") != -1);return 0;}\n")) {
      fputs("#define os_mkdir(path,mode) _wmkdir(path)\n", versionFile);
    } else {
      fprintf(logFile, "\n *** Cannot define os_mkdir.\n");
      showErrors();
    } /* if */
#endif
#ifndef os_rmdir
    if (compileAndLinkOk("#include <stdio.h>\n#include <direct.h>\n"
                         "int main(int argc,char *argv[])\n"
                         "{printf(\"%d\\n\", _wrmdir(L\"testdir\") != -1);return 0;}\n")) {
      fputs("#define os_rmdir _wrmdir\n", versionFile);
    } else {
      fprintf(logFile, "\n *** Cannot define os_rmdir.\n");
      showErrors();
    } /* if */
#endif
#ifndef os_chmod
    if (compileAndLinkOk("#include <stdio.h>\n#include <direct.h>\n"
                         "int main(int argc,char *argv[])\n"
                         "{printf(\"%d\\n\", _wchmod(L\"testfile\",0777) != -1);return 0;}\n")) {
      fputs("#define os_chmod _wchmod\n", versionFile);
    } else if (compileAndLinkOk("#include <stdio.h>\n#include <direct.h>\n#include <io.h>\n"
                         "int main(int argc,char *argv[])\n"
                         "{printf(\"%d\\n\", _wchmod(L\"testfile\",0777) != -1);return 0;}\n")) {
      fputs("#define OS_CHMOD_INCLUDE_IO_H\n", versionFile);
      fputs("#define os_chmod _wchmod\n", versionFile);
    } else {
      fprintf(logFile, "\n *** Cannot define os_chmod.\n");
      showErrors();
    } /* if */
#endif
#ifndef os_chown
    fputs("#define os_chown(name,uid,gid)\n", versionFile);
#endif
#ifndef os_utime
    determineOsUtime(versionFile);
#endif
#ifndef os_remove
    if (compileAndLinkOk("#include <stdio.h>\n"
                         "int main(int argc,char *argv[])\n"
                         "{printf(\"%d\\n\", _wremove(L\"testfile\") != -1);return 0;}\n")) {
      fputs("#define os_remove _wremove\n", versionFile);
    } else {
      fprintf(logFile, "\n *** Cannot define os_remove.\n");
      showErrors();
    } /* if */
#endif
#ifndef os_rename
    if (compileAndLinkOk("#include <stdio.h>\n"
                         "int main(int argc,char *argv[])\n"
                         "{printf(\"%d\\n\", _wrename(L\"testfile\", L\"newname\") == 0);return 0;}\n")) {
      fputs("#define os_rename _wrename\n", versionFile);
    } else {
      fprintf(logFile, "\n *** Cannot define os_rename.\n");
      showErrors();
    } /* if */
#endif
#ifndef os_system
    if (compileAndLinkOk("#include <stdio.h>\n#include <stdlib.h>\n"
                         "int main(int argc,char *argv[])\n"
                         "{printf(\"%d\\n\", _wsystem(L\"pwd\") != -1);return 0;}\n")) {
      fputs("#define os_system _wsystem\n", versionFile);
    } else {
      fprintf(logFile, "\n *** Cannot define os_system.\n");
      showErrors();
    } /* if */
#endif
#ifndef os_fopen
    if (compileAndLinkOk("#include <stdio.h>\n"
                         "int main(int argc,char *argv[])\n"
                         "{printf(\"%d\\n\", _wfopen(L\"testfile\", L\"r\") != NULL);return 0;}\n")) {
      fputs("#define os_fopen _wfopen\n", versionFile);
    } else if (compileAndLinkOk("#include <stdio.h>\n"
                         "int main(int argc,char *argv[])\n"
                         "{printf(\"%d\\n\", wfopen(L\"testfile\", L\"r\") != NULL);return 0;}\n")) {
      fputs("#define os_fopen wfopen\n", versionFile);
    } else {
      fprintf(logFile, "\n *** Cannot define os_fopen.\n");
      showErrors();
    } /* if */
#endif
#ifndef os_popen
    if (compileAndLinkOk("#include <stdio.h>\n"
                         "int main(int argc,char *argv[])\n"
                         "{printf(\"%d\\n\", _wpopen(L\"pwd\", L\"r\") != NULL);return 0;}\n")) {
      fputs("#define os_popen _wpopen\n", versionFile);
    } else if (compileAndLinkOk("#include <stdio.h>\n"
                         "int main(int argc,char *argv[])\n"
                         "{printf(\"%d\\n\", wpopen(L\"pwd\", L\"r\") != NULL);return 0;}\n")) {
      fputs("#define os_popen wpopen\n", versionFile);
    } else {
      fputs("#define DEFINE_WPOPEN FILE *wpopen (const wchar_t *command, const wchar_t *mode) { return NULL; }\n", versionFile);
      fputs("#define os_popen wpopen\n", versionFile);
    } /* if */
#endif
#ifndef os_pclose
    if (compileAndLinkOk("#include <stdio.h>\n"
                         "int main(int argc,char *argv[])\n"
                         "{printf(\"%d\\n\", _pclose(NULL) != -1);return 0;}\n")) {
      fputs("#define os_pclose _pclose\n", versionFile);
    } else {
      fprintf(logFile, "\n *** Cannot define os_pclose.\n");
      showErrors();
    } /* if */
#endif
#ifndef os_getenv
    if (compileAndLinkOk("#include <stdio.h>\n#include <stdlib.h>\n"
                         "int main(int argc,char *argv[])\n"
                         "{printf(\"%d\\n\", _wgetenv(L\"PATH\") != NULL);return 0;}\n")) {
      fputs("#define os_getenv _wgetenv\n", versionFile);
    } else if (compileAndLinkOk("#include <stdio.h>\n#include <stdlib.h>\n"
                         "int main(int argc,char *argv[])\n"
                         "{printf(\"%d\\n\", wgetenv(L\"PATH\") != NULL);return 0;}\n")) {
      fputs("#define os_getenv wgetenv\n", versionFile);
    } else {
      fputs("#define DEFINE_WGETENV\n", versionFile);
      fputs("#define os_getenv wgetenv\n", versionFile);
    } /* if */
#endif
  } /* determineOsWCharFunctions */
#endif



static void determineOsFunctions (FILE *versionFile)

  { /* determineOsFunctions */
    determineOsDirAccess(versionFile);
#ifdef OS_STRI_WCHAR
    determineOsWCharFunctions(versionFile);
#endif
    if (compileAndLinkOk("#include <stdio.h>\n#include <windows.h>\n"
                         "int main(int argc,char *argv[])\n"
                         "{SetErrorMode(SEM_NOGPFAULTERRORBOX);\n"
                         "printf(\"%d\\n\", fopen(\"version.h\", \"re\") != NULL);\n"
                         "return 0;}\n")) {
      fprintf(versionFile, "#define FOPEN_SUPPORTS_CLOEXEC_MODE %d\n", doTest() == 1);
    } else if (assertCompAndLnk("#include <stdio.h>\n"
                                "int main(int argc,char *argv[])\n"
                                "{printf(\"%d\\n\", fopen(\"version.h\", \"re\") != NULL);"
                                "return 0;}\n")) {
      fprintf(versionFile, "#define FOPEN_SUPPORTS_CLOEXEC_MODE %d\n", doTest() == 1);
    } /* if */
    fprintf(versionFile,
            "#define HAS_FCNTL_SETFD_CLOEXEC %d\n",
            compileAndLinkOk("#include <stdio.h>\n#include <unistd.h>\n"
                             "#include <fcntl.h>\n"
                             "int main(int argc,char *argv[])\n"
                             "{FILE *aFile;int fd;\n"
                             "printf(\"%d\\n\",\n"
                             "(aFile = fopen(\"version.h\", \"r\")) != NULL &&\n"
                             "(fd = fileno(aFile)) != -1 &&\n"
                             "fcntl(fd,F_SETFD,FD_CLOEXEC) == 0);\n"
                             "return 0;}\n") &&
            doTest() == 1);
    fprintf(versionFile,
            "#define HAS_PIPE2 %d\n",
            compileAndLinkOk("#include <stdio.h>\n#include <unistd.h>\n"
                             "int main(int argc,char *argv[])\n"
                             "{int pipefd[2];\n"
                             "printf(\"%d\\n\", pipe2(pipefd, O_CLOEXEC) == 0);\n"
                             "return 0;}\n") &&
            doTest() == 1);
  } /* determineOsFunctions */



static void appendToFile (const char *fileName, const char *data)

  {
    FILE *outFile;

  /* appendToFile */
    outFile = fopen(fileName, "a");
    if (outFile != NULL) {
      fputs(data, outFile);
      fclose(outFile);
    } /* if */
  } /* appendToFile */



static void replaceNLBySpace (char *text)

  { /* replaceNLBySpace */
    while (*text != '\0') {
      if (*text == '\n') {
        *text = ' ';
      } /* if */
      text++;
    } /* while */
  } /* replaceNLBySpace */



static void escapeString (FILE *versionFile, const char *text)

  { /* escapeString */
    while (*text != '\0') {
      if (*text == '\"' || *text == '\\') {
        putc('\\', versionFile);
        putc(*text, versionFile);
      } else if (*text == '\n') {
        fputs("\\n", versionFile);
      } else {
        putc(*text, versionFile);
      } /* if */
      text++;
    } /* while */
  } /* escapeString */



static void appendOption (char *include_options, const char *includeOption)

  { /* appendOption */
    if (strstr(include_options, includeOption) == NULL) {
      if (include_options[0] != '\0' && includeOption != '\0') {
        strcat(include_options, "\n");
      } /* if */
      strcat(include_options, includeOption);
    } /* if */
  } /* appendOption */



static void determineX11Includes (FILE *versionFile, char *include_options)

  { /* determineX11Includes */
    if (!fileIsDir("/usr/include/X11") &&
        fileIsDir("/opt/X11/include/X11")) {
      appendOption(include_options, "-I/opt/X11/include");
    } /* if */
  } /* determineX11Includes */



#ifdef WITH_SQL
static void determineMySqlDefines (FILE *versionFile,
    char *include_options, char *system_db_libs)

  {
    const char *dbHomeSys[] = {"MariaDB/MariaDB C Client Library",
                               "MariaDB/MariaDB C Client Library 64-bit",
                               "MySQL/MySQL Connector C 6.1"};
#ifdef MYSQL_DLL
    const char *dllNameList[] = { MYSQL_DLL };
#else
    const char *dllNameList[] = {"libmariadb.dll", "libmysql.dll"};
#endif
    const char *libNameList[] = {"mariadbclient.lib", "vs11/mysqlclient.lib"};
    const char *programFilesX86 = NULL;
    const char *programFiles = NULL;
    const char *libName = NULL;
    char dbHome[BUFFER_SIZE];
    char includeOption[BUFFER_SIZE];
    const char *mySqlInclude;
    char buffer[BUFFER_SIZE];
    char linkerOptions[BUFFER_SIZE];
    int dbHomeExists = 0;
    int writeDllList = 0;
    int idx;

  /* determineMySqlDefines */
#ifdef MYSQL_INCLUDE_OPTIONS
    strcpy(includeOption, MYSQL_INCLUDE_OPTIONS);
    mySqlInclude = "mysql.h";
#else
    includeOption[0] = '\0';
    mySqlInclude = "mysql/mysql.h";
#endif
    programFilesX86 = getenv("ProgramFiles(x86)");
    /* fprintf(logFile, "programFilesX86: %s\n", programFilesX86); */
    programFiles = getenv("ProgramFiles");
    /* fprintf(logFile, "programFiles: %s\n", programFiles); */
    if (programFiles != NULL) {
      if (sizeof(char *) == 4 && programFilesX86 != NULL) {
        programFiles = programFilesX86;
      } /* if */
      for (idx = 0; !dbHomeExists && idx < sizeof(dbHomeSys) / sizeof(char *); idx++) {
        sprintf(dbHome, "%s/%s", programFiles, dbHomeSys[idx]);
        if (fileIsDir(dbHome)) {
          dbHomeExists = 1;
        } /* if */
      } /* for */
    } /* if */
    if (dbHomeExists) {
      /* fprintf(logFile, "dbHome=%s\n", dbHome); */
      sprintf(includeOption, "-I\"%s/include\"", dbHome);
      /* fprintf(logFile, "includeOption=%s\n", includeOption); */
      if (compileAndLinkWithOptionsOk("#include \"stdlib.h\"\n#include \"mysql.h\"\n"
                                      "int main(int argc,char *argv[]){return 0;}\n",
                                      includeOption, "")) {
        mySqlInclude = "mysql.h";
        fprintf(logFile, "\rMySql/MariaDb: %s found in %s/include\n", mySqlInclude, dbHome);
        appendOption(include_options, includeOption);
      } else {
        mySqlInclude = NULL;
      } /* if */
    } else {
      sprintf(buffer, "#include <%s>\n"
                      "int main(int argc,char *argv[]){return 0;}\n", mySqlInclude);
      if (compileAndLinkWithOptionsOk(buffer, includeOption, "")) {
        fprintf(logFile, "\rMySql/MariaDb: %s found in system include directory.\n", mySqlInclude);
        appendOption(include_options, includeOption);
      } else if (compileAndLinkWithOptionsOk("#include \"db_my.h\"\n"
                                             "int main(int argc,char *argv[]){return 0;}\n",
                                             includeOption, "") ||
                 compileAndLinkWithOptionsOk("#define STDCALL\n"
                                             "#include \"db_my.h\"\n"
                                             "int main(int argc,char *argv[]){return 0;}\n",
                                             includeOption, "")) {
        mySqlInclude = "db_my.h";
        fprintf(logFile, "\rMySql/MariaDb: %s found in Seed7 include directory.\n", mySqlInclude);
      } /* if */
    } /* if */
    if (mySqlInclude != NULL) {
      fprintf(versionFile, "#define MYSQL_INCLUDE \"%s\"\n", mySqlInclude);
    } /* if */
    /* Handle libraries: */
    if (dbHomeExists) {
#ifdef MYSQL_USE_LIB
      for (idx = 0; libName == NULL && idx < sizeof(libNameList) / sizeof(char *); idx++) {
        sprintf(buffer, "%s/lib/%s", dbHome, libNameList[idx]);
        if (fileIsRegular(buffer)) {
          libName = libNameList[idx];
        } /* if */
      } /* for */
      if (libName != NULL) {
        fprintf(logFile, "\rMySql/MariaDb: %s found at: %s\n", libName, buffer);
        sprintf(buffer, "\"%s/lib/%s\"", dbHome, libName);
        appendOption(system_db_libs, buffer);
      } else {
        writeDllList = 1;
      } /* if */
#else
      writeDllList = 1;
#endif
      if (writeDllList) {
        fprintf(versionFile, "#define MYSQL_DLL");
        for (idx = 0; idx < sizeof(dllNameList) / sizeof(char *); idx++) {
          sprintf(buffer, "%s/lib/%s", dbHome, dllNameList[idx]);
          if (fileIsRegular(buffer)) {
            fprintf(logFile, "\rMySql/MariaDb: %s found at: %s\n", dllNameList[idx], buffer);
            fprintf(versionFile, " \"");
            escapeString(versionFile, buffer);
            fprintf(versionFile, "\",");
          } /* if */
        } /* for */
        for (idx = 0; idx < sizeof(dllNameList) / sizeof(char *); idx++) {
          fprintf(versionFile, " \"%s\",", dllNameList[idx]);
        } /* for */
        fprintf(versionFile, "\n");
      } /* if */
    } else {
#if defined MYSQL_USE_LIB && defined MYSQL_LIBS
      sprintf(buffer, "#include \"stdlib.h\"\n#include \"%s\"\n"
                      "int main(int argc,char *argv[]){\n"
                      "MYSQL *conn;\n"
                      "conn = mysql_init(NULL);\n"
                      "if (conn != NULL) {\n"
                      "mysql_real_connect(conn, \"\", \"\", \"\", \"\", 0, NULL, 0);\n"
                      "mysql_close(conn);\n"
                      "}\nreturn 0;\n}\n", mySqlInclude);
      linkerOptions[0] = '\0';
#ifdef MYSQL_LIBRARY_PATH
      appendOption(linkerOptions, MYSQL_LIBRARY_PATH);
#endif
      appendOption(linkerOptions, MYSQL_LIBS);
      if (compileAndLinkWithOptionsOk(buffer, includeOption, linkerOptions)) {
#ifdef MYSQL_LIBRARY_PATH
        appendOption(system_db_libs, MYSQL_LIBRARY_PATH);
#endif
        fprintf(logFile, "\rMySql/MariaDb: Linker option: %s\n", MYSQL_LIBS);
        appendOption(system_db_libs, MYSQL_LIBS);
      } else {
        writeDllList = 1;
      } /* if */
#else
      writeDllList = 1;
#endif
      if (writeDllList) {
        fprintf(versionFile, "#define MYSQL_DLL");
        for (idx = 0; idx < sizeof(dllNameList) / sizeof(char *); idx++) {
          fprintf(logFile, "\rMySql/MariaDb: DLL / Shared library: %s\n", dllNameList[idx]);
          fprintf(versionFile, " \"%s\",", dllNameList[idx]);
        } /* for */
        fprintf(versionFile, "\n");
      } /* if */
    } /* if */
  } /* determineMySqlDefines */



static void determineSqliteDefines (FILE *versionFile,
    char *include_options, char *system_db_libs)

  {
    const char *dbHomeDirs[] = {"C:/sqlite", "D:/sqlite"};
#ifdef SQLITE_DLL
    const char *dllNameList[] = { SQLITE_DLL };
#else
    const char *dllNameList[] = {"sqlite3.dll"};
#endif
    const char *libNameList[] = {"sqlite3.lib"};
    const char *dllName = NULL;
    const char *libName = NULL;
    char dbHome[BUFFER_SIZE];
    char includeOption[BUFFER_SIZE];
    const char *sqliteInclude = NULL;
    char buffer[BUFFER_SIZE];
    char linkerOptions[BUFFER_SIZE];
    int dbHomeExists = 0;
    int writeDllList = 0;
    int idx;

  /* determineSqliteDefines */
#ifdef SQLITE_INCLUDE_OPTIONS
    strcpy(includeOption, SQLITE_INCLUDE_OPTIONS);
#else
    includeOption[0] = '\0';
#endif
    for (idx = 0; !dbHomeExists && idx < sizeof(dbHomeDirs) / sizeof(char *); idx++) {
      strcpy(dbHome, dbHomeDirs[idx]);
      if (fileIsDir(dbHome)) {
        dbHomeExists = 1;
      } /* if */
    } /* for */
    if (dbHomeExists) {
      /* fprintf(logFile, "dbHome=%s\n", dbHome); */
      sprintf(includeOption, "-I\"%s\"", dbHome);
      /* fprintf(logFile, "includeOption=%s\n", includeOption); */
      if (compileAndLinkWithOptionsOk("#include <sqlite3.h>\n"
                                      "int main(int argc,char *argv[]){return 0;}\n",
                                      includeOption, "")) {
        sqliteInclude = "sqlite3.h";
        fprintf(logFile, "\rSQLite: %s found in %s\n", sqliteInclude, dbHome);
        appendOption(include_options, includeOption);
      } /* if */
    } else if (compileAndLinkWithOptionsOk("#include <sqlite3.h>\n"
                                           "int main(int argc,char *argv[]){return 0;}\n",
                                           includeOption, "")) {
      sqliteInclude = "sqlite3.h";
      fprintf(logFile, "\rSQLite: %s found in system include directory.\n", sqliteInclude);
      appendOption(include_options, includeOption);
    } else if (compileAndLinkWithOptionsOk("#include \"tst_vers.h\"\n#include \"db_lite.h\"\n"
                                           "int main(int argc,char *argv[]){return 0;}\n",
                                           includeOption, "")) {
      sqliteInclude = "db_lite.h";
      fprintf(logFile, "\rSQLite: %s found in Seed7 include directory.\n", sqliteInclude);
      appendOption(include_options, includeOption);
    } /* if */
    if (sqliteInclude != NULL) {
      fprintf(versionFile, "#define SQLITE_INCLUDE \"%s\"\n", sqliteInclude);
    } /* if */
    /* Handle libraries: */
    if (dbHomeExists) {
#ifdef SQLITE_USE_LIB
      for (idx = 0; libName == NULL && idx < sizeof(libNameList) / sizeof(char *); idx++) {
        sprintf(buffer, "%s/%s", dbHome, libNameList[idx]);
        if (fileIsRegular(buffer)) {
          libName = libNameList[idx];
        } /* if */
      } /* for */
      if (libName != NULL) {
        fprintf(logFile, "\rSQLite: %s found at: %s\n", libName, buffer);
        sprintf(buffer, "\"%s/%s\"", dbHome, libName);
        appendOption(system_db_libs, buffer);
      } else {
        writeDllList = 1;
      } /* if */
#else
      writeDllList = 1;
#endif
      if (writeDllList) {
        fprintf(versionFile, "#define SQLITE_DLL");
        for (idx = 0; idx < sizeof(dllNameList) / sizeof(char *); idx++) {
          sprintf(buffer, "%s/lib/%s", dbHome, dllNameList[idx]);
          if (fileIsRegular(buffer)) {
            fprintf(logFile, "\rSQLite: %s found at: %s\n", dllNameList[idx], buffer);
            fprintf(versionFile, " \"");
            escapeString(versionFile, buffer);
            fprintf(versionFile, "\",");
          } /* if */
        } /* for */
        for (idx = 0; idx < sizeof(dllNameList) / sizeof(char *); idx++) {
          fprintf(versionFile, " \"%s\",", dllNameList[idx]);
        } /* for */
        fprintf(versionFile, "\n");
      } /* if */
    } else {
#if defined SQLITE_USE_LIB && defined SQLITE_LIBS
      sprintf(buffer, "#include \"tst_vers.h\"\n#include \"%s\"\n"
                      "int main(int argc,char *argv[]){\n"
                      "sqlite3 *conn;\n"
                      "sqlite3_open(\"\", &conn);\n"
                      "sqlite3_close(conn);\n"
                      "return 0;\n}\n", sqliteInclude);
      linkerOptions[0] = '\0';
#ifdef SQLITE_LIBRARY_PATH
      appendOption(linkerOptions, SQLITE_LIBRARY_PATH);
#endif
      appendOption(linkerOptions, SQLITE_LIBS);
      if (compileAndLinkWithOptionsOk(buffer, includeOption, linkerOptions)) {
#ifdef SQLITE_LIBRARY_PATH
        appendOption(system_db_libs, SQLITE_LIBRARY_PATH);
#endif
        fprintf(logFile, "\rSQLite: Linker option: %s\n", SQLITE_LIBS);
        appendOption(system_db_libs, SQLITE_LIBS);
      } else {
        writeDllList = 1;
      } /* if */
#else
      writeDllList = 1;
#endif
      if (writeDllList) {
        fprintf(versionFile, "#define SQLITE_DLL");
        for (idx = 0; idx < sizeof(dllNameList) / sizeof(char *); idx++) {
          fprintf(logFile, "\rSQLite: DLL / Shared library: %s\n", dllNameList[idx]);
          fprintf(versionFile, " \"%s\",", dllNameList[idx]);
        } /* for */
        fprintf(versionFile, "\n");
      } /* if */
    } /* if */
  } /* determineSqliteDefines */



static void extractPostgresOid (const char* pgTypeFileName)
  {
    const char *oidNames[] = {
      "ABSTIMEOID",     "ACLITEMOID",      "ANYARRAYOID",     "ANYELEMENTOID",    "ANYENUMOID",
      "ANYNONARRAYOID", "ANYOID",          "BITOID",          "BOOLOID",          "BOXOID",
      "BPCHAROID",      "BYTEAOID",        "CASHOID",         "CHAROID",          "CIDOID",
      "CIDROID",        "CIRCLEOID",       "CSTRINGARRAYOID", "CSTRINGOID",       "DATEOID",
      "FDW_HANDLEROID", "FLOAT4ARRAYOID",  "FLOAT4OID",       "FLOAT8OID",        "GTSVECTOROID",
      "INETOID",        "INT2ARRAYOID",    "INT2OID",         "INT2VECTOROID",    "INT4ARRAYOID",
      "INT4OID",        "INT8OID",         "INTERNALOID",     "INTERVALOID",      "LANGUAGE_HANDLEROID",
      "LINEOID",        "LSEGOID",         "MACADDROID",      "NAMEOID",          "NUMERICOID",
      "OIDARRAYOID",    "OIDOID",          "OIDVECTOROID",    "OPAQUEOID",        "PATHOID",
      "PGNODETREEOID",  "POINTOID",        "POLYGONOID",      "RECORDARRAYOID",   "RECORDOID",
      "REFCURSOROID",   "REGCLASSOID",     "REGCONFIGOID",    "REGDICTIONARYOID", "REGOPERATOROID",
      "REGOPEROID",     "REGPROCEDUREOID", "REGPROCOID",      "REGTYPEARRAYOID",  "REGTYPEOID",
      "RELTIMEOID",     "TEXTARRAYOID",    "TEXTOID",         "TIDOID",           "TIMEOID",
      "TIMESTAMPOID",   "TIMESTAMPTZOID",  "TIMETZOID",       "TINTERVALOID",     "TRIGGEROID",
      "TSQUERYOID",     "TSVECTOROID",     "UNKNOWNOID",      "VARBITOID",        "VARCHAROID",
      "VOIDOID",        "XIDOID",          "XMLOID"};
    FILE *pgTypeFile;
    FILE *oidFile;
    char buffer[BUFFER_SIZE];
    char *line;
    int pos;
    int idx;
    int spaces;

  /* extractPostgresOid */
    fprintf(logFile, "\rExtracting OIDs from: %s\n", pgTypeFileName);
    pgTypeFile = fopen(pgTypeFileName, "r");
    if (pgTypeFile != NULL) {
      oidFile = fopen("pg_type.h", "w");
      if (oidFile != NULL) {
        fputs("/* Do not edit this file. It has been generated by chkccomp.c. */\n", oidFile);
        fputs("/* The contents of this file have been extracted from: */\n", oidFile);
        fprintf(oidFile, "/*   %s */\n", pgTypeFileName);
        fputs("\n", oidFile);
        while ((line = fgets(buffer, 4096, pgTypeFile)) != NULL) {
          pos = 0;
          while (line[pos] == ' ' || line[pos] == '\t') {
            pos++;
          } /* if */
          if (line[pos] == '#') {
            pos++;
            while (line[pos] == ' ' || line[pos] == '\t') {
              pos++;
            } /* if */
            if (strncmp(&line[pos], "define", 6) == 0) {
              pos += 6;
              while (line[pos] == ' ' || line[pos] == '\t') {
                pos++;
              } /* if */
              for (idx = 0; idx < sizeof(oidNames) / sizeof(char *); idx++) {
                if (strncmp(&line[pos], oidNames[idx], strlen(oidNames[idx])) == 0) {
                  fprintf(oidFile, "#define %s ", oidNames[idx]);
                  pos += strlen(oidNames[idx]);
                  while (line[pos] == ' ' || line[pos] == '\t') {
                    pos++;
                  } /* if */
                  spaces = 24 - strlen(oidNames[idx]) - strlen(&line[pos]);
                  while (spaces > 0) {
                    fputc(' ', oidFile);
                    spaces--;
                  } /* while */
                  fputs(&line[pos], oidFile);
                  idx = sizeof(oidNames) / sizeof(char *);
                } /* if */
              } /* for */
            } /* if */
          } /* if */
        } /* while */
        fclose(oidFile);
      } /* if */
      fclose(pgTypeFile);
    } /* if */
  } /* extractPostgresOid */



static int findPgTypeInclude (const char *includeOption, const char *pgTypeInclude)

  {
    const char *optionPos;
    const char *optionEnd;
    char includeDir[BUFFER_SIZE];
    char pgTypeFileName[BUFFER_SIZE];
    int found = 0;

  /* findPgTypeInclude */
    /* fprintf(logFile, "findPgTypeInclude(\"%s\")\n", includeOption); */
    while (includeOption != NULL && (optionPos = strstr(includeOption, "-I")) != NULL) {
      if (optionPos[2] == '\"') {
        optionEnd = strchr(&optionPos[3], '\"');
        if (optionEnd == NULL) {
          strcpy(includeDir, &optionPos[3]);
          includeOption = NULL;
        } else {
          memcpy(includeDir, &optionPos[3], optionEnd - &optionPos[3]);
          includeDir[optionEnd - &optionPos[3]] = '\0';
          includeOption = optionEnd + 1;
        } /* if */
      } else {
        optionEnd = strchr(&optionPos[2], ' ');
        if (optionEnd == NULL) {
          strcpy(includeDir, &optionPos[2]);
          includeOption = NULL;
        } else {
          memcpy(includeDir, &optionPos[2], optionEnd - &optionPos[2]);
          includeDir[optionEnd - &optionPos[2]] = '\0';
          includeOption = optionEnd + 1;
        } /* if */
      } /* if */
      /* fprintf(logFile, "includeDir: \"%s\"\n", includeDir); */
      if (includeDir[0] != '\0'  && fileIsDir(includeDir)) {
        sprintf(pgTypeFileName, "%s/%s", includeDir, pgTypeInclude);
        if (fileIsRegular(pgTypeFileName)) {
          extractPostgresOid(pgTypeFileName);
          includeOption = NULL;
          found = 1;
        } /* if */
      } /* if */
    } /* while */
    return found;
  } /* findPgTypeInclude */



static void determinePostgresDefines (FILE *versionFile,
    char *include_options, char *system_db_libs)

  {
    const char *dbHomeSys[] = {"PostgreSQL/9.5", "PostgreSQL/9.4", "PostgreSQL/9.3",
                               "PostgreSQL/9.2", "PostgreSQL/9.1", "PostgreSQL/9.0",
                               "PostgreSQL/8.4", "PostgreSQL/8.3"};
#ifdef POSTGRESQL_DLL
    const char *dllNameList[] = { POSTGRESQL_DLL };
#else
    const char *dllNameList[] = {"libpq.dll"};
#endif
    const char *libNameList[] = {"libpq.lib"};
    const char *libIntlDllList[] = {"libintl.dll", "libintl-8.dll"};
    const char *serverIncludeOption = "-I/usr/include/postgresql/server";
    const char *programFilesX86 = NULL;
    const char *programFiles = NULL;
    const char *dllName = NULL;
    const char *libName = NULL;
    char dbHome[BUFFER_SIZE];
    char includeOption[BUFFER_SIZE];
    const char *postgresqlInclude = NULL;
    const char *postgresInclude = NULL;
    const char *pgTypeInclude = NULL;
    char buffer[BUFFER_SIZE];
    char linkerOptions[BUFFER_SIZE];
    int dbHomeExists = 0;
    int writeDllList = 0;
    int idx;

  /* determinePostgresDefines */
#ifdef POSTGRESQL_INCLUDE_OPTIONS
    strcpy(includeOption, POSTGRESQL_INCLUDE_OPTIONS);
#else
    strcpy(includeOption, "-I/usr/include/postgresql");
#endif
    programFilesX86 = getenv("ProgramFiles(x86)");
    /* fprintf(logFile, "programFilesX86: %s\n", programFilesX86); */
    programFiles = getenv("ProgramFiles");
    /* fprintf(logFile, "programFiles: %s\n", programFiles); */
    if (programFiles != NULL) {
      if (sizeof(char *) == 4 && programFilesX86 != NULL) {
        programFiles = programFilesX86;
      } /* if */
      for (idx = 0; !dbHomeExists && idx < sizeof(dbHomeSys) / sizeof(char *); idx++) {
        sprintf(dbHome, "%s/%s", programFiles, dbHomeSys[idx]);
        if (fileIsDir(dbHome)) {
          dbHomeExists = 1;
        } /* if */
      } /* for */
    } /* if */
    if (dbHomeExists) {
      /* fprintf(logFile, "dbHome=%s\n", dbHome); */
      sprintf(includeOption, "-I\"%s/include\"", dbHome);
      /* fprintf(logFile, "includeOption=%s\n", includeOption); */
      if (compileAndLinkWithOptionsOk("#include \"libpq-fe.h\"\n"
                                      "int main(int argc,char *argv[]){return 0;}\n",
                                      includeOption, "")) {
        postgresqlInclude = "libpq-fe.h";
        fprintf(logFile, "\rPostgreSQL: %s found in %s/include\n", postgresqlInclude, dbHome);
        appendOption(include_options, includeOption);
        sprintf(buffer, "%s/include/server", dbHome);
        if (fileIsDir(buffer)) {
          sprintf(buffer, "%s/include/server/catalog/pg_type.h", dbHome);
        } else {
          sprintf(buffer, "%s/include/catalog/pg_type.h", dbHome);
        } /* if */
        extractPostgresOid(buffer);
        pgTypeInclude = "pg_type.h";
        fprintf(logFile, "\rPostgreSQL: %s found in Seed7 directory.\n", pgTypeInclude);
      } /* if */
    } else if (compileAndLinkWithOptionsOk("#include <libpq-fe.h>\n"
                                    "int main(int argc,char *argv[]){return 0;}\n",
                                    includeOption, "")) {
      postgresqlInclude = "libpq-fe.h";
      fprintf(logFile, "\rPostgreSQL: %s found in system include directory.\n", postgresqlInclude);
      appendOption(include_options, includeOption);
      if (compileAndLinkWithOptionsOk("#include <server/postgres.h>\n"
                                      "int main(int argc,char *argv[]){return 0;}\n",
                                      includeOption, "")) {
        postgresInclude = "server/postgres.h";
        pgTypeInclude = "server/catalog/pg_type.h";
      } else {
        appendOption(includeOption, serverIncludeOption);
        if (compileAndLinkWithOptionsOk("#include <server/postgres.h>\n"
                                        "int main(int argc,char *argv[]){return 0;}\n",
                                        includeOption, "")) {
          appendOption(include_options, serverIncludeOption);
          postgresInclude = "server/postgres.h";
          pgTypeInclude = "server/catalog/pg_type.h";
        } else {
          postgresInclude = "postgres.h";
          pgTypeInclude = "catalog/pg_type.h";
        } /* if */
      } /* if */
      sprintf(buffer, "#include <%s>\n#include <%s>\n"
                      "int main(int argc,char *argv[]){return 0;}\n",
                      postgresInclude, pgTypeInclude);
      if (compileAndLinkWithOptionsOk(buffer, includeOption, "")) {
        fprintf(logFile, "\rPostgreSQL: %s found in system include directory.\n", pgTypeInclude);
      } else if (findPgTypeInclude(includeOption, pgTypeInclude)) {
        pgTypeInclude = "pg_type.h";
        fprintf(logFile, "\rPostgreSQL: %s found in Seed7 include directory.\n", pgTypeInclude);
      } else {
        fprintf(logFile, "\rPostgreSQL: %s not found in include directories.\n", pgTypeInclude);
      } /* if */
    } else if (compileAndLinkWithOptionsOk("#include \"db_post.h\"\n"
                                           "int main(int argc,char *argv[]){return 0;}\n",
                                           "", "")) {
      postgresqlInclude = "db_post.h";
      fprintf(logFile, "\rPostgreSQL: %s found in Seed7 include directory.\n", postgresqlInclude);
    } /* if */
    if (postgresqlInclude != NULL) {
      fprintf(versionFile, "#define POSTGRESQL_INCLUDE \"%s\"\n", postgresqlInclude);
    } /* if */
    if (postgresInclude != NULL) {
      fprintf(versionFile, "#define POSTGRESQL_POSTGRES_H \"%s\"\n", postgresInclude);
    } /* if */
    if (pgTypeInclude != NULL) {
      fprintf(versionFile, "#define POSTGRESQL_PG_TYPE_H \"%s\"\n", pgTypeInclude);
    } /* if */
    /* Handle libraries: */
    if (dbHomeExists) {
#ifdef POSTGRESQL_USE_LIB
      for (idx = 0; libName == NULL && idx < sizeof(libNameList) / sizeof(char *); idx++) {
        sprintf(buffer, "%s/lib/%s", dbHome, libNameList[idx]);
        if (fileIsRegular(buffer)) {
          libName = libNameList[idx];
        } /* if */
      } /* for */
      if (libName != NULL) {
        fprintf(logFile, "\rPostgreSQL: %s found at: %s\n", libName, buffer);
        sprintf(buffer, "\"%s/lib/%s\"", dbHome, libName);
        appendOption(system_db_libs, buffer);
      } else {
        writeDllList = 1;
      } /* if */
#else
      writeDllList = 1;
#endif
      if (writeDllList) {
        fprintf(versionFile, "#define POSTGRESQL_DLL");
        for (idx = 0; idx < sizeof(dllNameList) / sizeof(char *); idx++) {
          sprintf(buffer, "%s/lib/%s", dbHome, dllNameList[idx]);
          if (fileIsRegular(buffer)) {
            fprintf(logFile, "\rPostgreSQL: %s found at: %s\n", dllNameList[idx], buffer);
            fprintf(versionFile, " \"");
            escapeString(versionFile, buffer);
            fprintf(versionFile, "\",");
          } /* if */
        } /* for */
        for (idx = 0; idx < sizeof(dllNameList) / sizeof(char *); idx++) {
          fprintf(versionFile, " \"%s\",", dllNameList[idx]);
        } /* for */
        fprintf(versionFile, "\n");
        dllName = NULL;
        for (idx = 0; dllName == NULL && idx < sizeof(libIntlDllList) / sizeof(char *); idx++) {
          sprintf(buffer, "%s/bin/%s", dbHome, libIntlDllList[idx]);
          if (fileIsRegular(buffer)) {
            dllName = libIntlDllList[idx];
          } /* if */
        } /* for */
        if (dllName != NULL) {
          fprintf(logFile, "\rPostgreSQL: %s found at: %s\n", dllName, buffer);
          fprintf(versionFile, "#define LIBINTL_DLL_PATH \"");
          escapeString(versionFile, buffer);
          fprintf(versionFile, "\"\n");
          fprintf(versionFile, "#define LIBINTL_DLL \"%s\"\n", dllName);
        } /* if */
      } /* if */
    } else {
#if defined POSTGRESQL_USE_LIB && defined POSTGRESQL_LIBS
      sprintf(buffer, "#include \"stdlib.h\"\n#include \"%s\"\n"
                      "int main(int argc,char *argv[]){\n"
                      "PGconn *conn;\n"
                      "conn = PQsetdbLogin(\"\", NULL, NULL, NULL, \"\", \"\", \"\");\n"
                      "PQfinish(conn);\n"
                      "return 0;\n}\n", postgresqlInclude);
      linkerOptions[0] = '\0';
#ifdef POSTGRESQL_LIBRARY_PATH
      appendOption(linkerOptions, POSTGRESQL_LIBRARY_PATH);
#endif
      appendOption(linkerOptions, POSTGRESQL_LIBS);
      if (compileAndLinkWithOptionsOk(buffer, includeOption, linkerOptions)) {
#ifdef POSTGRESQL_LIBRARY_PATH
        appendOption(system_db_libs, POSTGRESQL_LIBRARY_PATH);
#endif
        fprintf(logFile, "\rPostgreSQL: Linker option: %s\n", POSTGRESQL_LIBS);
        appendOption(system_db_libs, POSTGRESQL_LIBS);
      } else {
        writeDllList = 1;
      } /* if */
#else
      writeDllList = 1;
#endif
      if (writeDllList) {
        fprintf(versionFile, "#define POSTGRESQL_DLL");
        for (idx = 0; idx < sizeof(dllNameList) / sizeof(char *); idx++) {
          fprintf(logFile, "\rPostgreSQL: DLL / Shared library: %s\n", dllNameList[idx]);
          fprintf(versionFile, " \"%s\",", dllNameList[idx]);
        } /* for */
        fprintf(versionFile, "\n");
      } /* if */
    } /* if */
  } /* determinePostgresDefines */



static void determineOdbcDefines (FILE *versionFile,
    char *include_options, char *system_db_libs)

  {
#ifdef ODBC_DLL
    const char *dllNameList[] = { ODBC_DLL };
#else
    const char *dllNameList[] = {"odbc32.dll"};
#endif
    char includeOption[BUFFER_SIZE];
    int windowsOdbc = 0;
    const char *odbcInclude = NULL;
    char buffer[BUFFER_SIZE];
    char linkerOptions[BUFFER_SIZE];
    int writeDllList = 0;
    int idx;

  /* determineOdbcDefines */
#ifdef ODBC_INCLUDE_OPTIONS
    strcpy(includeOption, ODBC_INCLUDE_OPTIONS);
#else
    includeOption[0] = '\0';
#endif
    if (compileAndLinkWithOptionsOk("#include <windows.h>\n#include <sql.h>\n"
                                    "int main(int argc,char *argv[]){return 0;}\n",
                                    includeOption, "")) {
      fputs("#define WINDOWS_ODBC\n", versionFile);
      fputs("#define ODBC_INCLUDE_SQLEXT\n", versionFile);
      windowsOdbc = 1;
      odbcInclude = "sql.h";
      fprintf(logFile, "\rOdbc: %s found in system include directory.\n", odbcInclude);
    } else if (compileAndLinkWithOptionsOk("#include <sql.h>\n"
                                           "int main(int argc,char *argv[]){return 0;}\n",
                                           includeOption, "")) {
      fputs("#define ODBC_INCLUDE_SQLEXT\n", versionFile);
      odbcInclude = "sql.h";
      fprintf(logFile, "\rOdbc: %s found in system include directory.\n", odbcInclude);
    } else if (compileAndLinkWithOptionsOk("#include \"tst_vers.h\"\n#include \"db_odbc.h\"\n"
                                           "int main(int argc,char *argv[]){return 0;}\n",
                                           includeOption, "") ||
               compileAndLinkWithOptionsOk("#define STDCALL\n"
                                           "#include \"tst_vers.h\"\n#include \"db_odbc.h\"\n"
                                           "int main(int argc,char *argv[]){return 0;}\n",
                                           includeOption, "")) {
      odbcInclude = "db_odbc.h";
      fprintf(logFile, "\rOdbc: %s found in Seed7 include directory.\n", odbcInclude);
      includeOption[0] = '\0';
    } /* if */
    if (odbcInclude != NULL) {
      fprintf(versionFile, "#define ODBC_INCLUDE \"%s\"\n", odbcInclude);
      appendOption(include_options, includeOption);
    } /* if */
    /* Handle libraries: */
#if defined ODBC_USE_LIB && defined ODBC_LIBS
    sprintf(buffer, "#include \"tst_vers.h\"\n%s#include \"%s\"\n"
                    "int main(int argc,char *argv[]){\n"
                    "SQLHENV sql_env;\n"
                    "SQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HANDLE, &sql_env);\n"
                    "SQLFreeHandle(SQL_HANDLE_ENV, sql_env);\n"
                    "return 0;\n}\n",
                    windowsOdbc ? "#include \"windows.h\"\n" : "", odbcInclude);
    linkerOptions[0] = '\0';
#ifdef ODBC_LIBRARY_PATH
    appendOption(linkerOptions, ODBC_LIBRARY_PATH);
#endif
    appendOption(linkerOptions, ODBC_LIBS);
    if (compileAndLinkWithOptionsOk(buffer, includeOption, linkerOptions)) {
#ifdef ODBC_LIBRARY_PATH
      appendOption(system_db_libs, ODBC_LIBRARY_PATH);
#endif
      fprintf(logFile, "\rOdbc: Linker option: %s\n", ODBC_LIBS);
      appendOption(system_db_libs, ODBC_LIBS);
    } else {
      writeDllList = 1;
    } /* if */
#else
    writeDllList = 1;
#endif
    if (writeDllList) {
      fprintf(versionFile, "#define ODBC_DLL");
      for (idx = 0; idx < sizeof(dllNameList) / sizeof(char *); idx++) {
        fprintf(logFile, "\rOdbc: DLL / Shared library: %s\n", dllNameList[idx]);
        fprintf(versionFile, " \"%s\",", dllNameList[idx]);
      } /* for */
      fprintf(versionFile, "\n");
    } /* if */
  } /* determineOdbcDefines */



static void determineOciDefines (FILE *versionFile,
    char *include_options, char *system_db_libs)

  {
    char *oracle_home;
    const char *oci_incl_dir[] = {"/rdbms/public", "/oci/include"};
    const char *oci_dll_dir[] = {"/lib", "/bin"};
#ifdef OCI_DLL
    const char *dllNameList[] = { OCI_DLL };
#else
    const char *dllNameList[] = {"oci.dll"};
#endif
    char incl_path[BUFFER_SIZE];
    char dll_path[BUFFER_SIZE];
    char includeOption[BUFFER_SIZE];
    const char *ociInclude = NULL;
    char buffer[BUFFER_SIZE];
    char linkerOptions[BUFFER_SIZE];
    int writeDllList = 0;
    int incl_dir_idx;
    int dll_dir_idx;
    int idx;
    int found = 0;

  /* determineOciDefines */
#ifdef OCI_INCLUDE_OPTIONS
    strcpy(includeOption, OCI_INCLUDE_OPTIONS);
#else
    includeOption[0] = '\0';
#endif
    oracle_home = getenv("ORACLE_HOME");
    if (oracle_home != NULL) {
      /* fprintf(logFile, "ORACLE_HOME=%s\n", oracle_home); */
      for (incl_dir_idx = 0;
           ociInclude == NULL && incl_dir_idx < sizeof(oci_incl_dir) / sizeof(char *);
           incl_dir_idx++) {
        sprintf(incl_path, "%s%s/oci.h", oracle_home, oci_incl_dir[incl_dir_idx]);
        if (fileIsRegular(incl_path)) {
          sprintf(includeOption, "-I%s%s", oracle_home, oci_incl_dir[incl_dir_idx]);
          if (compileAndLinkWithOptionsOk("#include \"oci.h\"\n"
                                          "int main(int argc,char *argv[]){return 0;}\n",
                                          includeOption, "")) {
            ociInclude = "oci.h";
            fprintf(logFile, "\rOracle: %s found in %s%s\n",
                    ociInclude, oracle_home, oci_incl_dir[incl_dir_idx]);
            appendOption(include_options, includeOption);
          } /* if */
        } /* if */
      } /* for */
    } else if (compileAndLinkWithOptionsOk("#include <oci.h>\n"
                                           "int main(int argc,char *argv[]){return 0;}\n",
                                           includeOption, "")) {
      ociInclude = "oci.h";
      fprintf(logFile, "\rOracle: %s found in system include directory.\n", ociInclude);
      appendOption(include_options, includeOption);
    } else if (compileAndLinkWithOptionsOk("#include \"tst_vers.h\"\n#include \"stdlib.h\"\n"
                                           "#include \"db_oci.h\"\n"
                                           "int main(int argc,char *argv[]){return 0;}\n",
                                           includeOption, "")) {
      ociInclude = "db_oci.h";
      fprintf(logFile, "\rOracle: %s found in Seed7 include directory.\n", ociInclude);
      appendOption(include_options, includeOption);
    } /* if */
    if (ociInclude != NULL) {
      fprintf(versionFile, "#define OCI_INCLUDE \"%s\"\n", ociInclude);
    } /* if */
    /* Handle libraries: */
    if (oracle_home != NULL) {
#if defined OCI_USE_LIB && defined OCI_LIBS
#ifdef OCI_LIBRARY_PATH
      appendOption(system_db_libs, OCI_LIBRARY_PATH);
#endif
      appendOption(system_db_libs, OCI_LIBS);
#else
      fprintf(versionFile, "#define OCI_DLL");
      for (idx = 0; idx < sizeof(dllNameList) / sizeof(char *); idx++) {
        fprintf(versionFile, " \"%s\",", dllNameList[idx]);
      } /* for */
      fprintf(versionFile, "\n");
      for (dll_dir_idx = 0; !found && dll_dir_idx < sizeof(oci_dll_dir) / sizeof(char *); dll_dir_idx++) {
        sprintf(dll_path, "%s%s", oracle_home, oci_dll_dir[dll_dir_idx]);
        if (fileIsDir(dll_path)) {
          for (idx = 0; idx < sizeof(dllNameList) / sizeof(char *); idx++) {
            sprintf(buffer, "%s%s/%s", oracle_home, oci_dll_dir[dll_dir_idx], dllNameList[idx]);
            if (fileIsRegular(buffer)) {
              sprintf(buffer, "-Wl,-rpath=%s%s", oracle_home, oci_dll_dir[dll_dir_idx]);
              appendOption(system_db_libs, buffer);
              found = 1;
            } /* if */
          } /* for */
        } /* if */
      } /* for */
#endif
    } else {
#if defined OCI_USE_LIB && defined OCI_LIBS
      sprintf(buffer, "#include \"tst_vers.h\"\n#include \"stdlib.h\"\n#include \"%s\"\n"
                      "int main(int argc,char *argv[]){\n"
                      "OCIEnv *oci_env;\n"
                      "OCIEnvCreate(&oci_env, OCI_DEFAULT, NULL, NULL, NULL, NULL, 0, NULL);\n"
                      "OCIHandleFree(oci_env, OCI_HTYPE_ENV);\n"
                      "return 0;\n}\n", ociInclude);
      linkerOptions[0] = '\0';
#ifdef OCI_LIBRARY_PATH
      appendOption(linkerOptions, OCI_LIBRARY_PATH);
#endif
      appendOption(linkerOptions, OCI_LIBS);
      if (compileAndLinkWithOptionsOk(buffer, includeOption, linkerOptions)) {
#ifdef OCI_LIBRARY_PATH
        appendOption(system_db_libs, OCI_LIBRARY_PATH);
#endif
        fprintf(logFile, "\rOracle: Linker option: %s\n", OCI_LIBS);
        appendOption(system_db_libs, OCI_LIBS);
      } else {
        writeDllList = 1;
      } /* if */
#else
      writeDllList = 1;
#endif
      if (writeDllList) {
        fprintf(versionFile, "#define OCI_DLL");
        for (idx = 0; idx < sizeof(dllNameList) / sizeof(char *); idx++) {
          fprintf(logFile, "\rOracle: DLL / Shared library: %s\n", dllNameList[idx]);
          fprintf(versionFile, " \"%s\",", dllNameList[idx]);
        } /* for */
        fprintf(versionFile, "\n");
      } /* if */
    } /* if */
  } /* determineOciDefines */
#endif



static void determineIncludesAndLibs (FILE *versionFile)

  {
    char include_options[BUFFER_SIZE];
    char system_db_libs[BUFFER_SIZE];
    char buffer[BUFFER_SIZE];

  /* determineIncludesAndLibs */
    include_options[0] = '\0';
    system_db_libs[0] = '\0';
    determineX11Includes(versionFile, include_options);
#ifdef WITH_SQL
    determineMySqlDefines(versionFile, include_options, system_db_libs);
    determineSqliteDefines(versionFile, include_options, system_db_libs);
    determinePostgresDefines(versionFile, include_options, system_db_libs);
    determineOdbcDefines(versionFile, include_options, system_db_libs);
    determineOciDefines(versionFile, include_options, system_db_libs);
    sprintf(buffer, "INCLUDE_OPTIONS = %s", include_options);
    replaceNLBySpace(buffer);
    strcat(buffer, "\n");
    appendToFile("macros", buffer);
    sprintf(buffer, "SYSTEM_DB_LIBS = %s", system_db_libs);
    replaceNLBySpace(buffer);
    strcat(buffer, "\n");
    appendToFile("macros", buffer);
#endif
    fprintf(versionFile, "#define INCLUDE_OPTIONS \"");
    escapeString(versionFile, include_options);
    fprintf(versionFile, "\"\n");
    fprintf(versionFile, "#define SYSTEM_DB_LIBS \"");
    escapeString(versionFile, system_db_libs);
    fprintf(versionFile, "\"\n");
  } /* determineIncludesAndLibs */



static void writeReadBufferEmptyMacro (FILE *versionFile)

  {
    const char *define_read_buffer_empty;
    int offset_to_count;
    char macro_buffer[BUFFER_SIZE];
    char buffer[BUFFER_SIZE];

  /* writeReadBufferEmptyMacro */
    if (compileAndLinkOk("#include<stdio.h>\nint main(int argc,char *argv[])\n"
                         "{FILE*fp;fp->_IO_read_ptr>=fp->_IO_read_end;return 0;}\n")) {
      define_read_buffer_empty = "#define read_buffer_empty(fp) "
                                 "((fp)->_IO_read_ptr >= (fp)->_IO_read_end)";
    } else if (compileAndLinkOk("#include<stdio.h>\nint main(int argc,char *argv[])\n"
                                "{FILE*fp;fp->_cnt <= 0;return 0;}\n")) {
      define_read_buffer_empty = "#define read_buffer_empty(fp) ((fp)->_cnt <= 0)";
    } else if (compileAndLinkOk("#include<stdio.h>\nint main(int argc,char *argv[])\n"
                                "{FILE*fp;fp->__cnt <= 0;return 0;}\n")) {
      define_read_buffer_empty = "#define read_buffer_empty(fp) ((fp)->__cnt <= 0)";
    } else if (compileAndLinkOk("#include<stdio.h>\nint main(int argc,char *argv[])\n"
                                "{FILE*fp;fp->level <= 0;return 0;}\n")) {
      define_read_buffer_empty = "#define read_buffer_empty(fp) ((fp)->level <= 0)";
    } else if (compileAndLinkOk("#include<stdio.h>\nint main(int argc,char *argv[])\n"
                                "{FILE*fp;fp->_r <= 0;return 0;}\n")) {
      define_read_buffer_empty = "#define read_buffer_empty(fp) ((fp)->_r <= 0)";
    } else if (compileAndLinkOk("#include<stdio.h>\nint main(int argc,char *argv[])\n"
                                "{FILE*fp;fp->ptr >= fp->getend;return 0;}\n")) {
      define_read_buffer_empty = "#define read_buffer_empty(fp) ((fp)->ptr >= (fp)->getend)";
    } else if (compileAndLinkOk("#include<stdio.h>\nint main(int argc,char *argv[])\n"
                                "{FILE stru; FILE*fp=&stru;char**base;char**pointer;int*count;\n"
                                "_get_stream_buffer_pointers(fp,&base,&pointer,&count);\n"
                                "printf(\"%d\\n\",(int)((char *)count-(char *)fp)); return 0;}\n")) {
      if ((offset_to_count = doTest()) != -1) {
        sprintf(macro_buffer,
                "#define read_buffer_empty(fp) (*((int *)&((char *)(fp))[%d])==0)",
                offset_to_count);
        define_read_buffer_empty = macro_buffer;
      } else {
        define_read_buffer_empty = NULL;
      } /* if */
    } else {
      define_read_buffer_empty = NULL;
    } /* if */
    if (define_read_buffer_empty != NULL) {
      strcpy(buffer, "#include<stdio.h>\n");
      strcat(buffer, define_read_buffer_empty);
      strcat(buffer, "\nint main(int argc,char *argv[])\n"
                     "{FILE*fp;fp=fopen(\"tst_vers.h\",\"r\");\n"
                     "if(fp==NULL)puts(0);else\n"
                     "if(!read_buffer_empty(fp)){fclose(fp);puts(0);}else{"
                     "getc(fp);printf(\"%d\\n\","
                     "read_buffer_empty(fp)?0:1);fclose(fp);}\n"
                     "return 0;}\n");
      if (!compileAndLinkOk(buffer) || doTest() != 1) {
        define_read_buffer_empty = NULL;
      } /* if */
    } /* if */
    if (define_read_buffer_empty != NULL) {
      fprintf(versionFile, "%s\n", define_read_buffer_empty);
      fprintf(logFile, "\rMacro define_read_buffer_empty defined.\n");
    } /* if */
  } /* writeReadBufferEmptyMacro */



static FILE *openVersionFile (const char *versionFileName)

  {
    FILE *versionFile = NULL;

  /* openVersionFile */
    if (versionFileName != NULL) {
      versionFile = fopen(versionFileName, "a");
    } /* if */
    if (versionFile == NULL) {
      versionFile = stdout;
      logFile = fopen("chkccomp.log", "w");
      if (logFile == NULL) {
        logFile = stdout;
      } /* if */
    } /* if */
    return versionFile;
  } /* openVersionFile */



static void closeVersionFile (FILE *versionFile)

  { /* closeVersionFile */
    if (versionFile != NULL && versionFile != stdout) {
      fclose(versionFile);
    } /* if */
  } /* closeVersionFile */



static void copyFile (const char *sourceName, const char *destName)

  {
    FILE *source;
    FILE *dest;
    char buffer[1024];
    size_t len;

  /* copyFile */
    if (sourceName != NULL && destName != NULL) {
      if ((source = fopen(sourceName, "r")) != NULL) {
        if ((dest = fopen(destName, "w")) != NULL) {
          while ((len = fread(buffer, 1, 1024, source)) != 0) {
            fwrite(buffer, 1, len, dest);
          } /* while */
          fclose(dest);
        } /* if */
        fclose(source);
      } /* if */
    } /* if */
  } /* copyFile */



/**
 *  Program to Check properties of C compiler and runtime.
 */
int main (int argc, char **argv)

  {
    char *versionFileName = NULL;
    FILE *versionFile = NULL;
    int driveLetters;
    FILE *aFile;
    int ch;

  /* main */
    logFile = stdout;
    fprintf(logFile, "General settings: ");
    fflush(logFile);
    if (argc >= 2) {
      versionFileName = argv[1];
    } /* if */
    copyFile(versionFileName, "tst_vers.h");
    versionFile = openVersionFile(versionFileName);
    prepareCompileCommand();
#ifdef WRITE_CC_VERSION_INFO
    WRITE_CC_VERSION_INFO
#endif
    aFile = fopen("cc_vers.txt", "r");
    if (aFile != NULL) {
      fprintf(versionFile, "#define C_COMPILER_VERSION \"");
      for (ch=getc(aFile); ch != EOF && ch != 10 && ch != 13; ch = getc(aFile)) {
        if (ch >= ' ' && ch <= '~') {
          if (ch == '\"' || ch == '\'' || ch == '\\') {
            putc('\\', versionFile);
          } /* if */
          putc(ch, versionFile);
        } else {
          fprintf(versionFile, "\\%3o", ch);
        } /* if */
      } /* for */
      fputs("\"\n", versionFile);
      fclose(aFile);
    } /* if */
    fprintf(versionFile, "#define UNISTD_H_PRESENT %d\n",
            compileAndLinkOk("#include <unistd.h>\n"
                             "int main(int argc,char *argv[]){return 0;}\n"));
    checkSignal(versionFile);
    writeMacroDefs(versionFile);
    closeVersionFile(versionFile);
    copyFile(versionFileName, "tst_vers.h");
    versionFile = openVersionFile(versionFileName);
    makeDirDefinition = defineMakeDir();
    determineOsFunctions(versionFile);
    checkPopen(versionFile);
#ifndef FILENO_WORKS_FOR_NULL
    if (assertCompAndLnk("#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n"
                         "void handleSig(int sig){puts(\"2\");exit(0);}\n"
                         "int main(int argc, char *argv[]){\n"
                         "FILE *aFile = NULL;\n"
                         "signal(SIGSEGV,handleSig);\n"
                         "printf(\"%d\\n\", fileno(aFile) == -1); return 0;}\n")) {
      fprintf(versionFile, "#define FILENO_WORKS_FOR_NULL %d\n", doTest() == 1);
    } /* if */
#endif
    if (assertCompAndLnk("#include <stdio.h>\nint main(int argc, char *argv[])\n"
                         "{printf(\"%d\\n\", fseek(stdin, 0,  SEEK_SET) == 0);\n"
                         "return 0;}\n")) {
      fprintf(versionFile, "#define FSEEK_SUCCEEDS_FOR_STDIN %d\n", doTest() == 1);
    } /* if */
    if (assertCompAndLnk("#include <stdio.h>\nint main(int argc, char *argv[])\n"
                         "{FILE *aFile; aFile=fopen(\".\",\"r\");\n"
                         "printf(\"%d\\n\",aFile!=NULL);\n"
                         "if(aFile!=NULL)fclose(aFile);return 0;}\n")) {
      fprintf(versionFile, "#define FOPEN_OPENS_DIRECTORIES %d\n", doTest() == 1);
    } /* if */
    if (assertCompAndLnk("#include <stdio.h>\nint main(int argc, char *argv[])\n"
                         "{int canWrite=0;FILE *aFile;\n"
                         "if((aFile=fopen(\"tmp_test_file\",\"w\"))!=NULL){\n"
                         " fwrite(\"asdf\",1,4,aFile);fclose(aFile);\n"
                         " if((aFile=fopen(\"tmp_test_file\",\"r\"))!=NULL){\n"
                         "  canWrite=fwrite(\"qwert\",1,5,aFile)!=0;fclose(aFile);}\n"
                         " remove(\"tmp_test_file\");}\n"
                         "printf(\"%d\\n\",canWrite);return 0;}\n")) {
      fprintf(versionFile, "#define FWRITE_WRONG_FOR_READ_ONLY_FILES %d\n", doTest() == 1);
    } /* if */
    checkRemoveDir(makeDirDefinition, versionFile);
    if (compileAndLinkOk("#include <stdio.h>\n#include <unistd.h>\n#include <ctype.h>\n"
                         "int main(int argc, char *argv[])\n"
                         "{char buffer[8192]; char *cwd;\n"
                         "cwd = getcwd(buffer, 8192);\n"
                         "printf(\"%d\\n\", cwd!=NULL && isalpha(cwd[0]) && cwd[1]==':');\n"
                         "return 0;}\n") ||
        compileAndLinkOk("#include <stdio.h>\n#include <unistd.h>\n#include <ctype.h>\n"
                         "int main(int argc, char *argv[])\n"
                         "{char buffer[8192]; char *cwd;\n"
                         "cwd = _getcwd(buffer, 8192);\n"
                         "printf(\"%d\\n\", cwd!=NULL && isalpha(cwd[0]) && cwd[1]==':');\n"
                         "return 0;}\n") ||
        compileAndLinkOk("#include <stdio.h>\n#include <direct.h>\n#include <ctype.h>\n"
                         "int main(int argc, char *argv[])\n"
                         "{char buffer[8192]; char *cwd;\n"
                         "cwd = getcwd(buffer, 8192);\n"
                         "printf(\"%d\\n\", cwd!=NULL && isalpha(cwd[0]) && cwd[1]==':');\n"
                         "return 0;}\n") ||
        compileAndLinkOk("#include <stdio.h>\n#include <direct.h>\n#include <ctype.h>\n"
                         "int main(int argc, char *argv[])\n"
                         "{char buffer[8192]; char *cwd;\n"
                         "cwd = _getcwd(buffer, 8192);\n"
                         "printf(\"%d\\n\", cwd!=NULL && isalpha(cwd[0]) && cwd[1]==':');\n"
                         "return 0;}\n")) {
      driveLetters = doTest() == 1;
      fprintf(versionFile, "#define OS_PATH_HAS_DRIVE_LETTERS %d\n", driveLetters);
      if (driveLetters) {
        /* The check for HOME and USERPROFILE is done with a program,        */
        /* because some compilers (e.g.: emcc) provide their own evironment. */
        if (assertCompAndLnk("#include <stdio.h>\n#include <stdlib.h>\n"
                             "int main(int argc, char *argv[])\n"
                             "{printf(\"%d\\n\", getenv(\"USERPROFILE\") != NULL);\n"
                             "return 0;}\n") && doTest() == 1) {
          /* When USERPROFILE is defined then it is used, even when HOME is defined. */
          fputs("#define HOME_DIR_ENV_VAR {'U', 'S', 'E', 'R', "
                "'P', 'R', 'O', 'F', 'I', 'L', 'E', 0}\n", versionFile);
        } else if (assertCompAndLnk("#include <stdio.h>\n#include <stdlib.h>\n"
                                    "int main(int argc, char *argv[])\n"
                                    "{printf(\"%d\\n\", getenv(\"HOME\") != NULL);\n"
                                    "return 0;}\n") && doTest() == 1) {
          fputs("#define HOME_DIR_ENV_VAR {'H', 'O', 'M', 'E', 0}\n", versionFile);
        } else {
          fputs("#define HOME_DIR_ENV_VAR {'H', 'O', 'M', 'E', 0}\n", versionFile);
          fputs("#define DEFAULT_HOME_DIR {'C', ':', '\\\\', 0}\n", versionFile);
        } /* if */
      } else {
        fputs("#define HOME_DIR_ENV_VAR {'H', 'O', 'M', 'E', 0}\n", versionFile);
      } /* if */
    } else {
      fputs("#define HOME_DIR_ENV_VAR {'H', 'O', 'M', 'E', 0}\n", versionFile);
    } /* if */
    checkMoveDirectory(makeDirDefinition, versionFile);
    if (compileAndLinkOk("#include <stdio.h>\n#include <errno.h>\nint main(int argc,char *argv[])"
                         "{int saved_errno=EXDEV; printf(\"%d\\n\",saved_errno); return 0;}\n")) {
      fputs("#define EXDEV_IS_DEFINED\n", versionFile);
    } /* if */
#if defined OS_STRI_WCHAR && defined USE_WINSOCK
    /* Under Windows a rename between different    */
    /* devices fails with EACCES instead of EXDEV. */
    fputs("#define USE_EACCES_INSTEAD_OF_EXDEV\n", versionFile);
    /* Windows uses pending deletes which cause    */
    /* problems when a file with the same name is  */
    /* created shortly after the delete. To avoid  */
    /* problems files are renamed before they are  */
    /* removed.                                    */
    fputs("#define RENAME_BEFORE_REMOVE\n", versionFile);
#endif
    fprintf(logFile, " determined\n");
    numericSizes(versionFile);
    numericProperties(versionFile);
    fprintf(logFile, "Advanced settings: ");
    fflush(logFile);
    determineMallocAlignment(versionFile);
    if (compileAndLinkOk("#include<signal.h>\nint main(int argc, char *argv[]){\n"
                         "signal(SIGBUS,SIG_DFL); return 0;}\n")) {
      if (assertCompAndLnk("#include<stdlib.h>\n#include <stdio.h>\n#include<signal.h>\n"
                           "void handleSig(int sig){puts(\"2\");exit(0);}\n"
                           "int main(int argc, char *argv[]){\n"
                           "signal(SIGBUS,handleSig);\n"
                           "int p[3]={12,34,56}, q, *pp; pp=(int *)((char *)&p[1]+1); q=*pp;\n"
                           "printf(\"1\\n\"); return 0;}\n")) {
        fprintf(versionFile, "#define UNALIGNED_MEMORY_ACCESS_OKAY %d\n", doTest() == 1);
      } /* if */
    } else if (assertCompAndLnk("#include <stdio.h>\nint main(int argc, char *argv[])\n"
                                "{int p[3]={12,34,56}, q, *pp; pp=(int *)((char *)&p[1]+1); q=*pp;\n"
                                "printf(\"1\\n\"); return 0;}\n")) {
      fprintf(versionFile, "#define UNALIGNED_MEMORY_ACCESS_OKAY %d\n", doTest() == 1);
    } /* if */
    if (assertCompAndLnk("#include <stdio.h>\nint main(int argc, char *argv[])\n"
                         "{union{char ch;unsigned long gen;}aUnion;\n"
                         "memset(&aUnion,0,sizeof(aUnion));aUnion.ch='X';\n"
                         "printf(\"%d\\n\",aUnion.ch==(char)aUnion.gen);return 0;}\n")) {
      fprintf(versionFile, "#define CASTING_GETS_A_UNION_ELEMENT %d\n", doTest() == 1);
    } /* if */
    if (expectTestResult("#include <stdio.h>\nint main(int argc, char *argv[])\n"
                         "{printf(\"%d\\n\",EOF!= -1);return 0;}\n", 1)) {
      fputs("#define EOF_IS_NOT_MINUS_ONE\n", versionFile);
    } /* if */
    if (!compileAndLinkOk("#include <stdio.h>\n"
                          "typedef struct emptyStruct { } emptyRecord;\n"
                          "int main(int argc, char *argv[]){\n"
                          "return 0;}\n")) {
      fputs("#define NO_EMPTY_STRUCTS\n", versionFile);
    } /* if */
    if (assertCompAndLnk("#include <stdio.h>\n#include <string.h>\n"
                         "int main(int argc, char *argv[]){\n"
                         "printf(\"%d\\n\", strcmp(\"\?\?(\", \"[\") == 0);\n"
                         "return 0;}\n")) {
      fprintf(versionFile, "#define TRIGRAPH_SEQUENCES_ARE_REPLACED %d\n", doTest() == 1);
    } /* if */
    checkForLimitedStringLiteralLength(versionFile);
    determineStackDirection(versionFile);
#ifndef STACK_SIZE
    if (sizeof(char *) == 8) { /* Machine with 64-bit addresses */
      /* Due to alignment some 64-bit machines have huge stack requirements. */
      fputs("#define STACK_SIZE 0x1000000\n", versionFile); /* 16777216 bytes */
    } else {
      fputs("#define STACK_SIZE 0x800000\n", versionFile); /* 8388608 bytes */
    } /* if */
#endif
    localtimeProperties(versionFile);
    /* Make sure that the file version.h up to this position is copied to tst_vers.h. */
    closeVersionFile(versionFile);
    copyFile(versionFileName, "tst_vers.h");
    versionFile = openVersionFile(versionFileName);
    determineEnvironDefines(versionFile);
    determineGetaddrlimit(versionFile);
    fprintf(versionFile, "#define HAS_WMEMCMP %d\n",
        compileAndLinkOk("#include <stdio.h>\n#include <wchar.h>\n"
                         "int main(int argc, char *argv[]){\n"
                         "wchar_t str1[] = {0x0201, 0x0102, 0};\n"
                         "wchar_t str2[] = {0x0102, 0x0201, 0};\n"
                         "printf(\"%d\\n\", wmemcmp(str1, str2, 2) > 0);\n"
                         "return 0;}\n") && doTest() == 1);
    fprintf(versionFile, "#define HAS_WMEMCHR %d\n",
        compileAndLinkOk("#include <stdio.h>\n#include <wchar.h>\n"
                         "int main(int argc, char *argv[]){\n"
                         "wchar_t str1[] = {0x0201, 0x0102, 0};\n"
                         "wchar_t ch1 = 0x0102;\n"
                         "printf(\"%d\\n\", wmemchr(str1, ch1, 2) ==  &str1[1]);\n"
                         "return 0;}\n") && doTest() == 1);
    fprintf(versionFile, "#define HAS_WMEMSET %d\n",
        compileAndLinkOk("#include <stdio.h>\n#include <wchar.h>\n"
                         "int main(int argc, char *argv[]){\n"
                         "wchar_t str1[4];\n"
                         "wchar_t str2[] = {0, 0, 0, 0};\n"
                         "wchar_t ch1 = 0x00;\n"
                         "wmemset(str1, ch1, 4);\n"
                         "printf(\"%d\\n\", memcmp(str1, str2, 4 * sizeof(wchar_t)) == 0);\n"
                         "return 0;}\n") && doTest() == 1);
    fprintf(versionFile, "#define HAS_SETJMP %d\n",
        compileAndLinkOk("#include <stdio.h>\n#include <setjmp.h>\n"
                         "int main(int argc, char *argv[]){\n"
                         "jmp_buf env; int ret_code; int count = 2;\n"
                         "if ((ret_code=setjmp(env)) == 0) {\n"
                         "count--; longjmp(env, count);\n"
                         "} else printf(\"%d\\n\", ret_code);\n"
                         "return 0;}\n") && doTest() == 1);
    fprintf(versionFile, "#define HAS_SIGSETJMP %d\n",
        compileAndLinkOk("#include <stdio.h>\n#include <setjmp.h>\n"
                         "int main(int argc, char *argv[]){\n"
                         "sigjmp_buf env; int ret_code; int count = 2;\n"
                         "if ((ret_code=sigsetjmp(env, 1)) == 0) {\n"
                         "count--; siglongjmp(env, count);\n"
                         "} else printf(\"%d\\n\", ret_code);\n"
                         "return 0;}\n") && doTest() == 1);
    fprintf(versionFile, "#define HAS_SYMBOLIC_LINKS %d\n",
        compileAndLinkOk("#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n"
                         "int main(int argc, char *argv[]){\n"
                         "char buf[256]; ssize_t link_len; int okay=0;\n"
                         "if (symlink(\"qwertzuiop\",\"test_symlink\") == 0){;\n"
                         "link_len=readlink(\"test_symlink\", buf, 256);\n"
                         "okay = link_len == 10 && memcmp(buf,\"qwertzuiop\",10) == 0;\n"
                         "remove(\"test_symlink\");}\n"
                         "printf(\"%d\\n\", okay);\n"
                         "return 0;}\n") && doTest() == 1);
    fprintf(versionFile, "#define HAS_READLINK %d\n",
        compileAndLinkOk("#include <stdio.h>\n#include <unistd.h>\n"
                         "#include <string.h>\n#include <errno.h>\n"
                         "int main(int argc, char *argv[]){\n"
                         "char buf[256]; ssize_t link_len;\n"
                         "link_len = readlink(\" does_not_exist \", buf, 256);\n"
                         "printf(\"%d\\n\", link_len == -1);\n"
                         "return 0;}\n") && doTest() == 1);
    fprintf(versionFile, "#define HAS_FIFO_FILES %d\n",
        compileAndLinkOk("#include <sys/types.h>\n#include <sys/stat.h>\n"
                         "int main(int argc, char *argv[]){\n"
                         "int ret_code;\n"
                         "ret_code=mkfifo(\"qwertzuiop\", 0);\n"
                         "return 0;}\n"));
    fprintf(versionFile, "#define HAS_POLL %d\n",
        compileAndLinkOk("#include<poll.h>\nint main(int argc,char *argv[])"
                         "{struct pollfd pollFd[1];poll(pollFd, 1, 0);return 0;}\n"));
    fprintf(logFile, " determined\n");
    determineIncludesAndLibs(versionFile);
    writeReadBufferEmptyMacro(versionFile);
    cleanUpCompilation(testNumber);
    closeVersionFile(versionFile);
    if (fileIsRegular("tst_vers.h")) {
      remove("tst_vers.h");
    } /* if */
    return 0;
  } /* main */
