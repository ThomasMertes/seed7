/********************************************************************/
/*                                                                  */
/*  chkccomp.c    Check properties of C compiler and runtime.       */
/*  Copyright (C) 2010 - 2014  Thomas Mertes                        */
/*                                                                  */
/*  This program is free software; you can redistribute it and/or   */
/*  modify it under the terms of the GNU General Public License as  */
/*  published by the Free Software Foundation; either version 2 of  */
/*  the License, or (at your option) any later version.             */
/*                                                                  */
/*  This program is distributed in the hope that it will be useful, */
/*  but WITHOUT ANY WARRANTY; without even the implied warranty of  */
/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   */
/*  GNU General Public License for more details.                    */
/*                                                                  */
/*  You should have received a copy of the GNU General Public       */
/*  License along with this program; if not, write to the           */
/*  Free Software Foundation, Inc., 51 Franklin Street,             */
/*  Fifth Floor, Boston, MA  02110-1301, USA.                       */
/*                                                                  */
/*  Module: Chkccomp                                                */
/*  File: seed7/src/chkccomp.c                                      */
/*  Changes: 2010 - 2014  Thomas Mertes                             */
/*  Content: Program to Check properties of C compiler and runtime. */
/*                                                                  */
/********************************************************************/

#include "version.h"

/**
 *  From version.h the following defines are used (for details see: read_me.txt):
 *
 *  os_off_t
 *      Type used for os_fseek(), os_ftell(), offsetSeek(), offsetTell()
 *      and seekFileLength().
 *  TURN_OFF_FP_EXCEPTIONS
 *      Use the function _control87() to turn off floating point exceptions.
 *  DEFINE_MATHERR_FUNCTION
 *      Define the function _matherr() which handles floating point errors.
 *  PATH_DELIMITER:
 *      Path delimiter character used by the command shell of the operating system.
 *  QUOTE_WHOLE_SHELL_COMMAND:
 *      Defined when shell commands, starting with " need to be quoted again.
 *  OBJECT_FILE_EXTENSION:
 *      The extension used by the C compiler for object files.
 *  EXECUTABLE_FILE_EXTENSION:
 *      The extension which is used by the operating system for executables.
 *  C_COMPILER:
 *      Contains the command to call the stand-alone C compiler and linker.
 *  CC_NO_OPT_OUTPUT_FILE:
 *      Defined, when compiling and linking with one command cannot use -o.
 *  REDIRECT_C_ERRORS:
 *      The redirect command to redirect the errors of the C compiler to a file.
 *  LINKER_OPT_OUTPUT_FILE:
 *      Contains the linker option to provide the output filename (e.g.: "-o ").
 */

#include "stdlib.h"
#include "string.h"
#include "stdio.h"
#include "stddef.h"
#include "time.h"
#include "float.h"
#include "math.h"
#include "sys/types.h"
#include "sys/stat.h"

#include "config.h"

/**
 *  From config.h the following defines are used (for details see: read_me.txt):
 *
 *  MAP_ABSOLUTE_PATH_TO_DRIVE_LETTERS
 *      Map absolute paths to operating system paths with drive letter.
 */

#include "chkccomp.h"

/**
 *  The file chkccomp.h is NOT part of the Seed7 release.
 *  Instead chkccomp.h is generated by the makefile and
 *  removed after chkccomp was compiled and executed.
 *  In chkccomp.h the following macros might be defined:
 *
 *  mkdir(path,mode)
 *      Macro to replace the Posix function mkdir.
 *      E.g.: #define mkdir(path,mode) mkdir(path)
 *            #define mkdir(path,mode) _mkdir(path)
 *  rmdir
 *      Name of Posix function rmdir.
 *      E.g.: #define rmdir _rmdir
 *  WRITE_CC_VERSION_INFO
 *      Write the version of the C compiler to the file "cc_vers.txt".
 *      E.g.: #define WRITE_CC_VERSION_INFO system("$(GET_CC_VERSION_INFO) cc_vers.txt");
 *  LIST_DIRECTORY_CONTENTS
 *      Either "ls" or "dir".
 *      E.g.: #define LIST_DIRECTORY_CONTENTS "ls"
 *            #define LIST_DIRECTORY_CONTENTS "dir"
 *  The macros described above are only used in the program chkccomp.
 *  This macros are not used in the Seed7 Interpreter (s7) or in the
 *  Seed7 Runtime Library.
 */


#ifndef EXECUTABLE_FILE_EXTENSION
#define EXECUTABLE_FILE_EXTENSION ""
#endif

#ifndef S_ISREG
#define S_ISREG(mode) (((mode) & S_IFMT) == S_IFREG)
#endif

#ifndef S_ISDIR
#define S_ISDIR(mode) (((mode) & S_IFMT) == S_IFDIR)
#endif

#define xstr(s) str(s)
#define str(s) #s

char c_compiler[1024];

static const int alignmentTable[] = {
    6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
  };

char *stack_base;



#ifdef DEFINE_MATHERR_FUNCTION
int _matherr (struct _exception *a)

  { /* _matherr */
    a->retval = a->retval;
    return 1;
  } /* _matherr */
#endif



void prepareCompileCommand (void)

  {
    int pos;
    int quote_command = 0;
    int len;

  /* prepareCompileCommand */
    strcpy(c_compiler, C_COMPILER);
#ifdef MAP_ABSOLUTE_PATH_TO_DRIVE_LETTERS
    if (c_compiler[0] == '/') {
      c_compiler[0] = c_compiler[1];
      c_compiler[1] = ':';
    } /* if */
#endif
    for (pos = 0; c_compiler[pos] != '\0'; pos++) {
      if (c_compiler[pos] == '/') {
        c_compiler[pos] = PATH_DELIMITER;
      } else if (c_compiler[pos] == ' ') {
        quote_command = 1;
      } /* if */
    } /* for */
    if (quote_command) {
      len = strlen(c_compiler);
      memmove(&c_compiler[1], c_compiler, len);
      c_compiler[0] = '\"';
      c_compiler[len + 1] = '\"';
      c_compiler[len + 2] = '\0';
    } /* if */
  } /* prepareCompileCommand */



int fileIsRegular (const char *fileName)

  {
    struct stat stat_buf;

  /* fileIsRegular */
    return stat(fileName, &stat_buf) == 0 && S_ISREG(stat_buf.st_mode);
  } /* fileIsRegular */



int fileIsDir (const char *fileName)

  {
    struct stat stat_buf;

  /* fileIsDir */
    return stat(fileName, &stat_buf) == 0 && S_ISDIR(stat_buf.st_mode);
  } /* fileIsDir */



void cleanUpCompilation (void)

  {
    char fileName[1024];

  /* cleanUpCompilation */
    if (fileIsRegular("ctest.c")) {
      remove("ctest.c");
    } /* if */
    if (fileIsRegular("ctest.cerrs")) {
      remove("ctest.cerrs");
    } /* if */
    if (fileIsRegular("ctest.lerrs")) {
      remove("ctest.lerrs");
    } /* if */
    sprintf(fileName, "ctest%s", OBJECT_FILE_EXTENSION);
    if (fileIsRegular(fileName)) {
      remove(fileName);
    } /* if */
    sprintf(fileName, "ctest%s", EXECUTABLE_FILE_EXTENSION);
    if (fileIsRegular(fileName)) {
      remove(fileName);
    } /* if */
    if (fileIsRegular("ctest.out")) {
      remove("ctest.out");
    } /* if */
  } /* cleanUpCompilation */



int doCompileAndLink (const char *options, const char *linkerOptions)

  {
    char command[1024];
    int len;
    char fileName[1024];
    int returncode;
    int result = 0;

  /* doCompileAndLink */
#ifdef CC_FLAGS
    sprintf(command, "%s %s %s ctest.c %s",
            c_compiler, options, CC_FLAGS, linkerOptions);
#else
    sprintf(command, "%s %s ctest.c %s",
            c_compiler, options, linkerOptions);
#endif
#if defined LINKER_OPT_OUTPUT_FILE && !defined CC_NO_OPT_OUTPUT_FILE
    sprintf(&command[strlen(command)], " %sctest%s",
            LINKER_OPT_OUTPUT_FILE, EXECUTABLE_FILE_EXTENSION);
#endif
#ifdef REDIRECT_C_ERRORS
    sprintf(&command[strlen(command)], " %sctest.cerrs",
            REDIRECT_C_ERRORS);
#endif
#ifdef QUOTE_WHOLE_SHELL_COMMAND
    if (command[0] == '\"') {
      len = strlen(command);
      memmove(&command[1], command, len);
      command[0] = '\"';
      command[len + 1] = '\"';
      command[len + 2] = '\0';
    } /* if */
#endif
    returncode = system(command);
    sprintf(fileName, "ctest%s", EXECUTABLE_FILE_EXTENSION);
    if (fileIsRegular(fileName)) {
      if (returncode == 0) {
        result = 1;
      } else {
        /* printf(" *** The compiler %s fails, but creates an executable.", c_compiler); */
      } /* if */
    } /* if */
#ifdef DEBUG_CHKCCOMP
    printf("command: %s\n", command);
    printf("returncode: %d\n", returncode);
    printf("result: %d\n", result);
#endif
    return result;
  } /* doCompileAndLink */



int compileAndLinkWithOptionsOk (const char *content, const char *options,
    const char *linkerOptions)

  {
    FILE *testFile;
    int result = 0;

  /* compileAndLinkWithOptionsOk */
    /* printf("compileAndLinkWithOptionsOk(%s)\n", content); */
    cleanUpCompilation();
    testFile = fopen("ctest.c", "w");
    if (testFile != NULL) {
      fprintf(testFile, "%s", content);
      fclose(testFile);
      result = doCompileAndLink(options, linkerOptions);
    } /* if */
#ifdef DEBUG_CHKCCOMP
    printf("content: %s\n", content);
#endif
    return result;
  } /* compileAndLinkWithOptionsOk */



int compileAndLinkOk (const char *content)

  { /* compileAndLinkOk */
    return compileAndLinkWithOptionsOk(content, "", "");
  } /* compileAndLinkOk */



int doTest (void)

  {
    char command[1024];
    FILE *outFile;
    int result = -1;

  /* doTest */
    sprintf(command, ".%cctest%s>ctest.out", PATH_DELIMITER, EXECUTABLE_FILE_EXTENSION);
    if (system(command) != -1 && (outFile = fopen("ctest.out", "r")) != NULL) {
      fscanf(outFile, "%d", &result);
      fclose(outFile);
    } /* if */
    return result;
  } /* doTest */



/**
 *  Determine if DEFINE_OS_ENVIRON or INITIALIZE_OS_ENVIRON must be defined.
 */
void determineEnvironDefines (FILE *versionFile)

  {
    char buffer[4096];
    int define_os_environ = 0;

  /* determineEnvironDefines */
    buffer[0] = '\0';
    if (compileAndLinkOk("#include <stdlib.h>\n#include \"tst_vers.h\"\n"
                         "int main(int argc,char *argv[])"
                         "{os_environ;return 0;}\n")) {
      strcat(buffer, "#include <stdlib.h>\n");
    } else if (compileAndLinkOk("#include <unistd.h>\n#include \"tst_vers.h\"\n"
                                "int main(int argc,char *argv[])"
                                "{os_environ;return 0;}\n")) {
      strcat(buffer, "#include <unistd.h>\n");
    } else {
      fprintf(versionFile, "#define DEFINE_OS_ENVIRON\n");
      define_os_environ = 1;
    } /* if */
    strcat(buffer, "#include <stdio.h>\n");
    strcat(buffer, "#include \"tst_vers.h\"\n");
#ifdef OS_STRI_WCHAR
    strcat(buffer, "typedef wchar_t *os_striType;\n");
#else
    strcat(buffer, "typedef char *os_striType;\n");
#endif
    if (define_os_environ) {
      strcat(buffer, "extern os_striType *os_environ;\n");
    } /* if */
#ifdef USE_WMAIN
    strcat(buffer, "int wmain(int argc,wchar_t *argv[])");
#else
    strcat(buffer, "int main(int argc,char *argv[])");
#endif
    strcat(buffer, "{printf(\"%d\\n\",os_environ==(os_striType *)0);return 0;}\n");
    if (!compileAndLinkOk(buffer) || doTest() == 1) {
      fputs("#define INITIALIZE_OS_ENVIRON\n", versionFile);
    } /* if */
  } /* determineEnvironDefines */



void numericSizes (FILE *versionFile)

  {
    int testResult;
    const char *int32TypeStri = NULL;
    const char *uint32TypeStri;
    const char *int32TypeSuffix = "";
    const char *int32TypeFormat = NULL;
    const char *int64TypeStri = NULL;
    const char *uint64TypeStri;
    const char *int64TypeSuffix = "";
    const char *int64TypeFormat = NULL;
    const char *int128TypeStri = NULL;
    const char *uint128TypeStri = NULL;
    char buffer[4096];

  /* numericSizes */
    printf("Numeric sizes:");
    fflush(stdout);
    fprintf(versionFile, "#define SHORT_SIZE %lu\n",    (long unsigned) (8 * sizeof(short)));
    fprintf(versionFile, "#define INT_SIZE %lu\n",      (long unsigned) (8 * sizeof(int)));
    fprintf(versionFile, "#define LONG_SIZE %lu\n",     (long unsigned) (8 * sizeof(long)));
    if (compileAndLinkOk("#include <stdio.h>\nint main(int argc, char *argv[])"
                         "{printf(\"%d\\n\",sizeof(long long));return 0;}\n")) {
      testResult = doTest();
      if (testResult != -1) {
        fprintf(versionFile, "#define LONG_LONG_SIZE %lu\n",     (long unsigned) (8 * testResult));
      } /* if */
    } /* if */
    fprintf(versionFile, "#define POINTER_SIZE %lu\n",  (long unsigned) (8 * sizeof(char *)));
    fprintf(versionFile, "#define FLOAT_SIZE %lu\n",    (long unsigned) (8 * sizeof(float)));
    fprintf(versionFile, "#define DOUBLE_SIZE %lu\n",   (long unsigned) (8 * sizeof(double)));
    fprintf(versionFile, "#define WCHAR_T_SIZE %lu\n",  (long unsigned) (8 * sizeof(wchar_t)));
    fprintf(versionFile, "#define OS_OFF_T_SIZE %lu\n", (long unsigned) (8 * sizeof(os_off_t)));
    fprintf(versionFile, "#define TIME_T_SIZE %lu\n",   (long unsigned) (8 * sizeof(time_t)));
    if ((time_t) -1 < 0) {
      fputs("#define TIME_T_SIGNED\n", versionFile);
    } /* if */
    if ((size_t) -1 < 0) {
      fputs("#define SIZE_T_SIGNED\n", versionFile);
    } /* if */
    if (sizeof(char) == 1) {
      fputs("#define INT8TYPE signed char\n", versionFile);
      fputs("#define INT8TYPE_STRI \"signed char\"\n", versionFile);
      fputs("#define UINT8TYPE unsigned char\n", versionFile);
      fputs("#define UINT8TYPE_STRI \"unsigned char\"\n", versionFile);
    } /* if */
    if (sizeof(short int) == 2) {
      fputs("#define INT16TYPE short int\n", versionFile);
      fputs("#define INT16TYPE_STRI \"short int\"\n", versionFile);
      fputs("#define UINT16TYPE unsigned short int\n", versionFile);
      fputs("#define UINT16TYPE_STRI \"unsigned short int\"\n", versionFile);
    } else if (sizeof(int) == 4) {
      fputs("#define INT16TYPE int\n", versionFile);
      fputs("#define INT16TYPE_STRI \"int\"\n", versionFile);
      fputs("#define UINT16TYPE unsigned int\n", versionFile);
      fputs("#define UINT16TYPE_STRI \"unsigned int\"\n", versionFile);
    } /* if */
    if (sizeof(int) == 4) {
      int32TypeStri = "int";
      uint32TypeStri = "unsigned int";
      int32TypeSuffix = "";
      int32TypeFormat = "";
    } else if (sizeof(long) == 4) {
      int32TypeStri = "long";
      uint32TypeStri = "unsigned long";
      int32TypeSuffix = "L";
      int32TypeFormat = "l";
    } /* if */
    if (int32TypeStri != NULL) {
      fprintf(versionFile, "#define INT32TYPE %s\n", int32TypeStri);
      fprintf(versionFile, "#define INT32TYPE_STRI \"%s\"\n", int32TypeStri);
      fprintf(versionFile, "#define UINT32TYPE %s\n", uint32TypeStri);
      fprintf(versionFile, "#define UINT32TYPE_STRI \"%s\"\n", uint32TypeStri);
      if (int32TypeSuffix[0] == '\0') {
        fprintf(versionFile, "#define INT32_SUFFIX(num) num\n");
      } else {
        fprintf(versionFile, "#define INT32_SUFFIX(num) num ## %s\n", int32TypeSuffix);
      } /* if */
      fprintf(versionFile, "#define UINT32_SUFFIX(num) num ## U%s\n", int32TypeSuffix);
      fprintf(versionFile, "#define INT32TYPE_LITERAL_SUFFIX \"%s\"\n", int32TypeSuffix);
      fprintf(versionFile, "#define INT32TYPE_FORMAT \"%s\"\n", int32TypeFormat);
    } /* if */
    if (sizeof(long) == 8) {
      int64TypeStri = "long";
      uint64TypeStri = "unsigned long";
      if (compileAndLinkOk("#include <stdio.h>\nint main(int argc, char *argv[])"
                           "{long n=12345678L;printf(\"%d\\n\",(int)sizeof(1L));return 0;}\n") && doTest() == 8) {
        int64TypeSuffix = "L";
      } /* if */
      int64TypeFormat = "l";
    } else if (compileAndLinkOk("#include <stdio.h>\nint main(int argc, char *argv[])"
                                "{printf(\"%d\\n\",sizeof(long long));return 0;}\n") && doTest() == 8) {
      /* The type long long is defined and it is a 64-bit type */
      int64TypeStri = "long long";
      uint64TypeStri = "unsigned long long";
      if (compileAndLinkOk("#include <stdio.h>\nint main(int argc, char *argv[])"
                           "{long long n=12345678LL;printf(\"%d\\n\",sizeof(1LL));return 0;}\n") && doTest() == 8) {
        int64TypeSuffix = "LL";
      } /* if */
      if (compileAndLinkOk("#include <stdio.h>\n#include <string.h>\n"
                           "int main(int argc, char *argv[])\n"
                           "{char b[99]; sprintf(b, \"A%lldB\", (long long) 1 << 32);\n"
                           "printf(\"%d\\n\", strcmp(b,\"A4294967296B\")==0);return 0;}\n") && doTest() == 1) {
        int64TypeFormat = "ll";
      } else if (compileAndLinkOk("#include <stdio.h>\n#include <string.h>\n"
                                  "int main(int argc, char *argv[])\n"
                                  "{char b[99]; sprintf(b, \"A%LdB\", (long long) 1 << 32);\n"
                                  "printf(\"%d\\n\", strcmp(b,\"A4294967296B\")==0);return 0;}\n") && doTest() == 1) {
        int64TypeFormat = "L";
      } else if (compileAndLinkOk("#include <stdio.h>\n#include <string.h>\n"
                                  "int main(int argc, char *argv[])\n"
                                  "{char b[99]; sprintf(b, \"A%I64dB\", (long long) 1 << 32);\n"
                                  "printf(\"%d\\n\", strcmp(b,\"A4294967296B\")==0);return 0;}\n") && doTest() == 1) {
        int64TypeFormat = "I64";
      } /* if */
    } else if (compileAndLinkOk("#include <stdio.h>\nint main(int argc, char *argv[])\n"
                                "{printf(\"%d\\n\",sizeof(__int64));return 0;}\n") && doTest() == 8) {
      /* The type __int64 is defined and it is a 64-bit type */
      int64TypeStri = "__int64";
      uint64TypeStri = "unsigned __int64";
      if (compileAndLinkOk("#include <stdio.h>\nint main(int argc, char *argv[])"
                           "{__int64 n=12345678LL;printf(\"%d\\n\",sizeof(1LL));return 0;}\n") && doTest() == 8) {
        int64TypeSuffix = "LL";
      } /* if */
      if (compileAndLinkOk("#include <stdio.h>\n#include <string.h>\n"
                           "int main(int argc, char *argv[])\n"
                           "{char b[99]; sprintf(b, \"A%lldB\", (__int64) 1 << 32);\n"
                           "printf(\"%d\\n\", strcmp(b,\"A4294967296B\")==0);return 0;}\n") && doTest() == 1) {
        int64TypeFormat = "ll";
      } else if (compileAndLinkOk("#include <stdio.h>\n#include <string.h>\n"
                                  "int main(int argc, char *argv[])\n"
                                  "{char b[99]; sprintf(b, \"A%LdB\", (__int64) 1 << 32);\n"
                                  "printf(\"%d\\n\", strcmp(b,\"A4294967296B\")==0);return 0;}\n") && doTest() == 1) {
        int64TypeFormat = "L";
      } else if (compileAndLinkOk("#include <stdio.h>\n#include <string.h>\n"
                                  "int main(int argc, char *argv[])\n"
                                  "{char b[99]; sprintf(b, \"A%I64dB\", (__int64) 1 << 32);\n"
                                  "printf(\"%d\\n\", strcmp(b,\"A4294967296B\")==0);return 0;}\n") && doTest() == 1) {
        int64TypeFormat = "I64";
      } /* if */
    } /* if */
    if (int64TypeStri != NULL) {
      fprintf(versionFile, "#define INT64TYPE %s\n", int64TypeStri);
      fprintf(versionFile, "#define INT64TYPE_STRI \"%s\"\n", int64TypeStri);
      fprintf(versionFile, "#define UINT64TYPE %s\n", uint64TypeStri);
      fprintf(versionFile, "#define UINT64TYPE_STRI \"%s\"\n", uint64TypeStri);
#ifdef INT64TYPE_NO_SUFFIX_BUT_CAST
      fprintf(versionFile, "#define INT64_SUFFIX(num)  ((int64Type) num)\n");
      fprintf(versionFile, "#define UINT64_SUFFIX(num) ((uint64Type) num ## U)\n");
      fprintf(versionFile, "#define INT64TYPE_LITERAL_SUFFIX \"\"\n");
#else
      if (int64TypeSuffix[0] == '\0') {
        fprintf(versionFile, "#define INT64_SUFFIX(num) num\n");
      } else {
        fprintf(versionFile, "#define INT64_SUFFIX(num) num ## %s\n", int64TypeSuffix);
      } /* if */
      fprintf(versionFile, "#define UINT64_SUFFIX(num) num ## U%s\n", int64TypeSuffix);
      fprintf(versionFile, "#define INT64TYPE_LITERAL_SUFFIX \"%s\"\n", int64TypeSuffix);
#endif
      fprintf(versionFile, "#define INT64TYPE_FORMAT \"%s\"\n", int64TypeFormat);
    } /* if */
    if (compileAndLinkOk("#include <stdio.h>\n#include <time.h>\n"
                         "int main(int argc, char *argv[])\n"
                         "{__int128 a = (__int128) time(NULL) * (__int128) clock();\n"
                         "if (sizeof(__int128)==sizeof(unsigned __int128))\n"
                         "printf(\"%d\\n\",sizeof(__int128));\n"
                         "else printf(\"0\\n\");return 0;}\n") && doTest() == 16) {
      /* The type __int128 is defined and it is a 128-bit type */
      int128TypeStri = "__int128";
      uint128TypeStri = "unsigned __int128";
    } else if (compileAndLinkOk("#include <stdio.h>\n#include <time.h>\n"
                                "int main(int argc, char *argv[])\n"
                                "{__int128 a = (__int128) time(NULL) * (__int128) clock();\n"
                                "if (sizeof(__int128_t)==sizeof(__uint128_t))\n"
                                "printf(\"%d\\n\",sizeof(__int128_t));\n"
                                "else printf(\"0\\n\");return 0;}\n") && doTest() == 16) {
      /* The type __int128_t is defined and it is a 128-bit type */
      int128TypeStri = "__int128_t";
      uint128TypeStri = "__uint128_t";
    } /* if */
    if (int128TypeStri != NULL && uint128TypeStri != NULL) {
      fprintf(versionFile, "#define INT128TYPE %s\n", int128TypeStri);
      fprintf(versionFile, "#define INT128TYPE_STRI \"%s\"\n", int128TypeStri);
      fprintf(versionFile, "#define UINT128TYPE %s\n", uint128TypeStri);
      fprintf(versionFile, "#define UINT128TYPE_STRI \"%s\"\n", uint128TypeStri);
    } /* if */
    printf(" determined\n");
  } /* numericSizes */



void numericProperties (FILE *versionFile)

  {
    int testResult;
    long number;
    char buffer[4096];
    int zero_divide_triggers_signal = 0;
    float zero = 0.0;
    float negativeZero;
    float minusZero;
    float nanValue1;
    float nanValue2;
    float plusInf;
    float minusInf;
    int floatRadixFactor;

  /* numericProperties */
    printf("Numeric properties:");
    fflush(stdout);
    number = -1;
    if (number >> 1 == (long) -1) {
      fputs("#define RSHIFT_DOES_SIGN_EXTEND\n", versionFile);
    } /* if */
    if (~number == (long) 0) {
      fputs("#define TWOS_COMPLEMENT_INTTYPE\n", versionFile);
    } else if (~number == (long) 1) {
      fputs("#define ONES_COMPLEMENT_INTTYPE\n", versionFile);
    } /* if */
    number = 1;
    if (((char *) &number)[0] == 1) {
      fputs("#define LITTLE_ENDIAN_INTTYPE\n", versionFile);
    } else {
      fputs("#define BIG_ENDIAN_INTTYPE\n", versionFile);
    } /* if */
#ifdef INT_DIV_BY_ZERO_POPUP
    fputs("#define CHECK_INT_DIV_BY_ZERO\n", versionFile);
#else
    if (!compileAndLinkOk("#include<stdio.h>\n"
                          "int main(int argc,char *argv[]){"
                          "printf(\"%d\\n\", 1/0);return 0;}\n") ||
        !compileAndLinkOk("#include<stdlib.h>\n#include<stdio.h>\n#include<signal.h>\n"
                          "void handleSigfpe(int sig){puts(\"2\");exit(0);}\n"
                          "void handleSigill(int sig){puts(\"3\");exit(0);}\n"
                          "int main(int argc,char *argv[]){\n"
                          "signal(SIGFPE,handleSigfpe);\n"
                          "signal(SIGILL,handleSigill);\n"
                          "printf(\"%d\\n\",1/0==0);return 0;}\n") || doTest() != 2 ||
        !compileAndLinkOk("#include<stdlib.h>\n#include<stdio.h>\n#include<signal.h>\n"
                          "void handleSigfpe(int sig){puts(\"2\");exit(0);}\n"
                          "void handleSigill(int sig){puts(\"3\");exit(0);}\n"
                           "int main(int argc,char *argv[]){\n"
                          "int zero=0;\n"
                          "signal(SIGFPE,handleSigfpe);\n"
                          "signal(SIGILL,handleSigill);\n"
                          "printf(\"%d\\n\",1/zero==0);return 0;}\n") || doTest() != 2 ||
        !compileAndLinkOk("#include<stdlib.h>\n#include<stdio.h>\n#include<signal.h>\n"
                          "void handleSigfpe(int sig){puts(\"2\");exit(0);}\n"
                          "void handleSigill(int sig){puts(\"3\");exit(0);}\n"
                           "int main(int argc,char *argv[]){\n"
                          "signal(SIGFPE,handleSigfpe);\n"
                          "signal(SIGILL,handleSigill);\n"
                          "printf(\"%d\\n\",0/0==0);return 0;}\n") || doTest() != 2 ||
        !compileAndLinkOk("#include<stdlib.h>\n#include<stdio.h>\n#include<signal.h>\n"
                          "void handleSigfpe(int sig){puts(\"2\");exit(0);}\n"
                          "void handleSigill(int sig){puts(\"3\");exit(0);}\n"
                           "int main(int argc,char *argv[]){\n"
                          "int zero=0;\n"
                          "signal(SIGFPE,handleSigfpe);\n"
                          "signal(SIGILL,handleSigill);\n"
                          "printf(\"%d\\n\",0/zero==0);return 0;}\n") || doTest() != 2) {
      fputs("#define CHECK_INT_DIV_BY_ZERO\n", versionFile);
    } else {
      fputs("#define INT_DIV_BY_ZERO_SIGNALS\n", versionFile);
#ifndef DO_SIGFPE_WITH_DIV_BY_ZERO
      fputs("#define DO_SIGFPE_WITH_DIV_BY_ZERO\n", versionFile);
#endif
    } /* if */
    if (!compileAndLinkOk("#include<stdio.h>\n"
                          "int main(int argc,char *argv[]){"
                          "printf(\"%d\\n\", 1%0);return 0;}\n") ||
        !compileAndLinkOk("#include<stdlib.h>\n#include<stdio.h>\n#include<signal.h>\n"
                          "void handleSigfpe(int sig){puts(\"2\");exit(0);}\n"
                          "void handleSigill(int sig){puts(\"3\");exit(0);}\n"
                          "int main(int argc,char *argv[]){\n"
                          "int zero=0;\n"
                          "signal(SIGFPE,handleSigfpe);\n"
                          "signal(SIGILL,handleSigill);\n"
                          "printf(\"%d\\n\",1%zero==0);return 0;}\n") || doTest() != 2 ||
        !compileAndLinkOk("#include<stdlib.h>\n#include<stdio.h>\n#include<signal.h>\n"
                          "void handleSigfpe(int sig){puts(\"2\");exit(0);}\n"
                          "void handleSigill(int sig){puts(\"3\");exit(0);}\n"
                           "int main(int argc,char *argv[]){\n"
                          "int one=0, zero=0;\n"
                          "signal(SIGFPE,handleSigfpe);\n"
                          "signal(SIGILL,handleSigill);\n"
                          "printf(\"%d\\n\",one%zero==0);return 0;}\n") || doTest() != 2 ||
        !compileAndLinkOk("#include<stdlib.h>\n#include<stdio.h>\n#include<signal.h>\n"
                          "void handleSigfpe(int sig){puts(\"2\");exit(0);}\n"
                          "void handleSigill(int sig){puts(\"3\");exit(0);}\n"
                           "int main(int argc,char *argv[]){\n"
                          "int zero1=0, zero2=0;\n"
                          "signal(SIGFPE,handleSigfpe);\n"
                          "signal(SIGILL,handleSigill);\n"
                          "printf(\"%d\\n\",zero1%zero2==0);return 0;}\n") || doTest() != 2) {
      fputs("#define CHECK_INT_REM_BY_ZERO\n", versionFile);
    } /* if */
    if (!compileAndLinkOk("#include<stdlib.h>\n#include<stdio.h>\n#include<signal.h>\n"
                          "void handleSigfpe(int sig){puts(\"2\");exit(0);}\n"
                          "void handleSigill(int sig){puts(\"3\");exit(0);}\n"
                           "int main(int argc,char *argv[]){\n"
                          "signal(SIGFPE,handleSigfpe);\n"
                          "signal(SIGILL,handleSigill);\n"
                          "printf(\"%d\\n\",0%0==0);return 0;}\n") || doTest() != 2 ||
        !compileAndLinkOk("#include<stdlib.h>\n#include<stdio.h>\n#include<signal.h>\n"
                          "void handleSigfpe(int sig){puts(\"2\");exit(0);}\n"
                          "void handleSigill(int sig){puts(\"3\");exit(0);}\n"
                           "int main(int argc,char *argv[]){\n"
                          "int zero=0;\n"
                          "signal(SIGFPE,handleSigfpe);\n"
                          "signal(SIGILL,handleSigill);\n"
                          "printf(\"%d\\n\",0%zero==0);return 0;}\n") || doTest() != 2) {
      fputs("#define CHECK_INT_REM_ZERO_BY_ZERO\n", versionFile);
    } /* if */
#endif
#ifdef TURN_OFF_FP_EXCEPTIONS
    _control87(MCW_EM, MCW_EM);
#endif
    sprintf(buffer, "%1.0f %1.0f %1.0f %1.1f %1.1f %1.2f %1.2f %1.0f %1.0f %1.0f %1.1f %1.1f %1.2f %1.2f",
            0.5, 1.5, 2.5, 1.25, 1.75, 0.125, 0.375, -0.5, -1.5, -2.5, -1.25, -1.75, -0.125, -0.375);
    if (strcmp(buffer, "0 2 2 1.2 1.8 0.12 0.38 0 -2 -2 -1.2 -1.8 -0.12 -0.38") == 0 ||
        strcmp(buffer, "0 2 2 1.2 1.8 0.12 0.38 -0 -2 -2 -1.2 -1.8 -0.12 -0.38") == 0) {
      fputs("#define ROUND_HALF_TO_EVEN\n", versionFile);
    } else if (strcmp(buffer, "1 2 3 1.3 1.8 0.13 0.38 -1 -2 -3 -1.3 -1.8 -0.13 -0.38") == 0) {
      fputs("#define ROUND_HALF_AWAY_FROM_ZERO\n", versionFile);
    } else if (strcmp(buffer, "1 2 3 1.3 1.8 0.13 0.38 0 -1 -2 -1.2 -1.7 -0.12 -0.37") == 0 ||
               strcmp(buffer, "1 2 3 1.3 1.8 0.13 0.38 -0 -1 -2 -1.2 -1.7 -0.12 -0.37") == 0) {
      fputs("#define ROUND_HALF_UP\n", versionFile);
    } /* if */
    sprintf(buffer, "%1.10e", DBL_MAX);
    sscanf(strchr(buffer,'e') + 1, "%ld", &number);
    fprintf(versionFile, "#define DOUBLE_MAX_EXP10 %ld\n", number);
    sprintf(buffer, "%ld", number);
    fprintf(versionFile, "#define DOUBLE_MAX_EXP10_DIGITS %lu\n",
            (long unsigned) strlen(buffer));
    sprintf(buffer, "%1.14e", 1.12345678901234);
    fprintf(versionFile, "#define DOUBLE_MIN_EXP10_DIGITS %u\n", (unsigned int) strlen(buffer) - 18);
    fprintf(versionFile, "#define FLOAT_STR_FORMAT \"%%1.%de\"\n", FLT_DIG - 1);
    fprintf(versionFile, "#define FLOAT_STR_LARGE_NUMBER 1.0e%d\n", FLT_DIG);
    fprintf(versionFile, "#define DOUBLE_STR_FORMAT \"%%1.%de\"\n", DBL_DIG - 1);
    fprintf(versionFile, "#define DOUBLE_STR_LARGE_NUMBER 1.0e%d\n", DBL_DIG);
    if (!compileAndLinkOk("#include<stdio.h>\n"
                          "int main(int argc,char *argv[]){"
                          "printf(\"%f\", 1.0/0.0);return 0;}\n") ||
        !compileAndLinkOk("#include<stdlib.h>\n#include<stdio.h>\n#include<float.h>\n#include<signal.h>\n"
                          "void handleSig(int sig){puts(\"2\");exit(0);}\n"
                          "int main(int argc,char *argv[]){\n"
#ifdef TURN_OFF_FP_EXCEPTIONS
                          "_control87(MCW_EM, MCW_EM);\n"
#endif
                          "signal(SIGFPE,handleSig);\nsignal(SIGILL,handleSig);\nsignal(SIGINT,handleSig);\n"
                          "printf(\"%d\\n\",1.0/0.0==0.0);return 0;}\n") || doTest() == 2) {
      fputs("#define FLOAT_ZERO_DIV_ERROR\n", versionFile);
    } /* if */
    if (!compileAndLinkOk("#include<stdlib.h>\n#include<stdio.h>\n#include<float.h>\n#include<signal.h>\n"
                          "void handleSig(int sig){puts(\"2\");exit(0);}\n"
                          "int main(int argc,char *argv[]){\n"
                          "float zero=0.0;\n"
#ifdef TURN_OFF_FP_EXCEPTIONS
                          "_control87(MCW_EM, MCW_EM);\n"
#endif
                          "signal(SIGFPE,handleSig);\nsignal(SIGILL,handleSig);\nsignal(SIGINT,handleSig);\n"
                          "printf(\"%d\\n\",1.0/zero==0.0);return 0;}\n") || doTest() == 2) {
      fputs("#define CHECK_FLOAT_DIV_BY_ZERO\n", versionFile);
      zero_divide_triggers_signal = 1;
      if (sizeof(float) == sizeof(int)) {
        union {
          unsigned int i;
          float f;
        } transfer;
        transfer.i = 0xffc00000;
        nanValue1 = transfer.f;
        transfer.i = 0x7f800000;
        plusInf = transfer.f;
        transfer.i = 0xff800000;
        minusInf = transfer.f;
        transfer.i = 0x80000000;
        negativeZero = transfer.f;
      } else if (sizeof(float) == sizeof(long)) {
        union {
          unsigned long i;
          float f;
        } transfer;
        transfer.i = 0xffc00000;
        nanValue1 = transfer.f;
        transfer.i = 0x7f800000;
        plusInf = transfer.f;
        transfer.i = 0xff800000;
        minusInf = transfer.f;
        transfer.i = 0x80000000;
        negativeZero = transfer.f;
      } /* if */
      nanValue2 = nanValue1;
    } else {
      nanValue1 = 0.0 / zero;
      nanValue2 = 0.0 / zero;
      plusInf = 1.0 / zero;
      minusInf = -plusInf;
      negativeZero = -1.0 / plusInf;
      if (plusInf == minusInf || -1.0 / zero != minusInf) {
        fputs("#define CHECK_FLOAT_DIV_BY_ZERO\n", versionFile);
      } /* if */
    } /* if */
    if (0.0 * plusInf != nanValue1 || 0.0 * minusInf != nanValue1 ||
        plusInf * 0.0 != nanValue1 || minusInf * 0.0 != nanValue1) {
      fputs("#define FLOAT_ZERO_TIMES_INFINITE_WRONG\n", versionFile);
    } /* if */
    if (nanValue1 == nanValue2 ||
        nanValue1 <  nanValue2 || nanValue1 >  nanValue2 ||
        nanValue1 <= nanValue2 || nanValue1 >= nanValue2) {
      fputs("#define NAN_COMPARISON_WRONG\n", versionFile);
    } /* if */
    minusZero = -zero;
    if (zero_divide_triggers_signal ||
        memcmp(&negativeZero, &minusZero, sizeof(float)) != 0) {
      fputs("#define USE_NEGATIVE_ZERO_BITPATTERN\n", versionFile);
    } /* if */
    if (pow(zero, -2.0) != plusInf || pow(negativeZero, -1.0) != minusInf) {
      fputs("#define POWER_OF_ZERO_WRONG\n", versionFile);
    } /* if */
    if (!compileAndLinkOk("#include<float.h>\n#include<math.h>\nint main(int argc,char *argv[])"
                          "{float f=0.0; isnan(f); return 0;}\n") &&
        compileAndLinkOk("#include<float.h>\n#include<math.h>\nint main(int argc,char *argv[])"
                         "{float f=0.0; _isnan(f); return 0;}\n")) {
      fputs("#define ISNAN_WITH_UNDERLINE\n", versionFile);
    } /* if */
    if (!compileAndLinkOk("#include<float.h>\n#include<math.h>\nint main(int argc,char *argv[])"
                          "{float f=0.0; isinf(f); return 0;}\n")) {
      if (compileAndLinkOk("#include<float.h>\n#include<math.h>\nint main(int argc,char *argv[])"
                           "{float f=0.0; _isinf(f); return 0;}\n")) {
        fputs("#define isinf _isinf\n", versionFile);
      } else if (fabs(plusInf) > DBL_MAX && fabs(minusInf) > DBL_MAX) {
        fputs("#define isinf(x) (fabs(x) > DBL_MAX)\n", versionFile);
      } /* if */
    } /* if */
    if (compileAndLinkOk("#include<stdlib.h>\n#include<stdio.h>\n#include<float.h>\n#include<signal.h>\n"
                         "void handleSig(int sig){puts(\"2\");exit(0);}\n"
                         "int main(int argc,char *argv[]){\n"
                         "float zero=1.0E37;\n"
#ifdef TURN_OFF_FP_EXCEPTIONS
                         "_control87(MCW_EM, MCW_EM);\n"
#endif
                         "signal(SIGFPE,handleSig);\nsignal(SIGILL,handleSig);\nsignal(SIGINT,handleSig);\n"
                         "printf(\"%d\\n\",(int) 1.0E37);return 0;}\n")) {
      testResult = doTest();
      if ((sizeof(int) == 4 && (long) testResult == 2147483647L) ||
          (sizeof(int) == 2 && testResult == 32767)) {
        fputs("#define FLOAT_TO_INT_OVERFLOW_SATURATES\n", versionFile);
      } else if (testResult == 2) {
        fputs("#define FLOAT_TO_INT_OVERFLOW_SIGNALS\n", versionFile);
      } else if (testResult == 0) {
        fputs("#define FLOAT_TO_INT_OVERFLOW_ZERO\n", versionFile);
      } else {
        fprintf(versionFile, "#define FLOAT_TO_INT_OVERFLOW_GARBAGE %d\n", testResult);
      } /* if */
    } /* if */
#if FLT_RADIX == 2
    floatRadixFactor = 1;
#elif FLT_RADIX == 4
    floatRadixFactor = 2;
#elif FLT_RADIX == 8
    floatRadixFactor = 3;
#elif FLT_RADIX == 16
    floatRadixFactor = 4;
#endif
    fprintf(versionFile, "#define FLOAT_MANTISSA_FACTOR %0.1f\n", pow((double) FLT_RADIX, (double) FLT_MANT_DIG));
    fprintf(versionFile, "#define FLOAT_MANTISSA_SHIFT %u\n", FLT_MANT_DIG * floatRadixFactor);
    fprintf(versionFile, "#define DOUBLE_MANTISSA_FACTOR %0.1f\n", pow((double) FLT_RADIX, (double) DBL_MANT_DIG));
    fprintf(versionFile, "#define DOUBLE_MANTISSA_SHIFT %u\n", DBL_MANT_DIG * floatRadixFactor);
    if (compileAndLinkOk("#include<stdio.h>\n#include<string.h>\n"
                         "int main(int argc,char *argv[]){\n"
                         "char buffer[100003];\n"
                         "sprintf(buffer, \"%1.100000f\", 1.0);\n"
                         "printf(\"%lu\\n\",(unsigned long)strlen(buffer));\n"
                         "return 0;}\n")) {
      testResult = doTest();
      if (testResult >= 2 && testResult < 100002) {
        fprintf(versionFile, "#define PRINTF_MAXIMUM_FLOAT_PRECISION %d\n", testResult - 2);
      } /* if */
    } /* if */
    printf(" determined\n");
  } /* numericProperties */



void determineMallocAlignment (FILE *versionFile)

  {
    int count;
    unsigned long malloc_result;
    int alignment;
    int minAlignment = 7;

  /* determineMallocAlignment */
    for (count = 1; count <= 64; count++) {
      malloc_result = (unsigned long) (size_t) malloc(count);
      alignment = alignmentTable[malloc_result & 0x3f];
      if (alignment < minAlignment) {
        minAlignment = alignment;
      } /* if */
    } /* for */
    fprintf(versionFile, "#define MALLOC_ALIGNMENT %d\n", minAlignment);
  } /* determineMallocAlignment */



void checkForLimitedStringLiteralLength (FILE *versionFile)
  {
    const char *programStart = "#include <stdio.h>\n#include <string.h>\n"
                               "int main(int argc, char *argv[]){\n"
                               "char *stri =\n";
    const char *line = "\"1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890\"\n";
    const char *programEnd = "; printf(\"%d\\n\", strlen(stri) != 0); return 0;}\n";
    const int repeatCount = 1000; /* Corresponds to a string literal length of 100000. */
    int lineLength;
    int totalLength;
    int count;
    char *buffer;
    char *bufPos;

  /* checkForLimitedStringLiteralLength */
    lineLength = strlen(line);
    totalLength = strlen(programStart) + lineLength * repeatCount + strlen(programEnd);
    buffer = (char *) malloc((totalLength + 1) * sizeof(char));
    strcpy(buffer, programStart);
    bufPos = &buffer[strlen(buffer)];
    for (count = 1; count <= repeatCount; count++) {
      strcpy(bufPos, line);
      bufPos += lineLength;
    } /* for */
    strcpy(bufPos, programEnd);
    /* printf("%s\n", buffer); */
    /* Some C compilers limit the maximum string literal length. */
    /* There are limits of 2,048 bytes and 16,384 (16K) bytes.   */
    if (!compileAndLinkOk(buffer)) {
      /* A string literal of size repeatCount * lineLength is not accepted. */
      fputs("#define LIMITED_CSTRI_LITERAL_LEN\n", versionFile);
    } /* if */
    free(buffer);
  } /* checkForLimitedStringLiteralLength */



void checkMoveDirectory (FILE *versionFile)

  {
    int pos;
    FILE *aFile;
    char *buffer[1024];
    int okay = 1;

  /* checkMoveDirectory */
    mkdir("test_dir1", 0755);
    mkdir("test_dir1/subdir1", 0755);
    aFile = fopen("test_dir1/subdir1/subfile", "w");
    if (aFile != NULL) {
      fprintf(aFile, "File content\n");
      fclose(aFile);
    } /* if */
    mkdir("test_dir2", 0755);
    if (rename("test_dir1/subdir1", "test_dir2/subdir2") != 0) {
      okay = 0;
    } /* if */
    if (fileIsDir("test_dir1/subdir1")) {
      okay = 0;
      if (fileIsRegular("test_dir1/subdir1/subfile")) {
        remove("test_dir1/subdir1/subfile");
      } /* if */
      rmdir("test_dir1/subdir1");
    } /* if */
    if (fileIsDir("test_dir2/subdir2")) {
      if (fileIsRegular("test_dir2/subdir2/subfile")) {
        aFile = fopen("test_dir2/subdir2/subfile", "r");
        if (aFile == NULL) {
          okay = 0;
        } else {
          if (fread(buffer, 1, 13, aFile) != 13 ||
              memcmp(buffer, "File content\n", 13) != 0) {
            okay = 0;
          } /* if */
          fclose(aFile);
        } /* if */
        remove("test_dir2/subdir2/subfile");
      } else {
        okay = 0;
      } /* if */
      rmdir("test_dir2/subdir2");
    } else {
      okay = 0;
    } /* if */
    rmdir("test_dir1");
    rmdir("test_dir2");
    if (!okay) {
      fputs("#define MOVE_DIR_WITH_RENAME_FAILS\n", versionFile);
    } /* if */
  } /* checkMoveDirectory */



void detemineStackDirection (FILE *versionFile)

  {
    char aVariable;

  /* detemineStackDirection */
    if (stack_base < &aVariable) {
      fputs("#define STACK_GROWS_UPWARD\n", versionFile);
    } else {
      fputs("#define STACK_GROWS_DOWNWARD\n", versionFile);
    } /* if */
  } /* detemineStackDirection */



void appendToFile (const char *fileName, const char *data)

  {
    FILE *outFile;

  /* appendToFile */
    outFile = fopen(fileName, "a");
    if (outFile != NULL) {
      fputs(data, outFile);
      fclose(outFile);
    } /* if */
  } /* appendToFile */



void escapeString (FILE *versionFile, const char *text)

  { /* escapeString */
    while (*text != '\0') {
      if (*text == '\"' || *text == '\\') {
        putc('\\', versionFile);
      } /* if */
      putc(*text, versionFile);
      text++;
    } /* while */
  } /* escapeString */



void appendOption (char *include_options, const char *includeOption)

  { /* appendOption */
    if (strstr(include_options, includeOption) == NULL) {
      if (include_options[0] != '\0' && includeOption != '\0') {
        strcat(include_options, " ");
      } /* if */
      strcat(include_options, includeOption);
    } /* if */
  } /* appendOption */



void determineX11Includes (FILE *versionFile, char *include_options)

  { /* determineX11Includes */
    if (!fileIsDir("/usr/include/X11") &&
        fileIsDir("/opt/X11/include/X11")) {
      appendOption(include_options, "-I/opt/X11/include");
    } /* if */
  } /* determineX11Includes */



#ifdef WITH_SQL
void detemineMySqlDefines (FILE *versionFile,
    char *include_options, char *system_db_libs)

  {
    const char *dbHomeSys[] = {"MariaDB/MariaDB C Client Library",
                               "MariaDB/MariaDB C Client Library 64-bit",
                               "MySQL/MySQL Connector C 6.1"};
#ifdef MYSQL_DLL
    const char *dllNameList[] = { MYSQL_DLL };
#else
    const char *dllNameList[] = {"libmariadb.dll", "libmysql.dll"};
#endif
    const char *libNameList[] = {"mariadbclient.lib", "vs11/mysqlclient.lib"};
    const char *programFilesX86 = NULL;
    const char *programFiles = NULL;
    const char *libName = NULL;
    char dbHome[4096];
    char includeOption[4096];
    const char *mySqlInclude;
    char buffer[4096];
    char linkerOptions[4096];
    int dbHomeExists = 0;
    int writeDllList = 0;
    int idx;

  /* detemineMySqlDefines */
#ifdef MYSQL_INCLUDE_OPTIONS
    strcpy(includeOption, MYSQL_INCLUDE_OPTIONS);
    mySqlInclude = "mysql.h";
#else
    includeOption[0] = '\0';
    mySqlInclude = "mysql/mysql.h";
#endif
    programFilesX86 = getenv("ProgramFiles(x86)");
    /* printf("programFilesX86: %s\n", programFilesX86); */
    programFiles = getenv("ProgramFiles");
    /* printf("programFiles: %s\n", programFiles); */
    if (programFiles != NULL) {
      if (sizeof(char *) == 4 && programFilesX86 != NULL) {
        programFiles = programFilesX86;
      } /* if */
      for (idx = 0; !dbHomeExists && idx < sizeof(dbHomeSys) / sizeof(char *); idx++) {
        sprintf(dbHome, "%s/%s", programFiles, dbHomeSys[idx]);
        if (fileIsDir(dbHome)) {
          dbHomeExists = 1;
        } /* if */
      } /* for */
    } /* if */
    if (dbHomeExists) {
      /* printf("dbHome=%s\n", dbHome); */
      sprintf(includeOption, "-I\"%s/include\"", dbHome);
      /* printf("includeOption=%s\n", includeOption); */
      if (compileAndLinkWithOptionsOk("#include \"stdlib.h\"\n#include \"mysql.h\"\n"
                                      "int main(int argc,char *argv[]){return 0;}\n",
                                      includeOption, "")) {
        mySqlInclude = "mysql.h";
        printf("MySql/MariaDb: %s found in %s/include\n", mySqlInclude, dbHome);
        appendOption(include_options, includeOption);
      } else {
        mySqlInclude = NULL;
      } /* if */
    } else {
      sprintf(buffer, "#include <%s>\n"
                      "int main(int argc,char *argv[]){return 0;}\n", mySqlInclude);
      if (compileAndLinkWithOptionsOk(buffer, includeOption, "")) {
        printf("MySql/MariaDb: %s found in system include directory.\n", mySqlInclude);
        appendOption(include_options, includeOption);
      } else if (compileAndLinkWithOptionsOk("#include \"db_my.h\"\n"
                                             "int main(int argc,char *argv[]){return 0;}\n",
                                             includeOption, "")) {
        mySqlInclude = "db_my.h";
        printf("MySql/MariaDb: %s found in Seed7 include directory.\n", mySqlInclude);
      } /* if */
    } /* if */
    if (mySqlInclude != NULL) {
      fprintf(versionFile, "#define MYSQL_INCLUDE \"%s\"\n", mySqlInclude);
    } /* if */
    /* Handle libraries: */
    if (dbHomeExists) {
#ifdef MYSQL_USE_LIB
      for (idx = 0; libName == NULL && idx < sizeof(libNameList) / sizeof(char *); idx++) {
        sprintf(buffer, "%s/lib/%s", dbHome, libNameList[idx]);
        if (fileIsRegular(buffer)) {
          libName = libNameList[idx];
        } /* if */
      } /* for */
      if (libName != NULL) {
        printf("MySql/MariaDb: %s found at: %s\n", libName, buffer);
        sprintf(buffer, "\"%s/lib/%s\"", dbHome, libName);
        appendOption(system_db_libs, buffer);
      } else {
        writeDllList = 1;
      } /* if */
#else
      writeDllList = 1;
#endif
      if (writeDllList) {
        fprintf(versionFile, "#define MYSQL_DLL");
        for (idx = 0; idx < sizeof(dllNameList) / sizeof(char *); idx++) {
          sprintf(buffer, "%s/lib/%s", dbHome, dllNameList[idx]);
          if (fileIsRegular(buffer)) {
            printf("MySql/MariaDb: %s found at: %s\n", dllNameList[idx], buffer);
            fprintf(versionFile, " \"");
            escapeString(versionFile, buffer);
            fprintf(versionFile, "\",");
          } /* if */
        } /* for */
        for (idx = 0; idx < sizeof(dllNameList) / sizeof(char *); idx++) {
          fprintf(versionFile, " \"%s\",", dllNameList[idx]);
        } /* for */
        fprintf(versionFile, "\n");
      } /* if */
    } else {
#if defined MYSQL_USE_LIB && defined MYSQL_LIBS
      sprintf(buffer, "#include \"stdlib.h\"\n#include \"%s\"\n"
                      "int main(int argc,char *argv[]){\n"
                      "MYSQL *conn;\n"
                      "conn = mysql_init(NULL);\n"
                      "if (conn != NULL) {\n"
                      "mysql_real_connect(conn, \"\", \"\", \"\", \"\", 0, NULL, 0);\n"
                      "mysql_close(conn);\n"
                      "}\nreturn 0;\n}\n", mySqlInclude);
      linkerOptions[0] = '\0';
#ifdef MYSQL_LIBRARY_PATH
      appendOption(linkerOptions, MYSQL_LIBRARY_PATH);
#endif
      appendOption(linkerOptions, MYSQL_LIBS);
      if (compileAndLinkWithOptionsOk(buffer, includeOption, linkerOptions)) {
#ifdef MYSQL_LIBRARY_PATH
        appendOption(system_db_libs, MYSQL_LIBRARY_PATH);
#endif
        printf("MySql/MariaDb: Linker option: %s\n", MYSQL_LIBS);
        appendOption(system_db_libs, MYSQL_LIBS);
      } else {
        writeDllList = 1;
      } /* if */
#else
      writeDllList = 1;
#endif
      if (writeDllList) {
        fprintf(versionFile, "#define MYSQL_DLL");
        for (idx = 0; idx < sizeof(dllNameList) / sizeof(char *); idx++) {
          printf("MySql/MariaDb: DLL / Shared library: %s\n", dllNameList[idx]);
          fprintf(versionFile, " \"%s\",", dllNameList[idx]);
        } /* for */
        fprintf(versionFile, "\n");
      } /* if */
    } /* if */
  } /* detemineMySqlDefines */



void detemineSqliteDefines (FILE *versionFile,
    char *include_options, char *system_db_libs)

  {
    const char *dbHomeDirs[] = {"C:/sqlite", "D:/sqlite"};
#ifdef SQLITE_DLL
    const char *dllNameList[] = { SQLITE_DLL };
#else
    const char *dllNameList[] = {"sqlite3.dll"};
#endif
    const char *libNameList[] = {"sqlite3.lib"};
    const char *dllName = NULL;
    const char *libName = NULL;
    char dbHome[4096];
    char includeOption[4096];
    const char *sqliteInclude = NULL;
    char buffer[4096];
    char linkerOptions[4096];
    int dbHomeExists = 0;
    int writeDllList = 0;
    int idx;

  /* detemineSqliteDefines */
#ifdef SQLITE_INCLUDE_OPTIONS
    strcpy(includeOption, SQLITE_INCLUDE_OPTIONS);
#else
    includeOption[0] = '\0';
#endif
    for (idx = 0; !dbHomeExists && idx < sizeof(dbHomeDirs) / sizeof(char *); idx++) {
      strcpy(dbHome, dbHomeDirs[idx]);
      if (fileIsDir(dbHome)) {
        dbHomeExists = 1;
      } /* if */
    } /* for */
    if (dbHomeExists) {
      /* printf("dbHome=%s\n", dbHome); */
      sprintf(includeOption, "-I\"%s\"", dbHome);
      /* printf("includeOption=%s\n", includeOption); */
      if (compileAndLinkWithOptionsOk("#include <sqlite3.h>\n"
                                      "int main(int argc,char *argv[]){return 0;}\n",
                                      includeOption, "")) {
        sqliteInclude = "sqlite3.h";
        printf("SQLite: %s found in %s\n", sqliteInclude, dbHome);
        appendOption(include_options, includeOption);
      } /* if */
    } else if (compileAndLinkWithOptionsOk("#include <sqlite3.h>\n"
                                           "int main(int argc,char *argv[]){return 0;}\n",
                                           includeOption, "")) {
      sqliteInclude = "sqlite3.h";
      printf("SQLite: %s found in system include directory.\n", sqliteInclude);
      appendOption(include_options, includeOption);
    } else if (compileAndLinkWithOptionsOk("#include \"tst_vers.h\"\n#include \"db_lite.h\"\n"
                                           "int main(int argc,char *argv[]){return 0;}\n",
                                           includeOption, "")) {
      sqliteInclude = "db_lite.h";
      printf("SQLite: %s found in Seed7 include directory.\n", sqliteInclude);
      appendOption(include_options, includeOption);
    } /* if */
    if (sqliteInclude != NULL) {
      fprintf(versionFile, "#define SQLITE_INCLUDE \"%s\"\n", sqliteInclude);
    } /* if */
    /* Handle libraries: */
    if (dbHomeExists) {
#ifdef SQLITE_USE_LIB
      for (idx = 0; libName == NULL && idx < sizeof(libNameList) / sizeof(char *); idx++) {
        sprintf(buffer, "%s/%s", dbHome, libNameList[idx]);
        if (fileIsRegular(buffer)) {
          libName = libNameList[idx];
        } /* if */
      } /* for */
      if (libName != NULL) {
        printf("SQLite: %s found at: %s\n", libName, buffer);
        sprintf(buffer, "\"%s/%s\"", dbHome, libName);
        appendOption(system_db_libs, buffer);
      } else {
        writeDllList = 1;
      } /* if */
#else
      writeDllList = 1;
#endif
      if (writeDllList) {
        fprintf(versionFile, "#define SQLITE_DLL");
        for (idx = 0; idx < sizeof(dllNameList) / sizeof(char *); idx++) {
          sprintf(buffer, "%s/lib/%s", dbHome, dllNameList[idx]);
          if (fileIsRegular(buffer)) {
            printf("SQLite: %s found at: %s\n", dllNameList[idx], buffer);
            fprintf(versionFile, " \"");
            escapeString(versionFile, buffer);
            fprintf(versionFile, "\",");
          } /* if */
        } /* for */
        for (idx = 0; idx < sizeof(dllNameList) / sizeof(char *); idx++) {
          fprintf(versionFile, " \"%s\",", dllNameList[idx]);
        } /* for */
        fprintf(versionFile, "\n");
      } /* if */
    } else {
#if defined SQLITE_USE_LIB && defined SQLITE_LIBS
      sprintf(buffer, "#include \"tst_vers.h\"\n#include \"%s\"\n"
                      "int main(int argc,char *argv[]){\n"
                      "sqlite3 *conn;\n"
                      "sqlite3_open(\"\", &conn);\n"
                      "sqlite3_close(conn);\n"
                      "return 0;\n}\n", sqliteInclude);
      linkerOptions[0] = '\0';
#ifdef SQLITE_LIBRARY_PATH
      appendOption(linkerOptions, SQLITE_LIBRARY_PATH);
#endif
      appendOption(linkerOptions, SQLITE_LIBS);
      if (compileAndLinkWithOptionsOk(buffer, includeOption, linkerOptions)) {
#ifdef SQLITE_LIBRARY_PATH
        appendOption(system_db_libs, SQLITE_LIBRARY_PATH);
#endif
        printf("SQLite: Linker option: %s\n", SQLITE_LIBS);
        appendOption(system_db_libs, SQLITE_LIBS);
      } else {
        writeDllList = 1;
      } /* if */
#else
      writeDllList = 1;
#endif
      if (writeDllList) {
        fprintf(versionFile, "#define SQLITE_DLL");
        for (idx = 0; idx < sizeof(dllNameList) / sizeof(char *); idx++) {
          printf("SQLite: DLL / Shared library: %s\n", dllNameList[idx]);
          fprintf(versionFile, " \"%s\",", dllNameList[idx]);
        } /* for */
        fprintf(versionFile, "\n");
      } /* if */
    } /* if */
  } /* detemineSqliteDefines */



static void extractPostgresOid (const char* pgTypeFileName)
  {
    const char *oidNames[] = {
      "ABSTIMEOID",     "ACLITEMOID",      "ANYARRAYOID",     "ANYELEMENTOID",    "ANYENUMOID",
      "ANYNONARRAYOID", "ANYOID",          "BITOID",          "BOOLOID",          "BOXOID",
      "BPCHAROID",      "BYTEAOID",        "CASHOID",         "CHAROID",          "CIDOID",
      "CIDROID",        "CIRCLEOID",       "CSTRINGARRAYOID", "CSTRINGOID",       "DATEOID",
      "FDW_HANDLEROID", "FLOAT4ARRAYOID",  "FLOAT4OID",       "FLOAT8OID",        "GTSVECTOROID",
      "INETOID",        "INT2ARRAYOID",    "INT2OID",         "INT2VECTOROID",    "INT4ARRAYOID",
      "INT4OID",        "INT8OID",         "INTERNALOID",     "INTERVALOID",      "LANGUAGE_HANDLEROID",
      "LINEOID",        "LSEGOID",         "MACADDROID",      "NAMEOID",          "NUMERICOID",
      "OIDARRAYOID",    "OIDOID",          "OIDVECTOROID",    "OPAQUEOID",        "PATHOID",
      "PGNODETREEOID",  "POINTOID",        "POLYGONOID",      "RECORDARRAYOID",   "RECORDOID",
      "REFCURSOROID",   "REGCLASSOID",     "REGCONFIGOID",    "REGDICTIONARYOID", "REGOPERATOROID",
      "REGOPEROID",     "REGPROCEDUREOID", "REGPROCOID",      "REGTYPEARRAYOID",  "REGTYPEOID",
      "RELTIMEOID",     "TEXTARRAYOID",    "TEXTOID",         "TIDOID",           "TIMEOID",
      "TIMESTAMPOID",   "TIMESTAMPTZOID",  "TIMETZOID",       "TINTERVALOID",     "TRIGGEROID",
      "TSQUERYOID",     "TSVECTOROID",     "UNKNOWNOID",      "VARBITOID",        "VARCHAROID",
      "VOIDOID",        "XIDOID",          "XMLOID"};
    FILE *pgTypeFile;
    FILE *oidFile;
    char buffer[4096];
    char *line;
    int pos;
    int idx;
    int spaces;

  /* extractPostgresOid */
    printf("Extracting OIDs from: %s\n", pgTypeFileName);
    pgTypeFile = fopen(pgTypeFileName, "r");
    if (pgTypeFile != NULL) {
      oidFile = fopen("pg_type.h", "w");
      if (oidFile != NULL) {
        fputs("/* Do not edit this file. It has been generated by chkccomp.c. */\n", oidFile);
        fputs("/* The contents of this file have been extracted from: */\n", oidFile);
        fprintf(oidFile, "/*   %s */\n", pgTypeFileName);
        fputs("\n", oidFile);
        while ((line = fgets(buffer, 4096, pgTypeFile)) != NULL) {
          pos = 0;
          while (line[pos] == ' ' || line[pos] == '\t') {
            pos++;
          } /* if */
          if (line[pos] == '#') {
            pos++;
            while (line[pos] == ' ' || line[pos] == '\t') {
              pos++;
            } /* if */
            if (strncmp(&line[pos], "define", 6) == 0) {
              pos += 6;
              while (line[pos] == ' ' || line[pos] == '\t') {
                pos++;
              } /* if */
              for (idx = 0; idx < sizeof(oidNames) / sizeof(char *); idx++) {
                if (strncmp(&line[pos], oidNames[idx], strlen(oidNames[idx])) == 0) {
                  fprintf(oidFile, "#define %s ", oidNames[idx]);
                  pos += strlen(oidNames[idx]);
                  while (line[pos] == ' ' || line[pos] == '\t') {
                    pos++;
                  } /* if */
                  spaces = 24 - strlen(oidNames[idx]) - strlen(&line[pos]);
                  while (spaces > 0) {
                    fputc(' ', oidFile);
                    spaces--;
                  } /* while */
                  fputs(&line[pos], oidFile);
                  idx = sizeof(oidNames) / sizeof(char *);
                } /* if */
              } /* for */
            } /* if */
          } /* if */
        } /* while */
        fclose(oidFile);
      } /* if */
      fclose(pgTypeFile);
    } /* if */
  } /* extractPostgresOid */



static int findPgTypeInclude (const char *includeOption, const char *pgTypeInclude)

  {
    const char *optionPos;
    const char *optionEnd;
    char includeDir[4096];
    char pgTypeFileName[4096];
    int found = 0;

  /* findPgTypeInclude */
    /* printf("findPgTypeInclude(\"%s\")\n", includeOption); */
    while (includeOption != NULL && (optionPos = strstr(includeOption, "-I")) != NULL) {
      if (optionPos[2] == '\"') {
        optionEnd = strchr(&optionPos[3], '\"');
        if (optionEnd == NULL) {
          strcpy(includeDir, &optionPos[3]);
          includeOption = NULL;
        } else {
          memcpy(includeDir, &optionPos[3], optionEnd - &optionPos[3]);
          includeDir[optionEnd - &optionPos[3]] = '\0';
          includeOption = optionEnd + 1;
        } /* if */
      } else {
        optionEnd = strchr(&optionPos[2], ' ');
        if (optionEnd == NULL) {
          strcpy(includeDir, &optionPos[2]);
          includeOption = NULL;
        } else {
          memcpy(includeDir, &optionPos[2], optionEnd - &optionPos[2]);
          includeDir[optionEnd - &optionPos[2]] = '\0';
          includeOption = optionEnd + 1;
        } /* if */
      } /* if */
      /* printf("includeDir: \"%s\"\n", includeDir); */
      if (includeDir[0] != '\0'  && fileIsDir(includeDir)) {
        sprintf(pgTypeFileName, "%s/%s", includeDir, pgTypeInclude);
        if (fileIsRegular(pgTypeFileName)) {
          extractPostgresOid(pgTypeFileName);
          includeOption = NULL;
          found = 1;
        } /* if */
      } /* if */
    } /* while */
    return found;
  } /* findPgTypeInclude */



void deteminePostgresDefines (FILE *versionFile,
    char *include_options, char *system_db_libs)

  {
    const char *dbHomeSys[] = {"PostgreSQL/9.4", "PostgreSQL/9.3", "PostgreSQL/9.2",
                               "PostgreSQL/9.1", "PostgreSQL/9.0", "PostgreSQL/8.4",
                               "PostgreSQL/8.3"};
#ifdef POSTGRESQL_DLL
    const char *dllNameList[] = { POSTGRESQL_DLL };
#else
    const char *dllNameList[] = {"libpq.dll"};
#endif
    const char *libNameList[] = {"libpq.lib"};
    const char *libIntlDllList[] = {"libintl.dll", "libintl-8.dll"};
    const char *serverIncludeOption = "-I/usr/include/postgresql/server";
    const char *programFilesX86 = NULL;
    const char *programFiles = NULL;
    const char *dllName = NULL;
    const char *libName = NULL;
    char dbHome[4096];
    char includeOption[4096];
    const char *postgresqlInclude = NULL;
    const char *postgresInclude = NULL;
    const char *pgTypeInclude = NULL;
    char buffer[4096];
    char linkerOptions[4096];
    int dbHomeExists = 0;
    int writeDllList = 0;
    int idx;

  /* deteminePostgresDefines */
#ifdef POSTGRESQL_INCLUDE_OPTIONS
    strcpy(includeOption, POSTGRESQL_INCLUDE_OPTIONS);
#else
    strcpy(includeOption, "-I/usr/include/postgresql");
#endif
    programFilesX86 = getenv("ProgramFiles(x86)");
    /* printf("programFilesX86: %s\n", programFilesX86); */
    programFiles = getenv("ProgramFiles");
    /* printf("programFiles: %s\n", programFiles); */
    if (programFiles != NULL) {
      if (sizeof(char *) == 4 && programFilesX86 != NULL) {
        programFiles = programFilesX86;
      } /* if */
      for (idx = 0; !dbHomeExists && idx < sizeof(dbHomeSys) / sizeof(char *); idx++) {
        sprintf(dbHome, "%s/%s", programFiles, dbHomeSys[idx]);
        if (fileIsDir(dbHome)) {
          dbHomeExists = 1;
        } /* if */
      } /* for */
    } /* if */
    if (dbHomeExists) {
      /* printf("dbHome=%s\n", dbHome); */
      sprintf(includeOption, "-I\"%s/include\"", dbHome);
      /* printf("includeOption=%s\n", includeOption); */
      if (compileAndLinkWithOptionsOk("#include \"libpq-fe.h\"\n"
                                      "int main(int argc,char *argv[]){return 0;}\n",
                                      includeOption, "")) {
        postgresqlInclude = "libpq-fe.h";
        printf("PostgreSQL: %s found in %s/include\n", postgresqlInclude, dbHome);
        appendOption(include_options, includeOption);
        sprintf(buffer, "%s/include/server", dbHome);
        if (fileIsDir(buffer)) {
          sprintf(buffer, "%s/include/server/catalog/pg_type.h", dbHome);
        } else {
          sprintf(buffer, "%s/include/catalog/pg_type.h", dbHome);
        } /* if */
        extractPostgresOid(buffer);
        pgTypeInclude = "pg_type.h";
        printf("PostgreSQL: %s found in Seed7 directory.\n", pgTypeInclude);
      } /* if */
    } else if (compileAndLinkWithOptionsOk("#include <libpq-fe.h>\n"
                                    "int main(int argc,char *argv[]){return 0;}\n",
                                    includeOption, "")) {
      postgresqlInclude = "libpq-fe.h";
      printf("PostgreSQL: %s found in system include directory.\n", postgresqlInclude);
      appendOption(include_options, includeOption);
      if (compileAndLinkWithOptionsOk("#include <server/postgres.h>\n"
                                      "int main(int argc,char *argv[]){return 0;}\n",
                                      includeOption, "")) {
        postgresInclude = "server/postgres.h";
        pgTypeInclude = "server/catalog/pg_type.h";
      } else {
        appendOption(includeOption, serverIncludeOption);
        if (compileAndLinkWithOptionsOk("#include <server/postgres.h>\n"
                                        "int main(int argc,char *argv[]){return 0;}\n",
                                        includeOption, "")) {
          appendOption(include_options, serverIncludeOption);
          postgresInclude = "server/postgres.h";
          pgTypeInclude = "server/catalog/pg_type.h";
        } else {
          postgresInclude = "postgres.h";
          pgTypeInclude = "catalog/pg_type.h";
        } /* if */
      } /* if */
      sprintf(buffer, "#include <%s>\n#include <%s>\n"
                      "int main(int argc,char *argv[]){return 0;}\n",
	              postgresInclude, pgTypeInclude);
      if (compileAndLinkWithOptionsOk(buffer, includeOption, "")) {
        printf("PostgreSQL: %s found in system include directory.\n", pgTypeInclude);
      } else if (findPgTypeInclude(includeOption, pgTypeInclude)) {
        pgTypeInclude = "pg_type.h";
        printf("PostgreSQL: %s found in Seed7 include directory.\n", pgTypeInclude);
      } else {
        printf("PostgreSQL: %s not found in include directories.\n", pgTypeInclude);
      } /* if */
    } else if (compileAndLinkWithOptionsOk("#include \"db_post.h\"\n"
                                           "int main(int argc,char *argv[]){return 0;}\n",
                                           "", "")) {
      postgresqlInclude = "db_post.h";
      printf("PostgreSQL: %s found in Seed7 include directory.\n", postgresqlInclude);
    } /* if */
    if (postgresqlInclude != NULL) {
      fprintf(versionFile, "#define POSTGRESQL_INCLUDE \"%s\"\n", postgresqlInclude);
    } /* if */
    if (postgresInclude != NULL) {
      fprintf(versionFile, "#define POSTGRESQL_POSTGRES_H \"%s\"\n", postgresInclude);
    } /* if */
    if (pgTypeInclude != NULL) {
      fprintf(versionFile, "#define POSTGRESQL_PG_TYPE_H \"%s\"\n", pgTypeInclude);
    } /* if */
    /* Handle libraries: */
    if (dbHomeExists) {
#ifdef POSTGRESQL_USE_LIB
      for (idx = 0; libName == NULL && idx < sizeof(libNameList) / sizeof(char *); idx++) {
        sprintf(buffer, "%s/lib/%s", dbHome, libNameList[idx]);
        if (fileIsRegular(buffer)) {
          libName = libNameList[idx];
        } /* if */
      } /* for */
      if (libName != NULL) {
        printf("PostgreSQL: %s found at: %s\n", libName, buffer);
        sprintf(buffer, "\"%s/lib/%s\"", dbHome, libName);
        appendOption(system_db_libs, buffer);
      } else {
        writeDllList = 1;
      } /* if */
#else
      writeDllList = 1;
#endif
      if (writeDllList) {
        fprintf(versionFile, "#define POSTGRESQL_DLL");
        for (idx = 0; idx < sizeof(dllNameList) / sizeof(char *); idx++) {
          sprintf(buffer, "%s/lib/%s", dbHome, dllNameList[idx]);
          if (fileIsRegular(buffer)) {
            printf("PostgreSQL: %s found at: %s\n", dllNameList[idx], buffer);
            fprintf(versionFile, " \"");
            escapeString(versionFile, buffer);
            fprintf(versionFile, "\",");
          } /* if */
        } /* for */
        for (idx = 0; idx < sizeof(dllNameList) / sizeof(char *); idx++) {
          fprintf(versionFile, " \"%s\",", dllNameList[idx]);
        } /* for */
        fprintf(versionFile, "\n");
        dllName = NULL;
        for (idx = 0; dllName == NULL && idx < sizeof(libIntlDllList) / sizeof(char *); idx++) {
          sprintf(buffer, "%s/bin/%s", dbHome, libIntlDllList[idx]);
          if (fileIsRegular(buffer)) {
            dllName = libIntlDllList[idx];
          } /* if */
        } /* for */
        if (dllName != NULL) {
          printf("PostgreSQL: %s found at: %s\n", dllName, buffer);
          fprintf(versionFile, "#define LIBINTL_DLL_PATH \"");
          escapeString(versionFile, buffer);
          fprintf(versionFile, "\"\n");
          fprintf(versionFile, "#define LIBINTL_DLL \"%s\"\n", dllName);
        } /* if */
      } /* if */
    } else {
#if defined POSTGRESQL_USE_LIB && defined POSTGRESQL_LIBS
      sprintf(buffer, "#include \"stdlib.h\"\n#include \"%s\"\n"
                      "int main(int argc,char *argv[]){\n"
                      "PGconn *conn;\n"
                      "conn = PQsetdbLogin(\"\", NULL, NULL, NULL, \"\", \"\", \"\");\n"
                      "PQfinish(conn);\n"
                      "return 0;\n}\n", postgresqlInclude);
      linkerOptions[0] = '\0';
#ifdef POSTGRESQL_LIBRARY_PATH
      appendOption(linkerOptions, POSTGRESQL_LIBRARY_PATH);
#endif
      appendOption(linkerOptions, POSTGRESQL_LIBS);
      if (compileAndLinkWithOptionsOk(buffer, includeOption, linkerOptions)) {
#ifdef POSTGRESQL_LIBRARY_PATH
        appendOption(system_db_libs, POSTGRESQL_LIBRARY_PATH);
#endif
        printf("PostgreSQL: Linker option: %s\n", POSTGRESQL_LIBS);
        appendOption(system_db_libs, POSTGRESQL_LIBS);
      } else {
        writeDllList = 1;
      } /* if */
#else
      writeDllList = 1;
#endif
      if (writeDllList) {
        fprintf(versionFile, "#define POSTGRESQL_DLL");
        for (idx = 0; idx < sizeof(dllNameList) / sizeof(char *); idx++) {
          printf("PostgreSQL: DLL / Shared library: %s\n", dllNameList[idx]);
          fprintf(versionFile, " \"%s\",", dllNameList[idx]);
        } /* for */
        fprintf(versionFile, "\n");
      } /* if */
    } /* if */
  } /* deteminePostgresDefines */



void detemineOdbcDefines (FILE *versionFile,
    char *include_options, char *system_db_libs)

  {
#ifdef ODBC_DLL
    const char *dllNameList[] = { ODBC_DLL };
#else
    const char *dllNameList[] = {"odbc32.dll"};
#endif
    char includeOption[4096];
    const char *odbcInclude = NULL;
    char buffer[4096];
    char linkerOptions[4096];
    int writeDllList = 0;
    int idx;

  /* detemineOdbcDefines */
#ifdef ODBC_INCLUDE_OPTIONS
    strcpy(includeOption, ODBC_INCLUDE_OPTIONS);
#else
    includeOption[0] = '\0';
#endif
    if (compileAndLinkWithOptionsOk("#include <windows.h>\n#include <sql.h>\n"
                                    "int main(int argc,char *argv[]){return 0;}\n",
                                    includeOption, "")) {
      fputs("#define WINDOWS_ODBC\n", versionFile);
      fputs("#define ODBC_INCLUDE_SQLEXT\n", versionFile);
      odbcInclude = "sql.h";
      printf("Odbc: %s found in system include directory.\n", odbcInclude);
    } else if (compileAndLinkWithOptionsOk("#include <sql.h>\n"
                                           "int main(int argc,char *argv[]){return 0;}\n",
                                           includeOption, "")) {
      fputs("#define ODBC_INCLUDE_SQLEXT\n", versionFile);
      odbcInclude = "sql.h";
      printf("Odbc: %s found in system include directory.\n", odbcInclude);
    } else if (compileAndLinkWithOptionsOk("#include \"tst_vers.h\"\n#include \"db_odbc.h\"\n"
                                           "int main(int argc,char *argv[]){return 0;}\n",
                                           "", "")) {
      odbcInclude = "db_odbc.h";
      printf("Odbc: %s found in Seed7 include directory.\n", odbcInclude);
      includeOption[0] = '\0';
    } /* if */
    if (odbcInclude != NULL) {
      fprintf(versionFile, "#define ODBC_INCLUDE \"%s\"\n", odbcInclude);
      appendOption(include_options, includeOption);
    } /* if */
    /* Handle libraries: */
#if defined ODBC_USE_LIB && defined ODBC_LIBS
    sprintf(buffer, "#include \"tst_vers.h\"\n#include \"%s\"\n"
                    "int main(int argc,char *argv[]){\n"
                    "SQLHENV sql_env;\n"
                    "SQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HANDLE, &sql_env);\n"
                    "SQLFreeHandle(SQL_HANDLE_ENV, sql_env);\n"
                    "return 0;\n}\n", odbcInclude);
    linkerOptions[0] = '\0';
#ifdef ODBC_LIBRARY_PATH
    appendOption(linkerOptions, ODBC_LIBRARY_PATH);
#endif
    appendOption(linkerOptions, ODBC_LIBS);
    if (compileAndLinkWithOptionsOk(buffer, includeOption, linkerOptions)) {
#ifdef ODBC_LIBRARY_PATH
      appendOption(system_db_libs, ODBC_LIBRARY_PATH);
#endif
      printf("Odbc: Linker option: %s\n", ODBC_LIBS);
      appendOption(system_db_libs, ODBC_LIBS);
    } else {
      writeDllList = 1;
    } /* if */
#else
    writeDllList = 1;
#endif
    if (writeDllList) {
      fprintf(versionFile, "#define ODBC_DLL");
      for (idx = 0; idx < sizeof(dllNameList) / sizeof(char *); idx++) {
        printf("Odbc: DLL / Shared library: %s\n", dllNameList[idx]);
        fprintf(versionFile, " \"%s\",", dllNameList[idx]);
      } /* for */
      fprintf(versionFile, "\n");
    } /* if */
  } /* detemineOdbcDefines */



void detemineOciDefines (FILE *versionFile,
    char *include_options, char *system_db_libs)

  {
    char *oracle_home;
    const char *oci_incl_dir[] = {"/rdbms/public", "/oci/include"};
    const char *oci_dll_dir[] = {"/lib", "/bin"};
#ifdef OCI_DLL
    const char *dllNameList[] = { OCI_DLL };
#else
    const char *dllNameList[] = {"oci.dll"};
#endif
    char incl_path[4096];
    char dll_path[4096];
    char includeOption[4096];
    const char *ociInclude = NULL;
    char buffer[4096];
    char linkerOptions[4096];
    int writeDllList = 0;
    int incl_dir_idx;
    int dll_dir_idx;
    int idx;
    int found = 0;

  /* detemineOciDefines */
#ifdef OCI_INCLUDE_OPTIONS
    strcpy(includeOption, OCI_INCLUDE_OPTIONS);
#else
    includeOption[0] = '\0';
#endif
    oracle_home = getenv("ORACLE_HOME");
    if (oracle_home != NULL) {
      /* printf("ORACLE_HOME=%s\n", oracle_home); */
      for (incl_dir_idx = 0;
           ociInclude == NULL && incl_dir_idx < sizeof(oci_incl_dir) / sizeof(char *);
           incl_dir_idx++) {
        sprintf(incl_path, "%s%s/oci.h", oracle_home, oci_incl_dir[incl_dir_idx]);
        if (fileIsRegular(incl_path)) {
          sprintf(includeOption, "-I%s%s", oracle_home, oci_incl_dir[incl_dir_idx]);
          if (compileAndLinkWithOptionsOk("#include \"oci.h\"\n"
                                          "int main(int argc,char *argv[]){return 0;}\n",
                                          includeOption, "")) {
            ociInclude = "oci.h";
            printf("Oracle: %s found in %s%s\n", ociInclude, oracle_home, oci_incl_dir[incl_dir_idx]);
            appendOption(include_options, includeOption);
          } /* if */
        } /* if */
      } /* for */
    } else if (compileAndLinkWithOptionsOk("#include <oci.h>\n"
                                           "int main(int argc,char *argv[]){return 0;}\n",
                                           includeOption, "")) {
      ociInclude = "oci.h";
      printf("Oracle: %s found in system include directory.\n", ociInclude);
      appendOption(include_options, includeOption);
    } else if (compileAndLinkWithOptionsOk("#include \"tst_vers.h\"\n#include \"stdlib.h\"\n"
                                           "#include \"db_oci.h\"\n"
                                           "int main(int argc,char *argv[]){return 0;}\n",
                                           includeOption, "")) {
      ociInclude = "db_oci.h";
      printf("Oracle: %s found in Seed7 include directory.\n", ociInclude);
      appendOption(include_options, includeOption);
    } /* if */
    if (ociInclude != NULL) {
      fprintf(versionFile, "#define OCI_INCLUDE \"%s\"\n", ociInclude);
    } /* if */
    /* Handle libraries: */
    if (oracle_home != NULL) {
#if defined OCI_USE_LIB && defined OCI_LIBS
#ifdef OCI_LIBRARY_PATH
      appendOption(system_db_libs, OCI_LIBRARY_PATH);
#endif
      appendOption(system_db_libs, OCI_LIBS);
#else
      fprintf(versionFile, "#define OCI_DLL");
      for (idx = 0; idx < sizeof(dllNameList) / sizeof(char *); idx++) {
        fprintf(versionFile, " \"%s\",", dllNameList[idx]);
      } /* for */
      fprintf(versionFile, "\n");
      for (dll_dir_idx = 0; !found && dll_dir_idx < sizeof(oci_dll_dir) / sizeof(char *); dll_dir_idx++) {
        sprintf(dll_path, "%s%s", oracle_home, oci_dll_dir[dll_dir_idx]);
        if (fileIsDir(dll_path)) {
          for (idx = 0; idx < sizeof(dllNameList) / sizeof(char *); idx++) {
            sprintf(buffer, "%s%s/%s", oracle_home, oci_dll_dir[dll_dir_idx], dllNameList[idx]);
            if (fileIsRegular(buffer)) {
              sprintf(buffer, "-Wl,-rpath=%s%s", oracle_home, oci_dll_dir[dll_dir_idx]);
              appendOption(system_db_libs, buffer);
              found = 1;
            } /* if */
          } /* for */
        } /* if */
      } /* for */
#endif
    } else {
#if defined OCI_USE_LIB && defined OCI_LIBS
      sprintf(buffer, "#include \"tst_vers.h\"\n#include \"stdlib.h\"\n#include \"%s\"\n"
                      "int main(int argc,char *argv[]){\n"
                      "OCIEnv *oci_env;\n"
                      "OCIEnvCreate(&oci_env, OCI_DEFAULT, NULL, NULL, NULL, NULL, 0, NULL);\n"
                      "OCIHandleFree(oci_env, OCI_HTYPE_ENV);\n"
                      "return 0;\n}\n", ociInclude);
      linkerOptions[0] = '\0';
#ifdef OCI_LIBRARY_PATH
      appendOption(linkerOptions, OCI_LIBRARY_PATH);
#endif
      appendOption(linkerOptions, OCI_LIBS);
      if (compileAndLinkWithOptionsOk(buffer, includeOption, linkerOptions)) {
#ifdef OCI_LIBRARY_PATH
        appendOption(system_db_libs, OCI_LIBRARY_PATH);
#endif
        printf("Oracle: Linker option: %s\n", OCI_LIBS);
        appendOption(system_db_libs, OCI_LIBS);
      } else {
        writeDllList = 1;
      } /* if */
#else
      writeDllList = 1;
#endif
      if (writeDllList) {
        fprintf(versionFile, "#define OCI_DLL");
        for (idx = 0; idx < sizeof(dllNameList) / sizeof(char *); idx++) {
          printf("Oracle: DLL / Shared library: %s\n", dllNameList[idx]);
          fprintf(versionFile, " \"%s\",", dllNameList[idx]);
        } /* for */
        fprintf(versionFile, "\n");
      } /* if */
    } /* if */
  } /* detemineOciDefines */
#endif



void detemineIncludesAndLibs (FILE *versionFile)

  {
    char include_options[4096];
    char system_db_libs[4096];
    char buffer[4096];

  /* detemineIncludesAndLibs */
    include_options[0] = '\0';
    system_db_libs[0] = '\0';
    determineX11Includes(versionFile, include_options);
#ifdef WITH_SQL
    detemineMySqlDefines(versionFile, include_options, system_db_libs);
    detemineSqliteDefines(versionFile, include_options, system_db_libs);
    deteminePostgresDefines(versionFile, include_options, system_db_libs);
    detemineOdbcDefines(versionFile, include_options, system_db_libs);
    detemineOciDefines(versionFile, include_options, system_db_libs);
    sprintf(buffer, "INCLUDE_OPTIONS = %s\n", include_options);
    appendToFile("macros", buffer);
    sprintf(buffer, "SYSTEM_DB_LIBS = %s\n", system_db_libs);
    appendToFile("macros", buffer);
#endif
    fprintf(versionFile, "#define INCLUDE_OPTIONS \"");
    escapeString(versionFile, include_options);
    fprintf(versionFile, "\"\n");
    fprintf(versionFile, "#define SYSTEM_DB_LIBS \"");
    escapeString(versionFile, system_db_libs);
    fprintf(versionFile, "\"\n");
  } /* detemineIncludesAndLibs */



static FILE *openVersionFile (const char *versionFileName)

  {
    FILE *versionFile = NULL;

  /* openVersionFile */
    if (versionFileName != NULL) {
      versionFile = fopen(versionFileName, "a");
    } /* if */
    if (versionFile == NULL) {
      versionFile = stdout;
    } /* if */
    return versionFile;
  } /* openVersionFile */



static void closeVersionFile (FILE *versionFile)

  { /* closeVersionFile */
    if (versionFile != NULL && versionFile != stdout) {
      fclose(versionFile);
    } /* if */
  } /* closeVersionFile */



static void copyFile (const char *sourceName, const char *destName)

  {
    FILE *source;
    FILE *dest;
    char buffer[1024];
    size_t len;

  /* copyFile */
    if (sourceName != NULL && destName != NULL) {
      if ((source = fopen(sourceName, "r")) != NULL) {
        if ((dest = fopen(destName, "w")) != NULL) {
          while ((len = fread(buffer, 1, 1024, source)) != 0) {
            fwrite(buffer, 1, len, dest);
          } /* while */
          fclose(dest);
        } /* if */
        fclose(source);
      } /* if */
    } /* if */
  } /* copyFile */



/**
 *  Program to Check properties of C compiler and runtime.
 */
int main (int argc, char **argv)

  {
    char *versionFileName = NULL;
    FILE *versionFile = NULL;
    char aVariable;
    FILE *aFile;
    time_t timestamp;
    struct tm *local_time;
    char buffer[4096];
    int ch;
    union {
      char           charValue;
      unsigned long  genericValue;
    } testUnion;
    int testResult;
    const char *define_read_buffer_empty;

  /* main */
    if (argc >= 1) {
      versionFileName = argv[1];
    } /* if */
    versionFile = openVersionFile(versionFileName);
    prepareCompileCommand();
#ifdef WRITE_CC_VERSION_INFO
    WRITE_CC_VERSION_INFO
#endif
    aFile = fopen("cc_vers.txt", "r");
    if (aFile != NULL) {
      fprintf(versionFile, "#define C_COMPILER_VERSION \"");
      for (ch=getc(aFile); ch != EOF && ch != 10 && ch != 13; ch = getc(aFile)) {
        if (ch >= ' ' && ch <= '~') {
          if (ch == '\"' || ch == '\'' || ch == '\\') {
            putc('\\', versionFile);
          } /* if */
          putc(ch, versionFile);
        } else {
          fprintf(versionFile, "\\%3o", ch);
        } /* if */
      } /* for */
      fputs("\"\n", versionFile);
      fclose(aFile);
    } /* if */
    if (compileAndLinkOk("#include <unistd.h>\nint main(int argc,char *argv[]){return 0;}\n")) {
      fputs("#define UNISTD_H_PRESENT\n", versionFile);
    } /* if */
    if (compileAndLinkOk("static inline int test(int a){return 2*a;}\n"
                         "int main(int argc,char *argv[]){return test(argc);}\n")) {
      /* The C compiler accepts the definition of inline functions. */
    } else if (compileAndLinkOk("static __inline int test(int a){return 2*a;}\n"
                                "int main(int argc,char *argv[]){return test(argc);}\n")) {
      fputs("#define inline __inline\n", versionFile);
    } else if (compileAndLinkOk("static __inline__ int test(int a){return 2*a;}\n"
                                "int main(int argc,char *argv[]){return test(argc);}\n")) {
      fputs("#define inline __inline__\n", versionFile);
    } else {
      fputs("#define inline\n", versionFile);
    } /* if */
    if (!compileAndLinkOk("int test (int *restrict ptrA, int *restrict ptrB, int *restrict ptrC)\n"
                          "{*ptrA += *ptrC; *ptrB += *ptrC; return *ptrA+ptrB;}\n"
                          "int main(int argc,char *argv[])\n"
                          "{int a=1, b=2, c=3; return test(&a, &b, &c);}\n")) {
      fputs("#define restrict\n", versionFile);
    } /* if */
    buffer[0] = '\0';
    if (compileAndLinkOk("#include <stdio.h>\nint main(int argc,char *argv[])\n"
                         "{if(__builtin_expect(1,1))puts(\"1\");else puts(\"0\");\n"
                         "return 0;}\n") && doTest() == 1) {
      fputs("#define likely(x)   __builtin_expect((x),1)\n", versionFile);
      fputs("#define unlikely(x) __builtin_expect((x),0)\n", versionFile);
      strcat(buffer, "#define likely(x)   __builtin_expect((x),1)\\n");
      strcat(buffer, "#define unlikely(x) __builtin_expect((x),0)\\n");
    } else {
      strcat(buffer, "#define likely(x) (x)\\n");
      strcat(buffer, "#define unlikely(x) (x)\\n");
    } /* if */
    if (compileAndLinkOk("#include <stdlib.h>\n"
                         "void fatal (void) __attribute__ ((noreturn));\n"
                         "void fatal (void) {exit(1);}\n"
                         "int main(int argc,char *argv[])\n"
                         "{return 0;}\n")) {
      fputs("#define NORETURN __attribute__ ((noreturn))\n", versionFile);
      strcat(buffer, "#define NORETURN __attribute__ ((noreturn))\\n");
    } else {
      strcat(buffer, "#define NORETURN\\n");
    } /* if */
    fprintf(versionFile, "#define MACRO_DEFS \"%s\"\n", buffer);
    if (compileAndLinkOk("#include <stdio.h>\nint main(int argc, char *argv[])\n"
                         "{FILE *aFile; aFile=popen(\""
                         LIST_DIRECTORY_CONTENTS
                         "\", \"r\");\n"
                         "printf(\"%d\\n\", ftell(aFile) != -1); return 0;}\n") ||
        compileAndLinkOk("#include <stdio.h>\nint main(int argc, char *argv[])\n"
                         "{FILE *aFile; aFile=_popen(\""
                         LIST_DIRECTORY_CONTENTS
                         "\", \"r\");\n"
                         "printf(\"%d\\n\", ftell(aFile) != -1); return 0;}\n")) {
      if (doTest() == 1) {
        fputs("#define FTELL_WRONG_FOR_PIPE\n", versionFile);
      } /* if */
    } else {
      fputs("#define POPEN_MISSING\n", versionFile);
    } /* if */
    if ((aFile = fopen("tmp_test_file","w")) != NULL) {
      fwrite("asdf",1,4,aFile);
      fclose(aFile);
      if ((aFile = fopen("tmp_test_file","r")) != NULL) {
        if (fwrite("qwert",1,5,aFile) != 0) {
          fputs("#define FWRITE_WRONG_FOR_READ_ONLY_FILES\n", versionFile);
        } /* if */
        fclose(aFile);
      } /* if */
      remove("tmp_test_file");
    } /* if */
    mkdir("tmp_empty_dir", 0755);
    if (compileAndLinkOk(
        "#include <stdio.h>\n#include <utime.h>\n#include <errno.h>\nint main(int argc,char *argv[])"
        "{struct utimbuf utime_buf;\n"
        "utime_buf.actime=1234567890;utime_buf.modtime=1234567890;\n"
        "printf(\"%d\\n\",utime(\"tmp_empty_dir\",&utime_buf)!=0&&errno==EACCES);return 0;}\n") &&
        doTest() == 1) {
      fputs("#define USE_ALTERNATE_UTIME\n", versionFile);
#ifdef os_utime
      fprintf(versionFile, "#define os_utime_orig %s\n", xstr(os_utime));
      fputs("#undef os_utime\n", versionFile);
#else
      fputs("#define os_utime_orig utime\n", versionFile);
#endif
      fputs("#define os_utime alternate_utime\n", versionFile);
    } else if (compileAndLinkOk(
        "#include <stdio.h>\n#include <sys/utime.h>\n#include <errno.h>\nint main(int argc,char *argv[])"
        "{struct utimbuf utime_buf;\n"
        "utime_buf.actime=1234567890;utime_buf.modtime=1234567890;\n"
        "printf(\"%d\\n\",utime(\"tmp_empty_dir\",&utime_buf)!=0&&errno==EACCES);return 0;}\n") &&
        doTest() == 1) {
      fputs("#define INCLUDE_SYS_UTIME\n", versionFile);
      fputs("#define USE_ALTERNATE_UTIME\n", versionFile);
#ifdef os_utime
      fprintf(versionFile, "#define os_utime_orig %s\n", xstr(os_utime));
      fputs("#undef os_utime\n", versionFile);
#else
      fputs("#define os_utime_orig utime\n", versionFile);
#endif
      fputs("#define os_utime alternate_utime\n", versionFile);
    } /* if */
    if (remove("tmp_empty_dir") != 0) {
      fputs("#define REMOVE_FAILS_FOR_EMPTY_DIRS\n", versionFile);
      rmdir("tmp_empty_dir");
    } /* if */
    checkMoveDirectory(versionFile);
    if (compileAndLinkOk("#include <stdio.h>\n#include <errno.h>\nint main(int argc,char *argv[])"
                         "{int saved_errno=EXDEV; printf(\"%d\\n\",saved_errno); return 0;}\n")) {
      fputs("#define EXDEV_IS_DEFINED\n", versionFile);
    } /* if */
#if defined OS_STRI_WCHAR && defined USE_WINSOCK
    /* Under Windows a rename between different    */
    /* devices fails with EACCES instead of EXDEV. */
    fputs("#define USE_EACCES_INSTEAD_OF_EXDEV\n", versionFile);
    /* Windows uses pending deletes which cause    */
    /* problems when a file with the same name is  */
    /* created shortly after the delete. To avoid  */
    /* problems files are renamed before they are  */
    /* removed.                                    */
    fputs("#define RENAME_BEFORE_REMOVE\n", versionFile);
#endif
    aFile = fopen(".","r");
    if (aFile != NULL) {
      fputs("#define FOPEN_OPENS_DIRECTORIES\n", versionFile);
      fclose(aFile);
    } /* if */
    numericSizes(versionFile);
    determineMallocAlignment(versionFile);
    if (compileAndLinkOk("#include<signal.h>\nint main(int argc, char *argv[]){\n"
                         "signal(SIGBUS,SIG_DFL); return 0;}\n")) {
      if (compileAndLinkOk("#include<stdlib.h>\n#include <stdio.h>\n#include<signal.h>\n"
                           "void handleSig(int sig){puts(\"2\");exit(0);}\n"
                           "int main(int argc, char *argv[]){\n"
                           "signal(SIGBUS,handleSig);\n"
                           "int p[3]={12,34,56}, q, *pp; pp=(int *)((char *)&p[1]+1); q=*pp;\n"
                           "printf(\"1\\n\"); return 0;}\n") && doTest() == 1) {
        fputs("#define UNALIGNED_MEMORY_ACCESS_OKAY\n", versionFile);
      } else {
        fputs("#define UNALIGNED_MEMORY_ACCESS_FAILS\n", versionFile);
      } /* if */
    } else {
      if (compileAndLinkOk("#include <stdio.h>\nint main(int argc, char *argv[])\n"
                           "{int p[3]={12,34,56}, q, *pp; pp=(int *)((char *)&p[1]+1); q=*pp;\n"
                           "printf(\"1\\n\"); return 0;}\n") && doTest() == 1) {
        fputs("#define UNALIGNED_MEMORY_ACCESS_OKAY\n", versionFile);
      } else {
        fputs("#define UNALIGNED_MEMORY_ACCESS_FAILS\n", versionFile);
      } /* if */
    } /* if */
    memset(&testUnion, 0, sizeof(testUnion));
    testUnion.charValue = 'X';
    if (testUnion.charValue != (char) testUnion.genericValue) {
      fputs("#define CASTING_DOES_NOT_GET_A_UNION_ELEMENT\n", versionFile);
    } /* if */
    if (EOF != -1) {
      fputs("#define EOF_IS_NOT_MINUS_ONE\n", versionFile);
    } /* if */
    if (!compileAndLinkOk("#include <stdio.h>\n"
                          "typedef struct emptyStruct { } emptyRecord;\n"
                          "int main(int argc, char *argv[]){\n"
                          "return 0;}\n")) {
      fputs("#define NO_EMPTY_STRUCTS\n", versionFile);
    } /* if */
    if (compileAndLinkOk("#include <stdio.h>\n#include <string.h>\n"
                         "int main(int argc, char *argv[]){\n"
                         "printf(\"%d\\n\", strcmp(\"\?\?(\", \"[\") == 0);\n"
                         "return 0;}\n") && doTest() == 1) {
      fputs("#define TRIGRAPH_SEQUENCES_ARE_REPLACED\n", versionFile);
    } /* if */
    checkForLimitedStringLiteralLength(versionFile);
    stack_base = &aVariable;
    detemineStackDirection(versionFile);
#ifndef STACK_SIZE
    if (sizeof(char *) == 8) { /* Machine with 64-bit addresses */
      /* Due to alignment some 64-bit machines have huge stack requirements. */
      fputs("#define STACK_SIZE 0x1000000\n", versionFile); /* 16777216 bytes */
    } else {
      fputs("#define STACK_SIZE 0x800000\n", versionFile); /* 8388608 bytes */
    } /* if */
#endif
    numericProperties(versionFile);
#ifdef USE_ALTERNATE_LOCALTIME_R
    fputs("#define USE_LOCALTIME_R\n", versionFile);
    if ((time_t) -1 < 0) {
      fputs("#define LOCALTIME_WORKS_SIGNED\n", versionFile);
    } /* if */
#else
    if (compileAndLinkOk("#include<time.h>\nint main(int argc,char *argv[])"
                         "{time_t ts;struct tm res;struct tm*lt;lt=localtime_r(&ts,&res);return 0;}\n")) {
      fputs("#define USE_LOCALTIME_R\n", versionFile);
      if (compileAndLinkOk("#include<time.h>\nint main(int argc,char *argv[])"
                           "{time_t ts=-2147483647-1;struct tm res;struct tm*lt;\n"
                           "lt=localtime_r(&ts,&res);\n"
                           "printf(\"%d\\n\",lt!=NULL&&lt->tm_year==1);return 0;}\n") && doTest() == 1) {
        fputs("#define LOCALTIME_WORKS_SIGNED\n", versionFile);
      } /* if */
    } else if (compileAndLinkOk("#include<time.h>\nint main(int argc,char *argv[])"
                                "{time_t ts;struct tm res;localtime_s(&res,&ts);return 0;}\n")) {
      fputs("#define USE_LOCALTIME_S\n", versionFile);
      if (compileAndLinkOk("#include<time.h>\nint main(int argc,char *argv[])"
                           "{time_t ts=-2147483647-1;struct tm res;\n"
                           "localtime_s(&res,&ts);\n"
                           "printf(\"%d\\n\",lt!=NULL&&lt->tm_year==1);return 0;}\n") && doTest() == 1) {
        fputs("#define LOCALTIME_WORKS_SIGNED\n", versionFile);
      } /* if */
    } else {
      timestamp = -2147483647 - 1;
      local_time = localtime(&timestamp);
      if (local_time != NULL && local_time->tm_year == 1) {
        fputs("#define LOCALTIME_WORKS_SIGNED\n", versionFile);
      } /* if */
    } /* if */
#endif
    /* Make sure that the file version.h up to this position is copied to tst_vers.h. */
    closeVersionFile(versionFile);
    copyFile(versionFileName, "tst_vers.h");
    versionFile = openVersionFile(versionFileName);
    determineEnvironDefines(versionFile);
#ifdef OS_PATH_HAS_DRIVE_LETTERS
    if (getenv("USERPROFILE") != NULL) {
      /* When USERPROFILE is defined then it is used, even when HOME is defined. */
      fputs("#define HOME_DIR_ENV_VAR {'U', 'S', 'E', 'R', 'P', 'R', 'O', 'F', 'I', 'L', 'E', 0}\n", versionFile);
    } else if (getenv("HOME") != NULL) {
      fputs("#define HOME_DIR_ENV_VAR {'H', 'O', 'M', 'E', 0}\n", versionFile);
    } else {
      fputs("#define HOME_DIR_ENV_VAR {'H', 'O', 'M', 'E', 0}\n", versionFile);
      fputs("#define DEFAULT_HOME_DIR {'C', ':', '\\\\', 0}\n", versionFile);
    } /* if */
#else
    fputs("#define HOME_DIR_ENV_VAR {'H', 'O', 'M', 'E', 0}\n", versionFile);
#endif
    if (compileAndLinkOk("#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n"
                         "void handleSig(int sig){puts(\"1\");exit(0);}\n"
                         "int main(int argc, char *argv[]){\n"
                         "struct sigaction sig_act;\n"
                         "sig_act.sa_handler = handleSig;\n"
                         "sigemptyset(&sig_act.sa_mask);\n"
                         "sig_act.sa_flags = SA_RESTART;\n"
                         "if (sigaction(SIGINT, &sig_act, NULL) == -1)\n"
                         "{puts(\"2\");}else{raise(SIGINT);puts(\"3\");}\n"
                         "return 0;}\n") && doTest() == 1) {
      fputs("#define HAS_SIGACTION\n", versionFile);
    } /* if */
    if (compileAndLinkOk("#include <stdio.h>\n#include <sys/resource.h>\n"
                         "int main(int argc, char *argv[]){\n"
                         "struct rlimit rlim;\n"
                         "printf(\"%d\\n\", getrlimit(RLIMIT_STACK, &rlim) == 0);\n"
                         "return 0;}\n") && doTest() == 1) {
      fputs("#define HAS_GETRLIMIT\n", versionFile);
      if (compileAndLinkOk("#include <stdio.h>\n#include <sys/resource.h>\n"
                           "int main(int argc, char *argv[]){\n"
                           "struct rlimit rlim;\n"
                           "getrlimit(RLIMIT_STACK, &rlim);"
                           "if (rlim.rlim_cur == RLIM_INFINITY)\n"
                           "printf(\"0\\n\");\n"
                           "else\n"
                           "printf(\"%d\\n\", rlim.rlim_cur / 1024);\n"
                           "return 0;}\n")) {
        fprintf(versionFile, "#define SOFT_STACK_LIMIT %lu\n", (unsigned long) doTest() * 1024);
      } /* if */
      if (compileAndLinkOk("#include <stdio.h>\n#include <sys/resource.h>\n"
                           "int main(int argc, char *argv[]){\n"
                           "struct rlimit rlim;\n"
                           "getrlimit(RLIMIT_STACK, &rlim);"
                           "if (rlim.rlim_max == RLIM_INFINITY)\n"
                           "printf(\"0\\n\");\n"
                           "else\n"
                           "printf(\"%d\\n\", rlim.rlim_max / 1024);\n"
                           "return 0;}\n")) {
        fprintf(versionFile, "#define HARD_STACK_LIMIT %lu\n", (unsigned long) doTest() * 1024);
      } /* if */
    } /* if */
    if (compileAndLinkOk("#include <stdio.h>\n#include <setjmp.h>\n"
                         "int main(int argc, char *argv[]){\n"
                         "sigjmp_buf env; int ret_code; int count = 2;\n"
                         "if ((ret_code=sigsetjmp(env, 1)) == 0) {\n"
                         "count--; siglongjmp(env, count);\n"
                         "} else printf(\"%d\\n\", ret_code);\n"
                         "return 0;}\n") && doTest() == 1) {
      fputs("#define HAS_SIGSETJMP\n", versionFile);
    } /* if */
    if (compileAndLinkOk("#include <unistd.h>\n"
                         "int main(int argc, char *argv[]){\n"
                         "char buf[256]; ssize_t link_len; int ret_code;\n"
                         "link_len=readlink(\"qwertzuiop\", buf, 256);\n"
                         "ret_code=symlink(\"qwertzuiop\", \"asdfghjkl\");\n"
                         "return 0;}\n")) {
      fputs("#define HAS_SYMLINKS\n", versionFile);
    } /* if */
    if (compileAndLinkOk("#include <sys/types.h>\n#include <sys/stat.h>\n"
                         "int main(int argc, char *argv[]){\n"
                         "int ret_code;\n"
                         "ret_code=mkfifo(\"qwertzuiop\", 0);\n"
                         "return 0;}\n")) {
      fputs("#define HAS_FIFO_FILES\n", versionFile);
    } /* if */
    if (compileAndLinkOk("#include<poll.h>\nint main(int argc,char *argv[])"
                         "{struct pollfd pollFd[1];poll(pollFd, 1, 0);return 0;}\n")) {
      fputs("#define HAS_POLL\n", versionFile);
    } /* if */
    detemineIncludesAndLibs(versionFile);
    if (compileAndLinkOk("#include<stdio.h>\nint main(int argc,char *argv[]){FILE*fp;fp->_IO_read_ptr>=fp->_IO_read_end;return 0;}\n")) {
      define_read_buffer_empty = "#define read_buffer_empty(fp) ((fp)->_IO_read_ptr >= (fp)->_IO_read_end)";
    } else if (compileAndLinkOk("#include<stdio.h>\nint main(int argc,char *argv[]){FILE*fp;fp->_cnt <= 0;return 0;}\n")) {
      define_read_buffer_empty = "#define read_buffer_empty(fp) ((fp)->_cnt <= 0)";
    } else if (compileAndLinkOk("#include<stdio.h>\nint main(int argc,char *argv[]){FILE*fp;fp->__cnt <= 0;return 0;}\n")) {
      define_read_buffer_empty = "#define read_buffer_empty(fp) ((fp)->__cnt <= 0)";
    } else if (compileAndLinkOk("#include<stdio.h>\nint main(int argc,char *argv[]){FILE*fp;fp->level <= 0;return 0;}\n")) {
      define_read_buffer_empty = "#define read_buffer_empty(fp) ((fp)->level <= 0)";
    } else if (compileAndLinkOk("#include<stdio.h>\nint main(int argc,char *argv[]){FILE*fp;fp->_r <= 0;return 0;}\n")) {
      define_read_buffer_empty = "#define read_buffer_empty(fp) ((fp)->_r <= 0)";
    } else {
      define_read_buffer_empty = NULL;
    } /* if */
    if (define_read_buffer_empty != NULL) {
      strcpy(buffer, "#include<stdio.h>\n");
      strcat(buffer, define_read_buffer_empty);
      strcat(buffer, "\nint main(int argc,char *argv[])\n"
                     "{FILE*fp;fp=fopen(\"tst_vers.h\",\"r\");"
                     "if(fp==NULL||!read_buffer_empty(fp))puts(0);else{"
                     "getc(fp);printf(\"%d\\n\",read_buffer_empty(fp)?0:1);}return 0;}\n");
      if (!compileAndLinkOk(buffer) || doTest() != 1) {
        define_read_buffer_empty = NULL;
      } /* if */
    } /* if */
    if (define_read_buffer_empty != NULL) {
      fprintf(versionFile, "%s\n", define_read_buffer_empty);
    } /* if */
    cleanUpCompilation();
    closeVersionFile(versionFile);
    if (fileIsRegular("tst_vers.h")) {
      remove("tst_vers.h");
    } /* if */
    return 0;
  } /* main */
