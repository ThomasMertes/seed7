/********************************************************************/
/*                                                                  */
/*  s7   Seed7 interpreter                                          */
/*  Copyright (C) 1990 - 2008  Thomas Mertes                        */
/*                                                                  */
/*  This program is free software; you can redistribute it and/or   */
/*  modify it under the terms of the GNU General Public License as  */
/*  published by the Free Software Foundation; either version 2 of  */
/*  the License, or (at your option) any later version.             */
/*                                                                  */
/*  This program is distributed in the hope that it will be useful, */
/*  but WITHOUT ANY WARRANTY; without even the implied warranty of  */
/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   */
/*  GNU General Public License for more details.                    */
/*                                                                  */
/*  You should have received a copy of the GNU General Public       */
/*  License along with this program; if not, write to the           */
/*  Free Software Foundation, Inc., 51 Franklin Street,             */
/*  Fifth Floor, Boston, MA  02110-1301, USA.                       */
/*                                                                  */
/*  Module: Compiler data reflection                                */
/*  File: seed7/src/rfl_data.c                                      */
/*  Changes: 1991-1995, 2007, 2008  Thomas Mertes                   */
/*  Content: Primitive actions for the ref_list type.               */
/*                                                                  */
/********************************************************************/

#include "version.h"

#include "stdlib.h"
#include "stdio.h"

#include "common.h"
#include "data.h"
#include "data_rtl.h"
#include "heaputl.h"
#include "flistutl.h"
#include "listutl.h"
#include "rtl_err.h"

#undef EXTERN
#define EXTERN
#include "rfl_data.h"



void rflAppend (listtype *const list_to, const listtype list_from)

  {
    listtype list1_end;

  /* rflAppend */
    if (*list_to != NULL) {
      list1_end = *list_to;
      while (list1_end->next != NULL) {
        list1_end = list1_end->next;
      } /* while */
      list1_end->next = list_from;
    } else {
      *list_to = list_from;
    } /* if */
  } /* rflAppend */



listtype rflCat (listtype list1, const listtype list2)

  {
    listtype result;

  /* rflCat */
    if (list1 != NULL) {
      result = list1;
      while (list1->next != NULL) {
        list1 = list1->next;
      } /* while */
      list1->next = list2;
    } else {
      result = list2;
    } /* if */
    return result;
  } /* rflCat */



inline inttype rflCmp (const_listtype list1, const_listtype list2)

  {
    inttype result;

  /* rflCmp */
    while (list1 != NULL && list2 != NULL &&
        list1->obj == list2->obj) {
      list1 = list1->next;
      list2 = list2->next;
    } /* while */
    if (list1 == NULL && list2 == NULL) {
      result = 0;
    } else if (list1 == NULL) {
      result = -1;
    } else if (list2 == NULL) {
      result = 1;
    } else if ((memsizetype) (list1) < (memsizetype) (list2)) {
      result = -1;
    } else {
      result = 1;
    } /* if */
    return result;
  } /* rflCmp */



/**
 *  Reinterpret the generic parameters as listtype and call rflCmp.
 *  Function pointers in C programs generated by the Seed7 compiler
 *  may point to this function. This assures correct behaviour even
 *  when sizeof(rtlGenerictype) != sizeof(listtype).
 */
inttype rflCmpGeneric (const rtlGenerictype value1, const rtlGenerictype value2)

  { /* rflCmpGeneric */
    return rflCmp((const_listtype) (memsizetype) value1,
                  (const_listtype) (memsizetype) value2);
  } /* rflCmpGeneric */



void rflCpy (listtype *const list_to, const const_listtype list_from)

  {
    listtype help_list;
    errinfotype err_info = OKAY_NO_ERROR;

  /* rflCpy */
    if (list_from != *list_to) {
      help_list = copy_list(list_from, &err_info);
      if (err_info != OKAY_NO_ERROR) {
        raise_error(MEMORY_ERROR);
      } else {
        free_list(*list_to);
        *list_to = help_list;
      } /* if */
    } /* if */
  } /* rflCpy */



listtype rflCreate (const const_listtype list_from)

  {
    errinfotype err_info = OKAY_NO_ERROR;
    listtype result;

  /* rflCreate */
    result = copy_list(list_from, &err_info);
    if (err_info != OKAY_NO_ERROR) {
      raise_error(MEMORY_ERROR);
      result = NULL;
    } /* if */
    return result;
  } /* rflCreate */



/**
 *  Generic Create function to be used via function pointers.
 *  Function pointers in C programs generated by the Seed7 compiler
 *  may point to this function. This assures correct behaviour even
 *  when sizeof(rtlGenerictype) != sizeof(listtype).
 */
rtlGenerictype rflCreateGeneric (const rtlGenerictype from_value)

  { /* rflCreateGeneric */
    return (rtlGenerictype) (memsizetype)
           rflCreate((const_listtype) (memsizetype) from_value);
  } /* rflCreateGeneric */



void rflDestr (const listtype old_list)

  { /* rflDestr */
    free_list(old_list);
  } /* rflDestr */



booltype rflElem (const const_objecttype searched_object, const_listtype list_element)

  { /* rflElem */
    /* printf("rflElem(%lx, %lx)\n",
        (unsigned long) searched_object, (unsigned long) list_element); */
    while (list_element != NULL && list_element->obj != searched_object) {
      list_element = list_element->next;
    } /* while */
    if (list_element != NULL) {
      return TRUE;
    } else {
      return FALSE;
    } /* if */
  } /* rflElem */



void rflElemcpy (listtype list, inttype position, objecttype elem)

  {
    inttype number;

  /* rflElemcpy */
    if (position >= 1) {
      number = 1;
      while (number < position && list != NULL) {
        number++;
        list = list->next;
      } /* while */
      if (list != NULL) {
        list->obj = elem;
      } else {
        raise_error(RANGE_ERROR);
      } /* if */
    } else {
      raise_error(RANGE_ERROR);
    } /* if */
  } /* rflElemcpy */



booltype rflEq (const_listtype list1, const_listtype list2)

  {
    booltype result;

  /* rflEq */
    while (list1 != NULL && list2 != NULL &&
        list1->obj == list2->obj) {
      list1 = list1->next;
      list2 = list2->next;
    } /* while */
    if (list1 == NULL && list2 == NULL) {
      result = TRUE;
    } else {
      result = FALSE;
    } /* if */
    return result;
  } /* rflEq */



listtype rflHead (const listtype list, inttype stop)

  {
    inttype number;
    listtype stop_element;
    listtype saved_list_rest;
    errinfotype err_info = OKAY_NO_ERROR;
    listtype result;

  /* rflHead */
    if (stop >= 1) {
      number = 1;
      stop_element = list;
      while (number < stop && stop_element != NULL) {
        number++;
        stop_element = stop_element->next;
      } /* while */
      if (stop_element != NULL) {
        saved_list_rest = stop_element->next;
        stop_element->next = NULL;
        result = copy_list(list, &err_info);
        stop_element->next = saved_list_rest;
      } else {
        result = copy_list(list, &err_info);
      } /* if */
      if (err_info != OKAY_NO_ERROR) {
        raise_error(MEMORY_ERROR);
        result = NULL;
      } /* if */
    } else {
      result = NULL;
    } /* if */
    return result;
  } /* rflHead */



objecttype rflIdx (const_listtype list, inttype position)

  {
    inttype number;
    objecttype result;

  /* rflIdx */
    if (position >= 1) {
      number = 1;
      while (number < position && list != NULL) {
        number++;
        list = list->next;
      } /* while */
      if (list != NULL) {
        result = list->obj;
      } else {
        raise_error(RANGE_ERROR);
        result = 0;
      } /* if */
    } else {
      raise_error(RANGE_ERROR);
      result = 0;
    } /* if */
    return result;
  } /* rflIdx */



void rflIncl (listtype *list, objecttype elem)

  {
    errinfotype err_info = OKAY_NO_ERROR;

  /* rflIncl */
    incl_list(list, elem, &err_info);
    if (err_info != OKAY_NO_ERROR) {
      raise_error(MEMORY_ERROR);
    } /* if */
  } /* rflIncl */



inttype rflLng (const_listtype list)

  {
    inttype result;

  /* rflLng */
    result = 0;
    while (list != NULL) {
      list = list->next;
      result++;
    } /* while */
    return result;
  } /* rflLng */



listtype rflMklist (objecttype elem)

  {
    listtype result;

  /* rflMklist */
    if (ALLOC_L_ELEM(result)) {
      result->next = NULL;
      result->obj = elem;
    } else {
      raise_error(MEMORY_ERROR);
      result = NULL;
    } /* if */
    return result;
  } /* rflMklist */



inttype rflPos (const_listtype list_element, const const_objecttype searched_object)

  {
    inttype result;

  /* rflPos */
    result = 1;
    while (list_element != NULL &&
        list_element->obj != searched_object) {
      list_element = list_element->next;
      result++;
    } /* while */
    if (list_element == NULL) {
      result = 0;
    } /* if */
    return result;
  } /* rflPos */



inttype rflIpos (listtype list_element, objecttype searched_object,
    const inttype from_index)

  {
    inttype result;

  /* rflIpos */
    result = 1;
    while (list_element != NULL && result < from_index) {
      list_element = list_element->next;
      result++;
    } /* while */
    while (list_element != NULL &&
        list_element->obj != searched_object) {
      list_element = list_element->next;
      result++;
    } /* while */
    if (list_element == NULL) {
      result = 0;
    } /* if */
    return result;
  } /* rflIpos */



listtype rflRange (const listtype list, inttype start, inttype stop)

  {
    inttype number;
    listtype start_element;
    listtype stop_element;
    listtype saved_list_rest;
    errinfotype err_info = OKAY_NO_ERROR;
    listtype result;

  /* rflRange */
    number = 1;
    start_element = list;
    while (number < start && start_element != NULL) {
      number++;
      start_element = start_element->next;
    } /* while */
    if (start_element != NULL && stop >= start) {
      stop_element = start_element;
      while (number < stop && stop_element != NULL) {
        number++;
        stop_element = stop_element->next;
      } /* while */
      if (stop_element != NULL) {
        saved_list_rest = stop_element->next;
        stop_element->next = NULL;
        result = copy_list(start_element, &err_info);
        stop_element->next = saved_list_rest;
      } else {
        result = copy_list(start_element, &err_info);
      } /* if */
    } else {
      result = NULL;
    } /* if */
    if (err_info != OKAY_NO_ERROR) {
      raise_error(MEMORY_ERROR);
      result = NULL;
    } /* if */
    return result;
  } /* rflRange */



listtype rflTail (const listtype list, inttype start)

  {
    inttype number;
    listtype list_element;
    errinfotype err_info = OKAY_NO_ERROR;
    listtype result;

  /* rflTail */
    list_element = list;
    if (start > 1 && list_element != NULL) {
      number = 2;
      while (number < start && list_element->next != NULL) {
        number++;
        list_element = list_element->next;
      } /* while */
      if (number >= start) {
        result = copy_list(list_element->next, &err_info);
      } else {
        result = NULL;
      } /* if */
    } else {
      result = copy_list(list_element, &err_info);
    } /* if */
    if (err_info != OKAY_NO_ERROR) {
      raise_error(MEMORY_ERROR);
      result = NULL;
    } /* if */
    return result;
  } /* rflTail */
