/********************************************************************/
/*                                                                  */
/*  s7   Seed7 interpreter                                          */
/*  Copyright (C) 1990 - 2008  Thomas Mertes                        */
/*                                                                  */
/*  This program is free software; you can redistribute it and/or   */
/*  modify it under the terms of the GNU General Public License as  */
/*  published by the Free Software Foundation; either version 2 of  */
/*  the License, or (at your option) any later version.             */
/*                                                                  */
/*  This program is distributed in the hope that it will be useful, */
/*  but WITHOUT ANY WARRANTY; without even the implied warranty of  */
/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   */
/*  GNU General Public License for more details.                    */
/*                                                                  */
/*  You should have received a copy of the GNU General Public       */
/*  License along with this program; if not, write to the           */
/*  Free Software Foundation, Inc., 51 Franklin Street,             */
/*  Fifth Floor, Boston, MA  02110-1301, USA.                       */
/*                                                                  */
/*  Module: Compiler data reflection                                */
/*  File: seed7/src/rfl_data.c                                      */
/*  Changes: 1991-1995, 2007, 2008  Thomas Mertes                   */
/*  Content: Primitive actions for the ref_list type.               */
/*                                                                  */
/********************************************************************/

#include "version.h"

#include "stdlib.h"
#include "stdio.h"

#include "common.h"
#include "data.h"
#include "data_rtl.h"
#include "heaputl.h"
#include "flistutl.h"
#include "listutl.h"
#include "rtl_err.h"

#undef EXTERN
#define EXTERN
#include "rfl_data.h"



void rflAppend (listType *const list_to, const listType list_from)

  {
    listType list1_end;

  /* rflAppend */
    if (*list_to != NULL) {
      list1_end = *list_to;
      while (list1_end->next != NULL) {
        list1_end = list1_end->next;
      } /* while */
      list1_end->next = list_from;
    } else {
      *list_to = list_from;
    } /* if */
  } /* rflAppend */



listType rflCat (listType list1, const listType list2)

  {
    listType result;

  /* rflCat */
    if (list1 != NULL) {
      result = list1;
      while (list1->next != NULL) {
        list1 = list1->next;
      } /* while */
      list1->next = list2;
    } else {
      result = list2;
    } /* if */
    return result;
  } /* rflCat */



inline intType rflCmp (const_listType list1, const_listType list2)

  {
    intType result;

  /* rflCmp */
    while (list1 != NULL && list2 != NULL &&
        list1->obj == list2->obj) {
      list1 = list1->next;
      list2 = list2->next;
    } /* while */
    if (list1 == NULL && list2 == NULL) {
      result = 0;
    } else if (list1 == NULL) {
      result = -1;
    } else if (list2 == NULL) {
      result = 1;
    } else if ((memSizeType) (list1) < (memSizeType) (list2)) {
      result = -1;
    } else {
      result = 1;
    } /* if */
    return result;
  } /* rflCmp */



/**
 *  Reinterpret the generic parameters as listType and call rflCmp.
 *  Function pointers in C programs generated by the Seed7 compiler
 *  may point to this function. This assures correct behaviour even
 *  when sizeof(genericType) != sizeof(listType).
 */
intType rflCmpGeneric (const genericType value1, const genericType value2)

  { /* rflCmpGeneric */
    return rflCmp((const_listType) ((const_rtlObjectType *) &value1)->value.listValue,
                  (const_listType) ((const_rtlObjectType *) &value2)->value.listValue);
  } /* rflCmpGeneric */



void rflCpy (listType *const list_to, const const_listType list_from)

  {
    listType help_list;
    errInfoType err_info = OKAY_NO_ERROR;

  /* rflCpy */
    if (list_from != *list_to) {
      help_list = copy_list(list_from, &err_info);
      if (err_info != OKAY_NO_ERROR) {
        raise_error(MEMORY_ERROR);
      } else {
        free_list(*list_to);
        *list_to = help_list;
      } /* if */
    } /* if */
  } /* rflCpy */



void rflCpyGeneric (genericType *const dest, const genericType source)

  { /* rflCpyGeneric */
    rflCpy((listType *) &((rtlObjectType *) dest)->value.listValue,
           (const_listType) ((const_rtlObjectType *) &source)->value.listValue);
  } /* rflCpyGeneric */



listType rflCreate (const const_listType list_from)

  {
    errInfoType err_info = OKAY_NO_ERROR;
    listType result;

  /* rflCreate */
    result = copy_list(list_from, &err_info);
    if (err_info != OKAY_NO_ERROR) {
      raise_error(MEMORY_ERROR);
      result = NULL;
    } /* if */
    return result;
  } /* rflCreate */



/**
 *  Generic Create function to be used via function pointers.
 *  Function pointers in C programs generated by the Seed7 compiler
 *  may point to this function. This assures correct behaviour even
 *  when sizeof(genericType) != sizeof(listType).
 */
genericType rflCreateGeneric (const genericType from_value)

  {
    rtlObjectType result;

  /* rflCreateGeneric */
    result.value.listValue =
        (rtlListType) rflCreate((const_listType) ((const_rtlObjectType *) &from_value)->value.listValue);
    return result.value.genericValue;
  } /* rflCreateGeneric */



void rflDestr (const listType old_list)

  { /* rflDestr */
    free_list(old_list);
  } /* rflDestr */



/**
 *  Generic Destr function to be used via function pointers.
 *  Function pointers in C programs generated by the Seed7 compiler
 *  may point to this function. This assures correct behaviour even
 *  when sizeof(genericType) != sizeof(listType).
 */
void rflDestrGeneric (const genericType old_value)

  { /* rflDestrGeneric */
    rflDestr((listType) ((const_rtlObjectType *) &old_value)->value.listValue);
  } /* rflDestrGeneric */



boolType rflElem (const const_objectType searched_object, const_listType list_element)

  { /* rflElem */
    /* printf("rflElem(%lx, %lx)\n",
        (unsigned long) searched_object, (unsigned long) list_element); */
    while (list_element != NULL && list_element->obj != searched_object) {
      list_element = list_element->next;
    } /* while */
    if (list_element != NULL) {
      return TRUE;
    } else {
      return FALSE;
    } /* if */
  } /* rflElem */



void rflElemcpy (listType list, intType position, objectType elem)

  { /* rflElemcpy */
    if (position >= 1) {
      position--;
      while (position != 0 && list != NULL) {
        position--;
        list = list->next;
      } /* while */
      if (list != NULL) {
        list->obj = elem;
      } else {
        raise_error(RANGE_ERROR);
      } /* if */
    } else {
      raise_error(RANGE_ERROR);
    } /* if */
  } /* rflElemcpy */



boolType rflEq (const_listType list1, const_listType list2)

  {
    boolType result;

  /* rflEq */
    while (list1 != NULL && list2 != NULL &&
        list1->obj == list2->obj) {
      list1 = list1->next;
      list2 = list2->next;
    } /* while */
    if (list1 == NULL && list2 == NULL) {
      result = TRUE;
    } else {
      result = FALSE;
    } /* if */
    return result;
  } /* rflEq */



listType rflHead (const listType list, intType stop)

  {
    intType number;
    listType stop_element;
    listType saved_list_rest;
    errInfoType err_info = OKAY_NO_ERROR;
    listType result;

  /* rflHead */
    if (stop >= 1) {
      number = 1;
      stop_element = list;
      while (number < stop && stop_element != NULL) {
        number++;
        stop_element = stop_element->next;
      } /* while */
      if (stop_element != NULL) {
        saved_list_rest = stop_element->next;
        stop_element->next = NULL;
        result = copy_list(list, &err_info);
        stop_element->next = saved_list_rest;
      } else {
        result = copy_list(list, &err_info);
      } /* if */
      if (err_info != OKAY_NO_ERROR) {
        raise_error(MEMORY_ERROR);
        result = NULL;
      } /* if */
    } else {
      result = NULL;
    } /* if */
    return result;
  } /* rflHead */



objectType rflIdx (const_listType list, intType position)

  {
    objectType result;

  /* rflIdx */
    if (position >= 1) {
      position--;
      while (position != 0 && list != NULL) {
        position--;
        list = list->next;
      } /* while */
      if (list != NULL) {
        result = list->obj;
      } else {
        raise_error(RANGE_ERROR);
        result = 0;
      } /* if */
    } else {
      raise_error(RANGE_ERROR);
      result = 0;
    } /* if */
    return result;
  } /* rflIdx */



void rflIncl (listType *list, objectType elem)

  {
    errInfoType err_info = OKAY_NO_ERROR;

  /* rflIncl */
    incl_list(list, elem, &err_info);
    if (err_info != OKAY_NO_ERROR) {
      raise_error(MEMORY_ERROR);
    } /* if */
  } /* rflIncl */



intType rflLng (const_listType list)

  {
    intType result;

  /* rflLng */
    result = 0;
    while (list != NULL) {
      list = list->next;
      result++;
    } /* while */
    return result;
  } /* rflLng */



listType rflMklist (objectType elem)

  {
    listType result;

  /* rflMklist */
    if (ALLOC_L_ELEM(result)) {
      result->next = NULL;
      result->obj = elem;
    } else {
      raise_error(MEMORY_ERROR);
      result = NULL;
    } /* if */
    return result;
  } /* rflMklist */



intType rflPos (const_listType list_element, const const_objectType searched_object)

  {
    intType result;

  /* rflPos */
    result = 1;
    while (list_element != NULL &&
        list_element->obj != searched_object) {
      list_element = list_element->next;
      result++;
    } /* while */
    if (list_element == NULL) {
      result = 0;
    } /* if */
    return result;
  } /* rflPos */



intType rflIpos (listType list_element, objectType searched_object,
    const intType from_index)

  {
    intType result;

  /* rflIpos */
    result = 1;
    while (list_element != NULL && result < from_index) {
      list_element = list_element->next;
      result++;
    } /* while */
    while (list_element != NULL &&
        list_element->obj != searched_object) {
      list_element = list_element->next;
      result++;
    } /* while */
    if (list_element == NULL) {
      result = 0;
    } /* if */
    return result;
  } /* rflIpos */



listType rflRange (const listType list, intType start, intType stop)

  {
    intType number;
    listType start_element;
    listType stop_element;
    listType saved_list_rest;
    errInfoType err_info = OKAY_NO_ERROR;
    listType result;

  /* rflRange */
    number = 1;
    start_element = list;
    while (number < start && start_element != NULL) {
      number++;
      start_element = start_element->next;
    } /* while */
    if (start_element != NULL && stop >= start) {
      stop_element = start_element;
      while (number < stop && stop_element != NULL) {
        number++;
        stop_element = stop_element->next;
      } /* while */
      if (stop_element != NULL) {
        saved_list_rest = stop_element->next;
        stop_element->next = NULL;
        result = copy_list(start_element, &err_info);
        stop_element->next = saved_list_rest;
      } else {
        result = copy_list(start_element, &err_info);
      } /* if */
    } else {
      result = NULL;
    } /* if */
    if (err_info != OKAY_NO_ERROR) {
      raise_error(MEMORY_ERROR);
      result = NULL;
    } /* if */
    return result;
  } /* rflRange */



listType rflTail (const_listType list, intType start)

  {
    errInfoType err_info = OKAY_NO_ERROR;
    listType result;

  /* rflTail */
    if (start >= 2 && list != NULL) {
      start -= 2;
      list = list->next;
      while (start != 0 && list != NULL) {
        start--;
        list = list->next;
      } /* while */
    } /* if */
    result = copy_list(list, &err_info);
    if (err_info != OKAY_NO_ERROR) {
      raise_error(MEMORY_ERROR);
    } /* if */
    return result;
  } /* rflTail */
